"AP4_AtomSampleTable__GetSample_Ap4AtomSampleTable_cwe-476.cpp","CWE-476","AP4_AtomSampleTable::GetSample(AP4_Ordinal index,                                 AP4_Sample& sample) {     AP4_Result result;      // check that we have an stsc atom     if (!m_StscAtom) {         return AP4_ERROR_INVALID_FORMAT;     }          // check that we have a chunk offset table     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {         return AP4_ERROR_INVALID_FORMAT;     }      // MP4 uses 1-based indexes internally, so adjust by one     index++;      // find out in which chunk this sample is located     AP4_Ordinal chunk, skip, desc;     result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);     if (AP4_FAILED(result)) return result;          // check that the result is within bounds     if (skip > index) return AP4_ERROR_INTERNAL;      // get the atom offset for this chunk     AP4_UI64 offset;     if (m_StcoAtom) {         AP4_UI32 offset_32;         result = m_StcoAtom->GetChunkOffset(chunk, offset_32);         offset = offset_32;     } else {         result = m_Co64Atom->GetChunkOffset(chunk, offset);     }     if (AP4_FAILED(result)) return result;          // compute the additional offset inside the chunk     for (unsigned int i = index-skip; i < index; i++) {         AP4_Size size = 0;         if (m_StszAtom) {             result = m_StszAtom->GetSampleSize(i, size);          } else if (m_Stz2Atom) {             result = m_Stz2Atom->GetSampleSize(i, size);          } else {             result = AP4_ERROR_INVALID_FORMAT;         }         if (AP4_FAILED(result)) return result;         offset += size;     }      // set the description index     sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes      // set the dts and cts     AP4_UI32 cts_offset = 0;     AP4_UI64 dts        = 0;     AP4_UI32 duration   = 0;     result = m_SttsAtom->GetDts(index, dts, &duration);     if (AP4_FAILED(result)) return result;     sample.SetDuration(duration);     sample.SetDts(dts);     if (m_CttsAtom == NULL) {         sample.SetCts(dts);     } else {         result = m_CttsAtom->GetCtsOffset(index, cts_offset);  	    if (AP4_FAILED(result)) return result;         sample.SetCtsDelta(cts_offset);     }           // set the size     AP4_Size sample_size = 0;     if (m_StszAtom) {         result = m_StszAtom->GetSampleSize(index, sample_size);      } else if (m_Stz2Atom) {         result = m_Stz2Atom->GetSampleSize(index, sample_size);      } else {         result = AP4_ERROR_INVALID_FORMAT;     }     if (AP4_FAILED(result)) return result;     sample.SetSize(sample_size);      // set the sync flag     if (m_StssAtom == NULL) {         sample.SetSync(true);     } else {         sample.SetSync(m_StssAtom->IsSampleSync(index));     }      // set the offset     sample.SetOffset(offset);      // set the data stream     sample.SetDataStream(m_SampleStream);       return AP4_SUCCESS; }"
"AP4_AtomSampleTable__GetSample_Ap4AtomSampleTable_not_vulnerable.cpp","not_vulnerable","AP4_AtomSampleTable::GetSample(AP4_Ordinal index,                                 AP4_Sample& sample) {     AP4_Result result;      // check that we have an stsc atom     if (!m_StscAtom) {         return AP4_ERROR_INVALID_FORMAT;     }          // check that we have a chunk offset table     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {         return AP4_ERROR_INVALID_FORMAT;     }      // MP4 uses 1-based indexes internally, so adjust by one     index++;      // find out in which chunk this sample is located     AP4_Ordinal chunk, skip, desc;     result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);     if (AP4_FAILED(result)) return result;          // check that the result is within bounds     if (skip > index) return AP4_ERROR_INTERNAL;      // get the atom offset for this chunk     AP4_UI64 offset;     if (m_StcoAtom) {         AP4_UI32 offset_32;         result = m_StcoAtom->GetChunkOffset(chunk, offset_32);         offset = offset_32;     } else {         result = m_Co64Atom->GetChunkOffset(chunk, offset);     }     if (AP4_FAILED(result)) return result;          // compute the additional offset inside the chunk     for (unsigned int i = index-skip; i < index; i++) {         AP4_Size size = 0;         if (m_StszAtom) {             result = m_StszAtom->GetSampleSize(i, size);          } else if (m_Stz2Atom) {             result = m_Stz2Atom->GetSampleSize(i, size);          } else {             result = AP4_ERROR_INVALID_FORMAT;         }         if (AP4_FAILED(result)) return result;         offset += size;     }      // set the description index     sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes      // set the dts and cts     AP4_UI32 cts_offset = 0;     AP4_UI64 dts        = 0;     AP4_UI32 duration   = 0;     if (m_SttsAtom) {         result = m_SttsAtom->GetDts(index, dts, &duration);         if (AP4_FAILED(result)) return result;     }     sample.SetDuration(duration);     sample.SetDts(dts);     if (m_CttsAtom == NULL) {         sample.SetCts(dts);     } else {         result = m_CttsAtom->GetCtsOffset(index, cts_offset);  	    if (AP4_FAILED(result)) return result;         sample.SetCtsDelta(cts_offset);     }           // set the size     AP4_Size sample_size = 0;     if (m_StszAtom) {         result = m_StszAtom->GetSampleSize(index, sample_size);      } else if (m_Stz2Atom) {         result = m_Stz2Atom->GetSampleSize(index, sample_size);      } else {         result = AP4_ERROR_INVALID_FORMAT;     }     if (AP4_FAILED(result)) return result;     sample.SetSize(sample_size);      // set the sync flag     if (m_StssAtom == NULL) {         sample.SetSync(true);     } else {         sample.SetSync(m_StssAtom->IsSampleSync(index));     }      // set the offset     sample.SetOffset(offset);      // set the data stream     sample.SetDataStream(m_SampleStream);       return AP4_SUCCESS; }"
"Exiv2__WebPImage__getHeaderOffset_webpimage_cwe-190.cpp","CWE-190","    long WebPImage::getHeaderOffset(byte *data, long data_size,                                     byte *header, long header_size) {         long pos = -1;         for (long i=0; i < data_size - header_size; i++) {             if (memcmp(header, &data[i], header_size) == 0) {                 pos = i;                 break;             }         }         return pos;     }"
"Exiv2__WebPImage__getHeaderOffset_webpimage_not_vulnerable.cpp","not_vulnerable","    long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size)     {         if (data_size < header_size) { return -1; }         long pos = -1;         for (long i=0; i < data_size - header_size; i++) {             if (memcmp(header, &data[i], header_size) == 0) {                 pos = i;                 break;             }         }         return pos;     }"
"GetMagickModulePath_module_cwe-022.c","CWE-022","static MagickBooleanType GetMagickModulePath(const char *filename,   MagickModuleType module_type,char *path,ExceptionInfo *exception) {   char     *module_path;    assert(filename != (const char *) NULL);   (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);   assert(path != (char *) NULL);   assert(exception != (ExceptionInfo *) NULL);   (void) CopyMagickString(path,filename,MaxTextExtent);   module_path=(char *) NULL;   switch (module_type)   {     case MagickImageCoderModule:     default:     {       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),         ""Searching for coder module file \""%s\"" ..."",filename);       module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH""); #if defined(MAGICKCORE_CODER_PATH)       if (module_path == (char *) NULL)         module_path=AcquireString(MAGICKCORE_CODER_PATH); #endif       break;     }     case MagickImageFilterModule:     {       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),         ""Searching for filter module file \""%s\"" ..."",filename);       module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH""); #if defined(MAGICKCORE_FILTER_PATH)       if (module_path == (char *) NULL)         module_path=AcquireString(MAGICKCORE_FILTER_PATH); #endif       break;     }   }   if (module_path != (char *) NULL)     {       register char         *p,         *q;        for (p=module_path-1; p != (char *) NULL; )       {         (void) CopyMagickString(path,p+1,MaxTextExtent);         q=strchr(path,DirectoryListSeparator);         if (q != (char *) NULL)           *q='\0';         q=path+strlen(path)-1;         if ((q >= path) && (*q != *DirectorySeparator))           (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);         (void) ConcatenateMagickString(path,filename,MaxTextExtent);         if (IsPathAccessible(path) != MagickFalse)           {             module_path=DestroyString(module_path);             return(MagickTrue);           }         p=strchr(p+1,DirectoryListSeparator);       }       module_path=DestroyString(module_path);     } #if defined(MAGICKCORE_INSTALLED_SUPPORT)   else #if defined(MAGICKCORE_CODER_PATH)     {       const char         *directory;        /*         Search hard coded paths.       */       switch (module_type)       {         case MagickImageCoderModule:         default:         {           directory=MAGICKCORE_CODER_PATH;           break;         }         case MagickImageFilterModule:         {           directory=MAGICKCORE_FILTER_PATH;           break;         }       }       (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);       if (IsPathAccessible(path) == MagickFalse)         {           ThrowFileException(exception,ConfigureWarning,             ""UnableToOpenModuleFile"",path);           return(MagickFalse);         }       return(MagickTrue);     } #else #if defined(MAGICKCORE_WINDOWS_SUPPORT)     {       const char         *registery_key;        unsigned char         *key_value;        /*         Locate path via registry key.       */       switch (module_type)       {         case MagickImageCoderModule:         default:         {           registery_key=""CoderModulesPath"";           break;         }         case MagickImageFilterModule:         {           registery_key=""FilterModulesPath"";           break;         }       }       key_value=NTRegistryKeyLookup(registery_key);       if (key_value == (unsigned char *) NULL)         {           ThrowMagickException(exception,GetMagickModule(),ConfigureError,             ""RegistryKeyLookupFailed"",""`%s'"",registery_key);           return(MagickFalse);         }       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,         DirectorySeparator,filename);       key_value=(unsigned char *) RelinquishMagickMemory(key_value);       if (IsPathAccessible(path) == MagickFalse)         {           ThrowFileException(exception,ConfigureWarning,             ""UnableToOpenModuleFile"",path);           return(MagickFalse);         }       return(MagickTrue);     } #endif #endif #if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT) # error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined #endif #else   {     char       *home;      home=GetEnvironmentValue(""MAGICK_HOME"");     if (home != (char *) NULL)       {         /*           Search MAGICK_HOME.         */ #if !defined(MAGICKCORE_POSIX_SUPPORT)         (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,           DirectorySeparator,filename); #else         const char           *directory;          switch (module_type)         {           case MagickImageCoderModule:           default:           {             directory=MAGICKCORE_CODER_RELATIVE_PATH;             break;           }           case MagickImageFilterModule:           {             directory=MAGICKCORE_FILTER_RELATIVE_PATH;             break;           }         }         (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,           directory,filename); #endif         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   }   if (*GetClientPath() != '\0')     {       /*         Search based on executable directory.       */ #if !defined(MAGICKCORE_POSIX_SUPPORT)       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),         DirectorySeparator,filename); #else       char         prefix[MaxTextExtent];        const char         *directory;        switch (module_type)       {         case MagickImageCoderModule:         default:         {           directory=""coders"";           break;         }         case MagickImageFilterModule:         {           directory=""filters"";           break;         }       }       (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);       ChopPathComponents(prefix,1);       (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,         MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename); #endif       if (IsPathAccessible(path) != MagickFalse)         return(MagickTrue);     } #if defined(MAGICKCORE_WINDOWS_SUPPORT)   {     /*       Search module path.     */     if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||         (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||         (NTGetModulePath(""Magick.dll"",path) != MagickFalse))       {         (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);         (void) ConcatenateMagickString(path,filename,MaxTextExtent);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   } #endif   {     char       *home;      home=GetEnvironmentValue(""XDG_CONFIG_HOME"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""LOCALAPPDATA"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""APPDATA"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""USERPROFILE"");     if (home != (char *) NULL)       {         /*           Search $XDG_CONFIG_HOME/ImageMagick.         */         (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",           home,DirectorySeparator,DirectorySeparator,filename);         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }     home=GetEnvironmentValue(""HOME"");     if (home != (char *) NULL)       {         /*           Search $HOME/.config/ImageMagick.         */         (void) FormatLocaleString(path,MaxTextExtent,           ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,           DirectorySeparator,DirectorySeparator,filename);         if (IsPathAccessible(path) != MagickFalse)           {             home=DestroyString(home);             return(MagickTrue);           }         /*           Search $HOME/.magick.         */         (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,           DirectorySeparator,DirectorySeparator,filename);         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   }   /*     Search current directory.   */   if (IsPathAccessible(path) != MagickFalse)     return(MagickTrue);   if (exception->severity < ConfigureError)     ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",       path); #endif   return(MagickFalse); }"
"GetMagickModulePath_module_not_vulnerable.c","not_vulnerable","static MagickBooleanType GetMagickModulePath(const char *filename,   MagickModuleType module_type,char *path,ExceptionInfo *exception) {   char     *module_path;    assert(filename != (const char *) NULL);   (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);   assert(path != (char *) NULL);   assert(exception != (ExceptionInfo *) NULL);   (void) CopyMagickString(path,filename,MaxTextExtent); #if defined(MAGICKCORE_INSTALLED_SUPPORT)   if (strstr(path,""../"") != (char *) NULL)     {       errno=EPERM;       (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,         ""NotAuthorized"",""`%s'"",path);       return(MagickFalse);     } #endif   module_path=(char *) NULL;   switch (module_type)   {     case MagickImageCoderModule:     default:     {       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),         ""Searching for coder module file \""%s\"" ..."",filename);       module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH""); #if defined(MAGICKCORE_CODER_PATH)       if (module_path == (char *) NULL)         module_path=AcquireString(MAGICKCORE_CODER_PATH); #endif       break;     }     case MagickImageFilterModule:     {       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),         ""Searching for filter module file \""%s\"" ..."",filename);       module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH""); #if defined(MAGICKCORE_FILTER_PATH)       if (module_path == (char *) NULL)         module_path=AcquireString(MAGICKCORE_FILTER_PATH); #endif       break;     }   }   if (module_path != (char *) NULL)     {       register char         *p,         *q;        for (p=module_path-1; p != (char *) NULL; )       {         (void) CopyMagickString(path,p+1,MaxTextExtent);         q=strchr(path,DirectoryListSeparator);         if (q != (char *) NULL)           *q='\0';         q=path+strlen(path)-1;         if ((q >= path) && (*q != *DirectorySeparator))           (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);         (void) ConcatenateMagickString(path,filename,MaxTextExtent);         if (IsPathAccessible(path) != MagickFalse)           {             module_path=DestroyString(module_path);             return(MagickTrue);           }         p=strchr(p+1,DirectoryListSeparator);       }       module_path=DestroyString(module_path);     } #if defined(MAGICKCORE_INSTALLED_SUPPORT)   else #if defined(MAGICKCORE_CODER_PATH)     {       const char         *directory;        /*         Search hard coded paths.       */       switch (module_type)       {         case MagickImageCoderModule:         default:         {           directory=MAGICKCORE_CODER_PATH;           break;         }         case MagickImageFilterModule:         {           directory=MAGICKCORE_FILTER_PATH;           break;         }       }       (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);       if (IsPathAccessible(path) == MagickFalse)         {           ThrowFileException(exception,ConfigureWarning,             ""UnableToOpenModuleFile"",path);           return(MagickFalse);         }       return(MagickTrue);     } #else #if defined(MAGICKCORE_WINDOWS_SUPPORT)     {       const char         *registery_key;        unsigned char         *key_value;        /*         Locate path via registry key.       */       switch (module_type)       {         case MagickImageCoderModule:         default:         {           registery_key=""CoderModulesPath"";           break;         }         case MagickImageFilterModule:         {           registery_key=""FilterModulesPath"";           break;         }       }       key_value=NTRegistryKeyLookup(registery_key);       if (key_value == (unsigned char *) NULL)         {           ThrowMagickException(exception,GetMagickModule(),ConfigureError,             ""RegistryKeyLookupFailed"",""`%s'"",registery_key);           return(MagickFalse);         }       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,         DirectorySeparator,filename);       key_value=(unsigned char *) RelinquishMagickMemory(key_value);       if (IsPathAccessible(path) == MagickFalse)         {           ThrowFileException(exception,ConfigureWarning,             ""UnableToOpenModuleFile"",path);           return(MagickFalse);         }       return(MagickTrue);     } #endif #endif #if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT) # error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined #endif #else   {     char       *home;      home=GetEnvironmentValue(""MAGICK_HOME"");     if (home != (char *) NULL)       {         /*           Search MAGICK_HOME.         */ #if !defined(MAGICKCORE_POSIX_SUPPORT)         (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,           DirectorySeparator,filename); #else         const char           *directory;          switch (module_type)         {           case MagickImageCoderModule:           default:           {             directory=MAGICKCORE_CODER_RELATIVE_PATH;             break;           }           case MagickImageFilterModule:           {             directory=MAGICKCORE_FILTER_RELATIVE_PATH;             break;           }         }         (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,           directory,filename); #endif         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   }   if (*GetClientPath() != '\0')     {       /*         Search based on executable directory.       */ #if !defined(MAGICKCORE_POSIX_SUPPORT)       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),         DirectorySeparator,filename); #else       char         prefix[MaxTextExtent];        const char         *directory;        switch (module_type)       {         case MagickImageCoderModule:         default:         {           directory=""coders"";           break;         }         case MagickImageFilterModule:         {           directory=""filters"";           break;         }       }       (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);       ChopPathComponents(prefix,1);       (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,         MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename); #endif       if (IsPathAccessible(path) != MagickFalse)         return(MagickTrue);     } #if defined(MAGICKCORE_WINDOWS_SUPPORT)   {     /*       Search module path.     */     if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||         (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||         (NTGetModulePath(""Magick.dll"",path) != MagickFalse))       {         (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);         (void) ConcatenateMagickString(path,filename,MaxTextExtent);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   } #endif   {     char       *home;      home=GetEnvironmentValue(""XDG_CONFIG_HOME"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""LOCALAPPDATA"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""APPDATA"");     if (home == (char *) NULL)       home=GetEnvironmentValue(""USERPROFILE"");     if (home != (char *) NULL)       {         /*           Search $XDG_CONFIG_HOME/ImageMagick.         */         (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",           home,DirectorySeparator,DirectorySeparator,filename);         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }     home=GetEnvironmentValue(""HOME"");     if (home != (char *) NULL)       {         /*           Search $HOME/.config/ImageMagick.         */         (void) FormatLocaleString(path,MaxTextExtent,           ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,           DirectorySeparator,DirectorySeparator,filename);         if (IsPathAccessible(path) != MagickFalse)           {             home=DestroyString(home);             return(MagickTrue);           }         /*           Search $HOME/.magick.         */         (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,           DirectorySeparator,DirectorySeparator,filename);         home=DestroyString(home);         if (IsPathAccessible(path) != MagickFalse)           return(MagickTrue);       }   }   /*     Search current directory.   */   if (IsPathAccessible(path) != MagickFalse)     return(MagickTrue);   if (exception->severity < ConfigureError)     ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",       path); #endif   return(MagickFalse); }"
"HPHP__HHVM_METHOD_ext_memcache_cwe-125.cpp","CWE-125","static Array HHVM_METHOD(Memcache, getextendedstats,                          const String& /*type*/ /* = null_string */,                          int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {   auto data = Native::data<MemcacheData>(this_);   memcached_return_t ret;   memcached_stat_st *stats;    stats = memcached_stat(&data->m_memcache, nullptr, &ret);   if (ret != MEMCACHED_SUCCESS) {     return Array();   }    int server_count = memcached_server_count(&data->m_memcache);    Array return_val;    for (int server_id = 0; server_id < server_count; server_id++) {     memcached_stat_st *stat;     char stats_key[30] = {0};     size_t key_len;      LMCD_SERVER_POSITION_INSTANCE_TYPE instance =       memcached_server_instance_by_position(&data->m_memcache, server_id);     const char *hostname = LMCD_SERVER_HOSTNAME(instance);     in_port_t port = LMCD_SERVER_PORT(instance);      stat = stats + server_id;      Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);     if (ret != MEMCACHED_SUCCESS) {       continue;     }      key_len = snprintf(stats_key, sizeof(stats_key), ""%s:%d"", hostname, port);      return_val.set(String(stats_key, key_len, CopyString), server_stats);   }    free(stats);   return return_val; }"
"HPHP__HHVM_METHOD_ext_memcache_not_vulnerable.cpp","not_vulnerable","static Array HHVM_METHOD(Memcache, getextendedstats,                          const String& /*type*/ /* = null_string */,                          int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {   auto data = Native::data<MemcacheData>(this_);   memcached_return_t ret;   memcached_stat_st *stats;    stats = memcached_stat(&data->m_memcache, nullptr, &ret);   if (ret != MEMCACHED_SUCCESS) {     return Array();   }    int server_count = memcached_server_count(&data->m_memcache);    Array return_val;    for (int server_id = 0; server_id < server_count; server_id++) {     memcached_stat_st *stat;     LMCD_SERVER_POSITION_INSTANCE_TYPE instance =       memcached_server_instance_by_position(&data->m_memcache, server_id);     const char *hostname = LMCD_SERVER_HOSTNAME(instance);     in_port_t port = LMCD_SERVER_PORT(instance);      stat = stats + server_id;      Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);     if (ret != MEMCACHED_SUCCESS) {       continue;     }      auto const port_str = folly::to<std::string>(port);     auto const key_len = strlen(hostname) + 1 + port_str.length();     auto key = String(key_len, ReserveString);     key += hostname;     key += "":"";     key += port_str;     return_val.set(key, server_stats);   }    free(stats);   return return_val; }"
"HPHP__exif_scan_JPEG_header_ext_gd_cwe-125.cpp","CWE-125","static int exif_scan_JPEG_header(image_info_type *ImageInfo) {   int section, sn;   int marker = 0, last_marker = M_PSEUDO, comment_correction=1;   int ll, lh;   unsigned char *Data;   size_t fpos, size, got, itemlen;   jpeg_sof_info  sof_info;    for(section=0;;section++) {     // get marker byte, swallowing possible padding     // some software does not count the length bytes of COM section     // one company doing so is very much envolved in JPEG...     // so we accept too     if (last_marker==M_COM && comment_correction) {       comment_correction = 2;     }     do {       if ((marker = ImageInfo->infile->getc()) == EOF) {         raise_warning(""File structure corrupted"");         return 0;       }       if (last_marker==M_COM && comment_correction>0) {         if (marker!=0xFF) {           marker = 0xff;           comment_correction--;         } else  {           last_marker = M_PSEUDO; /* stop skipping 0 for M_COM */         }       }     } while (marker == 0xff);     if (last_marker==M_COM && !comment_correction) {       raise_notice(""Image has corrupt COM section: some software set ""                    ""wrong length information"");     }     if (last_marker==M_COM && comment_correction)       return M_EOI; /* ah illegal: char after COM section not 0xFF */      fpos = ImageInfo->infile->tell();      if (marker == 0xff) {       // 0xff is legal padding, but if we get that many, something's wrong.       raise_warning(""To many padding bytes"");       return 0;     }      /* Read the length of the section. */      if ((lh = ImageInfo->infile->getc()) == EOF) {       raise_warning(""File structure corrupted"");       return 0;     }      if ((ll = ImageInfo->infile->getc()) == EOF) {       raise_warning(""File structure corrupted"");       return 0;     }      itemlen = (lh << 8) | ll;      if (itemlen < 2) {       raise_warning(""File structure corrupted"");       return 0;     }      sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr);     if (sn == -1) return 0;     Data = ImageInfo->file.list[sn].data;      /* Store first two pre-read bytes. */     Data[0] = (unsigned char)lh;     Data[1] = (unsigned char)ll;      String str = ImageInfo->infile->read(itemlen-2);     got = str.length();     if (got != itemlen-2) {       raise_warning(""Error reading from file: ""                       ""got=x%04lX(=%lu) != itemlen-2=x%04lX(=%lu)"",                       got, got, itemlen-2, itemlen-2);       return 0;     }     memcpy(Data+2, str.c_str(), got);     switch(marker) {       case M_SOS:   /* stop before hitting compressed data  */         // If reading entire image is requested, read the rest of the data.         if (ImageInfo->read_all) {           /* Determine how much file is left. */           fpos = ImageInfo->infile->tell();           size = ImageInfo->FileSize - fpos;           sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr);           if (sn == -1) return 0;           Data = ImageInfo->file.list[sn].data;           str = ImageInfo->infile->read(size);           got = str.length();           if (got != size) {             raise_warning(""Unexpected end of file reached"");             return 0;           }           memcpy(Data, str.c_str(), got);         }         return 1;        case M_EOI:   /* in case it's a tables-only JPEG stream */         raise_warning(""No image in jpeg!"");         return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0;        case M_COM: /* Comment section */         exif_process_COM(ImageInfo, (char *)Data, itemlen);         break;        case M_EXIF:         if (!(ImageInfo->sections_found&FOUND_IFD0)) {           /*ImageInfo->sections_found |= FOUND_EXIF;*/           /* Seen files from some 'U-lead' software with Vivitar scanner              that uses marker 31 later in the file (no clue what for!) */           exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos);         }         break;        case M_APP12:         exif_process_APP12(ImageInfo, (char *)Data, itemlen);         break;         case M_SOF0:       case M_SOF1:       case M_SOF2:       case M_SOF3:       case M_SOF5:       case M_SOF6:       case M_SOF7:       case M_SOF9:       case M_SOF10:       case M_SOF11:       case M_SOF13:       case M_SOF14:       case M_SOF15:         exif_process_SOFn(Data, marker, &sof_info);         ImageInfo->Width  = sof_info.width;         ImageInfo->Height = sof_info.height;         if (sof_info.num_components == 3) {           ImageInfo->IsColor = 1;         } else {           ImageInfo->IsColor = 0;         }         break;       default:         /* skip any other marker silently. */         break;     }      /* keep track of last marker */     last_marker = marker;   }   return 1; }"
"HPHP__exif_scan_JPEG_header_ext_gd_not_vulnerable.cpp","not_vulnerable","static int exif_scan_JPEG_header(image_info_type *ImageInfo) {   int section, sn;   int marker = 0, last_marker = M_PSEUDO, comment_correction=1;   int ll, lh;   unsigned char *Data;   size_t fpos, size, got, itemlen;   jpeg_sof_info  sof_info;    for(section=0;;section++) {     // get marker byte, swallowing possible padding     // some software does not count the length bytes of COM section     // one company doing so is very much envolved in JPEG...     // so we accept too     if (last_marker==M_COM && comment_correction) {       comment_correction = 2;     }     do {       if ((marker = ImageInfo->infile->getc()) == EOF) {         raise_warning(""File structure corrupted"");         return 0;       }       if (last_marker==M_COM && comment_correction>0) {         if (marker!=0xFF) {           marker = 0xff;           comment_correction--;         } else  {           last_marker = M_PSEUDO; /* stop skipping 0 for M_COM */         }       }     } while (marker == 0xff);     if (last_marker==M_COM && !comment_correction) {       raise_notice(""Image has corrupt COM section: some software set ""                    ""wrong length information"");     }     if (last_marker==M_COM && comment_correction)       return M_EOI; /* ah illegal: char after COM section not 0xFF */      fpos = ImageInfo->infile->tell();      if (marker == 0xff) {       // 0xff is legal padding, but if we get that many, something's wrong.       raise_warning(""To many padding bytes"");       return 0;     }      /* Read the length of the section. */      if ((lh = ImageInfo->infile->getc()) == EOF) {       raise_warning(""File structure corrupted"");       return 0;     }      if ((ll = ImageInfo->infile->getc()) == EOF) {       raise_warning(""File structure corrupted"");       return 0;     }      itemlen = (lh << 8) | ll;      if (itemlen < 2) {       raise_warning(""File structure corrupted"");       return 0;     }      sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr);     if (sn == -1) return 0;     Data = ImageInfo->file.list[sn].data;      /* Store first two pre-read bytes. */     Data[0] = (unsigned char)lh;     Data[1] = (unsigned char)ll;      String str = ImageInfo->infile->read(itemlen-2);     got = str.length();     if (got != itemlen-2) {       raise_warning(""Error reading from file: ""                       ""got=x%04lX(=%lu) != itemlen-2=x%04lX(=%lu)"",                       got, got, itemlen-2, itemlen-2);       return 0;     }     memcpy(Data+2, str.c_str(), got);     switch(marker) {       case M_SOS:   /* stop before hitting compressed data  */         // If reading entire image is requested, read the rest of the data.         if (ImageInfo->read_all) {           /* Determine how much file is left. */           fpos = ImageInfo->infile->tell();           size = ImageInfo->FileSize - fpos;           sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr);           if (sn == -1) return 0;           Data = ImageInfo->file.list[sn].data;           str = ImageInfo->infile->read(size);           got = str.length();           if (got != size) {             raise_warning(""Unexpected end of file reached"");             return 0;           }           memcpy(Data, str.c_str(), got);         }         return 1;        case M_EOI:   /* in case it's a tables-only JPEG stream */         raise_warning(""No image in jpeg!"");         return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0;        case M_COM: /* Comment section */         exif_process_COM(ImageInfo, (char *)Data, itemlen);         break;        case M_EXIF:         if (!(ImageInfo->sections_found&FOUND_IFD0)) {           /*ImageInfo->sections_found |= FOUND_EXIF;*/           /* Seen files from some 'U-lead' software with Vivitar scanner              that uses marker 31 later in the file (no clue what for!) */           exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos);         }         break;        case M_APP12:         exif_process_APP12(ImageInfo, (char *)Data, itemlen);         break;         case M_SOF0:       case M_SOF1:       case M_SOF2:       case M_SOF3:       case M_SOF5:       case M_SOF6:       case M_SOF7:       case M_SOF9:       case M_SOF10:       case M_SOF11:       case M_SOF13:       case M_SOF14:       case M_SOF15:         if ((itemlen - 2) < 6) {           return 0;         }          exif_process_SOFn(Data, marker, &sof_info);         ImageInfo->Width  = sof_info.width;         ImageInfo->Height = sof_info.height;         if (sof_info.num_components == 3) {           ImageInfo->IsColor = 1;         } else {           ImageInfo->IsColor = 0;         }         break;       default:         /* skip any other marker silently. */         break;     }      /* keep track of last marker */     last_marker = marker;   }   return 1; }"
"ImagingLibTiffDecode_TiffDecode_cwe-190.c","CWE-190","int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;     char *filename = ""tempfile.tif"";     char *mode = ""r"";     TIFF *tiff;      /* buffer is the encoded file, bytes is the length of the encoded file */     /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */      TRACE((""in decoder: bytes %d\n"", bytes));     TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,            state->x, state->y, state->ystep));     TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,            state->xoff, state->yoff));     TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));     TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));     TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));     TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",            im->mode, im->type, im->bands, im->xsize, im->ysize));     TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",            im->image8, im->image32, im->image, im->block));     TRACE((""Image: pixelsize: %d, linesize %d \n"",            im->pixelsize, im->linesize));      dump_state(clientstate);     clientstate->size = bytes;     clientstate->eof = clientstate->size;     clientstate->loc = 0;     clientstate->data = (tdata_t)buffer;     clientstate->flrealloc = 0;     dump_state(clientstate);      TIFFSetWarningHandler(NULL);     TIFFSetWarningHandlerExt(NULL);      if (clientstate->fp) {         TRACE((""Opening using fd: %d\n"",clientstate->fp));         lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.         tiff = TIFFFdOpen(clientstate->fp, filename, mode);     } else {         TRACE((""Opening from string\n""));         tiff = TIFFClientOpen(filename, mode,                               (thandle_t) clientstate,                               _tiffReadProc, _tiffWriteProc,                               _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,                               _tiffMapProc, _tiffUnmapProc);     }      if (!tiff){         TRACE((""Error, didn't get the tiff\n""));         state->errcode = IMAGING_CODEC_BROKEN;         return -1;     }      if (clientstate->ifd){         int rv;         uint32 ifdoffset = clientstate->ifd;         TRACE((""reading tiff ifd %u\n"", ifdoffset));         rv = TIFFSetSubDirectory(tiff, ifdoffset);         if (!rv){             TRACE((""error in TIFFSetSubDirectory""));             return -1;         }     }      if (TIFFIsTiled(tiff)) {         UINT32 x, y, tile_y, row_byte_size;         UINT32 tile_width, tile_length, current_tile_width;         UINT8 *new_data;          TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);         TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);          // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size         row_byte_size = (tile_width * state->bits + 7) / 8;         state->bytes = row_byte_size * tile_length;          /* overflow check for malloc */         if (state->bytes > INT_MAX - 1) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }          /* realloc to fit whole tile */         new_data = realloc (state->buffer, state->bytes);         if (!new_data) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }          state->buffer = new_data;          TRACE((""TIFFTileSize: %d\n"", state->bytes));          for (y = state->yoff; y < state->ysize; y += tile_length) {             for (x = state->xoff; x < state->xsize; x += tile_width) {                 if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {                     TRACE((""Decode Error, Tile at %dx%d\n"", x, y));                     state->errcode = IMAGING_CODEC_BROKEN;                     TIFFClose(tiff);                     return -1;                 }                  TRACE((""Read tile at %dx%d; \n\n"", x, y));                  current_tile_width = min(tile_width, state->xsize - x);                  // iterate over each line in the tile and stuff data into image                 for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {                     TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width));                      // UINT8 * bbb = state->buffer + tile_y * row_byte_size;                     // TRACE((""chars: %x%x%x%x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));                      state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,                        state->buffer + tile_y * row_byte_size,                        current_tile_width                     );                 }             }         }     } else {         UINT32 strip_row, row_byte_size;         UINT8 *new_data;         UINT32 rows_per_strip;         int ret;          ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);         if (ret != 1) {             rows_per_strip = state->ysize;         }         TRACE((""RowsPerStrip: %u \n"", rows_per_strip));          // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size         row_byte_size = (state->xsize * state->bits + 7) / 8;         state->bytes = rows_per_strip * row_byte_size;          TRACE((""StripSize: %d \n"", state->bytes));          /* realloc to fit whole strip */         new_data = realloc (state->buffer, state->bytes);         if (!new_data) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }          state->buffer = new_data;          for (; state->y < state->ysize; state->y += rows_per_strip) {             if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {                 TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0)));                 state->errcode = IMAGING_CODEC_BROKEN;                 TIFFClose(tiff);                 return -1;             }              TRACE((""Decoded strip for row %d \n"", state->y));              // iterate over each row in the strip and stuff data into image             for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {                 TRACE((""Writing data into line %d ; \n"", state->y + strip_row));                  // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);                 // TRACE((""chars: %x %x %x %x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));                  state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +                                state->xoff * im->pixelsize,                                state->buffer + strip_row * row_byte_size,                                state->xsize);             }         }     }      TIFFClose(tiff);     TRACE((""Done Decoding, Returning \n""));     // Returning -1 here to force ImageFile.load to break, rather than     // even think about looping back around.     return -1; }"
"ImagingLibTiffDecode_TiffDecode_not_vulnerable.c","not_vulnerable","int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;     char *filename = ""tempfile.tif"";     char *mode = ""r"";     TIFF *tiff;      /* buffer is the encoded file, bytes is the length of the encoded file */     /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */      TRACE((""in decoder: bytes %d\n"", bytes));     TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,            state->x, state->y, state->ystep));     TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,            state->xoff, state->yoff));     TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));     TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));     TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));     TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",            im->mode, im->type, im->bands, im->xsize, im->ysize));     TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",            im->image8, im->image32, im->image, im->block));     TRACE((""Image: pixelsize: %d, linesize %d \n"",            im->pixelsize, im->linesize));      dump_state(clientstate);     clientstate->size = bytes;     clientstate->eof = clientstate->size;     clientstate->loc = 0;     clientstate->data = (tdata_t)buffer;     clientstate->flrealloc = 0;     dump_state(clientstate);      TIFFSetWarningHandler(NULL);     TIFFSetWarningHandlerExt(NULL);      if (clientstate->fp) {         TRACE((""Opening using fd: %d\n"",clientstate->fp));         lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.         tiff = TIFFFdOpen(clientstate->fp, filename, mode);     } else {         TRACE((""Opening from string\n""));         tiff = TIFFClientOpen(filename, mode,                               (thandle_t) clientstate,                               _tiffReadProc, _tiffWriteProc,                               _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,                               _tiffMapProc, _tiffUnmapProc);     }      if (!tiff){         TRACE((""Error, didn't get the tiff\n""));         state->errcode = IMAGING_CODEC_BROKEN;         return -1;     }      if (clientstate->ifd){         int rv;         uint32 ifdoffset = clientstate->ifd;         TRACE((""reading tiff ifd %u\n"", ifdoffset));         rv = TIFFSetSubDirectory(tiff, ifdoffset);         if (!rv){             TRACE((""error in TIFFSetSubDirectory""));             return -1;         }     }      if (TIFFIsTiled(tiff)) {         UINT32 x, y, tile_y, row_byte_size;         UINT32 tile_width, tile_length, current_tile_width;         UINT8 *new_data;          TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);         TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);          // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size         row_byte_size = (tile_width * state->bits + 7) / 8;          /* overflow check for realloc */         if (INT_MAX / row_byte_size < tile_length) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }                  state->bytes = row_byte_size * tile_length;          /* realloc to fit whole tile */         /* malloc check above */         new_data = realloc (state->buffer, state->bytes);         if (!new_data) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }          state->buffer = new_data;          TRACE((""TIFFTileSize: %d\n"", state->bytes));          for (y = state->yoff; y < state->ysize; y += tile_length) {             for (x = state->xoff; x < state->xsize; x += tile_width) {                 if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {                     TRACE((""Decode Error, Tile at %dx%d\n"", x, y));                     state->errcode = IMAGING_CODEC_BROKEN;                     TIFFClose(tiff);                     return -1;                 }                  TRACE((""Read tile at %dx%d; \n\n"", x, y));                  current_tile_width = min(tile_width, state->xsize - x);                  // iterate over each line in the tile and stuff data into image                 for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {                     TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width));                      // UINT8 * bbb = state->buffer + tile_y * row_byte_size;                     // TRACE((""chars: %x%x%x%x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));                      state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,                        state->buffer + tile_y * row_byte_size,                        current_tile_width                     );                 }             }         }     } else {         UINT32 strip_row, row_byte_size;         UINT8 *new_data;         UINT32 rows_per_strip;         int ret;          ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);         if (ret != 1) {             rows_per_strip = state->ysize;         }         TRACE((""RowsPerStrip: %u \n"", rows_per_strip));          // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size         row_byte_size = (state->xsize * state->bits + 7) / 8;          /* overflow check for realloc */         if (INT_MAX / row_byte_size < rows_per_strip) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }                  state->bytes = rows_per_strip * row_byte_size;          TRACE((""StripSize: %d \n"", state->bytes));          /* realloc to fit whole strip */         /* malloc check above */         new_data = realloc (state->buffer, state->bytes);         if (!new_data) {             state->errcode = IMAGING_CODEC_MEMORY;             TIFFClose(tiff);             return -1;         }          state->buffer = new_data;          for (; state->y < state->ysize; state->y += rows_per_strip) {             if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {                 TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0)));                 state->errcode = IMAGING_CODEC_BROKEN;                 TIFFClose(tiff);                 return -1;             }              TRACE((""Decoded strip for row %d \n"", state->y));              // iterate over each row in the strip and stuff data into image             for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {                 TRACE((""Writing data into line %d ; \n"", state->y + strip_row));                  // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);                 // TRACE((""chars: %x %x %x %x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));                  state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +                                state->xoff * im->pixelsize,                                state->buffer + strip_row * row_byte_size,                                state->xsize);             }         }     }      TIFFClose(tiff);     TRACE((""Done Decoding, Returning \n""));     // Returning -1 here to force ImageFile.load to break, rather than     // even think about looping back around.     return -1; }"
"Logger__addMessage_logger_cwe-079.cpp","CWE-079","void Logger::addMessage(const QString &message, const Log::MsgType &type) {     QWriteLocker locker(&lock);      Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };     m_messages.push_back(temp);      if (m_messages.size() >= MAX_LOG_MESSAGES)         m_messages.pop_front();      emit newLogMessage(temp); }"
"Logger__addMessage_logger_not_vulnerable.cpp","not_vulnerable","void Logger::addMessage(const QString &message, const Log::MsgType &type) {     QWriteLocker locker(&lock);      Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };     m_messages.push_back(temp);      if (m_messages.size() >= MAX_LOG_MESSAGES)         m_messages.pop_front();      emit newLogMessage(temp); }"
"Logger__addPeer_logger_cwe-079.cpp","CWE-079","void Logger::addPeer(const QString &ip, bool blocked, const QString &reason) {     QWriteLocker locker(&lock);      Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };     m_peers.push_back(temp);      if (m_peers.size() >= MAX_LOG_MESSAGES)         m_peers.pop_front();      emit newLogPeer(temp); }"
"Logger__addPeer_logger_not_vulnerable.cpp","not_vulnerable","void Logger::addPeer(const QString &ip, bool blocked, const QString &reason) {     QWriteLocker locker(&lock);      Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };     m_peers.push_back(temp);      if (m_peers.size() >= MAX_LOG_MESSAGES)         m_peers.pop_front();      emit newLogPeer(temp); }"
"MAPIPrint_ytnef_cwe-125.c","CWE-125","void MAPIPrint(MAPIProps *p) {   int j, i, index, h, x;   DDWORD *ddword_ptr;   DDWORD ddword_tmp;   dtr thedate;   MAPIProperty *mapi;   variableLength *mapidata;   variableLength vlTemp;   int found;    for (j = 0; j < p->count; j++) {     mapi = &(p->properties[j]);     printf(""   #%i: Type: ["", j);     switch (PROP_TYPE(mapi->id)) {       case PT_UNSPECIFIED:         printf(""  NONE   ""); break;       case PT_NULL:         printf(""  NULL   ""); break;       case PT_I2:         printf(""   I2    ""); break;       case PT_LONG:         printf(""  LONG   ""); break;       case PT_R4:         printf(""   R4    ""); break;       case PT_DOUBLE:         printf("" DOUBLE  ""); break;       case PT_CURRENCY:         printf(""CURRENCY ""); break;       case PT_APPTIME:         printf(""APP TIME ""); break;       case PT_ERROR:         printf(""  ERROR  ""); break;       case PT_BOOLEAN:         printf("" BOOLEAN ""); break;       case PT_OBJECT:         printf("" OBJECT  ""); break;       case PT_I8:         printf(""   I8    ""); break;       case PT_STRING8:         printf("" STRING8 ""); break;       case PT_UNICODE:         printf("" UNICODE ""); break;       case PT_SYSTIME:         printf(""SYS TIME ""); break;       case PT_CLSID:         printf(""OLE GUID ""); break;       case PT_BINARY:         printf("" BINARY  ""); break;       default:         printf(""<%x>"", PROP_TYPE(mapi->id)); break;     }      printf(""]  Code: ["");     if (mapi->custom == 1) {       printf(""UD:x%04x"", PROP_ID(mapi->id));     } else {       found = 0;       for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {         if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {           printf(""%s"", MPList[index].name);           found = 1;         }       }       if (found == 0) {         printf(""0x%04x"", PROP_ID(mapi->id));       }     }     printf(""]\n"");     if (mapi->namedproperty > 0) {       for (i = 0; i < mapi->namedproperty; i++) {         printf(""    Name: %s\n"", mapi->propnames[i].data);       }     }     for (i = 0; i < mapi->count; i++) {       mapidata = &(mapi->data[i]);       if (mapi->count > 1) {         printf(""    [%i/%u] "", i, mapi->count);       } else {         printf(""    "");       }       printf(""Size: %i"", mapidata->size);       switch (PROP_TYPE(mapi->id)) {         case PT_SYSTIME:           MAPISysTimetoDTR(mapidata->data, &thedate);           printf(""    Value: "");           ddword_tmp = *((DDWORD *)mapidata->data);           TNEFPrintDate(thedate);           printf("" [HEX: "");           for (x = 0; x < sizeof(ddword_tmp); x++) {             printf("" %02x"", (BYTE)mapidata->data[x]);           }           printf(""] (%llu)\n"", ddword_tmp);           break;         case PT_LONG:           printf(""    Value: %li\n"", *((long*)mapidata->data));           break;         case PT_I2:           printf(""    Value: %hi\n"", *((short int*)mapidata->data));           break;         case PT_BOOLEAN:           if (mapi->data->data[0] != 0) {             printf(""    Value: True\n"");           } else {             printf(""    Value: False\n"");           }           break;         case PT_OBJECT:           printf(""\n"");           break;         case PT_BINARY:           if (IsCompressedRTF(mapidata) == 1) {             printf(""    Detected Compressed RTF. "");             printf(""Decompressed text follows\n"");             printf(""-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"");             if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {               printf(""%s\n"", vlTemp.data);               free(vlTemp.data);             }             printf(""-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"");           } else {             printf(""    Value: ["");             for (h = 0; h < mapidata->size; h++) {               if (isprint(mapidata->data[h])) {                 printf(""%c"", mapidata->data[h]);               } else {                 printf(""."");               }              }             printf(""]\n"");           }           break;         case PT_STRING8:           printf(""    Value: [%s]\n"", mapidata->data);           if (strlen((char*)mapidata->data) != mapidata->size - 1) {             printf(""Detected Hidden data: ["");             for (h = 0; h < mapidata->size; h++) {               if (isprint(mapidata->data[h])) {                 printf(""%c"", mapidata->data[h]);               } else {                 printf(""."");               }              }             printf(""]\n"");           }           break;         case PT_CLSID:           printf(""    Value: "");           printf(""[HEX: "");           for(x=0; x< 16; x++) {             printf("" %02x"", (BYTE)mapidata->data[x]);           }           printf(""]\n"");           break;         default:           printf(""    Value: [%s]\n"", mapidata->data);       }     }   } }"
"MAPIPrint_ytnef_not_vulnerable.c","not_vulnerable","void MAPIPrint(MAPIProps *p) {   int j, i, index, h, x;   DDWORD *ddword_ptr;   DDWORD ddword_tmp;   dtr thedate;   MAPIProperty *mapi;   variableLength *mapidata;   variableLength vlTemp;   int found;    for (j = 0; j < p->count; j++) {     mapi = &(p->properties[j]);     printf(""   #%i: Type: ["", j);     switch (PROP_TYPE(mapi->id)) {       case PT_UNSPECIFIED:         printf(""  NONE   ""); break;       case PT_NULL:         printf(""  NULL   ""); break;       case PT_I2:         printf(""   I2    ""); break;       case PT_LONG:         printf(""  LONG   ""); break;       case PT_R4:         printf(""   R4    ""); break;       case PT_DOUBLE:         printf("" DOUBLE  ""); break;       case PT_CURRENCY:         printf(""CURRENCY ""); break;       case PT_APPTIME:         printf(""APP TIME ""); break;       case PT_ERROR:         printf(""  ERROR  ""); break;       case PT_BOOLEAN:         printf("" BOOLEAN ""); break;       case PT_OBJECT:         printf("" OBJECT  ""); break;       case PT_I8:         printf(""   I8    ""); break;       case PT_STRING8:         printf("" STRING8 ""); break;       case PT_UNICODE:         printf("" UNICODE ""); break;       case PT_SYSTIME:         printf(""SYS TIME ""); break;       case PT_CLSID:         printf(""OLE GUID ""); break;       case PT_BINARY:         printf("" BINARY  ""); break;       default:         printf(""<%x>"", PROP_TYPE(mapi->id)); break;     }      printf(""]  Code: ["");     if (mapi->custom == 1) {       printf(""UD:x%04x"", PROP_ID(mapi->id));     } else {       found = 0;       for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {         if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {           printf(""%s"", MPList[index].name);           found = 1;         }       }       if (found == 0) {         printf(""0x%04x"", PROP_ID(mapi->id));       }     }     printf(""]\n"");     if (mapi->namedproperty > 0) {       for (i = 0; i < mapi->namedproperty; i++) {         printf(""    Name: %s\n"", mapi->propnames[i].data);       }     }     for (i = 0; i < mapi->count; i++) {       mapidata = &(mapi->data[i]);       if (mapi->count > 1) {         printf(""    [%i/%u] "", i, mapi->count);       } else {         printf(""    "");       }       printf(""Size: %i"", mapidata->size);       switch (PROP_TYPE(mapi->id)) {         case PT_SYSTIME:           MAPISysTimetoDTR(mapidata->data, &thedate);           printf(""    Value: "");           ddword_tmp = *((DDWORD *)mapidata->data);           TNEFPrintDate(thedate);           printf("" [HEX: "");           for (x = 0; x < sizeof(ddword_tmp); x++) {             printf("" %02x"", (BYTE)mapidata->data[x]);           }           printf(""] (%llu)\n"", ddword_tmp);           break;         case PT_LONG:           printf(""    Value: %i\n"", *((int*)mapidata->data));           break;         case PT_I2:           printf(""    Value: %hi\n"", *((short int*)mapidata->data));           break;         case PT_BOOLEAN:           if (mapi->data->data[0] != 0) {             printf(""    Value: True\n"");           } else {             printf(""    Value: False\n"");           }           break;         case PT_OBJECT:           printf(""\n"");           break;         case PT_BINARY:           if (IsCompressedRTF(mapidata) == 1) {             printf(""    Detected Compressed RTF. "");             printf(""Decompressed text follows\n"");             printf(""-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"");             if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {               printf(""%s\n"", vlTemp.data);               free(vlTemp.data);             }             printf(""-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"");           } else {             printf(""    Value: ["");             for (h = 0; h < mapidata->size; h++) {               if (isprint(mapidata->data[h])) {                 printf(""%c"", mapidata->data[h]);               } else {                 printf(""."");               }              }             printf(""]\n"");           }           break;         case PT_STRING8:           printf(""    Value: [%s]\n"", mapidata->data);           if (strlen((char*)mapidata->data) != mapidata->size - 1) {             printf(""Detected Hidden data: ["");             for (h = 0; h < mapidata->size; h++) {               if (isprint(mapidata->data[h])) {                 printf(""%c"", mapidata->data[h]);               } else {                 printf(""."");               }              }             printf(""]\n"");           }           break;         case PT_CLSID:           printf(""    Value: "");           printf(""[HEX: "");           for(x=0; x< 16; x++) {             printf("" %02x"", (BYTE)mapidata->data[x]);           }           printf(""]\n"");           break;         default:           printf(""    Value: [%s]\n"", mapidata->data);       }     }   } }"
"MultiPartInputFile__Data__chunkOffsetReconstruction_ImfMultiPartInputFile_cwe-787.cpp","CWE-787","MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts) {     //     // Reconstruct broken chunk offset tables. Stop once we received any exception.     //      Int64 position = is.tellg();           //     // check we understand all the parts available: if not, we cannot continue     // exceptions thrown here should trickle back up to the constructor     //          for (size_t i = 0; i < parts.size(); i++)     {         Header& header=parts[i]->header;                  //         // do we have a valid type entry?         // we only need them for true multipart files or single part non-image (deep) files         //         if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))         {             throw IEX_NAMESPACE::ArgExc(""cannot reconstruct incomplete file: part with missing type"");         }         if(!isSupportedType(header.type()))         {             throw IEX_NAMESPACE::ArgExc(""cannot reconstruct incomplete file: part with unknown type ""+header.type());         }     }               // how many chunks should we read? We should stop when we reach the end     size_t total_chunks = 0;              // for tiled-based parts, array of (pointers to) tileOffsets objects     // to create mapping between tile coordinates and chunk table indices               vector<TileOffsets*> tileOffsets(parts.size());          // for scanline-based parts, number of scanlines in each chunk     vector<int> rowsizes(parts.size());              for(size_t i = 0 ; i < parts.size() ; i++)     {         total_chunks += parts[i]->chunkOffsets.size();         if (isTiled(parts[i]->header.type()))         {             tileOffsets[i] = createTileOffsets(parts[i]->header);         }else{             tileOffsets[i] = NULL;             // (TODO) fix this so that it doesn't need to be revised for future compression types.             switch(parts[i]->header.compression())             {                 case DWAB_COMPRESSION :                     rowsizes[i] = 256;                     break;                 case PIZ_COMPRESSION :                 case B44_COMPRESSION :                 case B44A_COMPRESSION :                 case DWAA_COMPRESSION :                     rowsizes[i]=32;                     break;                 case ZIP_COMPRESSION :                 case PXR24_COMPRESSION :                     rowsizes[i]=16;                     break;                 case ZIPS_COMPRESSION :                 case RLE_COMPRESSION :                 case NO_COMPRESSION :                     rowsizes[i]=1;                     break;                 default :                     throw(IEX_NAMESPACE::ArgExc(""Unknown compression method in chunk offset reconstruction""));             }         }      }               try      {                      //         //          //                  Int64 chunk_start = position;         for (size_t i = 0; i < total_chunks ; i++)         {             //             // do we have a part number?             //                          int partNumber = 0;             if(isMultiPart(version))             {                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);             }                                                    if(partNumber<0 || partNumber> static_cast<int>(parts.size()))             {                 throw IEX_NAMESPACE::IoExc(""part number out of range"");             }                          Header& header = parts[partNumber]->header;              // size of chunk NOT including multipart field                          Int64 size_of_chunk=0;              if (isTiled(header.type()))             {                 //                 //                  //                 int tilex,tiley,levelx,levely;                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);                                  //std::cout << ""chunk_start for "" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;                                                       if(!tileOffsets[partNumber])                 {                     // this shouldn't actually happen - we should have allocated a valid                     // tileOffsets for any part which isTiled                     throw IEX_NAMESPACE::IoExc(""part not tiled"");                                      }                                  if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))                 {                     throw IEX_NAMESPACE::IoExc(""invalid tile coordinates"");                 }                                  (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;                                  // compute chunk sizes - different procedure for deep tiles and regular                 // ones                 if(header.type()==DEEPTILE)                 {                     Int64 packed_offset;                     Int64 packed_sample;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);                                          //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)                     size_of_chunk=packed_offset+packed_sample+40;                 }                 else                 {                                          // regular image has 20 bytes of header, 4 byte chunksize;                     int chunksize;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);                     size_of_chunk=chunksize+20;                 }             }             else             {                 int y_coordinate;                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);                                                   if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)                 {                    throw IEX_NAMESPACE::IoExc(""y out of range"");                 }                 y_coordinate -= header.dataWindow().min.y;                 y_coordinate /= rowsizes[partNumber];                                     if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))                 {                    throw IEX_NAMESPACE::IoExc(""chunk index out of range"");                 }                                  parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;                                  if(header.type()==DEEPSCANLINE)                 {                     Int64 packed_offset;                     Int64 packed_sample;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);                                                               size_of_chunk=packed_offset+packed_sample+28;                 }                 else                 {                     int chunksize;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);                        size_of_chunk=chunksize+8;                 }                              }                          if(isMultiPart(version))             {                 chunk_start+=4;             }                          chunk_start+=size_of_chunk;                          is.seekg(chunk_start);                      }              }     catch (...)     {         //         // Suppress all exceptions.  This functions is         // called only to reconstruct the line offset         // table for incomplete files, and exceptions         // are likely.         //     }      // copy tiled part data back to chunk offsets          for(size_t partNumber=0;partNumber<parts.size();partNumber++)     {         if(tileOffsets[partNumber])         {             size_t pos=0;             vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();             for (size_t l = 0; l < offsets.size(); l++)                 for (size_t y = 0; y < offsets[l].size(); y++)                     for (size_t x = 0; x < offsets[l][y].size(); x++)                     {                         parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];                         pos++;                     }            delete tileOffsets[partNumber];         }     }      is.clear();     is.seekg (position); }"
"MultiPartInputFile__Data__chunkOffsetReconstruction_ImfMultiPartInputFile_not_vulnerable.cpp","not_vulnerable","MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts) {     //     // Reconstruct broken chunk offset tables. Stop once we received any exception.     //      Int64 position = is.tellg();           //     // check we understand all the parts available: if not, we cannot continue     // exceptions thrown here should trickle back up to the constructor     //          for (size_t i = 0; i < parts.size(); i++)     {         Header& header=parts[i]->header;                  //         // do we have a valid type entry?         // we only need them for true multipart files or single part non-image (deep) files         //         if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))         {             throw IEX_NAMESPACE::ArgExc(""cannot reconstruct incomplete file: part with missing type"");         }         if(!isSupportedType(header.type()))         {             throw IEX_NAMESPACE::ArgExc(""cannot reconstruct incomplete file: part with unknown type ""+header.type());         }     }               // how many chunks should we read? We should stop when we reach the end     size_t total_chunks = 0;              // for tiled-based parts, array of (pointers to) tileOffsets objects     // to create mapping between tile coordinates and chunk table indices               vector<TileOffsets*> tileOffsets(parts.size());          // for scanline-based parts, number of scanlines in each chunk     vector<int> rowsizes(parts.size());              for(size_t i = 0 ; i < parts.size() ; i++)     {         total_chunks += parts[i]->chunkOffsets.size();         if (isTiled(parts[i]->header.type()))         {             tileOffsets[i] = createTileOffsets(parts[i]->header);         }else{             tileOffsets[i] = NULL;             // (TODO) fix this so that it doesn't need to be revised for future compression types.             switch(parts[i]->header.compression())             {                 case DWAB_COMPRESSION :                     rowsizes[i] = 256;                     break;                 case PIZ_COMPRESSION :                 case B44_COMPRESSION :                 case B44A_COMPRESSION :                 case DWAA_COMPRESSION :                     rowsizes[i]=32;                     break;                 case ZIP_COMPRESSION :                 case PXR24_COMPRESSION :                     rowsizes[i]=16;                     break;                 case ZIPS_COMPRESSION :                 case RLE_COMPRESSION :                 case NO_COMPRESSION :                     rowsizes[i]=1;                     break;                 default :                     throw(IEX_NAMESPACE::ArgExc(""Unknown compression method in chunk offset reconstruction""));             }         }      }               try      {                      //         //          //                  Int64 chunk_start = position;         for (size_t i = 0; i < total_chunks ; i++)         {             //             // do we have a part number?             //                          int partNumber = 0;             if(isMultiPart(version))             {                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);             }                                                    if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))             {                 throw IEX_NAMESPACE::IoExc(""part number out of range"");             }                          Header& header = parts[partNumber]->header;              // size of chunk NOT including multipart field                          Int64 size_of_chunk=0;              if (isTiled(header.type()))             {                 //                 //                  //                 int tilex,tiley,levelx,levely;                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);                                  //std::cout << ""chunk_start for "" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;                                                       if(!tileOffsets[partNumber])                 {                     // this shouldn't actually happen - we should have allocated a valid                     // tileOffsets for any part which isTiled                     throw IEX_NAMESPACE::IoExc(""part not tiled"");                                      }                                  if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))                 {                     throw IEX_NAMESPACE::IoExc(""invalid tile coordinates"");                 }                                  (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;                                  // compute chunk sizes - different procedure for deep tiles and regular                 // ones                 if(header.type()==DEEPTILE)                 {                     Int64 packed_offset;                     Int64 packed_sample;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);                                          //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)                     size_of_chunk=packed_offset+packed_sample+40;                 }                 else                 {                                          // regular image has 20 bytes of header, 4 byte chunksize;                     int chunksize;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);                     size_of_chunk=chunksize+20;                 }             }             else             {                 int y_coordinate;                 OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);                                                   if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)                 {                    throw IEX_NAMESPACE::IoExc(""y out of range"");                 }                 y_coordinate -= header.dataWindow().min.y;                 y_coordinate /= rowsizes[partNumber];                                     if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))                 {                    throw IEX_NAMESPACE::IoExc(""chunk index out of range"");                 }                                  parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;                                  if(header.type()==DEEPSCANLINE)                 {                     Int64 packed_offset;                     Int64 packed_sample;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);                                                               size_of_chunk=packed_offset+packed_sample+28;                 }                 else                 {                     int chunksize;                     OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);                        size_of_chunk=chunksize+8;                 }                              }                          if(isMultiPart(version))             {                 chunk_start+=4;             }                          chunk_start+=size_of_chunk;                          is.seekg(chunk_start);                      }              }     catch (...)     {         //         // Suppress all exceptions.  This functions is         // called only to reconstruct the line offset         // table for incomplete files, and exceptions         // are likely.         //     }      // copy tiled part data back to chunk offsets          for(size_t partNumber=0;partNumber<parts.size();partNumber++)     {         if(tileOffsets[partNumber])         {             size_t pos=0;             vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();             for (size_t l = 0; l < offsets.size(); l++)                 for (size_t y = 0; y < offsets[l].size(); y++)                     for (size_t x = 0; x < offsets[l][y].size(); x++)                     {                         parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];                         pos++;                     }            delete tileOffsets[partNumber];         }     }      is.clear();     is.seekg (position); }"
"PHP_MINIT_FUNCTION_spl_array_cwe-416.c","CWE-416","PHP_MINIT_FUNCTION(spl_array) { 	REGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Countable); 	memcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));  	spl_handler_ArrayObject.clone_obj = spl_array_object_clone; 	spl_handler_ArrayObject.read_dimension = spl_array_read_dimension; 	spl_handler_ArrayObject.write_dimension = spl_array_write_dimension; 	spl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension; 	spl_handler_ArrayObject.has_dimension = spl_array_has_dimension; 	spl_handler_ArrayObject.count_elements = spl_array_object_count_elements;  	spl_handler_ArrayObject.get_properties = spl_array_get_properties; 	spl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info; 	spl_handler_ArrayObject.get_gc = spl_array_get_gc; 	spl_handler_ArrayObject.read_property = spl_array_read_property; 	spl_handler_ArrayObject.write_property = spl_array_write_property; 	spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr; 	spl_handler_ArrayObject.has_property = spl_array_has_property; 	spl_handler_ArrayObject.unset_property = spl_array_unset_property;  	spl_handler_ArrayObject.compare_objects = spl_array_compare_objects;  	REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable); 	memcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers)); 	spl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;  	REGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator); 	REGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator); 	spl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;  	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST); 	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);  	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST); 	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);  	REGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, ""CHILD_ARRAYS_ONLY"", SPL_ARRAY_CHILD_ARRAYS_ONLY);  	return SUCCESS; }"
"PHP_MINIT_FUNCTION_spl_array_not_vulnerable.c","not_vulnerable","PHP_MINIT_FUNCTION(spl_array) { 	REGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable); 	REGISTER_SPL_IMPLEMENTS(ArrayObject, Countable); 	memcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));  	spl_handler_ArrayObject.clone_obj = spl_array_object_clone; 	spl_handler_ArrayObject.read_dimension = spl_array_read_dimension; 	spl_handler_ArrayObject.write_dimension = spl_array_write_dimension; 	spl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension; 	spl_handler_ArrayObject.has_dimension = spl_array_has_dimension; 	spl_handler_ArrayObject.count_elements = spl_array_object_count_elements;  	spl_handler_ArrayObject.get_properties = spl_array_get_properties; 	spl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info; 	spl_handler_ArrayObject.get_gc = spl_array_get_gc; 	spl_handler_ArrayObject.read_property = spl_array_read_property; 	spl_handler_ArrayObject.write_property = spl_array_write_property; 	spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr; 	spl_handler_ArrayObject.has_property = spl_array_has_property; 	spl_handler_ArrayObject.unset_property = spl_array_unset_property;  	spl_handler_ArrayObject.compare_objects = spl_array_compare_objects;  	REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable); 	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable); 	memcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers)); 	spl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;  	REGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator); 	REGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator); 	spl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;  	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST); 	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);  	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST); 	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);  	REGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, ""CHILD_ARRAYS_ONLY"", SPL_ARRAY_CHILD_ARRAYS_ONLY);  	return SUCCESS; }"
"PeerListWidget__addPeer_peerlistwidget_cwe-079.cpp","CWE-079","QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) {     int row = m_listModel->rowCount();     // Adding Peer to peer list     m_listModel->insertRow(row);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);     if (m_resolveCountries) {         const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());         if (!ico.isNull()) {             m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);             const QString countryName = Net::GeoIPManager::CountryName(peer.country());             m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);         }         else {             m_missingFlags.insert(ip);         }     }     m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());     QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";"")));     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole);      return m_listModel->item(row, PeerListDelegate::IP); }"
"PeerListWidget__addPeer_peerlistwidget_not_vulnerable.cpp","not_vulnerable","QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) {     int row = m_listModel->rowCount();     // Adding Peer to peer list     m_listModel->insertRow(row);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);     if (m_resolveCountries) {         const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());         if (!ico.isNull()) {             m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);             const QString countryName = Net::GeoIPManager::CountryName(peer.country());             m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);         }         else {             m_missingFlags.insert(ip);         }     }     m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);     m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());     m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());     QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";"")));     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole);      return m_listModel->item(row, PeerListDelegate::IP); }"
"ReadDCMImage_dcm_cwe-476.c","CWE-476","static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception) {   char     explicit_vr[MagickPathExtent],     implicit_vr[MagickPathExtent],     magick[MagickPathExtent],     photometric[MagickPathExtent];    DCMStreamInfo     *stream_info;    Image     *image;    int     *bluemap,     datum,     *greenmap,     *graymap,     index,     *redmap;    MagickBooleanType     explicit_file,     explicit_retry,     polarity,     sequence,     use_explicit;    MagickOffsetType     offset;    Quantum     *scale;    register ssize_t     i,     x;    register Quantum     *q;    register unsigned char     *p;    size_t     bits_allocated,     bytes_per_pixel,     colors,     depth,     height,     length,     mask,     max_value,     number_scenes,     quantum,     samples_per_pixel,     signed_data,     significant_bits,     status,     width,     window_width;    ssize_t     count,     rescale_intercept,     rescale_slope,     scene,     window_center,     y;    unsigned char     *data;    unsigned short     group,     element;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info,exception);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   image->depth=8UL;   image->endian=LSBEndian;   /*     Read DCM preamble.   */   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));   if (stream_info == (DCMStreamInfo *) NULL)     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");   (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));   count=ReadBlob(image,128,(unsigned char *) magick);   if (count != 128)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   count=ReadBlob(image,4,(unsigned char *) magick);   if ((count != 4) || (LocaleNCompare(magick,""DICM"",4) != 0))     {       offset=SeekBlob(image,0L,SEEK_SET);       if (offset < 0)         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     }   /*     Read DCM Medical image.   */   (void) CopyMagickString(photometric,""MONOCHROME1 "",MagickPathExtent);   bits_allocated=8;   bytes_per_pixel=1;   polarity=MagickFalse;   data=(unsigned char *) NULL;   depth=8;   element=0;   explicit_vr[2]='\0';   explicit_file=MagickFalse;   colors=0;   redmap=(int *) NULL;   greenmap=(int *) NULL;   bluemap=(int *) NULL;   graymap=(int *) NULL;   height=0;   max_value=255UL;   mask=0xffff;   number_scenes=1;   rescale_intercept=0;   rescale_slope=1;   samples_per_pixel=1;   scale=(Quantum *) NULL;   sequence=MagickFalse;   signed_data=(~0UL);   significant_bits=0;   use_explicit=MagickFalse;   explicit_retry = MagickFalse;   width=0;   window_center=0;   window_width=0;   for (group=0; (group != 0x7FE0) || (element != 0x0010) ||                 (sequence != MagickFalse); )   {     /*       Read a group.     */     image->offset=(ssize_t) TellBlob(image);     group=ReadBlobLSBShort(image);     element=ReadBlobLSBShort(image);     if ((group != 0x0002) && (image->endian == MSBEndian))       {         group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));         element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));       }     quantum=0;     /*       Find corresponding VR for this group and element.     */     for (i=0; dicom_info[i].group < 0xffff; i++)       if ((group == dicom_info[i].group) && (element == dicom_info[i].element))         break;     (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);     count=ReadBlob(image,2,(unsigned char *) explicit_vr);     if (count != 2)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     /*       Check for ""explicitness"", but meta-file headers always explicit.     */     if ((explicit_file == MagickFalse) && (group != 0x0002))       explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&         (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?         MagickTrue : MagickFalse;     use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||       (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;     if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,""xs"",2) == 0))       (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);     if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,""!!"",2) == 0))       {         offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);         if (offset < 0)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         quantum=4;       }     else       {         /*           Assume explicit type.         */         quantum=2;         if ((strncmp(explicit_vr,""OB"",2) == 0) ||             (strncmp(explicit_vr,""UN"",2) == 0) ||             (strncmp(explicit_vr,""OW"",2) == 0) ||             (strncmp(explicit_vr,""SQ"",2) == 0))           {             (void) ReadBlobLSBShort(image);             quantum=4;           }       }     datum=0;     if (quantum == 4)       {         if (group == 0x0002)           datum=ReadBlobLSBSignedLong(image);         else           datum=ReadBlobSignedLong(image);       }     else       if (quantum == 2)         {           if (group == 0x0002)             datum=ReadBlobLSBSignedShort(image);           else             datum=ReadBlobSignedShort(image);         }     quantum=0;     length=1;     if (datum != 0)       {         if ((strncmp(implicit_vr,""SS"",2) == 0) ||             (strncmp(implicit_vr,""US"",2) == 0))           quantum=2;         else           if ((strncmp(implicit_vr,""UL"",2) == 0) ||               (strncmp(implicit_vr,""SL"",2) == 0) ||               (strncmp(implicit_vr,""FL"",2) == 0))             quantum=4;           else             if (strncmp(implicit_vr,""FD"",2) != 0)               quantum=1;             else               quantum=8;         if (datum != ~0)           length=(size_t) datum/quantum;         else           {             /*               Sequence and item of undefined length.             */             quantum=0;             length=0;           }       }     if (image_info->verbose != MagickFalse)       {         /*           Display Dicom info.         */         if (use_explicit == MagickFalse)           explicit_vr[0]='\0';         for (i=0; dicom_info[i].description != (char *) NULL; i++)           if ((group == dicom_info[i].group) &&               (element == dicom_info[i].element))             break;         (void) FormatLocaleFile(stdout,""0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)"",           (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,           (unsigned long) group,(unsigned long) element);         if (dicom_info[i].description != (char *) NULL)           (void) FormatLocaleFile(stdout,"" %s"",dicom_info[i].description);         (void) FormatLocaleFile(stdout,"": "");       }     if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))       {         if (image_info->verbose != MagickFalse)           (void) FormatLocaleFile(stdout,""\n"");         break;       }     /*       Allocate space and read an array.     */     data=(unsigned char *) NULL;     if ((length == 1) && (quantum == 1))       datum=ReadBlobByte(image);     else       if ((length == 1) && (quantum == 2))         {           if (group == 0x0002)             datum=ReadBlobLSBSignedShort(image);           else             datum=ReadBlobSignedShort(image);         }       else         if ((length == 1) && (quantum == 4))           {             if (group == 0x0002)               datum=ReadBlobLSBSignedLong(image);             else               datum=ReadBlobSignedLong(image);           }         else           if ((quantum != 0) && (length != 0))             {               if (~length >= 1)                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*                   sizeof(*data));               if (data == (unsigned char *) NULL)                 ThrowReaderException(ResourceLimitError,                   ""MemoryAllocationFailed"");               count=ReadBlob(image,(size_t) quantum*length,data);               if (count != (ssize_t) (quantum*length))                 {                   if (image_info->verbose != MagickFalse)                     (void) FormatLocaleFile(stdout,""count=%d quantum=%d ""                       ""length=%d group=%d\n"",(int) count,(int) quantum,(int)                       length,(int) group);                    ThrowReaderException(CorruptImageError,                      ""InsufficientImageDataInFile"");                 }               data[length*quantum]='\0';             }           else             if ((unsigned int) datum == 0xFFFFFFFFU)               {                 sequence=MagickTrue;                 continue;               }      if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)       {         if (data != (unsigned char *) NULL)           data=(unsigned char *) RelinquishMagickMemory(data);         sequence=MagickFalse;         continue;       }      if (sequence != MagickFalse)       {         if (data != (unsigned char *) NULL)           data=(unsigned char *) RelinquishMagickMemory(data);         continue;       }      switch (group)     {       case 0x0002:       {         switch (element)         {           case 0x0010:           {             char               transfer_syntax[MagickPathExtent];              /*               Transfer Syntax.             */             if ((datum == 0) && (explicit_retry == MagickFalse))               {                 explicit_retry=MagickTrue;                 (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);                 group=0;                 element=0;                 if (image_info->verbose != MagickFalse)                   (void) FormatLocaleFile(stdout,                     ""Corrupted image - trying explicit format\n"");                 break;               }             *transfer_syntax='\0';             if (data != (unsigned char *) NULL)               (void) CopyMagickString(transfer_syntax,(char *) data,                 MagickPathExtent);             if (image_info->verbose != MagickFalse)               (void) FormatLocaleFile(stdout,""transfer_syntax=%s\n"",                 (const char *) transfer_syntax);             if (strncmp(transfer_syntax,""1.2.840.10008.1.2"",17) == 0)               {                 int                   count,                   subtype,                   type;                  type=1;                 subtype=0;                 if (strlen(transfer_syntax) > 17)                   {                     count=sscanf(transfer_syntax+17,"".%d.%d"",&type,&subtype);                     if (count < 1)                       ThrowReaderException(CorruptImageError,                         ""ImproperImageHeader"");                   }                 switch (type)                 {                   case 1:                   {                     image->endian=LSBEndian;                     break;                   }                   case 2:                   {                     image->endian=MSBEndian;                     break;                   }                   case 4:                   {                     if ((subtype >= 80) && (subtype <= 81))                       image->compression=JPEGCompression;                     else                       if ((subtype >= 90) && (subtype <= 93))                         image->compression=JPEG2000Compression;                       else                         image->compression=JPEGCompression;                     break;                   }                   case 5:                   {                     image->compression=RLECompression;                     break;                   }                 }               }             break;           }           default:             break;         }         break;       }       case 0x0028:       {         switch (element)         {           case 0x0002:           {             /*               Samples per pixel.             */             samples_per_pixel=(size_t) datum;             break;           }           case 0x0004:           {             /*               Photometric interpretation.             */             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)               photometric[i]=(char) data[i];             photometric[i]='\0';             polarity=LocaleCompare(photometric,""MONOCHROME1 "") == 0 ?               MagickTrue : MagickFalse;             break;           }           case 0x0006:           {             /*               Planar configuration.             */             if (datum == 1)               image->interlace=PlaneInterlace;             break;           }           case 0x0008:           {             /*               Number of frames.             */             number_scenes=StringToUnsignedLong((char *) data);             break;           }           case 0x0010:           {             /*               Image rows.             */             height=(size_t) datum;             break;           }           case 0x0011:           {             /*               Image columns.             */             width=(size_t) datum;             break;           }           case 0x0100:           {             /*               Bits allocated.             */             bits_allocated=(size_t) datum;             bytes_per_pixel=1;             if (datum > 8)               bytes_per_pixel=2;             depth=bits_allocated;             if (depth > 32)               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");             max_value=(1UL << bits_allocated)-1;             break;           }           case 0x0101:           {             /*               Bits stored.             */             significant_bits=(size_t) datum;             bytes_per_pixel=1;             if (significant_bits > 8)               bytes_per_pixel=2;             depth=significant_bits;             if (depth > 32)               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");             max_value=(1UL << significant_bits)-1;             mask=(size_t) GetQuantumRange(significant_bits);             break;           }           case 0x0102:           {             /*               High bit.             */             break;           }           case 0x0103:           {             /*               Pixel representation.             */             signed_data=(size_t) datum;             break;           }           case 0x1050:           {             /*               Visible pixel range: center.             */             if (data != (unsigned char *) NULL)               window_center=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1051:           {             /*               Visible pixel range: width.             */             if (data != (unsigned char *) NULL)               window_width=StringToUnsignedLong((char *) data);             break;           }           case 0x1052:           {             /*               Rescale intercept             */             if (data != (unsigned char *) NULL)               rescale_intercept=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1053:           {             /*               Rescale slope             */             if (data != (unsigned char *) NULL)               rescale_slope=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1200:           case 0x3006:           {             /*               Populate graymap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/bytes_per_pixel);             datum=(int) colors;             graymap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*graymap));             if (graymap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             for (i=0; i < (ssize_t) colors; i++)               if (bytes_per_pixel == 1)                 graymap[i]=(int) data[i];               else                 graymap[i]=(int) ((short *) data)[i];             break;           }           case 0x1201:           {             unsigned short               index;              /*               Populate redmap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             redmap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*redmap));             if (redmap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               redmap[i]=(int) index;               p+=2;             }             break;           }           case 0x1202:           {             unsigned short               index;              /*               Populate greenmap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             greenmap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*greenmap));             if (greenmap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               greenmap[i]=(int) index;               p+=2;             }             break;           }           case 0x1203:           {             unsigned short               index;              /*               Populate bluemap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             bluemap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*bluemap));             if (bluemap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               bluemap[i]=(int) index;               p+=2;             }             break;           }           default:             break;         }         break;       }       case 0x2050:       {         switch (element)         {           case 0x0020:           {             if ((data != (unsigned char *) NULL) &&                 (strncmp((char *) data,""INVERSE"",7) == 0))               polarity=MagickTrue;             break;           }           default:             break;         }         break;       }       default:         break;     }     if (data != (unsigned char *) NULL)       {         char           *attribute;          for (i=0; dicom_info[i].description != (char *) NULL; i++)           if ((group == dicom_info[i].group) &&               (element == dicom_info[i].element))             break;         if (dicom_info[i].description != (char *) NULL)           {             attribute=AcquireString(""dcm:"");             (void) ConcatenateString(&attribute,dicom_info[i].description);             for (i=0; i < (ssize_t) MagickMax(length,4); i++)               if (isprint((int) data[i]) == MagickFalse)                 break;             if ((i == (ssize_t) length) || (length > 4))               {                 (void) SubstituteString(&attribute,"" "","""");                 (void) SetImageProperty(image,attribute,(char *) data,exception);               }             attribute=DestroyString(attribute);           }       }     if (image_info->verbose != MagickFalse)       {         if (data == (unsigned char *) NULL)           (void) FormatLocaleFile(stdout,""%d\n"",datum);         else           {             /*               Display group data.             */             for (i=0; i < (ssize_t) MagickMax(length,4); i++)               if (isprint((int) data[i]) == MagickFalse)                 break;             if ((i != (ssize_t) length) && (length <= 4))               {                 ssize_t                   j;                  datum=0;                 for (j=(ssize_t) length-1; j >= 0; j--)                   datum=(256*datum+data[j]);                 (void) FormatLocaleFile(stdout,""%d"",datum);               }             else               for (i=0; i < (ssize_t) length; i++)                 if (isprint((int) data[i]) != MagickFalse)                   (void) FormatLocaleFile(stdout,""%c"",data[i]);                 else                   (void) FormatLocaleFile(stdout,""%c"",'.');             (void) FormatLocaleFile(stdout,""\n"");           }       }     if (data != (unsigned char *) NULL)       data=(unsigned char *) RelinquishMagickMemory(data);     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }   }   if ((width == 0) || (height == 0))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   image->columns=(size_t) width;   image->rows=(size_t) height;   if (signed_data == 0xffff)     signed_data=(size_t) (significant_bits == 16 ? 1 : 0);   if ((image->compression == JPEGCompression) ||       (image->compression == JPEG2000Compression))     {       Image         *images;        ImageInfo         *read_info;        int         c;        size_t         length;        unsigned int         tag;        /*         Read offset table.       */       for (i=0; i < (ssize_t) stream_info->remaining; i++)         (void) ReadBlobByte(image);       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);       (void) tag;       length=(size_t) ReadBlobLSBLong(image);       stream_info->offset_count=length >> 2;       if (stream_info->offset_count != 0)         {           MagickOffsetType             offset;            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(             stream_info->offset_count,sizeof(*stream_info->offsets));           if (stream_info->offsets == (ssize_t *) NULL)             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);           offset=TellBlob(image);           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]+=offset;         }       /*         Handle non-native image formats.       */       read_info=CloneImageInfo(image_info);       SetImageInfoBlob(read_info,(void *) NULL,0);       images=NewImageList();       for (scene=0; scene < (ssize_t) number_scenes; scene++)       {         char           filename[MagickPathExtent];          const char           *property;          FILE           *file;          Image           *jpeg_image;          int           unique_file;          unsigned int           tag;          tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);         length=(size_t) ReadBlobLSBLong(image);         if (tag == 0xFFFEE0DD)           break; /* sequence delimiter tag */         if (tag != 0xFFFEE000)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         file=(FILE *) NULL;         unique_file=AcquireUniqueFileResource(filename);         if (unique_file != -1)           file=fdopen(unique_file,""wb"");         if (file == (FILE *) NULL)           {             (void) RelinquishUniqueFileResource(filename);             ThrowFileException(exception,FileOpenError,               ""UnableToCreateTemporaryFile"",filename);             break;           }         for ( ; length != 0; length--)         {           c=ReadBlobByte(image);           if (c == EOF)             {               ThrowFileException(exception,CorruptImageError,                 ""UnexpectedEndOfFile"",image->filename);               break;             }           (void) fputc(c,file);         }         (void) fclose(file);         (void) FormatLocaleString(read_info->filename,MagickPathExtent,           ""jpeg:%s"",filename);         if (image->compression == JPEG2000Compression)           (void) FormatLocaleString(read_info->filename,MagickPathExtent,             ""j2k:%s"",filename);         jpeg_image=ReadImage(read_info,exception);         if (jpeg_image != (Image *) NULL)           {             ResetImagePropertyIterator(image);             property=GetNextImageProperty(image);             while (property != (const char *) NULL)             {               (void) SetImageProperty(jpeg_image,property,                 GetImageProperty(image,property,exception),exception);               property=GetNextImageProperty(image);             }             AppendImageToList(&images,jpeg_image);           }         (void) RelinquishUniqueFileResource(filename);       }       read_info=DestroyImageInfo(read_info);       image=DestroyImage(image);       return(GetFirstImageInList(images));     }   if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))     {       QuantumAny         range;        size_t         length;        /*         Compute pixel scaling table.       */       length=(size_t) (GetQuantumRange(depth)+1);       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));       if (scale == (Quantum *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       range=GetQuantumRange(depth);       for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)         scale[i]=ScaleAnyToQuantum((size_t) i,range);     }   if (image->compression == RLECompression)     {       size_t         length;        unsigned int         tag;        /*         Read RLE offset table.       */       for (i=0; i < (ssize_t) stream_info->remaining; i++)         (void) ReadBlobByte(image);       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);       (void) tag;       length=(size_t) ReadBlobLSBLong(image);       stream_info->offset_count=length >> 2;       if (stream_info->offset_count != 0)         {           MagickOffsetType             offset;            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(             stream_info->offset_count,sizeof(*stream_info->offsets));           if (stream_info->offsets == (ssize_t *) NULL)             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);           offset=TellBlob(image);           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]+=offset;         }     }   for (scene=0; scene < (ssize_t) number_scenes; scene++)   {     if (image_info->ping != MagickFalse)       break;     image->columns=(size_t) width;     image->rows=(size_t) height;     image->depth=depth;     status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       break;     image->colorspace=RGBColorspace;     if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))       {         size_t           one;          one=1;         if (colors == 0)           colors=one << depth;         if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         if (redmap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=redmap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].red=(MagickRealType) index;           }         if (greenmap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=greenmap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].green=(MagickRealType) index;           }         if (bluemap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=bluemap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].blue=(MagickRealType) index;           }         if (graymap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=graymap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].red=(MagickRealType) index;             image->colormap[i].green=(MagickRealType) index;             image->colormap[i].blue=(MagickRealType) index;           }       }     if (image->compression == RLECompression)       {         unsigned int           tag;          /*           Read RLE segment table.         */         for (i=0; i < (ssize_t) stream_info->remaining; i++)           (void) ReadBlobByte(image);         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);         stream_info->remaining=(size_t) ReadBlobLSBLong(image);         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||             (EOFBlob(image) != MagickFalse))           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         stream_info->count=0;         stream_info->segment_count=ReadBlobLSBLong(image);         if (stream_info->segment_count > 1)           {             bytes_per_pixel=1;             depth=8;           }         for (i=0; i < 15; i++)           stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);         stream_info->remaining-=64;       }     if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))       {         /*           Convert Planar RGB DCM Medical image to pixel packets.         */         for (i=0; i < (ssize_t) samples_per_pixel; i++)         {           for (y=0; y < (ssize_t) image->rows; y++)           {             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);             if (q == (Quantum *) NULL)               break;             for (x=0; x < (ssize_t) image->columns; x++)             {               switch ((int) i)               {                 case 0:                 {                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 1:                 {                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 2:                 {                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 3:                 {                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 default:                   break;               }               q+=GetPixelChannels(image);             }             if (SyncAuthenticPixels(image,exception) == MagickFalse)               break;             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                   image->rows);                 if (status == MagickFalse)                   break;               }           }         }       }     else       {         const char           *option;          int           byte;          PixelPacket           pixel;          /*           Convert DCM Medical image to pixel packets.         */         byte=0;         i=0;         if ((window_center != 0) && (window_width == 0))           window_width=(size_t) window_center;         option=GetImageOption(image_info,""dcm:display-range"");         if (option != (const char *) NULL)           {             if (LocaleCompare(option,""reset"") == 0)               window_width=0;           }         (void) ResetMagickMemory(&pixel,0,sizeof(pixel));         for (y=0; y < (ssize_t) image->rows; y++)         {           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (Quantum *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             if (samples_per_pixel == 1)               {                 int                   pixel_value;                  if (bytes_per_pixel == 1)                   pixel_value=polarity != MagickFalse ?                     ((int) max_value-ReadDCMByte(stream_info,image)) :                     ReadDCMByte(stream_info,image);                 else                   if ((bits_allocated != 12) || (significant_bits != 12))                     {                       if (signed_data)                         pixel_value=ReadDCMSignedShort(stream_info,image);                       else                         pixel_value=ReadDCMShort(stream_info,image);                       if (polarity != MagickFalse)                         pixel_value=(int)max_value-pixel_value;                     }                   else                     {                       if ((i & 0x01) != 0)                         pixel_value=(ReadDCMByte(stream_info,image) << 8) |                           byte;                       else                         {                           pixel_value=ReadDCMSignedShort(stream_info,image);                           byte=(int) (pixel_value & 0x0f);                           pixel_value>>=4;                         }                       i++;                     }                 index=(pixel_value*rescale_slope)+rescale_intercept;                 if (window_width == 0)                   {                     if (signed_data == 1)                       index-=32767;                   }                 else                   {                     ssize_t                       window_max,                       window_min;                      window_min=(ssize_t) ceil((double) window_center-                       (window_width-1.0)/2.0-0.5);                     window_max=(ssize_t) floor((double) window_center+                       (window_width-1.0)/2.0+0.5);                     if ((ssize_t)index <= window_min)                       index=0;                     else                       if ((ssize_t)index > window_max)                         index=(int) max_value;                       else                         index=(int) (max_value*(((index-window_center-                           0.5)/(window_width-1))+0.5));                   }                 index&=mask;                 index=(int) ConstrainColormapIndex(image,(size_t) index,                   exception);                 SetPixelIndex(image,(Quantum) index,q);                 pixel.red=(unsigned int) image->colormap[index].red;                 pixel.green=(unsigned int) image->colormap[index].green;                 pixel.blue=(unsigned int) image->colormap[index].blue;               }             else               {                 if (bytes_per_pixel == 1)                   {                     pixel.red=(unsigned int) ReadDCMByte(stream_info,image);                     pixel.green=(unsigned int) ReadDCMByte(stream_info,image);                     pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);                   }                 else                   {                     pixel.red=ReadDCMShort(stream_info,image);                     pixel.green=ReadDCMShort(stream_info,image);                     pixel.blue=ReadDCMShort(stream_info,image);                   }                 pixel.red&=mask;                 pixel.green&=mask;                 pixel.blue&=mask;                 if (scale != (Quantum *) NULL)                   {                     pixel.red=scale[pixel.red];                     pixel.green=scale[pixel.green];                     pixel.blue=scale[pixel.blue];                   }               }             SetPixelRed(image,(Quantum) pixel.red,q);             SetPixelGreen(image,(Quantum) pixel.green,q);             SetPixelBlue(image,(Quantum) pixel.blue,q);             q+=GetPixelChannels(image);           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         if (stream_info->segment_count > 1)           for (y=0; y < (ssize_t) image->rows; y++)           {             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);             if (q == (Quantum *) NULL)               break;             for (x=0; x < (ssize_t) image->columns; x++)             {               if (samples_per_pixel == 1)                 {                   int                     pixel_value;                    if (bytes_per_pixel == 1)                     pixel_value=polarity != MagickFalse ?                       ((int) max_value-ReadDCMByte(stream_info,image)) :                       ReadDCMByte(stream_info,image);                   else                     if ((bits_allocated != 12) || (significant_bits != 12))                       {                         pixel_value=(int) (polarity != MagickFalse ?                           (max_value-ReadDCMShort(stream_info,image)) :                           ReadDCMShort(stream_info,image));                         if (signed_data == 1)                           pixel_value=((signed short) pixel_value);                       }                     else                       {                         if ((i & 0x01) != 0)                           pixel_value=(ReadDCMByte(stream_info,image) << 8) |                             byte;                         else                           {                             pixel_value=ReadDCMShort(stream_info,image);                             byte=(int) (pixel_value & 0x0f);                             pixel_value>>=4;                           }                         i++;                       }                   index=(pixel_value*rescale_slope)+rescale_intercept;                   if (window_width == 0)                     {                       if (signed_data == 1)                         index-=32767;                     }                   else                     {                       ssize_t                         window_max,                         window_min;                        window_min=(ssize_t) ceil((double) window_center-                         (window_width-1.0)/2.0-0.5);                       window_max=(ssize_t) floor((double) window_center+                         (window_width-1.0)/2.0+0.5);                       if ((ssize_t)index <= window_min)                         index=0;                       else                         if ((ssize_t)index > window_max)                           index=(int) max_value;                         else                           index=(int) (max_value*(((index-window_center-                             0.5)/(window_width-1))+0.5));                     }                   index&=mask;                   index=(int) ConstrainColormapIndex(image,(size_t) index,                     exception);                   SetPixelIndex(image,(Quantum) (((size_t)                     GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);                   pixel.red=(unsigned int) image->colormap[index].red;                   pixel.green=(unsigned int) image->colormap[index].green;                   pixel.blue=(unsigned int) image->colormap[index].blue;                 }               else                 {                   if (bytes_per_pixel == 1)                     {                       pixel.red=(unsigned int) ReadDCMByte(stream_info,image);                       pixel.green=(unsigned int) ReadDCMByte(stream_info,image);                       pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);                     }                   else                     {                       pixel.red=ReadDCMShort(stream_info,image);                       pixel.green=ReadDCMShort(stream_info,image);                       pixel.blue=ReadDCMShort(stream_info,image);                     }                   pixel.red&=mask;                   pixel.green&=mask;                   pixel.blue&=mask;                   if (scale != (Quantum *) NULL)                     {                       pixel.red=scale[pixel.red];                       pixel.green=scale[pixel.green];                       pixel.blue=scale[pixel.blue];                     }                 }               SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |                 (((size_t) pixel.red) << 8)),q);               SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |                 (((size_t) pixel.green) << 8)),q);               SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |                 (((size_t) pixel.blue) << 8)),q);               q+=GetPixelChannels(image);             }             if (SyncAuthenticPixels(image,exception) == MagickFalse)               break;             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                   image->rows);                 if (status == MagickFalse)                   break;               }           }       }     if (SetImageGray(image,exception) != MagickFalse)       (void) SetImageColorspace(image,GRAYColorspace,exception);     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     if (scene < (ssize_t) (number_scenes-1))       {         /*           Allocate next image structure.         */         AcquireNextImage(image_info,image,exception);         if (GetNextImageInList(image) == (Image *) NULL)           {             image=DestroyImageList(image);             return((Image *) NULL);           }         image=SyncNextImageInList(image);         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),           GetBlobSize(image));         if (status == MagickFalse)           break;       }   }   /*     Free resources.   */   if (stream_info->offsets != (ssize_t *) NULL)     stream_info->offsets=(ssize_t *)       RelinquishMagickMemory(stream_info->offsets);   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);   if (scale != (Quantum *) NULL)     scale=(Quantum *) RelinquishMagickMemory(scale);   if (graymap != (int *) NULL)     graymap=(int *) RelinquishMagickMemory(graymap);   if (bluemap != (int *) NULL)     bluemap=(int *) RelinquishMagickMemory(bluemap);   if (greenmap != (int *) NULL)     greenmap=(int *) RelinquishMagickMemory(greenmap);   if (redmap != (int *) NULL)     redmap=(int *) RelinquishMagickMemory(redmap);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"ReadDCMImage_dcm_not_vulnerable.c","not_vulnerable","static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception) {   char     explicit_vr[MagickPathExtent],     implicit_vr[MagickPathExtent],     magick[MagickPathExtent],     photometric[MagickPathExtent];    DCMStreamInfo     *stream_info;    Image     *image;    int     *bluemap,     datum,     *greenmap,     *graymap,     index,     *redmap;    MagickBooleanType     explicit_file,     explicit_retry,     polarity,     sequence,     use_explicit;    MagickOffsetType     offset;    Quantum     *scale;    register ssize_t     i,     x;    register Quantum     *q;    register unsigned char     *p;    size_t     bits_allocated,     bytes_per_pixel,     colors,     depth,     height,     length,     mask,     max_value,     number_scenes,     quantum,     samples_per_pixel,     signed_data,     significant_bits,     status,     width,     window_width;    ssize_t     count,     rescale_intercept,     rescale_slope,     scene,     window_center,     y;    unsigned char     *data;    unsigned short     group,     element;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info,exception);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   image->depth=8UL;   image->endian=LSBEndian;   /*     Read DCM preamble.   */   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));   if (stream_info == (DCMStreamInfo *) NULL)     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");   (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));   count=ReadBlob(image,128,(unsigned char *) magick);   if (count != 128)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   count=ReadBlob(image,4,(unsigned char *) magick);   if ((count != 4) || (LocaleNCompare(magick,""DICM"",4) != 0))     {       offset=SeekBlob(image,0L,SEEK_SET);       if (offset < 0)         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     }   /*     Read DCM Medical image.   */   (void) CopyMagickString(photometric,""MONOCHROME1 "",MagickPathExtent);   bits_allocated=8;   bytes_per_pixel=1;   polarity=MagickFalse;   data=(unsigned char *) NULL;   depth=8;   element=0;   explicit_vr[2]='\0';   explicit_file=MagickFalse;   colors=0;   redmap=(int *) NULL;   greenmap=(int *) NULL;   bluemap=(int *) NULL;   graymap=(int *) NULL;   height=0;   max_value=255UL;   mask=0xffff;   number_scenes=1;   rescale_intercept=0;   rescale_slope=1;   samples_per_pixel=1;   scale=(Quantum *) NULL;   sequence=MagickFalse;   signed_data=(~0UL);   significant_bits=0;   use_explicit=MagickFalse;   explicit_retry = MagickFalse;   width=0;   window_center=0;   window_width=0;   for (group=0; (group != 0x7FE0) || (element != 0x0010) ||                 (sequence != MagickFalse); )   {     /*       Read a group.     */     image->offset=(ssize_t) TellBlob(image);     group=ReadBlobLSBShort(image);     element=ReadBlobLSBShort(image);     if ((group != 0x0002) && (image->endian == MSBEndian))       {         group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));         element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));       }     quantum=0;     /*       Find corresponding VR for this group and element.     */     for (i=0; dicom_info[i].group < 0xffff; i++)       if ((group == dicom_info[i].group) && (element == dicom_info[i].element))         break;     (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);     count=ReadBlob(image,2,(unsigned char *) explicit_vr);     if (count != 2)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     /*       Check for ""explicitness"", but meta-file headers always explicit.     */     if ((explicit_file == MagickFalse) && (group != 0x0002))       explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&         (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?         MagickTrue : MagickFalse;     use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||       (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;     if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,""xs"",2) == 0))       (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);     if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,""!!"",2) == 0))       {         offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);         if (offset < 0)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         quantum=4;       }     else       {         /*           Assume explicit type.         */         quantum=2;         if ((strncmp(explicit_vr,""OB"",2) == 0) ||             (strncmp(explicit_vr,""UN"",2) == 0) ||             (strncmp(explicit_vr,""OW"",2) == 0) ||             (strncmp(explicit_vr,""SQ"",2) == 0))           {             (void) ReadBlobLSBShort(image);             quantum=4;           }       }     datum=0;     if (quantum == 4)       {         if (group == 0x0002)           datum=ReadBlobLSBSignedLong(image);         else           datum=ReadBlobSignedLong(image);       }     else       if (quantum == 2)         {           if (group == 0x0002)             datum=ReadBlobLSBSignedShort(image);           else             datum=ReadBlobSignedShort(image);         }     quantum=0;     length=1;     if (datum != 0)       {         if ((strncmp(implicit_vr,""SS"",2) == 0) ||             (strncmp(implicit_vr,""US"",2) == 0))           quantum=2;         else           if ((strncmp(implicit_vr,""UL"",2) == 0) ||               (strncmp(implicit_vr,""SL"",2) == 0) ||               (strncmp(implicit_vr,""FL"",2) == 0))             quantum=4;           else             if (strncmp(implicit_vr,""FD"",2) != 0)               quantum=1;             else               quantum=8;         if (datum != ~0)           length=(size_t) datum/quantum;         else           {             /*               Sequence and item of undefined length.             */             quantum=0;             length=0;           }       }     if (image_info->verbose != MagickFalse)       {         /*           Display Dicom info.         */         if (use_explicit == MagickFalse)           explicit_vr[0]='\0';         for (i=0; dicom_info[i].description != (char *) NULL; i++)           if ((group == dicom_info[i].group) &&               (element == dicom_info[i].element))             break;         (void) FormatLocaleFile(stdout,""0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)"",           (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,           (unsigned long) group,(unsigned long) element);         if (dicom_info[i].description != (char *) NULL)           (void) FormatLocaleFile(stdout,"" %s"",dicom_info[i].description);         (void) FormatLocaleFile(stdout,"": "");       }     if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))       {         if (image_info->verbose != MagickFalse)           (void) FormatLocaleFile(stdout,""\n"");         break;       }     /*       Allocate space and read an array.     */     data=(unsigned char *) NULL;     if ((length == 1) && (quantum == 1))       datum=ReadBlobByte(image);     else       if ((length == 1) && (quantum == 2))         {           if (group == 0x0002)             datum=ReadBlobLSBSignedShort(image);           else             datum=ReadBlobSignedShort(image);         }       else         if ((length == 1) && (quantum == 4))           {             if (group == 0x0002)               datum=ReadBlobLSBSignedLong(image);             else               datum=ReadBlobSignedLong(image);           }         else           if ((quantum != 0) && (length != 0))             {               if (~length >= 1)                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*                   sizeof(*data));               if (data == (unsigned char *) NULL)                 ThrowReaderException(ResourceLimitError,                   ""MemoryAllocationFailed"");               count=ReadBlob(image,(size_t) quantum*length,data);               if (count != (ssize_t) (quantum*length))                 {                   if (image_info->verbose != MagickFalse)                     (void) FormatLocaleFile(stdout,""count=%d quantum=%d ""                       ""length=%d group=%d\n"",(int) count,(int) quantum,(int)                       length,(int) group);                    ThrowReaderException(CorruptImageError,                      ""InsufficientImageDataInFile"");                 }               data[length*quantum]='\0';             }           else             if ((unsigned int) datum == 0xFFFFFFFFU)               {                 sequence=MagickTrue;                 continue;               }      if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)       {         if (data != (unsigned char *) NULL)           data=(unsigned char *) RelinquishMagickMemory(data);         sequence=MagickFalse;         continue;       }      if (sequence != MagickFalse)       {         if (data != (unsigned char *) NULL)           data=(unsigned char *) RelinquishMagickMemory(data);         continue;       }      switch (group)     {       case 0x0002:       {         switch (element)         {           case 0x0010:           {             char               transfer_syntax[MagickPathExtent];              /*               Transfer Syntax.             */             if ((datum == 0) && (explicit_retry == MagickFalse))               {                 explicit_retry=MagickTrue;                 (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);                 group=0;                 element=0;                 if (image_info->verbose != MagickFalse)                   (void) FormatLocaleFile(stdout,                     ""Corrupted image - trying explicit format\n"");                 break;               }             *transfer_syntax='\0';             if (data != (unsigned char *) NULL)               (void) CopyMagickString(transfer_syntax,(char *) data,                 MagickPathExtent);             if (image_info->verbose != MagickFalse)               (void) FormatLocaleFile(stdout,""transfer_syntax=%s\n"",                 (const char *) transfer_syntax);             if (strncmp(transfer_syntax,""1.2.840.10008.1.2"",17) == 0)               {                 int                   count,                   subtype,                   type;                  type=1;                 subtype=0;                 if (strlen(transfer_syntax) > 17)                   {                     count=sscanf(transfer_syntax+17,"".%d.%d"",&type,&subtype);                     if (count < 1)                       ThrowReaderException(CorruptImageError,                         ""ImproperImageHeader"");                   }                 switch (type)                 {                   case 1:                   {                     image->endian=LSBEndian;                     break;                   }                   case 2:                   {                     image->endian=MSBEndian;                     break;                   }                   case 4:                   {                     if ((subtype >= 80) && (subtype <= 81))                       image->compression=JPEGCompression;                     else                       if ((subtype >= 90) && (subtype <= 93))                         image->compression=JPEG2000Compression;                       else                         image->compression=JPEGCompression;                     break;                   }                   case 5:                   {                     image->compression=RLECompression;                     break;                   }                 }               }             break;           }           default:             break;         }         break;       }       case 0x0028:       {         switch (element)         {           case 0x0002:           {             /*               Samples per pixel.             */             samples_per_pixel=(size_t) datum;             break;           }           case 0x0004:           {             /*               Photometric interpretation.             */             if (data == (unsigned char *) NULL)               break;             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)               photometric[i]=(char) data[i];             photometric[i]='\0';             polarity=LocaleCompare(photometric,""MONOCHROME1 "") == 0 ?               MagickTrue : MagickFalse;             break;           }           case 0x0006:           {             /*               Planar configuration.             */             if (datum == 1)               image->interlace=PlaneInterlace;             break;           }           case 0x0008:           {             /*               Number of frames.             */             if (data == (unsigned char *) NULL)               break;             number_scenes=StringToUnsignedLong((char *) data);             break;           }           case 0x0010:           {             /*               Image rows.             */             height=(size_t) datum;             break;           }           case 0x0011:           {             /*               Image columns.             */             width=(size_t) datum;             break;           }           case 0x0100:           {             /*               Bits allocated.             */             bits_allocated=(size_t) datum;             bytes_per_pixel=1;             if (datum > 8)               bytes_per_pixel=2;             depth=bits_allocated;             if (depth > 32)               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");             max_value=(1UL << bits_allocated)-1;             break;           }           case 0x0101:           {             /*               Bits stored.             */             significant_bits=(size_t) datum;             bytes_per_pixel=1;             if (significant_bits > 8)               bytes_per_pixel=2;             depth=significant_bits;             if (depth > 32)               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");             max_value=(1UL << significant_bits)-1;             mask=(size_t) GetQuantumRange(significant_bits);             break;           }           case 0x0102:           {             /*               High bit.             */             break;           }           case 0x0103:           {             /*               Pixel representation.             */             signed_data=(size_t) datum;             break;           }           case 0x1050:           {             /*               Visible pixel range: center.             */             if (data != (unsigned char *) NULL)               window_center=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1051:           {             /*               Visible pixel range: width.             */             if (data != (unsigned char *) NULL)               window_width=StringToUnsignedLong((char *) data);             break;           }           case 0x1052:           {             /*               Rescale intercept             */             if (data != (unsigned char *) NULL)               rescale_intercept=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1053:           {             /*               Rescale slope             */             if (data != (unsigned char *) NULL)               rescale_slope=(ssize_t) StringToLong((char *) data);             break;           }           case 0x1200:           case 0x3006:           {             /*               Populate graymap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/bytes_per_pixel);             datum=(int) colors;             graymap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*graymap));             if (graymap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             for (i=0; i < (ssize_t) colors; i++)               if (bytes_per_pixel == 1)                 graymap[i]=(int) data[i];               else                 graymap[i]=(int) ((short *) data)[i];             break;           }           case 0x1201:           {             unsigned short               index;              /*               Populate redmap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             redmap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*redmap));             if (redmap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               redmap[i]=(int) index;               p+=2;             }             break;           }           case 0x1202:           {             unsigned short               index;              /*               Populate greenmap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             greenmap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*greenmap));             if (greenmap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               greenmap[i]=(int) index;               p+=2;             }             break;           }           case 0x1203:           {             unsigned short               index;              /*               Populate bluemap.             */             if (data == (unsigned char *) NULL)               break;             colors=(size_t) (length/2);             datum=(int) colors;             bluemap=(int *) AcquireQuantumMemory((size_t) colors,               sizeof(*bluemap));             if (bluemap == (int *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");             p=data;             for (i=0; i < (ssize_t) colors; i++)             {               if (image->endian == MSBEndian)                 index=(unsigned short) ((*p << 8) | *(p+1));               else                 index=(unsigned short) (*p | (*(p+1) << 8));               bluemap[i]=(int) index;               p+=2;             }             break;           }           default:             break;         }         break;       }       case 0x2050:       {         switch (element)         {           case 0x0020:           {             if ((data != (unsigned char *) NULL) &&                 (strncmp((char *) data,""INVERSE"",7) == 0))               polarity=MagickTrue;             break;           }           default:             break;         }         break;       }       default:         break;     }     if (data != (unsigned char *) NULL)       {         char           *attribute;          for (i=0; dicom_info[i].description != (char *) NULL; i++)           if ((group == dicom_info[i].group) &&               (element == dicom_info[i].element))             break;         if (dicom_info[i].description != (char *) NULL)           {             attribute=AcquireString(""dcm:"");             (void) ConcatenateString(&attribute,dicom_info[i].description);             for (i=0; i < (ssize_t) MagickMax(length,4); i++)               if (isprint((int) data[i]) == MagickFalse)                 break;             if ((i == (ssize_t) length) || (length > 4))               {                 (void) SubstituteString(&attribute,"" "","""");                 (void) SetImageProperty(image,attribute,(char *) data,exception);               }             attribute=DestroyString(attribute);           }       }     if (image_info->verbose != MagickFalse)       {         if (data == (unsigned char *) NULL)           (void) FormatLocaleFile(stdout,""%d\n"",datum);         else           {             /*               Display group data.             */             for (i=0; i < (ssize_t) MagickMax(length,4); i++)               if (isprint((int) data[i]) == MagickFalse)                 break;             if ((i != (ssize_t) length) && (length <= 4))               {                 ssize_t                   j;                  datum=0;                 for (j=(ssize_t) length-1; j >= 0; j--)                   datum=(256*datum+data[j]);                 (void) FormatLocaleFile(stdout,""%d"",datum);               }             else               for (i=0; i < (ssize_t) length; i++)                 if (isprint((int) data[i]) != MagickFalse)                   (void) FormatLocaleFile(stdout,""%c"",data[i]);                 else                   (void) FormatLocaleFile(stdout,""%c"",'.');             (void) FormatLocaleFile(stdout,""\n"");           }       }     if (data != (unsigned char *) NULL)       data=(unsigned char *) RelinquishMagickMemory(data);     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }   }   if ((width == 0) || (height == 0))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   image->columns=(size_t) width;   image->rows=(size_t) height;   if (signed_data == 0xffff)     signed_data=(size_t) (significant_bits == 16 ? 1 : 0);   if ((image->compression == JPEGCompression) ||       (image->compression == JPEG2000Compression))     {       Image         *images;        ImageInfo         *read_info;        int         c;        size_t         length;        unsigned int         tag;        /*         Read offset table.       */       for (i=0; i < (ssize_t) stream_info->remaining; i++)         (void) ReadBlobByte(image);       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);       (void) tag;       length=(size_t) ReadBlobLSBLong(image);       stream_info->offset_count=length >> 2;       if (stream_info->offset_count != 0)         {           MagickOffsetType             offset;            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(             stream_info->offset_count,sizeof(*stream_info->offsets));           if (stream_info->offsets == (ssize_t *) NULL)             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);           offset=TellBlob(image);           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]+=offset;         }       /*         Handle non-native image formats.       */       read_info=CloneImageInfo(image_info);       SetImageInfoBlob(read_info,(void *) NULL,0);       images=NewImageList();       for (scene=0; scene < (ssize_t) number_scenes; scene++)       {         char           filename[MagickPathExtent];          const char           *property;          FILE           *file;          Image           *jpeg_image;          int           unique_file;          unsigned int           tag;          tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);         length=(size_t) ReadBlobLSBLong(image);         if (tag == 0xFFFEE0DD)           break; /* sequence delimiter tag */         if (tag != 0xFFFEE000)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         file=(FILE *) NULL;         unique_file=AcquireUniqueFileResource(filename);         if (unique_file != -1)           file=fdopen(unique_file,""wb"");         if (file == (FILE *) NULL)           {             (void) RelinquishUniqueFileResource(filename);             ThrowFileException(exception,FileOpenError,               ""UnableToCreateTemporaryFile"",filename);             break;           }         for ( ; length != 0; length--)         {           c=ReadBlobByte(image);           if (c == EOF)             {               ThrowFileException(exception,CorruptImageError,                 ""UnexpectedEndOfFile"",image->filename);               break;             }           (void) fputc(c,file);         }         (void) fclose(file);         (void) FormatLocaleString(read_info->filename,MagickPathExtent,           ""jpeg:%s"",filename);         if (image->compression == JPEG2000Compression)           (void) FormatLocaleString(read_info->filename,MagickPathExtent,             ""j2k:%s"",filename);         jpeg_image=ReadImage(read_info,exception);         if (jpeg_image != (Image *) NULL)           {             ResetImagePropertyIterator(image);             property=GetNextImageProperty(image);             while (property != (const char *) NULL)             {               (void) SetImageProperty(jpeg_image,property,                 GetImageProperty(image,property,exception),exception);               property=GetNextImageProperty(image);             }             AppendImageToList(&images,jpeg_image);           }         (void) RelinquishUniqueFileResource(filename);       }       read_info=DestroyImageInfo(read_info);       image=DestroyImage(image);       return(GetFirstImageInList(images));     }   if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))     {       QuantumAny         range;        size_t         length;        /*         Compute pixel scaling table.       */       length=(size_t) (GetQuantumRange(depth)+1);       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));       if (scale == (Quantum *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       range=GetQuantumRange(depth);       for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)         scale[i]=ScaleAnyToQuantum((size_t) i,range);     }   if (image->compression == RLECompression)     {       size_t         length;        unsigned int         tag;        /*         Read RLE offset table.       */       for (i=0; i < (ssize_t) stream_info->remaining; i++)         (void) ReadBlobByte(image);       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);       (void) tag;       length=(size_t) ReadBlobLSBLong(image);       stream_info->offset_count=length >> 2;       if (stream_info->offset_count != 0)         {           MagickOffsetType             offset;            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(             stream_info->offset_count,sizeof(*stream_info->offsets));           if (stream_info->offsets == (ssize_t *) NULL)             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);           offset=TellBlob(image);           for (i=0; i < (ssize_t) stream_info->offset_count; i++)             stream_info->offsets[i]+=offset;         }     }   for (scene=0; scene < (ssize_t) number_scenes; scene++)   {     if (image_info->ping != MagickFalse)       break;     image->columns=(size_t) width;     image->rows=(size_t) height;     image->depth=depth;     status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       break;     image->colorspace=RGBColorspace;     if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))       {         size_t           one;          one=1;         if (colors == 0)           colors=one << depth;         if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         if (redmap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=redmap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].red=(MagickRealType) index;           }         if (greenmap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=greenmap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].green=(MagickRealType) index;           }         if (bluemap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=bluemap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].blue=(MagickRealType) index;           }         if (graymap != (int *) NULL)           for (i=0; i < (ssize_t) colors; i++)           {             index=graymap[i];             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))               index=(int) scale[index];             image->colormap[i].red=(MagickRealType) index;             image->colormap[i].green=(MagickRealType) index;             image->colormap[i].blue=(MagickRealType) index;           }       }     if (image->compression == RLECompression)       {         unsigned int           tag;          /*           Read RLE segment table.         */         for (i=0; i < (ssize_t) stream_info->remaining; i++)           (void) ReadBlobByte(image);         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);         stream_info->remaining=(size_t) ReadBlobLSBLong(image);         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||             (EOFBlob(image) != MagickFalse))           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");         stream_info->count=0;         stream_info->segment_count=ReadBlobLSBLong(image);         if (stream_info->segment_count > 1)           {             bytes_per_pixel=1;             depth=8;           }         for (i=0; i < 15; i++)           stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);         stream_info->remaining-=64;       }     if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))       {         /*           Convert Planar RGB DCM Medical image to pixel packets.         */         for (i=0; i < (ssize_t) samples_per_pixel; i++)         {           for (y=0; y < (ssize_t) image->rows; y++)           {             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);             if (q == (Quantum *) NULL)               break;             for (x=0; x < (ssize_t) image->columns; x++)             {               switch ((int) i)               {                 case 0:                 {                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 1:                 {                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 2:                 {                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 case 3:                 {                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)                     ReadDCMByte(stream_info,image)),q);                   break;                 }                 default:                   break;               }               q+=GetPixelChannels(image);             }             if (SyncAuthenticPixels(image,exception) == MagickFalse)               break;             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                   image->rows);                 if (status == MagickFalse)                   break;               }           }         }       }     else       {         const char           *option;          int           byte;          PixelPacket           pixel;          /*           Convert DCM Medical image to pixel packets.         */         byte=0;         i=0;         if ((window_center != 0) && (window_width == 0))           window_width=(size_t) window_center;         option=GetImageOption(image_info,""dcm:display-range"");         if (option != (const char *) NULL)           {             if (LocaleCompare(option,""reset"") == 0)               window_width=0;           }         (void) ResetMagickMemory(&pixel,0,sizeof(pixel));         for (y=0; y < (ssize_t) image->rows; y++)         {           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (Quantum *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             if (samples_per_pixel == 1)               {                 int                   pixel_value;                  if (bytes_per_pixel == 1)                   pixel_value=polarity != MagickFalse ?                     ((int) max_value-ReadDCMByte(stream_info,image)) :                     ReadDCMByte(stream_info,image);                 else                   if ((bits_allocated != 12) || (significant_bits != 12))                     {                       if (signed_data)                         pixel_value=ReadDCMSignedShort(stream_info,image);                       else                         pixel_value=ReadDCMShort(stream_info,image);                       if (polarity != MagickFalse)                         pixel_value=(int)max_value-pixel_value;                     }                   else                     {                       if ((i & 0x01) != 0)                         pixel_value=(ReadDCMByte(stream_info,image) << 8) |                           byte;                       else                         {                           pixel_value=ReadDCMSignedShort(stream_info,image);                           byte=(int) (pixel_value & 0x0f);                           pixel_value>>=4;                         }                       i++;                     }                 index=(pixel_value*rescale_slope)+rescale_intercept;                 if (window_width == 0)                   {                     if (signed_data == 1)                       index-=32767;                   }                 else                   {                     ssize_t                       window_max,                       window_min;                      window_min=(ssize_t) ceil((double) window_center-                       (window_width-1.0)/2.0-0.5);                     window_max=(ssize_t) floor((double) window_center+                       (window_width-1.0)/2.0+0.5);                     if ((ssize_t)index <= window_min)                       index=0;                     else                       if ((ssize_t)index > window_max)                         index=(int) max_value;                       else                         index=(int) (max_value*(((index-window_center-                           0.5)/(window_width-1))+0.5));                   }                 index&=mask;                 index=(int) ConstrainColormapIndex(image,(size_t) index,                   exception);                 SetPixelIndex(image,(Quantum) index,q);                 pixel.red=(unsigned int) image->colormap[index].red;                 pixel.green=(unsigned int) image->colormap[index].green;                 pixel.blue=(unsigned int) image->colormap[index].blue;               }             else               {                 if (bytes_per_pixel == 1)                   {                     pixel.red=(unsigned int) ReadDCMByte(stream_info,image);                     pixel.green=(unsigned int) ReadDCMByte(stream_info,image);                     pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);                   }                 else                   {                     pixel.red=ReadDCMShort(stream_info,image);                     pixel.green=ReadDCMShort(stream_info,image);                     pixel.blue=ReadDCMShort(stream_info,image);                   }                 pixel.red&=mask;                 pixel.green&=mask;                 pixel.blue&=mask;                 if (scale != (Quantum *) NULL)                   {                     if (pixel.red <= GetQuantumRange(depth))                       pixel.red=scale[pixel.red];                     if (pixel.green <= GetQuantumRange(depth))                       pixel.green=scale[pixel.green];                     if (pixel.blue <= GetQuantumRange(depth))                       pixel.blue=scale[pixel.blue];                   }               }             SetPixelRed(image,(Quantum) pixel.red,q);             SetPixelGreen(image,(Quantum) pixel.green,q);             SetPixelBlue(image,(Quantum) pixel.blue,q);             q+=GetPixelChannels(image);           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         if (stream_info->segment_count > 1)           for (y=0; y < (ssize_t) image->rows; y++)           {             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);             if (q == (Quantum *) NULL)               break;             for (x=0; x < (ssize_t) image->columns; x++)             {               if (samples_per_pixel == 1)                 {                   int                     pixel_value;                    if (bytes_per_pixel == 1)                     pixel_value=polarity != MagickFalse ?                       ((int) max_value-ReadDCMByte(stream_info,image)) :                       ReadDCMByte(stream_info,image);                   else                     if ((bits_allocated != 12) || (significant_bits != 12))                       {                         pixel_value=(int) (polarity != MagickFalse ?                           (max_value-ReadDCMShort(stream_info,image)) :                           ReadDCMShort(stream_info,image));                         if (signed_data == 1)                           pixel_value=((signed short) pixel_value);                       }                     else                       {                         if ((i & 0x01) != 0)                           pixel_value=(ReadDCMByte(stream_info,image) << 8) |                             byte;                         else                           {                             pixel_value=ReadDCMShort(stream_info,image);                             byte=(int) (pixel_value & 0x0f);                             pixel_value>>=4;                           }                         i++;                       }                   index=(pixel_value*rescale_slope)+rescale_intercept;                   if (window_width == 0)                     {                       if (signed_data == 1)                         index-=32767;                     }                   else                     {                       ssize_t                         window_max,                         window_min;                        window_min=(ssize_t) ceil((double) window_center-                         (window_width-1.0)/2.0-0.5);                       window_max=(ssize_t) floor((double) window_center+                         (window_width-1.0)/2.0+0.5);                       if ((ssize_t)index <= window_min)                         index=0;                       else                         if ((ssize_t)index > window_max)                           index=(int) max_value;                         else                           index=(int) (max_value*(((index-window_center-                             0.5)/(window_width-1))+0.5));                     }                   index&=mask;                   index=(int) ConstrainColormapIndex(image,(size_t) index,                     exception);                   SetPixelIndex(image,(Quantum) (((size_t)                     GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);                   pixel.red=(unsigned int) image->colormap[index].red;                   pixel.green=(unsigned int) image->colormap[index].green;                   pixel.blue=(unsigned int) image->colormap[index].blue;                 }               else                 {                   if (bytes_per_pixel == 1)                     {                       pixel.red=(unsigned int) ReadDCMByte(stream_info,image);                       pixel.green=(unsigned int) ReadDCMByte(stream_info,image);                       pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);                     }                   else                     {                       pixel.red=ReadDCMShort(stream_info,image);                       pixel.green=ReadDCMShort(stream_info,image);                       pixel.blue=ReadDCMShort(stream_info,image);                     }                   pixel.red&=mask;                   pixel.green&=mask;                   pixel.blue&=mask;                   if (scale != (Quantum *) NULL)                     {                       pixel.red=scale[pixel.red];                       pixel.green=scale[pixel.green];                       pixel.blue=scale[pixel.blue];                     }                 }               SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |                 (((size_t) pixel.red) << 8)),q);               SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |                 (((size_t) pixel.green) << 8)),q);               SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |                 (((size_t) pixel.blue) << 8)),q);               q+=GetPixelChannels(image);             }             if (SyncAuthenticPixels(image,exception) == MagickFalse)               break;             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                   image->rows);                 if (status == MagickFalse)                   break;               }           }       }     if (SetImageGray(image,exception) != MagickFalse)       (void) SetImageColorspace(image,GRAYColorspace,exception);     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     if (scene < (ssize_t) (number_scenes-1))       {         /*           Allocate next image structure.         */         AcquireNextImage(image_info,image,exception);         if (GetNextImageInList(image) == (Image *) NULL)           {             image=DestroyImageList(image);             return((Image *) NULL);           }         image=SyncNextImageInList(image);         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),           GetBlobSize(image));         if (status == MagickFalse)           break;       }   }   /*     Free resources.   */   if (stream_info->offsets != (ssize_t *) NULL)     stream_info->offsets=(ssize_t *)       RelinquishMagickMemory(stream_info->offsets);   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);   if (scale != (Quantum *) NULL)     scale=(Quantum *) RelinquishMagickMemory(scale);   if (graymap != (int *) NULL)     graymap=(int *) RelinquishMagickMemory(graymap);   if (bluemap != (int *) NULL)     bluemap=(int *) RelinquishMagickMemory(bluemap);   if (greenmap != (int *) NULL)     greenmap=(int *) RelinquishMagickMemory(greenmap);   if (redmap != (int *) NULL)     redmap=(int *) RelinquishMagickMemory(redmap);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"ReadMATImage_mat_cwe-416.c","CWE-416","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception) {   Image *image, *image2=NULL,    *rotated_image;   register Quantum *q;    unsigned int status;   MATHeader MATLAB_HDR;   size_t size;   size_t CellType;   QuantumInfo *quantum_info;   ImageInfo *clone_info;   int i;   ssize_t ldblk;   unsigned char *BImgBuff = NULL;   double MinVal, MaxVal;   unsigned z, z2;   unsigned Frames;   int logging;   int sample_size;   MagickOffsetType filepos=0x80;   BlobInfo *blob;   size_t one;    unsigned int (*ReadBlobXXXLong)(Image *image);   unsigned short (*ReadBlobXXXShort)(Image *image);   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);     assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");    /*      Open image file.    */   image = AcquireImage(image_info,exception);    status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*      Read MATLAB image.    */   quantum_info=(QuantumInfo *) NULL;   clone_info=(ImageInfo *) NULL;   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)     {       image2=ReadMATImageV4(image_info,image,exception);       if (image2  == NULL)         goto MATLAB_KO;       image=image2;       goto END_OF_READING;     }   MATLAB_HDR.Version = ReadBlobLSBShort(image);   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");    if (logging)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",       MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);   if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))   {     ReadBlobXXXLong = ReadBlobLSBLong;     ReadBlobXXXShort = ReadBlobLSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesLSB;     ReadBlobFloatsXXX = ReadBlobFloatsLSB;     image->endian = LSBEndian;   }   else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))   {     ReadBlobXXXLong = ReadBlobMSBLong;     ReadBlobXXXShort = ReadBlobMSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesMSB;     ReadBlobFloatsXXX = ReadBlobFloatsMSB;     image->endian = MSBEndian;   }   else     goto MATLAB_KO;    /* unsupported endian */    if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))     { MATLAB_KO:       if ((image != image2) && (image2 != (Image *) NULL))         image2=DestroyImage(image2);       if (clone_info != (ImageInfo *) NULL)         clone_info=DestroyImageInfo(clone_info);       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     }    filepos = TellBlob(image);   while(!EOFBlob(image)) /* object parser loop */   {     Frames = 1;     (void) SeekBlob(image,filepos,SEEK_SET);     /* printf(""pos=%X\n"",TellBlob(image)); */      MATLAB_HDR.DataType = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))       goto MATLAB_KO;     filepos += MATLAB_HDR.ObjectSize + 4 + 4;      clone_info=CloneImageInfo(image_info);     image2 = image; #if defined(MAGICKCORE_ZLIB_DELEGATE)     if(MATLAB_HDR.DataType == miCOMPRESSED)     {       image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);       if(image2==NULL) continue;       MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */     } #endif      if (MATLAB_HDR.DataType!=miMATRIX)       {         clone_info=DestroyImageInfo(clone_info);         continue;  /* skip another objects. */       }      MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);      MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;      MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);     if(image!=image2)       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);       switch(MATLAB_HDR.DimFlag)     {       case  8: z2=z=1; break;      /* 2D matrix*/       case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/            (void) ReadBlobXXXLong(image2);          if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");          break;       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */          if(z!=3 && z!=1)             ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");          Frames = ReadBlobXXXLong(image2);          if (Frames == 0)            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");          break;       default:         if (clone_info != (ImageInfo *) NULL)           clone_info=DestroyImageInfo(clone_info);         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");     }      MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),           ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */         MATLAB_HDR.StructureClass != mxINT8_CLASS &&         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */         MATLAB_HDR.StructureClass != mxINT16_CLASS &&         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */         MATLAB_HDR.StructureClass != mxINT32_CLASS &&         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */         MATLAB_HDR.StructureClass != mxINT64_CLASS &&         MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */       ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");      switch (MATLAB_HDR.NameFlag)     {       case 0:         size = ReadBlobXXXLong(image2);  /* Object name string size */         size = 4 * (ssize_t) ((size + 3 + 1) / 4);         (void) SeekBlob(image2, size, SEEK_CUR);         break;       case 1:       case 2:       case 3:       case 4:         (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */         break;       default:         goto MATLAB_KO;     }      CellType = ReadBlobXXXLong(image2);    /* Additional object type */     if (logging)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""MATLAB_HDR.CellType: %.20g"",(double) CellType);      (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */      NEXT_FRAME:     switch (CellType)     {       case miINT8:       case miUINT8:         sample_size = 8;         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)           image->depth = 1;         else           image->depth = 8;         /* Byte type cell */         ldblk = (ssize_t) MATLAB_HDR.SizeX;         break;       case miINT16:       case miUINT16:         sample_size = 16;         image->depth = 16;        /* Word type cell */         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);         break;       case miINT32:       case miUINT32:         sample_size = 32;         image->depth = 32;        /* Dword type cell */         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);         break;       case miINT64:       case miUINT64:         sample_size = 64;         image->depth = 64;        /* Qword type cell */         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);         break;       case miSINGLE:         sample_size = 32;         image->depth = 32;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {              /* complex float type cell */   }         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);         break;       case miDOUBLE:         sample_size = 64;         image->depth = 64;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point""); DisableMSCWarning(4127)         if (sizeof(double) != 8) RestoreMSCWarning           ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {                         /* complex double type cell */   }         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);         break;       default:         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         if (clone_info)           clone_info=DestroyImageInfo(clone_info);         ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");     }     (void) sample_size;     image->columns = MATLAB_HDR.SizeX;     image->rows = MATLAB_HDR.SizeY;     one=1;     image->colors = one << image->depth;     if (image->columns == 0 || image->rows == 0)       goto MATLAB_KO;     if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)       goto MATLAB_KO;     /* Image is gray when no complex flag is set and 2D Matrix */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       {         image->type=GrayscaleType;         SetImageColorspace(image,GRAYColorspace,exception);       }       /*       If ping is true, then only set image size and colors without       reading any image data.     */     if (image_info->ping)     {       size_t temp = image->columns;       image->columns = image->rows;       image->rows = temp;       goto done_reading; /* !!!!!! BAD  !!!! */     }     status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       {         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         return(DestroyImageList(image));       }     quantum_info=AcquireQuantumInfo(clone_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");    /* ----- Load raster data ----- */     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */     if (BImgBuff == NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));      MinVal = 0;     MaxVal = 0;     if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */     {       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);     }      /* Main loop for reading all scanlines */     if(z==1) z=0; /* read grey scanlines */     /* else read color scanlines */     do     {       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)       {         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);         if (q == (Quantum *) NULL)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto done_reading;    /* Skip image rotation, when cannot set image pixels    */   }         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))         {           FixLogical((unsigned char *)BImgBuff,ldblk);           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)     { ImportQuantumPixelsFailed:       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));       break;     }         }         else         {           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)       goto ImportQuantumPixelsFailed;             if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))       FixSignedValues(image,q,MATLAB_HDR.SizeX);         }          if (!SyncAuthenticPixels(image,exception))   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),             ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }       }     } while(z-- >= 2); ExitLoop:       /* Read complex part of numbers here */     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)     {        /* Find Min and Max Values for complex parts of floats */       CellType = ReadBlobXXXLong(image2);    /* Additional object type */       i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/        if (CellType==miDOUBLE || CellType==miSINGLE)       {         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);       }        if (CellType==miDOUBLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,             exception);   }        if (CellType==miSINGLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,             exception);   }     }        /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       image->type=GrayscaleType;     if (image->depth == 1)       image->type=BilevelType;      if(image2==image)         image2 = NULL;    /* Remove shadow copy to an image before rotation. */        /*  Rotate image. */     rotated_image = RotateImage(image, 90.0, exception);     if (rotated_image != (Image *) NULL)     {         /* Remove page offsets added by RotateImage */       rotated_image->page.x=0;       rotated_image->page.y=0;        blob = rotated_image->blob;       rotated_image->blob = image->blob;       rotated_image->colors = image->colors;       image->blob = blob;       AppendImageToList(&image,rotated_image);       DeleteImageFromList(&image);     }  done_reading:      if(image2!=NULL)       if(image2!=image)       {         DeleteImageFromList(&image2);   if(clone_info)   {           if(clone_info->file)     {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);     }         }       }        /* Allocate next image structure. */     AcquireNextImage(image_info,image,exception);     if (image->next == (Image *) NULL) break;     image=SyncNextImageInList(image);     image->columns=image->rows=0;     image->colors=0;        /* row scan buffer is no longer needed */     RelinquishMagickMemory(BImgBuff);     BImgBuff = NULL;      if(--Frames>0)     {       z = z2;       if(image2==NULL) image2 = image;       goto NEXT_FRAME;     }     if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */       { /*  CloseBlob(image2); */         DeleteImageFromList(&image2);         if(clone_info)         {           if(clone_info->file)           {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);           }         }         }      if (quantum_info != (QuantumInfo *) NULL)       quantum_info=DestroyQuantumInfo(quantum_info);     if (clone_info)       clone_info=DestroyImageInfo(clone_info);   }    RelinquishMagickMemory(BImgBuff);   if (quantum_info != (QuantumInfo *) NULL)     quantum_info=DestroyQuantumInfo(quantum_info); END_OF_READING:   if (clone_info)     clone_info=DestroyImageInfo(clone_info);   CloseBlob(image);     {     Image *p;     ssize_t scene=0;      /*       Rewind list, removing any empty images while rewinding.     */     p=image;     image=NULL;     while (p != (Image *) NULL)       {         Image *tmp=p;         if ((p->rows == 0) || (p->columns == 0)) {           p=p->previous;           DeleteImageFromList(&tmp);         } else {           image=p;           p=p->previous;         }       }      /*       Fix scene numbers     */     for (p=image; p != (Image *) NULL; p=p->next)       p->scene=scene++;   }    if(clone_info != NULL)  /* cleanup garbage file from compression */   {     if(clone_info->file)     {       fclose(clone_info->file);       clone_info->file = NULL;       (void) remove_utf8(clone_info->filename);     }     DestroyImageInfo(clone_info);     clone_info = NULL;   }   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");   if (image==NULL)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"")   else     if ((image != image2) && (image2 != (Image *) NULL))       image2=DestroyImage(image2);   return (image); }"
"ReadMATImage_mat_not_vulnerable.c","not_vulnerable","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception) {   Image *image, *image2=NULL,    *rotated_image;   register Quantum *q;    unsigned int status;   MATHeader MATLAB_HDR;   size_t size;   size_t CellType;   QuantumInfo *quantum_info;   ImageInfo *clone_info;   int i;   ssize_t ldblk;   unsigned char *BImgBuff = NULL;   double MinVal, MaxVal;   unsigned z, z2;   unsigned Frames;   int logging;   int sample_size;   MagickOffsetType filepos=0x80;   BlobInfo *blob;   size_t one;    unsigned int (*ReadBlobXXXLong)(Image *image);   unsigned short (*ReadBlobXXXShort)(Image *image);   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);     assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");    /*      Open image file.    */   image = AcquireImage(image_info,exception);    status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*      Read MATLAB image.    */   quantum_info=(QuantumInfo *) NULL;   clone_info=(ImageInfo *) NULL;   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)     {       image2=ReadMATImageV4(image_info,image,exception);       if (image2  == NULL)         goto MATLAB_KO;       image=image2;       goto END_OF_READING;     }   MATLAB_HDR.Version = ReadBlobLSBShort(image);   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");    if (logging)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",       MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);   if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))   {     ReadBlobXXXLong = ReadBlobLSBLong;     ReadBlobXXXShort = ReadBlobLSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesLSB;     ReadBlobFloatsXXX = ReadBlobFloatsLSB;     image->endian = LSBEndian;   }   else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))   {     ReadBlobXXXLong = ReadBlobMSBLong;     ReadBlobXXXShort = ReadBlobMSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesMSB;     ReadBlobFloatsXXX = ReadBlobFloatsMSB;     image->endian = MSBEndian;   }   else     goto MATLAB_KO;    /* unsupported endian */    if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))     { MATLAB_KO:       if ((image != image2) && (image2 != (Image *) NULL))         image2=DestroyImage(image2);       if (clone_info != (ImageInfo *) NULL)         clone_info=DestroyImageInfo(clone_info);       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     }    filepos = TellBlob(image);   while(!EOFBlob(image)) /* object parser loop */   {     Frames = 1;     (void) SeekBlob(image,filepos,SEEK_SET);     /* printf(""pos=%X\n"",TellBlob(image)); */      MATLAB_HDR.DataType = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))       goto MATLAB_KO;     filepos += MATLAB_HDR.ObjectSize + 4 + 4;      clone_info=CloneImageInfo(image_info);     image2 = image; #if defined(MAGICKCORE_ZLIB_DELEGATE)     if(MATLAB_HDR.DataType == miCOMPRESSED)     {       image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);       if(image2==NULL) continue;       MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */     } #endif      if (MATLAB_HDR.DataType!=miMATRIX)       {         clone_info=DestroyImageInfo(clone_info);         continue;  /* skip another objects. */       }      MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);      MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;      MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);     if(image!=image2)       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);       switch(MATLAB_HDR.DimFlag)     {       case  8: z2=z=1; break;      /* 2D matrix*/       case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/            (void) ReadBlobXXXLong(image2);          if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");          break;       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */          if(z!=3 && z!=1)             ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");          Frames = ReadBlobXXXLong(image2);          if (Frames == 0)            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");          break;       default:         if (clone_info != (ImageInfo *) NULL)           clone_info=DestroyImageInfo(clone_info);         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");     }      MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),           ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */         MATLAB_HDR.StructureClass != mxINT8_CLASS &&         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */         MATLAB_HDR.StructureClass != mxINT16_CLASS &&         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */         MATLAB_HDR.StructureClass != mxINT32_CLASS &&         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */         MATLAB_HDR.StructureClass != mxINT64_CLASS &&         MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */       ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");      switch (MATLAB_HDR.NameFlag)     {       case 0:         size = ReadBlobXXXLong(image2);  /* Object name string size */         size = 4 * (ssize_t) ((size + 3 + 1) / 4);         (void) SeekBlob(image2, size, SEEK_CUR);         break;       case 1:       case 2:       case 3:       case 4:         (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */         break;       default:         goto MATLAB_KO;     }      CellType = ReadBlobXXXLong(image2);    /* Additional object type */     if (logging)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""MATLAB_HDR.CellType: %.20g"",(double) CellType);      (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */      NEXT_FRAME:     switch (CellType)     {       case miINT8:       case miUINT8:         sample_size = 8;         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)           image->depth = 1;         else           image->depth = 8;         /* Byte type cell */         ldblk = (ssize_t) MATLAB_HDR.SizeX;         break;       case miINT16:       case miUINT16:         sample_size = 16;         image->depth = 16;        /* Word type cell */         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);         break;       case miINT32:       case miUINT32:         sample_size = 32;         image->depth = 32;        /* Dword type cell */         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);         break;       case miINT64:       case miUINT64:         sample_size = 64;         image->depth = 64;        /* Qword type cell */         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);         break;       case miSINGLE:         sample_size = 32;         image->depth = 32;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {              /* complex float type cell */   }         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);         break;       case miDOUBLE:         sample_size = 64;         image->depth = 64;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point""); DisableMSCWarning(4127)         if (sizeof(double) != 8) RestoreMSCWarning           ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {                         /* complex double type cell */   }         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);         break;       default:         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         if (clone_info)           clone_info=DestroyImageInfo(clone_info);         ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");     }     (void) sample_size;     image->columns = MATLAB_HDR.SizeX;     image->rows = MATLAB_HDR.SizeY;     one=1;     image->colors = one << image->depth;     if (image->columns == 0 || image->rows == 0)       goto MATLAB_KO;     if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)       goto MATLAB_KO;     /* Image is gray when no complex flag is set and 2D Matrix */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       {         image->type=GrayscaleType;         SetImageColorspace(image,GRAYColorspace,exception);       }       /*       If ping is true, then only set image size and colors without       reading any image data.     */     if (image_info->ping)     {       size_t temp = image->columns;       image->columns = image->rows;       image->rows = temp;       goto done_reading; /* !!!!!! BAD  !!!! */     }     status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       {         if ((image != image2) && (image2 != (Image *) NULL))           image2=DestroyImage(image2);         return(DestroyImageList(image));       }     quantum_info=AcquireQuantumInfo(clone_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");    /* ----- Load raster data ----- */     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */     if (BImgBuff == NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));      MinVal = 0;     MaxVal = 0;     if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */     {       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);     }      /* Main loop for reading all scanlines */     if(z==1) z=0; /* read grey scanlines */     /* else read color scanlines */     do     {       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)       {         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);         if (q == (Quantum *) NULL)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto done_reading;    /* Skip image rotation, when cannot set image pixels    */   }         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))         {           FixLogical((unsigned char *)BImgBuff,ldblk);           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)     { ImportQuantumPixelsFailed:       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));       break;     }         }         else         {           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)       goto ImportQuantumPixelsFailed;             if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))       FixSignedValues(image,q,MATLAB_HDR.SizeX);         }          if (!SyncAuthenticPixels(image,exception))   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),             ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }       }     } while(z-- >= 2); ExitLoop:       /* Read complex part of numbers here */     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)     {        /* Find Min and Max Values for complex parts of floats */       CellType = ReadBlobXXXLong(image2);    /* Additional object type */       i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/        if (CellType==miDOUBLE || CellType==miSINGLE)       {         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);       }        if (CellType==miDOUBLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,             exception);   }        if (CellType==miSINGLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,             exception);   }     }        /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       image->type=GrayscaleType;     if (image->depth == 1)       image->type=BilevelType;      if(image2==image)         image2 = NULL;    /* Remove shadow copy to an image before rotation. */        /*  Rotate image. */     rotated_image = RotateImage(image, 90.0, exception);     if (rotated_image != (Image *) NULL)     {         /* Remove page offsets added by RotateImage */       rotated_image->page.x=0;       rotated_image->page.y=0;        blob = rotated_image->blob;       rotated_image->blob = image->blob;       rotated_image->colors = image->colors;       image->blob = blob;       AppendImageToList(&image,rotated_image);       DeleteImageFromList(&image);     }  done_reading:      if(image2!=NULL)       if(image2!=image)       {         DeleteImageFromList(&image2);   if(clone_info)   {           if(clone_info->file)     {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);     }         }       }        /* Allocate next image structure. */     AcquireNextImage(image_info,image,exception);     if (image->next == (Image *) NULL) break;     image=SyncNextImageInList(image);     image->columns=image->rows=0;     image->colors=0;        /* row scan buffer is no longer needed */     RelinquishMagickMemory(BImgBuff);     BImgBuff = NULL;      if(--Frames>0)     {       z = z2;       if(image2==NULL) image2 = image;       goto NEXT_FRAME;     }     if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */       { /*  CloseBlob(image2); */         DeleteImageFromList(&image2);         if(clone_info)         {           if(clone_info->file)           {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);           }         }         }      if (quantum_info != (QuantumInfo *) NULL)       quantum_info=DestroyQuantumInfo(quantum_info);     if (clone_info)       clone_info=DestroyImageInfo(clone_info);   }    RelinquishMagickMemory(BImgBuff);   if (quantum_info != (QuantumInfo *) NULL)     quantum_info=DestroyQuantumInfo(quantum_info); END_OF_READING:   CloseBlob(image);     {     Image *p;     ssize_t scene=0;      /*       Rewind list, removing any empty images while rewinding.     */     p=image;     image=NULL;     while (p != (Image *) NULL)       {         Image *tmp=p;         if ((p->rows == 0) || (p->columns == 0)) {           p=p->previous;           if (tmp == image2)             image2=(Image *) NULL;           DeleteImageFromList(&tmp);         } else {           image=p;           p=p->previous;         }       }      /*       Fix scene numbers     */     for (p=image; p != (Image *) NULL; p=p->next)       p->scene=scene++;   }    if(clone_info != NULL)  /* cleanup garbage file from compression */   {     if(clone_info->file)     {       fclose(clone_info->file);       clone_info->file = NULL;       (void) remove_utf8(clone_info->filename);     }     DestroyImageInfo(clone_info);     clone_info = NULL;   }   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");   if (image==NULL)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"")   else     if ((image != image2) && (image2 != (Image *) NULL))       image2=DestroyImage(image2);   return (image); }"
"ReadPWPImage_pwp_cwe-416.c","CWE-416","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception) {   FILE     *file;    Image     *image,     *next_image,     *pwp_image;    ImageInfo     *read_info;    int     c,     unique_file;    MagickBooleanType     status;    register Image     *p;    register ssize_t     i;    size_t     filesize,     length;    ssize_t     count;    unsigned char     magick[MaxTextExtent];    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickSignature);   pwp_image=AcquireImage(image_info);   image=pwp_image;   status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     return((Image *) NULL);   count=ReadBlob(pwp_image,5,magick);   if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   read_info=CloneImageInfo(image_info);   (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,     (void *) NULL);   SetImageInfoBlob(read_info,(void *) NULL,0);   unique_file=AcquireUniqueFileResource(read_info->filename);   for ( ; ; )   {     for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))     {       for (i=0; i < 17; i++)         magick[i]=magick[i+1];       magick[17]=(unsigned char) c;       if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)         break;     }     if (c == EOF)       break;     if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)       {         (void) RelinquishUniqueFileResource(read_info->filename);         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     /*       Dump SFW image to a temporary file.     */     file=(FILE *) NULL;     if (unique_file != -1)       file=fdopen(unique_file,""wb"");     if ((unique_file == -1) || (file == (FILE *) NULL))       {         (void) RelinquishUniqueFileResource(read_info->filename);         ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",           image->filename);         image=DestroyImageList(image);         return((Image *) NULL);       }     length=fwrite(""SFW94A"",1,6,file);     (void) length;     filesize=65535UL*magick[2]+256L*magick[1]+magick[0];     for (i=0; i < (ssize_t) filesize; i++)     {       c=ReadBlobByte(pwp_image);       (void) fputc(c,file);     }     (void) fclose(file);     next_image=ReadImage(read_info,exception);     if (next_image == (Image *) NULL)       break;     (void) FormatLocaleString(next_image->filename,MaxTextExtent,       ""slide_%02ld.sfw"",(long) next_image->scene);     if (image == (Image *) NULL)       image=next_image;     else       {         /*           Link image into image list.         */         for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;         next_image->previous=p;         next_image->scene=p->scene+1;         p->next=next_image;       }     if (image_info->number_scenes != 0)       if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),       GetBlobSize(pwp_image));     if (status == MagickFalse)       break;   }   if (unique_file != -1)     (void) close(unique_file);   (void) RelinquishUniqueFileResource(read_info->filename);   read_info=DestroyImageInfo(read_info);   (void) CloseBlob(pwp_image);   pwp_image=DestroyImage(pwp_image);   if (EOFBlob(image) != MagickFalse)     {       char         *message;        message=GetExceptionMessage(errno);       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,         ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);       message=DestroyString(message);     }   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"ReadPWPImage_pwp_not_vulnerable.c","not_vulnerable","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception) {   FILE     *file;    Image     *image,     *next_image,     *pwp_image;    ImageInfo     *read_info;    int     c,     unique_file;    MagickBooleanType     status;    register Image     *p;    register ssize_t     i;    size_t     filesize,     length;    ssize_t     count;    unsigned char     magick[MaxTextExtent];    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickSignature);   pwp_image=AcquireImage(image_info);   image=pwp_image;   status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     return((Image *) NULL);   count=ReadBlob(pwp_image,5,magick);   if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   read_info=CloneImageInfo(image_info);   (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,     (void *) NULL);   SetImageInfoBlob(read_info,(void *) NULL,0);   unique_file=AcquireUniqueFileResource(read_info->filename);   for ( ; ; )   {     for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))     {       for (i=0; i < 17; i++)         magick[i]=magick[i+1];       magick[17]=(unsigned char) c;       if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)         break;     }     if (c == EOF)       break;     if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)       {         (void) RelinquishUniqueFileResource(read_info->filename);         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     /*       Dump SFW image to a temporary file.     */     file=(FILE *) NULL;     if (unique_file != -1)       file=fdopen(unique_file,""wb"");     if ((unique_file == -1) || (file == (FILE *) NULL))       {         (void) RelinquishUniqueFileResource(read_info->filename);         ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",           image->filename);         image=DestroyImageList(image);         return((Image *) NULL);       }     length=fwrite(""SFW94A"",1,6,file);     (void) length;     filesize=65535UL*magick[2]+256L*magick[1]+magick[0];     for (i=0; i < (ssize_t) filesize; i++)     {       c=ReadBlobByte(pwp_image);       (void) fputc(c,file);     }     (void) fclose(file);     next_image=ReadImage(read_info,exception);     if (next_image == (Image *) NULL)       break;     (void) FormatLocaleString(next_image->filename,MaxTextExtent,       ""slide_%02ld.sfw"",(long) next_image->scene);     if (image == (Image *) NULL)       image=next_image;     else       {         /*           Link image into image list.         */         for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;         next_image->previous=p;         next_image->scene=p->scene+1;         p->next=next_image;       }     if (image_info->number_scenes != 0)       if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),       GetBlobSize(pwp_image));     if (status == MagickFalse)       break;   }   if (unique_file != -1)     (void) close(unique_file);   (void) RelinquishUniqueFileResource(read_info->filename);   read_info=DestroyImageInfo(read_info);   if (EOFBlob(image) != MagickFalse)     {       char         *message;        message=GetExceptionMessage(errno);       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,         ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);       message=DestroyString(message);     }   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"ResolveStateAndPredicate_compat_cwe-476.c","CWE-476","ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,                          xkb_mod_mask_t *mods_rtrn, CompatInfo *info) {     if (expr == NULL) {         *pred_rtrn = MATCH_ANY_OR_NONE;         *mods_rtrn = MOD_REAL_MASK_ALL;         return true;     }      *pred_rtrn = MATCH_EXACTLY;     if (expr->expr.op == EXPR_ACTION_DECL) {         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);         if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {             log_err(info->ctx,                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);             return false;         }         expr = expr->action.args;     }     else if (expr->expr.op == EXPR_IDENT) {         const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);         if (pred_txt && istreq(pred_txt, ""any"")) {             *pred_rtrn = MATCH_ANY;             *mods_rtrn = MOD_REAL_MASK_ALL;             return true;         }     }      return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,                               mods_rtrn); }"
"ResolveStateAndPredicate_compat_not_vulnerable.c","not_vulnerable","ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,                          xkb_mod_mask_t *mods_rtrn, CompatInfo *info) {     if (expr == NULL) {         *pred_rtrn = MATCH_ANY_OR_NONE;         *mods_rtrn = MOD_REAL_MASK_ALL;         return true;     }      *pred_rtrn = MATCH_EXACTLY;     if (expr->expr.op == EXPR_ACTION_DECL) {         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);         if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||             !expr->action.args) {             log_err(info->ctx,                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);             return false;         }         expr = expr->action.args;     }     else if (expr->expr.op == EXPR_IDENT) {         const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);         if (pred_txt && istreq(pred_txt, ""any"")) {             *pred_rtrn = MATCH_ANY;             *mods_rtrn = MOD_REAL_MASK_ALL;             return true;         }     }      return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,                               mods_rtrn); }"
"SWFInput_readSBits_input_cwe-190.c","CWE-190","SWFInput_readSBits(SWFInput input, int number) { 	int num = SWFInput_readBits(input, number);  	if ( num & (1<<(number-1)) ) 		return num - (1<<number); 	else 		return num; }"
"SWFInput_readSBits_input_not_vulnerable.c","not_vulnerable","SWFInput_readSBits(SWFInput input, int number) { 	int num = SWFInput_readBits(input, number);  	if(number && num & (1<<(number-1))) 		return num - (1<<number); 	else 		return num; }"
"TIFFSeekCustomStream_tiff_cwe-190.c","CWE-190","static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,   const int whence,void *user_data) {   PhotoshopProfile     *profile;    profile=(PhotoshopProfile *) user_data;   switch (whence)   {     case SEEK_SET:     default:     {       if (offset < 0)         return(-1);       profile->offset=offset;       break;     }     case SEEK_CUR:     {       if ((profile->offset+offset) < 0)         return(-1);       profile->offset+=offset;       break;     }     case SEEK_END:     {       if (((MagickOffsetType) profile->length+offset) < 0)         return(-1);       profile->offset=profile->length+offset;       break;     }   }    return(profile->offset); }"
"TIFFSeekCustomStream_tiff_not_vulnerable.c","not_vulnerable","static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,   const int whence,void *user_data) {   PhotoshopProfile     *profile;    profile=(PhotoshopProfile *) user_data;   switch (whence)   {     case SEEK_SET:     default:     {       if (offset < 0)         return(-1);       profile->offset=offset;       break;     }     case SEEK_CUR:     {       if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||           ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))         {           errno=EOVERFLOW;           return(-1);         }       if ((profile->offset+offset) < 0)         return(-1);       profile->offset+=offset;       break;     }     case SEEK_END:     {       if (((MagickOffsetType) profile->length+offset) < 0)         return(-1);       profile->offset=profile->length+offset;       break;     }   }    return(profile->offset); }"
"TarFileReader__extract_TarFileReader_cwe-022.cpp","CWE-022","std::string TarFileReader::extract(const string &_path) {   if (_path.empty()) THROW(""path cannot be empty"");   if (!hasMore()) THROW(""No more tar files"");    string path = _path;   if (SystemUtilities::isDirectory(path)) path += ""/"" + getFilename();    LOG_DEBUG(5, ""Extracting: "" << path);    return extract(*SystemUtilities::oopen(path)); }"
"TarFileReader__extract_TarFileReader_not_vulnerable.cpp","not_vulnerable","std::string TarFileReader::extract(const string &_path) {   if (_path.empty()) THROW(""path cannot be empty"");   if (!hasMore()) THROW(""No more tar files"");    string path = _path;   if (SystemUtilities::isDirectory(path)) {     path += ""/"" + getFilename();      // Check that path is under the target directory     string a = SystemUtilities::getCanonicalPath(_path);     string b = SystemUtilities::getCanonicalPath(path);     if (!String::startsWith(b, a))       THROW(""Tar path points outside of the extraction directory: "" << path);   }    LOG_DEBUG(5, ""Extracting: "" << path);    switch (getType()) {   case NORMAL_FILE: case CONTIGUOUS_FILE:     return extract(*SystemUtilities::oopen(path));   case DIRECTORY: SystemUtilities::ensureDirectory(path); break;   default: THROW(""Unsupported tar file type "" << getType());   }    return getFilename(); }"
"Utility__UnZip_Utility_cwe-022.cpp","CWE-022","bool Utility::UnZip(const QString &zippath, const QString &destpath) {     int res = 0;     QDir dir(destpath);     if (!cp437) {         cp437 = new QCodePage437Codec();     } #ifdef Q_OS_WIN32     zlib_filefunc64_def ffunc;     fill_win32_filefunc64W(&ffunc);     unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc); #else     unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData()); #endif      if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {         return false;     }      res = unzGoToFirstFile(zfile);      if (res == UNZ_OK) {         do {             // Get the name of the file in the archive.             char file_name[MAX_PATH] = {0};             unz_file_info64 file_info;             unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);             QString qfile_name;             QString cp437_file_name;             qfile_name = QString::fromUtf8(file_name);             if (!(file_info.flag & (1<<11))) {                 // General purpose bit 11 says the filename is utf-8 encoded. If not set then                 // IBM 437 encoding might be used.                 cp437_file_name = cp437->toUnicode(file_name);             }              // If there is no file name then we can't do anything with it.             if (!qfile_name.isEmpty()) {                 // We use the dir object to create the path in the temporary directory.                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.                 // Full file path in the temporary directory.                 QString file_path = destpath + ""/"" + qfile_name;                 QFileInfo qfile_info(file_path);                  // Is this entry a directory?                 if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {                     dir.mkpath(qfile_name);                     continue;                 } else {                     dir.mkpath(qfile_info.path());                 }                  // Open the file entry in the archive for reading.                 if (unzOpenCurrentFile(zfile) != UNZ_OK) {                     unzClose(zfile);                     return false;                 }                  // Open the file on disk to write the entry in the archive to.                 QFile entry(file_path);                  if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {                     unzCloseCurrentFile(zfile);                     unzClose(zfile);                     return false;                 }                  // Buffered reading and writing.                 char buff[BUFF_SIZE] = {0};                 int read = 0;                  while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {                     entry.write(buff, read);                 }                  entry.close();                  // Read errors are marked by a negative read amount.                 if (read < 0) {                     unzCloseCurrentFile(zfile);                     unzClose(zfile);                     return false;                 }                  // The file was read but the CRC did not match.                 // We don't check the read file size vs the uncompressed file size                 // because if they're different there should be a CRC error.                 if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {                     unzClose(zfile);                     return false;                 }                  if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {                     QString cp437_file_path = destpath + ""/"" + cp437_file_name;                     QFile::copy(file_path, cp437_file_path);                 }             }         } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);     }      if (res != UNZ_END_OF_LIST_OF_FILE) {         unzClose(zfile);         return false;     }      unzClose(zfile);     return true; }"
"Utility__UnZip_Utility_not_vulnerable.cpp","not_vulnerable","bool Utility::UnZip(const QString &zippath, const QString &destpath) {     int res = 0;     QDir dir(destpath);     if (!cp437) {         cp437 = new QCodePage437Codec();     } #ifdef Q_OS_WIN32     zlib_filefunc64_def ffunc;     fill_win32_filefunc64W(&ffunc);     unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc); #else     unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData()); #endif      if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {         return false;     }      res = unzGoToFirstFile(zfile);      if (res == UNZ_OK) {         do {             // Get the name of the file in the archive.             char file_name[MAX_PATH] = {0};             unz_file_info64 file_info;             unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);             QString qfile_name;             QString cp437_file_name;             qfile_name = QString::fromUtf8(file_name);             if (!(file_info.flag & (1<<11))) {                 // General purpose bit 11 says the filename is utf-8 encoded. If not set then                 // IBM 437 encoding might be used.                 cp437_file_name = cp437->toUnicode(file_name);             }              // If there is no file name then we can't do anything with it.             if (!qfile_name.isEmpty()) {  	        // for security reasons against maliciously crafted zip archives 	        // we need the file path to always be inside the target folder  	        // and not outside, so we will remove all illegal backslashes 	        // and all relative upward paths segments ""/../"" from the zip's local  	        // file name/path before prepending the target folder to create  	        // the final path  	        QString original_path = qfile_name; 	        bool evil_or_corrupt_epub = false;  	        if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true;  	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");  	        if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true; 	        qfile_name = qfile_name.replace(""/../"",""/"");  	        while(qfile_name.startsWith(""/"")) {  		  qfile_name = qfile_name.remove(0,1); 	        }                  	        if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true;  	        cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");  	        if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true; 	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");  	        while(cp437_file_name.startsWith(""/"")) {  		  cp437_file_name = cp437_file_name.remove(0,1); 	        }  	        if (evil_or_corrupt_epub) { 		    unzCloseCurrentFile(zfile); 		    unzClose(zfile); 		    // throw (UNZIPLoadParseError(QString(QObject::tr(""Possible evil or corrupt zip file name: %1"")).arg(original_path).toStdString()));                     return false; 	        }                  // We use the dir object to create the path in the temporary directory.                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.                 // Full file path in the temporary directory.                 QString file_path = destpath + ""/"" + qfile_name;                 QFileInfo qfile_info(file_path);                  // Is this entry a directory?                 if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {                     dir.mkpath(qfile_name);                     continue;                 } else {                     dir.mkpath(qfile_info.path());                 }                  // Open the file entry in the archive for reading.                 if (unzOpenCurrentFile(zfile) != UNZ_OK) {                     unzClose(zfile);                     return false;                 }                  // Open the file on disk to write the entry in the archive to.                 QFile entry(file_path);                  if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {                     unzCloseCurrentFile(zfile);                     unzClose(zfile);                     return false;                 }                  // Buffered reading and writing.                 char buff[BUFF_SIZE] = {0};                 int read = 0;                  while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {                     entry.write(buff, read);                 }                  entry.close();                  // Read errors are marked by a negative read amount.                 if (read < 0) {                     unzCloseCurrentFile(zfile);                     unzClose(zfile);                     return false;                 }                  // The file was read but the CRC did not match.                 // We don't check the read file size vs the uncompressed file size                 // because if they're different there should be a CRC error.                 if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {                     unzClose(zfile);                     return false;                 }                  if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {                     QString cp437_file_path = destpath + ""/"" + cp437_file_name;                     QFile::copy(file_path, cp437_file_path);                 }             }         } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);     }      if (res != UNZ_END_OF_LIST_OF_FILE) {         unzClose(zfile);         return false;     }      unzClose(zfile);     return true; }"
"WriteTIFFImage_tiff_cwe-125.c","CWE-125","static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,   Image *image) {   const char     *mode,     *option;    CompressionType     compression;    EndianType     endian_type;    MagickBooleanType     debug,     status;    MagickOffsetType     scene;    QuantumInfo     *quantum_info;    QuantumType     quantum_type;    register ssize_t     i;    size_t     imageListLength;    ssize_t     y;    TIFF     *tiff;    TIFFInfo     tiff_info;    uint16     bits_per_sample,     compress_tag,     endian,     photometric,     predictor;    unsigned char     *pixels;    /*     Open TIFF file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(image != (Image *) NULL);   assert(image->signature == MagickCoreSignature);   if (image->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);   if (status == MagickFalse)     return(status);   (void) SetMagickThreadValue(tiff_exception,&image->exception);   endian_type=UndefinedEndian;   option=GetImageOption(image_info,""tiff:endian"");   if (option != (const char *) NULL)     {       if (LocaleNCompare(option,""msb"",3) == 0)         endian_type=MSBEndian;       if (LocaleNCompare(option,""lsb"",3) == 0)         endian_type=LSBEndian;;     }   switch (endian_type)   {     case LSBEndian: mode=""wl""; break;     case MSBEndian: mode=""wb""; break;     default: mode=""w""; break;   } #if defined(TIFF_VERSION_BIG)   if (LocaleCompare(image_info->magick,""TIFF64"") == 0)     switch (endian_type)     {       case LSBEndian: mode=""wl8""; break;       case MSBEndian: mode=""wb8""; break;       default: mode=""w8""; break;     } #endif   tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,     TIFFUnmapBlob);   if (tiff == (TIFF *) NULL)     return(MagickFalse);   if (image->exception.severity > ErrorException)     {       TIFFClose(tiff);       return(MagickFalse);     }   (void) DeleteImageProfile(image,""tiff:37724"");   scene=0;   debug=IsEventLogging();   (void) debug;   imageListLength=GetImageListLength(image);   do   {     /*       Initialize TIFF fields.     */     if ((image_info->type != UndefinedType) &&         (image_info->type != OptimizeType))       (void) SetImageType(image,image_info->type);     compression=UndefinedCompression;     if (image->compression != JPEGCompression)       compression=image->compression;     if (image_info->compression != UndefinedCompression)       compression=image_info->compression;     switch (compression)     {       case FaxCompression:       case Group4Compression:       {         (void) SetImageType(image,BilevelType);         (void) SetImageDepth(image,1);         break;       }       case JPEGCompression:       {         (void) SetImageStorageClass(image,DirectClass);         (void) SetImageDepth(image,8);         break;       }       default:         break;     }     quantum_info=AcquireQuantumInfo(image_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");     if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&         (quantum_info->format == UndefinedQuantumFormat) &&         (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))       {         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);         if (status == MagickFalse)           {             quantum_info=DestroyQuantumInfo(quantum_info);             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");           }       }     if ((LocaleCompare(image_info->magick,""PTIF"") == 0) &&         (GetPreviousImageInList(image) != (Image *) NULL))       (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);     if ((image->columns != (uint32) image->columns) ||         (image->rows != (uint32) image->rows))       ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");     (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);     (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);     switch (compression)     {       case FaxCompression:       {         compress_tag=COMPRESSION_CCITTFAX3;         option=GetImageOption(image_info,""quantum:polarity"");         if (option == (const char *) NULL)           SetQuantumMinIsWhite(quantum_info,MagickTrue);         break;       }       case Group4Compression:       {         compress_tag=COMPRESSION_CCITTFAX4;         option=GetImageOption(image_info,""quantum:polarity"");         if (option == (const char *) NULL)           SetQuantumMinIsWhite(quantum_info,MagickTrue);         break;       } #if defined(COMPRESSION_JBIG)       case JBIG1Compression:       {         compress_tag=COMPRESSION_JBIG;         break;       } #endif       case JPEGCompression:       {         compress_tag=COMPRESSION_JPEG;         break;       } #if defined(COMPRESSION_LZMA)       case LZMACompression:       {         compress_tag=COMPRESSION_LZMA;         break;       } #endif       case LZWCompression:       {         compress_tag=COMPRESSION_LZW;         break;       }       case RLECompression:       {         compress_tag=COMPRESSION_PACKBITS;         break;       } #if defined(COMPRESSION_WEBP)       case WebPCompression:       {         compress_tag=COMPRESSION_WEBP;         break;       } #endif       case ZipCompression:       {         compress_tag=COMPRESSION_ADOBE_DEFLATE;         break;       } #if defined(COMPRESSION_ZSTD)       case ZstdCompression:       {         compress_tag=COMPRESSION_ZSTD;         break;       } #endif       case NoCompression:       default:       {         compress_tag=COMPRESSION_NONE;         break;       }     } #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)     if ((compress_tag != COMPRESSION_NONE) &&         (TIFFIsCODECConfigured(compress_tag) == 0))       {         (void) ThrowMagickException(&image->exception,GetMagickModule(),           CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(           MagickCompressOptions,(ssize_t) compression));         compress_tag=COMPRESSION_NONE;       } #else       switch (compress_tag)       { #if defined(CCITT_SUPPORT)         case COMPRESSION_CCITTFAX3:         case COMPRESSION_CCITTFAX4: #endif #if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)         case COMPRESSION_JPEG: #endif #if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)         case COMPRESSION_LZMA: #endif #if defined(LZW_SUPPORT)         case COMPRESSION_LZW: #endif #if defined(PACKBITS_SUPPORT)         case COMPRESSION_PACKBITS: #endif #if defined(ZIP_SUPPORT)         case COMPRESSION_ADOBE_DEFLATE: #endif         case COMPRESSION_NONE:           break;         default:         {           (void) ThrowMagickException(&image->exception,GetMagickModule(),             CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(               MagickCompressOptions,(ssize_t) compression));           compress_tag=COMPRESSION_NONE;           break;         }       } #endif     if (image->colorspace == CMYKColorspace)       {         photometric=PHOTOMETRIC_SEPARATED;         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);         (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);       }     else       {         /*           Full color TIFF raster.         */         if (image->colorspace == LabColorspace)           {             photometric=PHOTOMETRIC_CIELAB;             EncodeLabImage(image,&image->exception);           }         else           if (image->colorspace == YCbCrColorspace)             {               photometric=PHOTOMETRIC_YCBCR;               (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);               (void) SetImageStorageClass(image,DirectClass);               (void) SetImageDepth(image,8);             }           else             photometric=PHOTOMETRIC_RGB;         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);         if ((image_info->type != TrueColorType) &&             (image_info->type != TrueColorMatteType))           {             if ((image_info->type != PaletteType) &&                 (SetImageGray(image,&image->exception) != MagickFalse))               {                 photometric=(uint16) (quantum_info->min_is_white !=                   MagickFalse ? PHOTOMETRIC_MINISWHITE :                   PHOTOMETRIC_MINISBLACK);                 (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);                 if ((image->depth == 1) && (image->matte == MagickFalse))                   SetImageMonochrome(image,&image->exception);               }             else               if (image->storage_class == PseudoClass)                 {                   size_t                     depth;                    /*                     Colormapped TIFF raster.                   */                   (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);                   photometric=PHOTOMETRIC_PALETTE;                   depth=1;                   while ((GetQuantumRange(depth)+1) < image->colors)                     depth<<=1;                   status=SetQuantumDepth(image,quantum_info,depth);                   if (status == MagickFalse)                     ThrowWriterException(ResourceLimitError,                       ""MemoryAllocationFailed"");                 }           }       }     (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);     if ((compress_tag == COMPRESSION_CCITTFAX3) ||         (compress_tag == COMPRESSION_CCITTFAX4))       {          if ((photometric != PHOTOMETRIC_MINISWHITE) &&              (photometric != PHOTOMETRIC_MINISBLACK))           {             compress_tag=COMPRESSION_NONE;             endian=FILLORDER_MSB2LSB;           }       }     option=GetImageOption(image_info,""tiff:fill-order"");     if (option != (const char *) NULL)       {         if (LocaleNCompare(option,""msb"",3) == 0)           endian=FILLORDER_MSB2LSB;         if (LocaleNCompare(option,""lsb"",3) == 0)           endian=FILLORDER_LSB2MSB;       }     (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);     (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);     (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);     if (image->matte != MagickFalse)       {         uint16           extra_samples,           sample_info[1],           samples_per_pixel;          /*           TIFF has a matte channel.         */         extra_samples=1;         sample_info[0]=EXTRASAMPLE_UNASSALPHA;         option=GetImageOption(image_info,""tiff:alpha"");         if (option != (const char *) NULL)           {             if (LocaleCompare(option,""associated"") == 0)               sample_info[0]=EXTRASAMPLE_ASSOCALPHA;             else               if (LocaleCompare(option,""unspecified"") == 0)                 sample_info[0]=EXTRASAMPLE_UNSPECIFIED;           }         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,           &samples_per_pixel);         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);         (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,           &sample_info);         if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)           SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);       }     (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);     switch (quantum_info->format)     {       case FloatingPointQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);         (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);         (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);         break;       }       case SignedQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);         break;       }       case UnsignedQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);         break;       }       default:         break;     }     (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);     if (photometric == PHOTOMETRIC_RGB)       if ((image_info->interlace == PlaneInterlace) ||           (image_info->interlace == PartitionInterlace))         (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);     predictor=0;     switch (compress_tag)     {       case COMPRESSION_JPEG:       { #if defined(JPEG_SUPPORT)         if (image_info->quality != UndefinedCompressionQuality)           (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);         (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);         if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)           {             const char               *value;              (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);             if (image->colorspace == YCbCrColorspace)               {                 const char                   *sampling_factor;                  GeometryInfo                   geometry_info;                  MagickStatusType                   flags;                  sampling_factor=(const char *) NULL;                 value=GetImageProperty(image,""jpeg:sampling-factor"");                 if (value != (char *) NULL)                   {                     sampling_factor=value;                     if (image->debug != MagickFalse)                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),                         ""  Input sampling-factors=%s"",sampling_factor);                   }                 if (image_info->sampling_factor != (char *) NULL)                   sampling_factor=image_info->sampling_factor;                 if (sampling_factor != (const char *) NULL)                   {                     flags=ParseGeometry(sampling_factor,&geometry_info);                     if ((flags & SigmaValue) == 0)                       geometry_info.sigma=geometry_info.rho;                     (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)                       geometry_info.rho,(uint16) geometry_info.sigma);                   }             }           }         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (bits_per_sample == 12)           (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT); #endif         break;       }       case COMPRESSION_ADOBE_DEFLATE:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (           image_info->quality == UndefinedCompressionQuality ? 7 :           MagickMin((ssize_t) image_info->quality/10,9)));         break;       }       case COMPRESSION_CCITTFAX3:       {         /*           Byte-aligned EOL.         */         (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);         break;       }       case COMPRESSION_CCITTFAX4:         break; #if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)       case COMPRESSION_LZMA:       {         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (           image_info->quality == UndefinedCompressionQuality ? 7 :           MagickMin((ssize_t) image_info->quality/10,9)));         break;       } #endif       case COMPRESSION_LZW:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         break;       } #if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)       case COMPRESSION_WEBP:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,mage_info->quality);         if (image_info->quality >= 100)           (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);         break;       } #endif #if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)       case COMPRESSION_ZSTD:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/           100.0);         break;       } #endif       default:         break;     }     option=GetImageOption(image_info,""tiff:predictor"");     if (option != (const char * ) NULL)       predictor=(size_t) strtol(option,(char **) NULL,10);     if (predictor != 0)       (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);     if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))       {         unsigned short           units;          /*           Set image resolution.         */         units=RESUNIT_NONE;         if (image->units == PixelsPerInchResolution)           units=RESUNIT_INCH;         if (image->units == PixelsPerCentimeterResolution)           units=RESUNIT_CENTIMETER;         (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);         (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);         (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);         if ((image->page.x < 0) || (image->page.y < 0))           (void) ThrowMagickException(&image->exception,GetMagickModule(),             CoderError,""TIFF: negative image positions unsupported"",""%s"",             image->filename);         if ((image->page.x > 0) && (image->x_resolution > 0.0))           {             /*               Set horizontal image position.             */             (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/               image->x_resolution);           }         if ((image->page.y > 0) && (image->y_resolution > 0.0))           {             /*               Set vertical image position.             */             (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/               image->y_resolution);           }       }     if (image->chromaticity.white_point.x != 0.0)       {         float           chromaticity[6];          /*           Set image chromaticity.         */         chromaticity[0]=(float) image->chromaticity.red_primary.x;         chromaticity[1]=(float) image->chromaticity.red_primary.y;         chromaticity[2]=(float) image->chromaticity.green_primary.x;         chromaticity[3]=(float) image->chromaticity.green_primary.y;         chromaticity[4]=(float) image->chromaticity.blue_primary.x;         chromaticity[5]=(float) image->chromaticity.blue_primary.y;         (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);         chromaticity[0]=(float) image->chromaticity.white_point.x;         chromaticity[1]=(float) image->chromaticity.white_point.y;         (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);       }     if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&         (image_info->adjoin != MagickFalse) && (imageListLength > 1))       {         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);         if (image->scene != 0)           (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,             imageListLength);       }     if (image->orientation != UndefinedOrientation)       (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);     else       (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);     (void) TIFFSetProfiles(tiff,image);     {       uint16         page,         pages;        page=(uint16) scene;       pages=(uint16) imageListLength;       if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&           (image_info->adjoin != MagickFalse) && (pages > 1))         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);       (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);     }     (void) TIFFSetProperties(tiff,image_info,image); DisableMSCWarning(4127)     if (0) RestoreMSCWarning       (void) TIFFSetEXIFProperties(tiff,image);     /*       Write image scanlines.     */     if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");     quantum_info->endian=LSBEndian;     pixels=GetQuantumPixels(quantum_info);     tiff_info.scanline=GetQuantumPixels(quantum_info);     switch (photometric)     {       case PHOTOMETRIC_CIELAB:       case PHOTOMETRIC_YCBCR:       case PHOTOMETRIC_RGB:       {         /*           RGB TIFF image.         */         switch (image_info->interlace)         {           case NoInterlace:           default:           {             quantum_type=RGBQuantum;             if (image->matte != MagickFalse)               quantum_type=RGBAQuantum;             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,quantum_type,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)                 break;               if (image->previous == (Image *) NULL)                 {                   status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)                     y,image->rows);                   if (status == MagickFalse)                     break;                 }             }             break;           }           case PlaneInterlace:           case PartitionInterlace:           {             /*               Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...             */             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,RedQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,100,400);                 if (status == MagickFalse)                   break;               }             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,GreenQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,200,400);                 if (status == MagickFalse)                   break;               }             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,BlueQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,300,400);                 if (status == MagickFalse)                   break;               }             if (image->matte != MagickFalse)               for (y=0; y < (ssize_t) image->rows; y++)               {                 register const PixelPacket                   *magick_restrict p;                  p=GetVirtualPixels(image,0,y,image->columns,1,                   &image->exception);                 if (p == (const PixelPacket *) NULL)                   break;                 (void) ExportQuantumPixels(image,(const CacheView *) NULL,                   quantum_info,AlphaQuantum,pixels,&image->exception);                 if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)                   break;               }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,400,400);                 if (status == MagickFalse)                   break;               }             break;           }         }         break;       }       case PHOTOMETRIC_SEPARATED:       {         /*           CMYK TIFF image.         */         quantum_type=CMYKQuantum;         if (image->matte != MagickFalse)           quantum_type=CMYKAQuantum;         if (image->colorspace != CMYKColorspace)           (void) TransformImageColorspace(image,CMYKColorspace);         for (y=0; y < (ssize_t) image->rows; y++)         {           register const PixelPacket             *magick_restrict p;            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);           if (p == (const PixelPacket *) NULL)             break;           (void) ExportQuantumPixels(image,(const CacheView *) NULL,             quantum_info,quantum_type,pixels,&image->exception);           if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case PHOTOMETRIC_PALETTE:       {         uint16           *blue,           *green,           *red;          /*           Colormapped TIFF image.         */         red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));         green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));         blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));         if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||             (blue == (uint16 *) NULL))           {             if (red != (uint16 *) NULL)               red=(uint16 *) RelinquishMagickMemory(red);             if (green != (uint16 *) NULL)               green=(uint16 *) RelinquishMagickMemory(green);             if (blue != (uint16 *) NULL)               blue=(uint16 *) RelinquishMagickMemory(blue);             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");           }         /*           Initialize TIFF colormap.         */         (void) memset(red,0,65536*sizeof(*red));         (void) memset(green,0,65536*sizeof(*green));         (void) memset(blue,0,65536*sizeof(*blue));         for (i=0; i < (ssize_t) image->colors; i++)         {           red[i]=ScaleQuantumToShort(image->colormap[i].red);           green[i]=ScaleQuantumToShort(image->colormap[i].green);           blue[i]=ScaleQuantumToShort(image->colormap[i].blue);         }         (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);         red=(uint16 *) RelinquishMagickMemory(red);         green=(uint16 *) RelinquishMagickMemory(green);         blue=(uint16 *) RelinquishMagickMemory(blue);       }       default:       {         /*           Convert PseudoClass packets to contiguous grayscale scanlines.         */         quantum_type=IndexQuantum;         if (image->matte != MagickFalse)           {             if (photometric != PHOTOMETRIC_PALETTE)               quantum_type=GrayAlphaQuantum;             else               quantum_type=IndexAlphaQuantum;            }          else            if (photometric != PHOTOMETRIC_PALETTE)              quantum_type=GrayQuantum;         for (y=0; y < (ssize_t) image->rows; y++)         {           register const PixelPacket             *magick_restrict p;            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);           if (p == (const PixelPacket *) NULL)             break;           (void) ExportQuantumPixels(image,(const CacheView *) NULL,             quantum_info,quantum_type,pixels,&image->exception);           if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }     }     quantum_info=DestroyQuantumInfo(quantum_info);     if (image->colorspace == LabColorspace)       DecodeLabImage(image,&image->exception);     DestroyTIFFInfo(&tiff_info);     if (image->exception.severity > ErrorException)       break; DisableMSCWarning(4127)     if (0 && (image_info->verbose != MagickFalse)) RestoreMSCWarning       TIFFPrintDirectory(tiff,stdout,MagickFalse);     (void) TIFFWriteDirectory(tiff);     image=SyncNextImageInList(image);     if (image == (Image *) NULL)       break;     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);     if (status == MagickFalse)       break;   } while (image_info->adjoin != MagickFalse);   TIFFClose(tiff);   return(image->exception.severity > ErrorException ? MagickFalse : MagickTrue); }"
"WriteTIFFImage_tiff_not_vulnerable.c","not_vulnerable","static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,   Image *image) {   const char     *mode,     *option;    CompressionType     compression;    EndianType     endian_type;    MagickBooleanType     debug,     status;    MagickOffsetType     scene;    QuantumInfo     *quantum_info;    QuantumType     quantum_type;    register ssize_t     i;    size_t     imageListLength;    ssize_t     y;    TIFF     *tiff;    TIFFInfo     tiff_info;    uint16     bits_per_sample,     compress_tag,     endian,     photometric,     predictor;    unsigned char     *pixels;    /*     Open TIFF file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(image != (Image *) NULL);   assert(image->signature == MagickCoreSignature);   if (image->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);   if (status == MagickFalse)     return(status);   (void) SetMagickThreadValue(tiff_exception,&image->exception);   endian_type=UndefinedEndian;   option=GetImageOption(image_info,""tiff:endian"");   if (option != (const char *) NULL)     {       if (LocaleNCompare(option,""msb"",3) == 0)         endian_type=MSBEndian;       if (LocaleNCompare(option,""lsb"",3) == 0)         endian_type=LSBEndian;;     }   switch (endian_type)   {     case LSBEndian: mode=""wl""; break;     case MSBEndian: mode=""wb""; break;     default: mode=""w""; break;   } #if defined(TIFF_VERSION_BIG)   if (LocaleCompare(image_info->magick,""TIFF64"") == 0)     switch (endian_type)     {       case LSBEndian: mode=""wl8""; break;       case MSBEndian: mode=""wb8""; break;       default: mode=""w8""; break;     } #endif   tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,     TIFFUnmapBlob);   if (tiff == (TIFF *) NULL)     return(MagickFalse);   if (image->exception.severity > ErrorException)     {       TIFFClose(tiff);       return(MagickFalse);     }   (void) DeleteImageProfile(image,""tiff:37724"");   scene=0;   debug=IsEventLogging();   (void) debug;   imageListLength=GetImageListLength(image);   do   {     /*       Initialize TIFF fields.     */     if ((image_info->type != UndefinedType) &&         (image_info->type != OptimizeType))       (void) SetImageType(image,image_info->type);     compression=UndefinedCompression;     if (image->compression != JPEGCompression)       compression=image->compression;     if (image_info->compression != UndefinedCompression)       compression=image_info->compression;     switch (compression)     {       case FaxCompression:       case Group4Compression:       {         (void) SetImageType(image,BilevelType);         (void) SetImageDepth(image,1);         break;       }       case JPEGCompression:       {         (void) SetImageStorageClass(image,DirectClass);         (void) SetImageDepth(image,8);         break;       }       default:         break;     }     quantum_info=AcquireQuantumInfo(image_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");     if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&         (quantum_info->format == UndefinedQuantumFormat) &&         (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))       {         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);         if (status == MagickFalse)           {             quantum_info=DestroyQuantumInfo(quantum_info);             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");           }       }     if ((LocaleCompare(image_info->magick,""PTIF"") == 0) &&         (GetPreviousImageInList(image) != (Image *) NULL))       (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);     if ((image->columns != (uint32) image->columns) ||         (image->rows != (uint32) image->rows))       ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");     (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);     (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);     switch (compression)     {       case FaxCompression:       {         compress_tag=COMPRESSION_CCITTFAX3;         option=GetImageOption(image_info,""quantum:polarity"");         if (option == (const char *) NULL)           SetQuantumMinIsWhite(quantum_info,MagickTrue);         break;       }       case Group4Compression:       {         compress_tag=COMPRESSION_CCITTFAX4;         option=GetImageOption(image_info,""quantum:polarity"");         if (option == (const char *) NULL)           SetQuantumMinIsWhite(quantum_info,MagickTrue);         break;       } #if defined(COMPRESSION_JBIG)       case JBIG1Compression:       {         compress_tag=COMPRESSION_JBIG;         break;       } #endif       case JPEGCompression:       {         compress_tag=COMPRESSION_JPEG;         break;       } #if defined(COMPRESSION_LZMA)       case LZMACompression:       {         compress_tag=COMPRESSION_LZMA;         break;       } #endif       case LZWCompression:       {         compress_tag=COMPRESSION_LZW;         break;       }       case RLECompression:       {         compress_tag=COMPRESSION_PACKBITS;         break;       } #if defined(COMPRESSION_WEBP)       case WebPCompression:       {         compress_tag=COMPRESSION_WEBP;         break;       } #endif       case ZipCompression:       {         compress_tag=COMPRESSION_ADOBE_DEFLATE;         break;       } #if defined(COMPRESSION_ZSTD)       case ZstdCompression:       {         compress_tag=COMPRESSION_ZSTD;         break;       } #endif       case NoCompression:       default:       {         compress_tag=COMPRESSION_NONE;         break;       }     } #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)     if ((compress_tag != COMPRESSION_NONE) &&         (TIFFIsCODECConfigured(compress_tag) == 0))       {         (void) ThrowMagickException(&image->exception,GetMagickModule(),           CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(           MagickCompressOptions,(ssize_t) compression));         compress_tag=COMPRESSION_NONE;       } #else       switch (compress_tag)       { #if defined(CCITT_SUPPORT)         case COMPRESSION_CCITTFAX3:         case COMPRESSION_CCITTFAX4: #endif #if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)         case COMPRESSION_JPEG: #endif #if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)         case COMPRESSION_LZMA: #endif #if defined(LZW_SUPPORT)         case COMPRESSION_LZW: #endif #if defined(PACKBITS_SUPPORT)         case COMPRESSION_PACKBITS: #endif #if defined(ZIP_SUPPORT)         case COMPRESSION_ADOBE_DEFLATE: #endif         case COMPRESSION_NONE:           break;         default:         {           (void) ThrowMagickException(&image->exception,GetMagickModule(),             CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(               MagickCompressOptions,(ssize_t) compression));           compress_tag=COMPRESSION_NONE;           break;         }       } #endif     if (image->colorspace == CMYKColorspace)       {         photometric=PHOTOMETRIC_SEPARATED;         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);         (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);       }     else       {         /*           Full color TIFF raster.         */         if (image->colorspace == LabColorspace)           {             photometric=PHOTOMETRIC_CIELAB;             EncodeLabImage(image,&image->exception);           }         else           if (image->colorspace == YCbCrColorspace)             {               photometric=PHOTOMETRIC_YCBCR;               (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);               (void) SetImageStorageClass(image,DirectClass);               (void) SetImageDepth(image,8);             }           else             photometric=PHOTOMETRIC_RGB;         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);         if ((image_info->type != TrueColorType) &&             (image_info->type != TrueColorMatteType))           {             if ((image_info->type != PaletteType) &&                 (SetImageGray(image,&image->exception) != MagickFalse))               {                 photometric=(uint16) (quantum_info->min_is_white !=                   MagickFalse ? PHOTOMETRIC_MINISWHITE :                   PHOTOMETRIC_MINISBLACK);                 (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);                 if ((image->depth == 1) && (image->matte == MagickFalse))                   SetImageMonochrome(image,&image->exception);               }             else               if (image->storage_class == PseudoClass)                 {                   size_t                     depth;                    /*                     Colormapped TIFF raster.                   */                   (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);                   photometric=PHOTOMETRIC_PALETTE;                   depth=1;                   while ((GetQuantumRange(depth)+1) < image->colors)                     depth<<=1;                   status=SetQuantumDepth(image,quantum_info,depth);                   if (status == MagickFalse)                     ThrowWriterException(ResourceLimitError,                       ""MemoryAllocationFailed"");                 }           }       }     (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);     if ((compress_tag == COMPRESSION_CCITTFAX3) ||         (compress_tag == COMPRESSION_CCITTFAX4))       {          if ((photometric != PHOTOMETRIC_MINISWHITE) &&              (photometric != PHOTOMETRIC_MINISBLACK))           {             compress_tag=COMPRESSION_NONE;             endian=FILLORDER_MSB2LSB;           }       }     option=GetImageOption(image_info,""tiff:fill-order"");     if (option != (const char *) NULL)       {         if (LocaleNCompare(option,""msb"",3) == 0)           endian=FILLORDER_MSB2LSB;         if (LocaleNCompare(option,""lsb"",3) == 0)           endian=FILLORDER_LSB2MSB;       }     (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);     (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);     (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);     if (image->matte != MagickFalse)       {         uint16           extra_samples,           sample_info[1],           samples_per_pixel;          /*           TIFF has a matte channel.         */         extra_samples=1;         sample_info[0]=EXTRASAMPLE_UNASSALPHA;         option=GetImageOption(image_info,""tiff:alpha"");         if (option != (const char *) NULL)           {             if (LocaleCompare(option,""associated"") == 0)               sample_info[0]=EXTRASAMPLE_ASSOCALPHA;             else               if (LocaleCompare(option,""unspecified"") == 0)                 sample_info[0]=EXTRASAMPLE_UNSPECIFIED;           }         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,           &samples_per_pixel);         (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);         (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,           &sample_info);         if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)           SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);       }     (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);     switch (quantum_info->format)     {       case FloatingPointQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);         (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);         (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);         break;       }       case SignedQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);         break;       }       case UnsignedQuantumFormat:       {         (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);         break;       }       default:         break;     }     (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);     if (photometric == PHOTOMETRIC_RGB)       if ((image_info->interlace == PlaneInterlace) ||           (image_info->interlace == PartitionInterlace))         (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);     predictor=0;     switch (compress_tag)     {       case COMPRESSION_JPEG:       { #if defined(JPEG_SUPPORT)         if (image_info->quality != UndefinedCompressionQuality)           (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);         (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);         if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)           {             const char               *value;              (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);             if (image->colorspace == YCbCrColorspace)               {                 const char                   *sampling_factor;                  GeometryInfo                   geometry_info;                  MagickStatusType                   flags;                  sampling_factor=(const char *) NULL;                 value=GetImageProperty(image,""jpeg:sampling-factor"");                 if (value != (char *) NULL)                   {                     sampling_factor=value;                     if (image->debug != MagickFalse)                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),                         ""  Input sampling-factors=%s"",sampling_factor);                   }                 if (image_info->sampling_factor != (char *) NULL)                   sampling_factor=image_info->sampling_factor;                 if (sampling_factor != (const char *) NULL)                   {                     flags=ParseGeometry(sampling_factor,&geometry_info);                     if ((flags & SigmaValue) == 0)                       geometry_info.sigma=geometry_info.rho;                     (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)                       geometry_info.rho,(uint16) geometry_info.sigma);                   }             }           }         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (bits_per_sample == 12)           (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT); #endif         break;       }       case COMPRESSION_ADOBE_DEFLATE:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (           image_info->quality == UndefinedCompressionQuality ? 7 :           MagickMin((ssize_t) image_info->quality/10,9)));         break;       }       case COMPRESSION_CCITTFAX3:       {         /*           Byte-aligned EOL.         */         (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);         break;       }       case COMPRESSION_CCITTFAX4:         break; #if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)       case COMPRESSION_LZMA:       {         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (           image_info->quality == UndefinedCompressionQuality ? 7 :           MagickMin((ssize_t) image_info->quality/10,9)));         break;       } #endif       case COMPRESSION_LZW:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         break;       } #if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)       case COMPRESSION_WEBP:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,mage_info->quality);         if (image_info->quality >= 100)           (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);         break;       } #endif #if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)       case COMPRESSION_ZSTD:       {         (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,           &bits_per_sample);         if (((photometric == PHOTOMETRIC_RGB) ||              (photometric == PHOTOMETRIC_SEPARATED) ||              (photometric == PHOTOMETRIC_MINISBLACK)) &&             ((bits_per_sample == 8) || (bits_per_sample == 16)))           predictor=PREDICTOR_HORIZONTAL;         (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/           100.0);         break;       } #endif       default:         break;     }     option=GetImageOption(image_info,""tiff:predictor"");     if (option != (const char * ) NULL)       predictor=(size_t) strtol(option,(char **) NULL,10);     if (predictor != 0)       (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);     if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))       {         unsigned short           units;          /*           Set image resolution.         */         units=RESUNIT_NONE;         if (image->units == PixelsPerInchResolution)           units=RESUNIT_INCH;         if (image->units == PixelsPerCentimeterResolution)           units=RESUNIT_CENTIMETER;         (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);         (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);         (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);         if ((image->page.x < 0) || (image->page.y < 0))           (void) ThrowMagickException(&image->exception,GetMagickModule(),             CoderError,""TIFF: negative image positions unsupported"",""%s"",             image->filename);         if ((image->page.x > 0) && (image->x_resolution > 0.0))           {             /*               Set horizontal image position.             */             (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/               image->x_resolution);           }         if ((image->page.y > 0) && (image->y_resolution > 0.0))           {             /*               Set vertical image position.             */             (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/               image->y_resolution);           }       }     if (image->chromaticity.white_point.x != 0.0)       {         float           chromaticity[6];          /*           Set image chromaticity.         */         chromaticity[0]=(float) image->chromaticity.red_primary.x;         chromaticity[1]=(float) image->chromaticity.red_primary.y;         chromaticity[2]=(float) image->chromaticity.green_primary.x;         chromaticity[3]=(float) image->chromaticity.green_primary.y;         chromaticity[4]=(float) image->chromaticity.blue_primary.x;         chromaticity[5]=(float) image->chromaticity.blue_primary.y;         (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);         chromaticity[0]=(float) image->chromaticity.white_point.x;         chromaticity[1]=(float) image->chromaticity.white_point.y;         (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);       }     if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&         (image_info->adjoin != MagickFalse) && (imageListLength > 1))       {         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);         if (image->scene != 0)           (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,             imageListLength);       }     if (image->orientation != UndefinedOrientation)       (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);     else       (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);     (void) TIFFSetProfiles(tiff,image);     {       uint16         page,         pages;        page=(uint16) scene;       pages=(uint16) imageListLength;       if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&           (image_info->adjoin != MagickFalse) && (pages > 1))         (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);       (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);     }     (void) TIFFSetProperties(tiff,image_info,image); DisableMSCWarning(4127)     if (0) RestoreMSCWarning       (void) TIFFSetEXIFProperties(tiff,image);     /*       Write image scanlines.     */     if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");     quantum_info->endian=LSBEndian;     pixels=GetQuantumPixels(quantum_info);     tiff_info.scanline=GetQuantumPixels(quantum_info);     switch (photometric)     {       case PHOTOMETRIC_CIELAB:       case PHOTOMETRIC_YCBCR:       case PHOTOMETRIC_RGB:       {         /*           RGB TIFF image.         */         switch (image_info->interlace)         {           case NoInterlace:           default:           {             quantum_type=RGBQuantum;             if (image->matte != MagickFalse)               quantum_type=RGBAQuantum;             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,quantum_type,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)                 break;               if (image->previous == (Image *) NULL)                 {                   status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)                     y,image->rows);                   if (status == MagickFalse)                     break;                 }             }             break;           }           case PlaneInterlace:           case PartitionInterlace:           {             /*               Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...             */             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,RedQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,100,400);                 if (status == MagickFalse)                   break;               }             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,GreenQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,200,400);                 if (status == MagickFalse)                   break;               }             for (y=0; y < (ssize_t) image->rows; y++)             {               register const PixelPacket                 *magick_restrict p;                p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);               if (p == (const PixelPacket *) NULL)                 break;               (void) ExportQuantumPixels(image,(const CacheView *) NULL,                 quantum_info,BlueQuantum,pixels,&image->exception);               if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)                 break;             }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,300,400);                 if (status == MagickFalse)                   break;               }             if (image->matte != MagickFalse)               for (y=0; y < (ssize_t) image->rows; y++)               {                 register const PixelPacket                   *magick_restrict p;                  p=GetVirtualPixels(image,0,y,image->columns,1,                   &image->exception);                 if (p == (const PixelPacket *) NULL)                   break;                 (void) ExportQuantumPixels(image,(const CacheView *) NULL,                   quantum_info,AlphaQuantum,pixels,&image->exception);                 if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)                   break;               }             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,SaveImageTag,400,400);                 if (status == MagickFalse)                   break;               }             break;           }         }         break;       }       case PHOTOMETRIC_SEPARATED:       {         /*           CMYK TIFF image.         */         quantum_type=CMYKQuantum;         if (image->matte != MagickFalse)           quantum_type=CMYKAQuantum;         if (image->colorspace != CMYKColorspace)           (void) TransformImageColorspace(image,CMYKColorspace);         for (y=0; y < (ssize_t) image->rows; y++)         {           register const PixelPacket             *magick_restrict p;            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);           if (p == (const PixelPacket *) NULL)             break;           (void) ExportQuantumPixels(image,(const CacheView *) NULL,             quantum_info,quantum_type,pixels,&image->exception);           if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case PHOTOMETRIC_PALETTE:       {         uint16           *blue,           *green,           *red;          /*           Colormapped TIFF image.         */         red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));         green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));         blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));         if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||             (blue == (uint16 *) NULL))           {             if (red != (uint16 *) NULL)               red=(uint16 *) RelinquishMagickMemory(red);             if (green != (uint16 *) NULL)               green=(uint16 *) RelinquishMagickMemory(green);             if (blue != (uint16 *) NULL)               blue=(uint16 *) RelinquishMagickMemory(blue);             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");           }         /*           Initialize TIFF colormap.         */         (void) memset(red,0,65536*sizeof(*red));         (void) memset(green,0,65536*sizeof(*green));         (void) memset(blue,0,65536*sizeof(*blue));         for (i=0; i < (ssize_t) image->colors; i++)         {           red[i]=ScaleQuantumToShort(image->colormap[i].red);           green[i]=ScaleQuantumToShort(image->colormap[i].green);           blue[i]=ScaleQuantumToShort(image->colormap[i].blue);         }         (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);         red=(uint16 *) RelinquishMagickMemory(red);         green=(uint16 *) RelinquishMagickMemory(green);         blue=(uint16 *) RelinquishMagickMemory(blue);       }       default:       {         /*           Convert PseudoClass packets to contiguous grayscale scanlines.         */         quantum_type=IndexQuantum;         if (image->matte != MagickFalse)           {             if (photometric != PHOTOMETRIC_PALETTE)               quantum_type=GrayAlphaQuantum;             else               quantum_type=IndexAlphaQuantum;            }          else            if (photometric != PHOTOMETRIC_PALETTE)              quantum_type=GrayQuantum;         for (y=0; y < (ssize_t) image->rows; y++)         {           register const PixelPacket             *magick_restrict p;            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);           if (p == (const PixelPacket *) NULL)             break;           (void) ExportQuantumPixels(image,(const CacheView *) NULL,             quantum_info,quantum_type,pixels,&image->exception);           if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }     }     quantum_info=DestroyQuantumInfo(quantum_info);     if (image->colorspace == LabColorspace)       DecodeLabImage(image,&image->exception);     DestroyTIFFInfo(&tiff_info); DisableMSCWarning(4127)     if (0 && (image_info->verbose != MagickFalse)) RestoreMSCWarning       TIFFPrintDirectory(tiff,stdout,MagickFalse);     if (TIFFWriteDirectory(tiff) == 0)       {         status=MagickFalse;         break;       }     image=SyncNextImageInList(image);     if (image == (Image *) NULL)       break;     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);     if (status == MagickFalse)       break;   } while (image_info->adjoin != MagickFalse);   TIFFClose(tiff);   return(status); }"
"X86_insn_reg_intel_X86Mapping_cwe-125.c","CWE-125","x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access) { 	unsigned int first = 0; 	unsigned int last = ARR_SIZE(insn_regs_intel) - 1; 	unsigned int mid = ARR_SIZE(insn_regs_intel) / 2;  	if (!intel_regs_sorted) { 		memcpy(insn_regs_intel_sorted, insn_regs_intel, 				sizeof(insn_regs_intel_sorted)); 		qsort(insn_regs_intel_sorted, 				ARR_SIZE(insn_regs_intel_sorted), 				sizeof(struct insn_reg), regs_cmp); 		intel_regs_sorted = true; 	}  	while (first <= last) { 		if (insn_regs_intel_sorted[mid].insn < id) { 			first = mid + 1; 		} else if (insn_regs_intel_sorted[mid].insn == id) { 			if (access) { 				*access = insn_regs_intel_sorted[mid].access; 			} 			return insn_regs_intel_sorted[mid].reg; 		} else { 			if (mid == 0) 				break; 			last = mid - 1; 		} 		mid = (first + last) / 2; 	}  	// not found 	return 0; }"
"X86_insn_reg_intel_X86Mapping_not_vulnerable.c","not_vulnerable","x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access) { 	static bool intel_regs_sorted = false; 	unsigned int first = 0; 	unsigned int last = ARR_SIZE(insn_regs_intel) - 1; 	unsigned int mid;  	if (!intel_regs_sorted) { 		memcpy(insn_regs_intel_sorted, insn_regs_intel, 				sizeof(insn_regs_intel_sorted)); 		qsort(insn_regs_intel_sorted, 				ARR_SIZE(insn_regs_intel_sorted), 				sizeof(struct insn_reg), regs_cmp); 		intel_regs_sorted = true; 	}  	if (insn_regs_intel_sorted[0].insn > id || 			insn_regs_intel_sorted[last].insn < id) { 		return 0; 	}  	while (first <= last) { 		mid = (first + last) / 2; 		if (insn_regs_intel_sorted[mid].insn < id) { 			first = mid + 1; 		} else if (insn_regs_intel_sorted[mid].insn == id) { 			if (access) { 				*access = insn_regs_intel_sorted[mid].access; 			} 			return insn_regs_intel_sorted[mid].reg; 		} else { 			if (mid == 0) 				break; 			last = mid - 1; 		} 	}  	// not found 	return 0; }"
"_6502_op_anal_6502_cwe-125.c","CWE-125","static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { 	char addrbuf[64]; 	const int buffsize = sizeof (addrbuf) - 1;  	memset (op, '\0', sizeof (RAnalOp)); 	op->size = snes_op_get_size (1, 1, &snes_op[data[0]]);	//snes-arch is similiar to nes/6502 	op->addr = addr; 	op->type = R_ANAL_OP_TYPE_UNK; 	op->id = data[0]; 	r_strbuf_init (&op->esil); 	switch (data[0]) { 	case 0x02: 	case 0x03: 	case 0x04: 	case 0x07: 	case 0x0b: 	case 0x0c: 	case 0x0f: 	case 0x12: 	case 0x13: 	case 0x14: 	case 0x17: 	case 0x1a: 	case 0x1b: 	case 0x1c: 	case 0x1f: 	case 0x22: 	case 0x23: 	case 0x27: 	case 0x2b: 	case 0x2f: 	case 0x32: 	case 0x33: 	case 0x34: 	case 0x37: 	case 0x3a: 	case 0x3b: 	case 0x3c: 	case 0x3f: 	case 0x42: 	case 0x43: 	case 0x44: 	case 0x47: 	case 0x4b: 	case 0x4f: 	case 0x52: 	case 0x53: 	case 0x54: 	case 0x57: 	case 0x5a: 	case 0x5b: 	case 0x5c: 	case 0x5f: 	case 0x62: 	case 0x63: 	case 0x64: 	case 0x67: 	case 0x6b: 	case 0x6f: 	case 0x72: 	case 0x73: 	case 0x74: 	case 0x77: 	case 0x7a: 	case 0x7b: 	case 0x7c: 	case 0x7f: 	case 0x80: 	case 0x82: 	case 0x83: 	case 0x87: 	case 0x89: 	case 0x8b: 	case 0x8f: 	case 0x92: 	case 0x93: 	case 0x97: 	case 0x9b: 	case 0x9c: 	case 0x9e: 	case 0x9f: 	case 0xa3: 	case 0xa7: 	case 0xab: 	case 0xaf: 	case 0xb2: 	case 0xb3: 	case 0xb7: 	case 0xbb: 	case 0xbf: 	case 0xc2: 	case 0xc3: 	case 0xc7: 	case 0xcb: 	case 0xcf: 	case 0xd2: 	case 0xd3: 	case 0xd4: 	case 0xd7: 	case 0xda: 	case 0xdb: 	case 0xdc: 	case 0xdf: 	case 0xe2: 	case 0xe3: 	case 0xe7: 	case 0xeb: 	case 0xef: 	case 0xf2: 	case 0xf3: 	case 0xf4: 	case 0xf7: 	case 0xfa: 	case 0xfb: 	case 0xfc: 	case 0xff: 		// undocumented or not-implemented opcodes for 6502. 		// some of them might be implemented in 65816 		op->size = 1; 		op->type = R_ANAL_OP_TYPE_ILL; 		break;  	// BRK 	case 0x00: // brk 		op->cycles = 7; 		op->type = R_ANAL_OP_TYPE_SWI; 		// override 65816 code which seems to be wrong: size is 1, but pc = pc + 2 		op->size = 1; 		// PC + 2 to Stack, P to Stack  B=1 D=0 I=1. ""B"" is not a flag. Only its bit is pushed on the stack 		// PC was already incremented by one at this point. Needs to incremented once more 		// New PC is Interrupt Vector: $fffe. (FIXME: Confirm this is valid for all 6502) 		r_strbuf_set (&op->esil, "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=""); 		break;  	// FLAGS 	case 0x78: // sei 	case 0x58: // cli 	case 0x38: // sec 	case 0x18: // clc 	case 0xf8: // sed 	case 0xd8: // cld 	case 0xb8: // clv 		op->cycles = 2; 		// FIXME: what opcode for this? 		op->type = R_ANAL_OP_TYPE_NOP; 		_6502_anal_esil_flags (op, data[0]); 		break; 	// BIT 	case 0x24: // bit $ff 	case 0x2c: // bit $ffff 		op->type = R_ANAL_OP_TYPE_MOV; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		r_strbuf_setf (&op->esil, ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="",addrbuf, addrbuf, addrbuf); 		break; 	// ADC 	case 0x69: // adc #$ff 	case 0x65: // adc $ff 	case 0x75: // adc $ff,x 	case 0x6d: // adc $ffff 	case 0x7d: // adc $ffff,x 	case 0x79: // adc $ffff,y 	case 0x61: // adc ($ff,x) 	case 0x71: // adc ($ff,y) 		// FIXME: update V 		// FIXME: support BCD mode 		op->type = R_ANAL_OP_TYPE_ADD; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x69) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		// fix Z 		r_strbuf_append (&op->esil, "",a,a,=,$z,Z,=""); 		break; 	// SBC 	case 0xe9: // sbc #$ff 	case 0xe5: // sbc $ff 	case 0xf5: // sbc $ff,x 	case 0xed: // sbc $ffff 	case 0xfd: // sbc $ffff,x 	case 0xf9: // sbc $ffff,y 	case 0xe1: // sbc ($ff,x) 	case 0xf1: // sbc ($ff,y) 		// FIXME: update V 		// FIXME: support BCD mode 		op->type = R_ANAL_OP_TYPE_SUB; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xe9) // immediate mode 			r_strbuf_setf (&op->esil, ""C,!,%s,+,a,-="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""C,!,%s,[1],+,a,-="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// fix Z and revert C 		r_strbuf_append (&op->esil, "",a,a,=,$z,Z,=,C,!=""); 		break; 	// ORA 	case 0x09: // ora #$ff 	case 0x05: // ora $ff 	case 0x15: // ora $ff,x 	case 0x0d: // ora $ffff 	case 0x1d: // ora $ffff,x 	case 0x19: // ora $ffff,y 	case 0x01: // ora ($ff,x) 	case 0x11: // ora ($ff),y 		op->type = R_ANAL_OP_TYPE_OR; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x09) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,|="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,|="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// AND 	case 0x29: // and #$ff 	case 0x25: // and $ff 	case 0x35: // and $ff,x 	case 0x2d: // and $ffff 	case 0x3d: // and $ffff,x 	case 0x39: // and $ffff,y 	case 0x21: // and ($ff,x) 	case 0x31: // and ($ff),y 		op->type = R_ANAL_OP_TYPE_AND; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x29) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,&="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,&="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// EOR 	case 0x49: // eor #$ff 	case 0x45: // eor $ff 	case 0x55: // eor $ff,x 	case 0x4d: // eor $ffff 	case 0x5d: // eor $ffff,x 	case 0x59: // eor $ffff,y 	case 0x41: // eor ($ff,x) 	case 0x51: // eor ($ff),y 		op->type = R_ANAL_OP_TYPE_XOR; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x49) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,^="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,^="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ASL 	case 0x0a: // asl a 	case 0x06: // asl $ff 	case 0x16: // asl $ff,x 	case 0x0e: // asl $ffff 	case 0x1e: // asl $ffff,x 		op->type = R_ANAL_OP_TYPE_SHL; 		if (data[0] == 0x0a) { 			r_strbuf_set (&op->esil, ""1,a,<<=,$c7,C,=,a,a,=""); 		} else  { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],<<,%s,=[1],$c7,C,="", addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LSR 	case 0x4a: // lsr a 	case 0x46: // lsr $ff 	case 0x56: // lsr $ff,x 	case 0x4e: // lsr $ffff 	case 0x5e: // lsr $ffff,x 		op->type = R_ANAL_OP_TYPE_SHR; 		if (data[0] == 0x4a) { 			r_strbuf_set (&op->esil, ""1,a,&,C,=,1,a,>>=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"", addrbuf, addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ROL 	case 0x2a: // rol a 	case 0x26: // rol $ff 	case 0x36: // rol $ff,x 	case 0x2e: // rol $ffff 	case 0x3e: // rol $ffff,x 		op->type = R_ANAL_OP_TYPE_ROL; 		if (data[0] == 0x2a) { 			r_strbuf_set (&op->esil, ""1,a,<<,C,|,a,=,$c7,C,=,a,a,=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="", addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ROR 	case 0x6a: // ror a 	case 0x66: // ror $ff 	case 0x76: // ror $ff,x 	case 0x6e: // ror $ffff 	case 0x7e: // ror $ffff,x 		// uses N as temporary to hold C value. but in fact, 		// it is not temporary since in all ROR ops, N will have the value of C 		op->type = R_ANAL_OP_TYPE_ROR; 		if (data[0] == 0x6a) { 			r_strbuf_set (&op->esil, ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"", addrbuf, addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// INC 	case 0xe6: // inc $ff 	case 0xf6: // inc $ff,x 	case 0xee: // inc $ffff 	case 0xfe: // inc $ffff,x 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""%s,++=[1]"", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// DEC 	case 0xc6: // dec $ff 	case 0xd6: // dec $ff,x 	case 0xce: // dec $ffff 	case 0xde: // dec $ffff,x 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""%s,--=[1]"", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// INX, INY 	case 0xe8: // inx 	case 0xc8: // iny 		op->cycles = 2; 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_inc_reg (op, data[0], ""+""); 		break; 	// DEX, DEY 	case 0xca: // dex 	case 0x88: // dey 		op->cycles = 2; 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_inc_reg (op, data[0], ""-""); 		break; 	// CMP 	case 0xc9: // cmp #$ff 	case 0xc5: // cmp $ff 	case 0xd5: // cmp $ff,x 	case 0xcd: // cmp $ffff 	case 0xdd: // cmp $ffff,x 	case 0xd9: // cmp $ffff,y 	case 0xc1: // cmp ($ff,x) 	case 0xd1: // cmp ($ff),y 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xc9) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// CPX 	case 0xe0: // cpx #$ff 	case 0xe4: // cpx $ff 	case 0xec: // cpx $ffff 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		if (data[0] == 0xe0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,x,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],x,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// CPY 	case 0xc0: // cpy #$ff 	case 0xc4: // cpy $ff 	case 0xcc: // cpy $ffff 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		if (data[0] == 0xc0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,y,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],y,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// BRANCHES 	case 0x10: // bpl $ffff 	case 0x30: // bmi $ffff 	case 0x50: // bvc $ffff 	case 0x70: // bvs $ffff 	case 0x90: // bcc $ffff 	case 0xb0: // bcs $ffff 	case 0xd0: // bne $ffff 	case 0xf0: // beq $ffff 		// FIXME: Add 1 if branch occurs to same page. 		// FIXME: Add 2 if branch occurs to different page 		op->cycles = 2; 		op->failcycles = 3; 		op->type = R_ANAL_OP_TYPE_CJMP; 		if (data[1] <= 127) 			op->jump = addr + data[1] + op->size; 		else	op->jump = addr - (256 - data[1]) + op->size; 		op->fail = addr + op->size; 		// FIXME: add a type of conditional 		// op->cond = R_ANAL_COND_LE; 		_6502_anal_esil_ccall (op, data[0]); 		break; 	// JSR 	case 0x20: // jsr $ffff 		op->cycles = 6; 		op->type = R_ANAL_OP_TYPE_CALL; 		op->jump = data[1] | data[2] << 8; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = 2; 		// JSR pushes the address-1 of the next operation on to the stack before transferring program 		// control to the following address 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_setf (&op->esil, ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="", op->jump); 		break; 	// JMP 	case 0x4c: // jmp $ffff 		op->cycles = 3; 		op->type = R_ANAL_OP_TYPE_JMP; 		op->jump = data[1] | data[2] << 8; 		r_strbuf_setf (&op->esil, ""0x%04x,pc,="", op->jump); 		break; 	case 0x6c: // jmp ($ffff) 		op->cycles = 5; 		op->type = R_ANAL_OP_TYPE_UJMP; 		// FIXME: how to read memory? 		// op->jump = data[1] | data[2] << 8; 		r_strbuf_setf (&op->esil, ""0x%04x,[2],pc,="", data[1] | data[2] << 8); 		break; 	// RTS 	case 0x60: // rts 		op->eob = true; 		op->type = R_ANAL_OP_TYPE_RET; 		op->cycles = 6; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -2; 		// Operation:  PC from Stack, PC + 1 -> PC 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_set (&op->esil, ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=""); 		break; 	// RTI 	case 0x40: // rti 		op->eob = true; 		op->type = R_ANAL_OP_TYPE_RET; 		op->cycles = 6; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -3; 		// Operation: P from Stack, PC from Stack 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_set (&op->esil, ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=""); 		break; 	// NOP 	case 0xea: // nop 		op->type = R_ANAL_OP_TYPE_NOP; 		op->cycles = 2; 		break; 	// LDA 	case 0xa9: // lda #$ff 	case 0xa5: // lda $ff 	case 0xb5: // lda $ff,x 	case 0xad: // lda $ffff 	case 0xbd: // lda $ffff,x 	case 0xb9: // lda $ffff,y 	case 0xa1: // lda ($ff,x) 	case 0xb1: // lda ($ff),y 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xa9) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LDX 	case 0xa2: // ldx #$ff 	case 0xa6: // ldx $ff 	case 0xb6: // ldx $ff,y 	case 0xae: // ldx $ffff 	case 0xbe: // ldx $ffff,y 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y'); 		if (data[0] == 0xa2) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,x,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],x,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LDY 	case 0xa0: // ldy #$ff 	case 0xa4: // ldy $ff 	case 0xb4: // ldy $ff,x 	case 0xac: // ldy $ffff 	case 0xbc: // ldy $ffff,x 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x'); 		if (data[0] == 0xa0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,y,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],y,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// STA 	case 0x85: // sta $ff 	case 0x95: // sta $ff,x 	case 0x8d: // sta $ffff 	case 0x9d: // sta $ffff,x 	case 0x99: // sta $ffff,y 	case 0x81: // sta ($ff,x) 	case 0x91: // sta ($ff),y 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		r_strbuf_setf (&op->esil, ""a,%s,=[1]"", addrbuf); 		break; 	// STX 	case 0x86: // stx $ff 	case 0x96: // stx $ff,y 	case 0x8e: // stx $ffff 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y'); 		r_strbuf_setf (&op->esil, ""x,%s,=[1]"", addrbuf); 		break; 	// STY 	case 0x84: // sty $ff 	case 0x94: // sty $ff,x 	case 0x8c: // sty $ffff 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""y,%s,=[1]"", addrbuf); 		break; 	// PHP/PHA 	case 0x08: // php 	case 0x48: // pha 		op->type = R_ANAL_OP_TYPE_PUSH; 		op->cycles = 3; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = 1; 		_6502_anal_esil_push (op, data[0]); 		break; 	// PLP,PLA 	case 0x28: // plp 	case 0x68: // plp 		op->type = R_ANAL_OP_TYPE_POP; 		op->cycles = 4; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -1; 		_6502_anal_esil_pop (op, data[0]); 		break; 	// TAX,TYA,... 	case 0xaa: // tax 	case 0x8a: // txa 	case 0xa8: // tay 	case 0x98: // tya 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		_6502_anal_esil_mov (op, data[0]); 		break; 	case 0x9a: // txs 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		op->stackop = R_ANAL_STACK_SET; 		// FIXME: should I get register X a place it here? 		// op->stackptr = get_register_x(); 		_6502_anal_esil_mov (op, data[0]); 		break; 	case 0xba: // tsx 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		op->stackop = R_ANAL_STACK_GET; 		_6502_anal_esil_mov (op, data[0]); 		break; 	} 	return op->size; }"
"_6502_op_anal_6502_not_vulnerable.c","not_vulnerable","static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { 	char addrbuf[64]; 	const int buffsize = sizeof (addrbuf) - 1;  	memset (op, '\0', sizeof (RAnalOp)); 	op->size = snes_op_get_size (1, 1, &snes_op[data[0]]);	//snes-arch is similiar to nes/6502 	op->addr = addr; 	op->type = R_ANAL_OP_TYPE_UNK; 	op->id = data[0]; 	r_strbuf_init (&op->esil); 	switch (data[0]) { 	case 0x02: 	case 0x03: 	case 0x04: 	case 0x07: 	case 0x0b: 	case 0x0c: 	case 0x0f: 	case 0x12: 	case 0x13: 	case 0x14: 	case 0x17: 	case 0x1a: 	case 0x1b: 	case 0x1c: 	case 0x1f: 	case 0x22: 	case 0x23: 	case 0x27: 	case 0x2b: 	case 0x2f: 	case 0x32: 	case 0x33: 	case 0x34: 	case 0x37: 	case 0x3a: 	case 0x3b: 	case 0x3c: 	case 0x3f: 	case 0x42: 	case 0x43: 	case 0x44: 	case 0x47: 	case 0x4b: 	case 0x4f: 	case 0x52: 	case 0x53: 	case 0x54: 	case 0x57: 	case 0x5a: 	case 0x5b: 	case 0x5c: 	case 0x5f: 	case 0x62: 	case 0x63: 	case 0x64: 	case 0x67: 	case 0x6b: 	case 0x6f: 	case 0x72: 	case 0x73: 	case 0x74: 	case 0x77: 	case 0x7a: 	case 0x7b: 	case 0x7c: 	case 0x7f: 	case 0x80: 	case 0x82: 	case 0x83: 	case 0x87: 	case 0x89: 	case 0x8b: 	case 0x8f: 	case 0x92: 	case 0x93: 	case 0x97: 	case 0x9b: 	case 0x9c: 	case 0x9e: 	case 0x9f: 	case 0xa3: 	case 0xa7: 	case 0xab: 	case 0xaf: 	case 0xb2: 	case 0xb3: 	case 0xb7: 	case 0xbb: 	case 0xbf: 	case 0xc2: 	case 0xc3: 	case 0xc7: 	case 0xcb: 	case 0xcf: 	case 0xd2: 	case 0xd3: 	case 0xd4: 	case 0xd7: 	case 0xda: 	case 0xdb: 	case 0xdc: 	case 0xdf: 	case 0xe2: 	case 0xe3: 	case 0xe7: 	case 0xeb: 	case 0xef: 	case 0xf2: 	case 0xf3: 	case 0xf4: 	case 0xf7: 	case 0xfa: 	case 0xfb: 	case 0xfc: 	case 0xff: 		// undocumented or not-implemented opcodes for 6502. 		// some of them might be implemented in 65816 		op->size = 1; 		op->type = R_ANAL_OP_TYPE_ILL; 		break;  	// BRK 	case 0x00: // brk 		op->cycles = 7; 		op->type = R_ANAL_OP_TYPE_SWI; 		// override 65816 code which seems to be wrong: size is 1, but pc = pc + 2 		op->size = 1; 		// PC + 2 to Stack, P to Stack  B=1 D=0 I=1. ""B"" is not a flag. Only its bit is pushed on the stack 		// PC was already incremented by one at this point. Needs to incremented once more 		// New PC is Interrupt Vector: $fffe. (FIXME: Confirm this is valid for all 6502) 		r_strbuf_set (&op->esil, "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=""); 		break;  	// FLAGS 	case 0x78: // sei 	case 0x58: // cli 	case 0x38: // sec 	case 0x18: // clc 	case 0xf8: // sed 	case 0xd8: // cld 	case 0xb8: // clv 		op->cycles = 2; 		// FIXME: what opcode for this? 		op->type = R_ANAL_OP_TYPE_NOP; 		_6502_anal_esil_flags (op, data[0]); 		break; 	// BIT 	case 0x24: // bit $ff 	case 0x2c: // bit $ffff 		op->type = R_ANAL_OP_TYPE_MOV; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		r_strbuf_setf (&op->esil, ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="",addrbuf, addrbuf, addrbuf); 		break; 	// ADC 	case 0x69: // adc #$ff 	case 0x65: // adc $ff 	case 0x75: // adc $ff,x 	case 0x6d: // adc $ffff 	case 0x7d: // adc $ffff,x 	case 0x79: // adc $ffff,y 	case 0x61: // adc ($ff,x) 	case 0x71: // adc ($ff,y) 		// FIXME: update V 		// FIXME: support BCD mode 		op->type = R_ANAL_OP_TYPE_ADD; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x69) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		// fix Z 		r_strbuf_append (&op->esil, "",a,a,=,$z,Z,=""); 		break; 	// SBC 	case 0xe9: // sbc #$ff 	case 0xe5: // sbc $ff 	case 0xf5: // sbc $ff,x 	case 0xed: // sbc $ffff 	case 0xfd: // sbc $ffff,x 	case 0xf9: // sbc $ffff,y 	case 0xe1: // sbc ($ff,x) 	case 0xf1: // sbc ($ff,y) 		// FIXME: update V 		// FIXME: support BCD mode 		op->type = R_ANAL_OP_TYPE_SUB; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xe9) // immediate mode 			r_strbuf_setf (&op->esil, ""C,!,%s,+,a,-="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""C,!,%s,[1],+,a,-="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// fix Z and revert C 		r_strbuf_append (&op->esil, "",a,a,=,$z,Z,=,C,!=""); 		break; 	// ORA 	case 0x09: // ora #$ff 	case 0x05: // ora $ff 	case 0x15: // ora $ff,x 	case 0x0d: // ora $ffff 	case 0x1d: // ora $ffff,x 	case 0x19: // ora $ffff,y 	case 0x01: // ora ($ff,x) 	case 0x11: // ora ($ff),y 		op->type = R_ANAL_OP_TYPE_OR; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x09) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,|="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,|="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// AND 	case 0x29: // and #$ff 	case 0x25: // and $ff 	case 0x35: // and $ff,x 	case 0x2d: // and $ffff 	case 0x3d: // and $ffff,x 	case 0x39: // and $ffff,y 	case 0x21: // and ($ff,x) 	case 0x31: // and ($ff),y 		op->type = R_ANAL_OP_TYPE_AND; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x29) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,&="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,&="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// EOR 	case 0x49: // eor #$ff 	case 0x45: // eor $ff 	case 0x55: // eor $ff,x 	case 0x4d: // eor $ffff 	case 0x5d: // eor $ffff,x 	case 0x59: // eor $ffff,y 	case 0x41: // eor ($ff,x) 	case 0x51: // eor ($ff),y 		op->type = R_ANAL_OP_TYPE_XOR; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0x49) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,^="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,^="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ASL 	case 0x0a: // asl a 	case 0x06: // asl $ff 	case 0x16: // asl $ff,x 	case 0x0e: // asl $ffff 	case 0x1e: // asl $ffff,x 		op->type = R_ANAL_OP_TYPE_SHL; 		if (data[0] == 0x0a) { 			r_strbuf_set (&op->esil, ""1,a,<<=,$c7,C,=,a,a,=""); 		} else  { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],<<,%s,=[1],$c7,C,="", addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LSR 	case 0x4a: // lsr a 	case 0x46: // lsr $ff 	case 0x56: // lsr $ff,x 	case 0x4e: // lsr $ffff 	case 0x5e: // lsr $ffff,x 		op->type = R_ANAL_OP_TYPE_SHR; 		if (data[0] == 0x4a) { 			r_strbuf_set (&op->esil, ""1,a,&,C,=,1,a,>>=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"", addrbuf, addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ROL 	case 0x2a: // rol a 	case 0x26: // rol $ff 	case 0x36: // rol $ff,x 	case 0x2e: // rol $ffff 	case 0x3e: // rol $ffff,x 		op->type = R_ANAL_OP_TYPE_ROL; 		if (data[0] == 0x2a) { 			r_strbuf_set (&op->esil, ""1,a,<<,C,|,a,=,$c7,C,=,a,a,=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="", addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// ROR 	case 0x6a: // ror a 	case 0x66: // ror $ff 	case 0x76: // ror $ff,x 	case 0x6e: // ror $ffff 	case 0x7e: // ror $ffff,x 		// uses N as temporary to hold C value. but in fact, 		// it is not temporary since in all ROR ops, N will have the value of C 		op->type = R_ANAL_OP_TYPE_ROR; 		if (data[0] == 0x6a) { 			r_strbuf_set (&op->esil, ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=""); 		} else { 			_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 			r_strbuf_setf (&op->esil, ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"", addrbuf, addrbuf, addrbuf); 		} 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// INC 	case 0xe6: // inc $ff 	case 0xf6: // inc $ff,x 	case 0xee: // inc $ffff 	case 0xfe: // inc $ffff,x 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""%s,++=[1]"", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// DEC 	case 0xc6: // dec $ff 	case 0xd6: // dec $ff,x 	case 0xce: // dec $ffff 	case 0xde: // dec $ffff,x 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""%s,--=[1]"", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// INX, INY 	case 0xe8: // inx 	case 0xc8: // iny 		op->cycles = 2; 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_inc_reg (op, data[0], ""+""); 		break; 	// DEX, DEY 	case 0xca: // dex 	case 0x88: // dey 		op->cycles = 2; 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_inc_reg (op, data[0], ""-""); 		break; 	// CMP 	case 0xc9: // cmp #$ff 	case 0xc5: // cmp $ff 	case 0xd5: // cmp $ff,x 	case 0xcd: // cmp $ffff 	case 0xdd: // cmp $ffff,x 	case 0xd9: // cmp $ffff,y 	case 0xc1: // cmp ($ff,x) 	case 0xd1: // cmp ($ff),y 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xc9) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// CPX 	case 0xe0: // cpx #$ff 	case 0xe4: // cpx $ff 	case 0xec: // cpx $ffff 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		if (data[0] == 0xe0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,x,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],x,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// CPY 	case 0xc0: // cpy #$ff 	case 0xc4: // cpy $ff 	case 0xcc: // cpy $ffff 		op->type = R_ANAL_OP_TYPE_CMP; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0); 		if (data[0] == 0xc0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,y,=="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],y,=="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_BNZ); 		// invert C, since C=1 when A-M >= 0 		r_strbuf_append (&op->esil, "",C,!,C,=""); 		break; 	// BRANCHES 	case 0x10: // bpl $ffff 	case 0x30: // bmi $ffff 	case 0x50: // bvc $ffff 	case 0x70: // bvs $ffff 	case 0x90: // bcc $ffff 	case 0xb0: // bcs $ffff 	case 0xd0: // bne $ffff 	case 0xf0: // beq $ffff 		// FIXME: Add 1 if branch occurs to same page. 		// FIXME: Add 2 if branch occurs to different page 		op->cycles = 2; 		op->failcycles = 3; 		op->type = R_ANAL_OP_TYPE_CJMP; 		if (len > 1) { 			if (data[1] <= 127) { 				op->jump = addr + data[1] + op->size; 			} else { 				op->jump = addr - (256 - data[1]) + op->size; 			} 		} else { 			op->jump = addr; 		} 		op->fail = addr + op->size; 		// FIXME: add a type of conditional 		// op->cond = R_ANAL_COND_LE; 		_6502_anal_esil_ccall (op, data[0]); 		break; 	// JSR 	case 0x20: // jsr $ffff 		op->cycles = 6; 		op->type = R_ANAL_OP_TYPE_CALL; 		op->jump = data[1] | data[2] << 8; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = 2; 		// JSR pushes the address-1 of the next operation on to the stack before transferring program 		// control to the following address 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_setf (&op->esil, ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="", op->jump); 		break; 	// JMP 	case 0x4c: // jmp $ffff 		op->cycles = 3; 		op->type = R_ANAL_OP_TYPE_JMP; 		op->jump = data[1] | data[2] << 8; 		r_strbuf_setf (&op->esil, ""0x%04x,pc,="", op->jump); 		break; 	case 0x6c: // jmp ($ffff) 		op->cycles = 5; 		op->type = R_ANAL_OP_TYPE_UJMP; 		// FIXME: how to read memory? 		// op->jump = data[1] | data[2] << 8; 		r_strbuf_setf (&op->esil, ""0x%04x,[2],pc,="", data[1] | data[2] << 8); 		break; 	// RTS 	case 0x60: // rts 		op->eob = true; 		op->type = R_ANAL_OP_TYPE_RET; 		op->cycles = 6; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -2; 		// Operation:  PC from Stack, PC + 1 -> PC 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_set (&op->esil, ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=""); 		break; 	// RTI 	case 0x40: // rti 		op->eob = true; 		op->type = R_ANAL_OP_TYPE_RET; 		op->cycles = 6; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -3; 		// Operation: P from Stack, PC from Stack 		// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100 		r_strbuf_set (&op->esil, ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=""); 		break; 	// NOP 	case 0xea: // nop 		op->type = R_ANAL_OP_TYPE_NOP; 		op->cycles = 2; 		break; 	// LDA 	case 0xa9: // lda #$ff 	case 0xa5: // lda $ff 	case 0xb5: // lda $ff,x 	case 0xad: // lda $ffff 	case 0xbd: // lda $ffff,x 	case 0xb9: // lda $ffff,y 	case 0xa1: // lda ($ff,x) 	case 0xb1: // lda ($ff),y 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		if (data[0] == 0xa9) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,a,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],a,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LDX 	case 0xa2: // ldx #$ff 	case 0xa6: // ldx $ff 	case 0xb6: // ldx $ff,y 	case 0xae: // ldx $ffff 	case 0xbe: // ldx $ffff,y 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y'); 		if (data[0] == 0xa2) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,x,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],x,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// LDY 	case 0xa0: // ldy #$ff 	case 0xa4: // ldy $ff 	case 0xb4: // ldy $ff,x 	case 0xac: // ldy $ffff 	case 0xbc: // ldy $ffff,x 		op->type = R_ANAL_OP_TYPE_LOAD; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x'); 		if (data[0] == 0xa0) // immediate mode 			r_strbuf_setf (&op->esil, ""%s,y,="", addrbuf); 		else	r_strbuf_setf (&op->esil, ""%s,[1],y,="", addrbuf); 		_6502_anal_update_flags (op, _6502_FLAGS_NZ); 		break; 	// STA 	case 0x85: // sta $ff 	case 0x95: // sta $ff,x 	case 0x8d: // sta $ffff 	case 0x9d: // sta $ffff,x 	case 0x99: // sta $ffff,y 	case 0x81: // sta ($ff,x) 	case 0x91: // sta ($ff),y 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize); 		r_strbuf_setf (&op->esil, ""a,%s,=[1]"", addrbuf); 		break; 	// STX 	case 0x86: // stx $ff 	case 0x96: // stx $ff,y 	case 0x8e: // stx $ffff 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y'); 		r_strbuf_setf (&op->esil, ""x,%s,=[1]"", addrbuf); 		break; 	// STY 	case 0x84: // sty $ff 	case 0x94: // sty $ff,x 	case 0x8c: // sty $ffff 		op->type = R_ANAL_OP_TYPE_STORE; 		_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x'); 		r_strbuf_setf (&op->esil, ""y,%s,=[1]"", addrbuf); 		break; 	// PHP/PHA 	case 0x08: // php 	case 0x48: // pha 		op->type = R_ANAL_OP_TYPE_PUSH; 		op->cycles = 3; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = 1; 		_6502_anal_esil_push (op, data[0]); 		break; 	// PLP,PLA 	case 0x28: // plp 	case 0x68: // plp 		op->type = R_ANAL_OP_TYPE_POP; 		op->cycles = 4; 		op->stackop = R_ANAL_STACK_INC; 		op->stackptr = -1; 		_6502_anal_esil_pop (op, data[0]); 		break; 	// TAX,TYA,... 	case 0xaa: // tax 	case 0x8a: // txa 	case 0xa8: // tay 	case 0x98: // tya 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		_6502_anal_esil_mov (op, data[0]); 		break; 	case 0x9a: // txs 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		op->stackop = R_ANAL_STACK_SET; 		// FIXME: should I get register X a place it here? 		// op->stackptr = get_register_x(); 		_6502_anal_esil_mov (op, data[0]); 		break; 	case 0xba: // tsx 		op->type = R_ANAL_OP_TYPE_MOV; 		op->cycles = 2; 		op->stackop = R_ANAL_STACK_GET; 		_6502_anal_esil_mov (op, data[0]); 		break; 	} 	return op->size; }"
"__ext4_journal_stop_ext4_jbd2_cwe-416.c","CWE-416","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle) { 	struct super_block *sb; 	int err; 	int rc;  	if (!ext4_handle_valid(handle)) { 		ext4_put_nojournal(handle); 		return 0; 	}  	if (!handle->h_transaction) { 		err = jbd2_journal_stop(handle); 		return handle->h_err ? handle->h_err : err; 	}  	sb = handle->h_transaction->t_journal->j_private; 	err = handle->h_err; 	rc = jbd2_journal_stop(handle);  	if (!err) 		err = rc; 	if (err) 		__ext4_std_error(sb, where, line, err); 	return err; }"
"__ext4_journal_stop_ext4_jbd2_not_vulnerable.c","not_vulnerable","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle) { 	struct super_block *sb; 	int err; 	int rc;  	if (!ext4_handle_valid(handle)) { 		ext4_put_nojournal(handle); 		return 0; 	}  	err = handle->h_err; 	if (!handle->h_transaction) { 		rc = jbd2_journal_stop(handle); 		return err ? err : rc; 	}  	sb = handle->h_transaction->t_journal->j_private; 	rc = jbd2_journal_stop(handle);  	if (!err) 		err = rc; 	if (err) 		__ext4_std_error(sb, where, line, err); 	return err; }"
"__mdiobus_register_mdio_bus_cwe-416.c","CWE-416","int __mdiobus_register(struct mii_bus *bus, struct module *owner) { 	struct mdio_device *mdiodev; 	int i, err; 	struct gpio_desc *gpiod;  	if (NULL == bus || NULL == bus->name || 	    NULL == bus->read || NULL == bus->write) 		return -EINVAL;  	BUG_ON(bus->state != MDIOBUS_ALLOCATED && 	       bus->state != MDIOBUS_UNREGISTERED);  	bus->owner = owner; 	bus->dev.parent = bus->parent; 	bus->dev.class = &mdio_bus_class; 	bus->dev.groups = NULL; 	dev_set_name(&bus->dev, ""%s"", bus->id);  	err = device_register(&bus->dev); 	if (err) { 		pr_err(""mii_bus %s failed to register\n"", bus->id); 		put_device(&bus->dev); 		return -EINVAL; 	}  	mutex_init(&bus->mdio_lock);  	/* de-assert bus level PHY GPIO reset */ 	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW); 	if (IS_ERR(gpiod)) { 		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"", 			bus->id); 		device_del(&bus->dev); 		return PTR_ERR(gpiod); 	} else	if (gpiod) { 		bus->reset_gpiod = gpiod;  		gpiod_set_value_cansleep(gpiod, 1); 		udelay(bus->reset_delay_us); 		gpiod_set_value_cansleep(gpiod, 0); 	}  	if (bus->reset) 		bus->reset(bus);  	for (i = 0; i < PHY_MAX_ADDR; i++) { 		if ((bus->phy_mask & (1 << i)) == 0) { 			struct phy_device *phydev;  			phydev = mdiobus_scan(bus, i); 			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) { 				err = PTR_ERR(phydev); 				goto error; 			} 		} 	}  	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);  	bus->state = MDIOBUS_REGISTERED; 	pr_info(""%s: probed\n"", bus->name); 	return 0;  error: 	while (--i >= 0) { 		mdiodev = bus->mdio_map[i]; 		if (!mdiodev) 			continue;  		mdiodev->device_remove(mdiodev); 		mdiodev->device_free(mdiodev); 	}  	/* Put PHYs in RESET to save power */ 	if (bus->reset_gpiod) 		gpiod_set_value_cansleep(bus->reset_gpiod, 1);  	device_del(&bus->dev); 	return err; }"
"__mdiobus_register_mdio_bus_not_vulnerable.c","not_vulnerable","int __mdiobus_register(struct mii_bus *bus, struct module *owner) { 	struct mdio_device *mdiodev; 	int i, err; 	struct gpio_desc *gpiod;  	if (NULL == bus || NULL == bus->name || 	    NULL == bus->read || NULL == bus->write) 		return -EINVAL;  	BUG_ON(bus->state != MDIOBUS_ALLOCATED && 	       bus->state != MDIOBUS_UNREGISTERED);  	bus->owner = owner; 	bus->dev.parent = bus->parent; 	bus->dev.class = &mdio_bus_class; 	bus->dev.groups = NULL; 	dev_set_name(&bus->dev, ""%s"", bus->id);  	err = device_register(&bus->dev); 	if (err) { 		pr_err(""mii_bus %s failed to register\n"", bus->id); 		return -EINVAL; 	}  	mutex_init(&bus->mdio_lock);  	/* de-assert bus level PHY GPIO reset */ 	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW); 	if (IS_ERR(gpiod)) { 		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"", 			bus->id); 		device_del(&bus->dev); 		return PTR_ERR(gpiod); 	} else	if (gpiod) { 		bus->reset_gpiod = gpiod;  		gpiod_set_value_cansleep(gpiod, 1); 		udelay(bus->reset_delay_us); 		gpiod_set_value_cansleep(gpiod, 0); 	}  	if (bus->reset) 		bus->reset(bus);  	for (i = 0; i < PHY_MAX_ADDR; i++) { 		if ((bus->phy_mask & (1 << i)) == 0) { 			struct phy_device *phydev;  			phydev = mdiobus_scan(bus, i); 			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) { 				err = PTR_ERR(phydev); 				goto error; 			} 		} 	}  	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);  	bus->state = MDIOBUS_REGISTERED; 	pr_info(""%s: probed\n"", bus->name); 	return 0;  error: 	while (--i >= 0) { 		mdiodev = bus->mdio_map[i]; 		if (!mdiodev) 			continue;  		mdiodev->device_remove(mdiodev); 		mdiodev->device_free(mdiodev); 	}  	/* Put PHYs in RESET to save power */ 	if (bus->reset_gpiod) 		gpiod_set_value_cansleep(bus->reset_gpiod, 1);  	device_del(&bus->dev); 	return err; }"
"ape_decode_frame_apedec_cwe-125.c","CWE-125","static int ape_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame_ptr, AVPacket *avpkt) {     AVFrame *frame     = data;     const uint8_t *buf = avpkt->data;     APEContext *s = avctx->priv_data;     uint8_t *sample8;     int16_t *sample16;     int32_t *sample24;     int i, ch, ret;     int blockstodecode;      /* this should never be negative, but bad things will happen if it is, so        check it just to make sure. */     av_assert0(s->samples >= 0);      if(!s->samples){         uint32_t nblocks, offset;         int buf_size;          if (!avpkt->size) {             *got_frame_ptr = 0;             return 0;         }         if (avpkt->size < 8) {             av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");             return AVERROR_INVALIDDATA;         }         buf_size = avpkt->size & ~3;         if (buf_size != avpkt->size) {             av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. ""                    ""extra bytes at the end will be skipped.\n"");         }         if (s->fileversion < 3950) // previous versions overread two bytes             buf_size += 2;         av_fast_padded_malloc(&s->data, &s->data_size, buf_size);         if (!s->data)             return AVERROR(ENOMEM);         s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,                           buf_size >> 2);         memset(s->data + (buf_size & ~3), 0, buf_size & 3);         s->ptr = s->data;         s->data_end = s->data + buf_size;          nblocks = bytestream_get_be32(&s->ptr);         offset  = bytestream_get_be32(&s->ptr);         if (s->fileversion >= 3900) {             if (offset > 3) {                 av_log(avctx, AV_LOG_ERROR, ""Incorrect offset passed\n"");                 s->data = NULL;                 return AVERROR_INVALIDDATA;             }             if (s->data_end - s->ptr < offset) {                 av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");                 return AVERROR_INVALIDDATA;             }             s->ptr += offset;         } else {             if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)                 return ret;             if (s->fileversion > 3800)                 skip_bits_long(&s->gb, offset * 8);             else                 skip_bits_long(&s->gb, offset);         }          if (!nblocks || nblocks > INT_MAX) {             av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"",                    nblocks);             return AVERROR_INVALIDDATA;         }          /* Initialize the frame decoder */         if (init_frame_decoder(s) < 0) {             av_log(avctx, AV_LOG_ERROR, ""Error reading frame header\n"");             return AVERROR_INVALIDDATA;         }         s->samples = nblocks;     }      if (!s->data) {         *got_frame_ptr = 0;         return avpkt->size;     }      blockstodecode = FFMIN(s->blocks_per_loop, s->samples);     // for old files coefficients were not interleaved,     // so we need to decode all of them at once     if (s->fileversion < 3930)         blockstodecode = s->samples;      /* reallocate decoded sample buffer if needed */     av_fast_malloc(&s->decoded_buffer, &s->decoded_size,                    2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));     if (!s->decoded_buffer)         return AVERROR(ENOMEM);     memset(s->decoded_buffer, 0, s->decoded_size);     s->decoded[0] = s->decoded_buffer;     s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);      /* get output buffer */     frame->nb_samples = blockstodecode;     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)         return ret;      s->error=0;      if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))         ape_unpack_mono(s, blockstodecode);     else         ape_unpack_stereo(s, blockstodecode);     emms_c();      if (s->error) {         s->samples=0;         av_log(avctx, AV_LOG_ERROR, ""Error decoding frame\n"");         return AVERROR_INVALIDDATA;     }      switch (s->bps) {     case 8:         for (ch = 0; ch < s->channels; ch++) {             sample8 = (uint8_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;         }         break;     case 16:         for (ch = 0; ch < s->channels; ch++) {             sample16 = (int16_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample16++ = s->decoded[ch][i];         }         break;     case 24:         for (ch = 0; ch < s->channels; ch++) {             sample24 = (int32_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample24++ = s->decoded[ch][i] << 8;         }         break;     }      s->samples -= blockstodecode;      *got_frame_ptr = 1;      return !s->samples ? avpkt->size : 0; }"
"ape_decode_frame_apedec_not_vulnerable.c","not_vulnerable","static int ape_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame_ptr, AVPacket *avpkt) {     AVFrame *frame     = data;     const uint8_t *buf = avpkt->data;     APEContext *s = avctx->priv_data;     uint8_t *sample8;     int16_t *sample16;     int32_t *sample24;     int i, ch, ret;     int blockstodecode;     uint64_t decoded_buffer_size;      /* this should never be negative, but bad things will happen if it is, so        check it just to make sure. */     av_assert0(s->samples >= 0);      if(!s->samples){         uint32_t nblocks, offset;         int buf_size;          if (!avpkt->size) {             *got_frame_ptr = 0;             return 0;         }         if (avpkt->size < 8) {             av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");             return AVERROR_INVALIDDATA;         }         buf_size = avpkt->size & ~3;         if (buf_size != avpkt->size) {             av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. ""                    ""extra bytes at the end will be skipped.\n"");         }         if (s->fileversion < 3950) // previous versions overread two bytes             buf_size += 2;         av_fast_padded_malloc(&s->data, &s->data_size, buf_size);         if (!s->data)             return AVERROR(ENOMEM);         s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,                           buf_size >> 2);         memset(s->data + (buf_size & ~3), 0, buf_size & 3);         s->ptr = s->data;         s->data_end = s->data + buf_size;          nblocks = bytestream_get_be32(&s->ptr);         offset  = bytestream_get_be32(&s->ptr);         if (s->fileversion >= 3900) {             if (offset > 3) {                 av_log(avctx, AV_LOG_ERROR, ""Incorrect offset passed\n"");                 s->data = NULL;                 return AVERROR_INVALIDDATA;             }             if (s->data_end - s->ptr < offset) {                 av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");                 return AVERROR_INVALIDDATA;             }             s->ptr += offset;         } else {             if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)                 return ret;             if (s->fileversion > 3800)                 skip_bits_long(&s->gb, offset * 8);             else                 skip_bits_long(&s->gb, offset);         }          if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {             av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"",                    nblocks);             return AVERROR_INVALIDDATA;         }          /* Initialize the frame decoder */         if (init_frame_decoder(s) < 0) {             av_log(avctx, AV_LOG_ERROR, ""Error reading frame header\n"");             return AVERROR_INVALIDDATA;         }         s->samples = nblocks;     }      if (!s->data) {         *got_frame_ptr = 0;         return avpkt->size;     }      blockstodecode = FFMIN(s->blocks_per_loop, s->samples);     // for old files coefficients were not interleaved,     // so we need to decode all of them at once     if (s->fileversion < 3930)         blockstodecode = s->samples;      /* reallocate decoded sample buffer if needed */     decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);     av_assert0(decoded_buffer_size <= INT_MAX);     av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);     if (!s->decoded_buffer)         return AVERROR(ENOMEM);     memset(s->decoded_buffer, 0, s->decoded_size);     s->decoded[0] = s->decoded_buffer;     s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);      /* get output buffer */     frame->nb_samples = blockstodecode;     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)         return ret;      s->error=0;      if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))         ape_unpack_mono(s, blockstodecode);     else         ape_unpack_stereo(s, blockstodecode);     emms_c();      if (s->error) {         s->samples=0;         av_log(avctx, AV_LOG_ERROR, ""Error decoding frame\n"");         return AVERROR_INVALIDDATA;     }      switch (s->bps) {     case 8:         for (ch = 0; ch < s->channels; ch++) {             sample8 = (uint8_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;         }         break;     case 16:         for (ch = 0; ch < s->channels; ch++) {             sample16 = (int16_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample16++ = s->decoded[ch][i];         }         break;     case 24:         for (ch = 0; ch < s->channels; ch++) {             sample24 = (int32_t *)frame->data[ch];             for (i = 0; i < blockstodecode; i++)                 *sample24++ = s->decoded[ch][i] << 8;         }         break;     }      s->samples -= blockstodecode;      *got_frame_ptr = 1;      return !s->samples ? avpkt->size : 0; }"
"ares_parse_a_reply_ares_parse_a_reply_cwe-125.c","CWE-125","int ares_parse_a_reply(const unsigned char *abuf, int alen, 		       struct hostent **host) {   unsigned int qdcount, ancount;   int status, i, rr_type, rr_class, rr_len, naddrs;   long int len;   int naliases;   const unsigned char *aptr;   char *hostname, *rr_name, *rr_data, **aliases;   struct in_addr *addrs;   struct hostent *hostent;    /* Set *host to NULL for all failure cases. */   *host = NULL;    /* Give up if abuf doesn't have room for a header. */   if (alen < HFIXEDSZ)     return ARES_EBADRESP;    /* Fetch the question and answer count from the header. */   qdcount = DNS_HEADER_QDCOUNT(abuf);   ancount = DNS_HEADER_ANCOUNT(abuf);   if (qdcount != 1)     return ARES_EBADRESP;    /* Expand the name from the question, and skip past the question. */   aptr = abuf + HFIXEDSZ;   status = ares_expand_name(aptr, abuf, alen, &hostname, &len);   if (status != ARES_SUCCESS)     return status;   if (aptr + len + QFIXEDSZ > abuf + alen)     {       free(hostname);       return ARES_EBADRESP;     }   aptr += len + QFIXEDSZ;    /* Allocate addresses and aliases; ancount gives an upper bound for both. */   addrs = malloc(ancount * sizeof(struct in_addr));   if (!addrs)     {       free(hostname);       return ARES_ENOMEM;     }   aliases = malloc((ancount + 1) * sizeof(char *));   if (!aliases)     {       free(hostname);       free(addrs);       return ARES_ENOMEM;     }   naddrs = 0;   naliases = 0;    /* Examine each answer resource record (RR) in turn. */   for (i = 0; i < (int)ancount; i++)     {       /* Decode the RR up to the data field. */       status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);       if (status != ARES_SUCCESS) 	break;       aptr += len;       if (aptr + RRFIXEDSZ > abuf + alen) 	{ 	  free(rr_name); 	  status = ARES_EBADRESP; 	  break; 	}       rr_type = DNS_RR_TYPE(aptr);       rr_class = DNS_RR_CLASS(aptr);       rr_len = DNS_RR_LEN(aptr);       aptr += RRFIXEDSZ;        if (rr_class == C_IN && rr_type == T_A 	  && rr_len == sizeof(struct in_addr) 	  && strcasecmp(rr_name, hostname) == 0) 	{ 	  memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr)); 	  naddrs++; 	  status = ARES_SUCCESS; 	}        if (rr_class == C_IN && rr_type == T_CNAME) 	{ 	  /* Record the RR name as an alias. */ 	  aliases[naliases] = rr_name; 	  naliases++;  	  /* Decode the RR data and replace the hostname with it. */ 	  status = ares_expand_name(aptr, abuf, alen, &rr_data, &len); 	  if (status != ARES_SUCCESS) 	    break; 	  free(hostname); 	  hostname = rr_data; 	}       else 	free(rr_name);        aptr += rr_len;       if (aptr > abuf + alen) 	{ 	  status = ARES_EBADRESP; 	  break; 	}     }    if (status == ARES_SUCCESS && naddrs == 0)     status = ARES_ENODATA;   if (status == ARES_SUCCESS)     {       /* We got our answer.  Allocate memory to build the host entry. */       aliases[naliases] = NULL;       hostent = malloc(sizeof(struct hostent));       if (hostent) 	{ 	  hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *)); 	  if (hostent->h_addr_list) 	    { 	      /* Fill in the hostent and return successfully. */ 	      hostent->h_name = hostname; 	      hostent->h_aliases = aliases; 	      hostent->h_addrtype = AF_INET; 	      hostent->h_length = sizeof(struct in_addr); 	      for (i = 0; i < naddrs; i++) 		hostent->h_addr_list[i] = (char *) &addrs[i]; 	      hostent->h_addr_list[naddrs] = NULL; 	      *host = hostent; 	      return ARES_SUCCESS; 	    } 	  free(hostent); 	}       status = ARES_ENOMEM;     }   for (i = 0; i < naliases; i++)     free(aliases[i]);   free(aliases);   free(addrs);   free(hostname);   return status; }"
"ares_parse_a_reply_ares_parse_a_reply_not_vulnerable.c","not_vulnerable","int ares_parse_a_reply(const unsigned char *abuf, int alen, 		       struct hostent **host) {   unsigned int qdcount, ancount;   int status, i, rr_type, rr_class, rr_len, naddrs;   long int len;   int naliases;   const unsigned char *aptr;   char *hostname, *rr_name, *rr_data, **aliases;   struct in_addr *addrs;   struct hostent *hostent;    /* Set *host to NULL for all failure cases. */   *host = NULL;    /* Give up if abuf doesn't have room for a header. */   if (alen < HFIXEDSZ)     return ARES_EBADRESP;    /* Fetch the question and answer count from the header. */   qdcount = DNS_HEADER_QDCOUNT(abuf);   ancount = DNS_HEADER_ANCOUNT(abuf);   if (qdcount != 1)     return ARES_EBADRESP;    /* Expand the name from the question, and skip past the question. */   aptr = abuf + HFIXEDSZ;   status = ares_expand_name(aptr, abuf, alen, &hostname, &len);   if (status != ARES_SUCCESS)     return status;   if (aptr + len + QFIXEDSZ > abuf + alen)     {       free(hostname);       return ARES_EBADRESP;     }   aptr += len + QFIXEDSZ;    /* Allocate addresses and aliases; ancount gives an upper bound for both. */   addrs = malloc(ancount * sizeof(struct in_addr));   if (!addrs)     {       free(hostname);       return ARES_ENOMEM;     }   aliases = malloc((ancount + 1) * sizeof(char *));   if (!aliases)     {       free(hostname);       free(addrs);       return ARES_ENOMEM;     }   naddrs = 0;   naliases = 0;    /* Examine each answer resource record (RR) in turn. */   for (i = 0; i < (int)ancount; i++)     {       /* Decode the RR up to the data field. */       status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);       if (status != ARES_SUCCESS) 	break;       aptr += len;       if (aptr + RRFIXEDSZ > abuf + alen) 	{ 	  free(rr_name); 	  status = ARES_EBADRESP; 	  break; 	}       rr_type = DNS_RR_TYPE(aptr);       rr_class = DNS_RR_CLASS(aptr);       rr_len = DNS_RR_LEN(aptr);       aptr += RRFIXEDSZ;       if (aptr + rr_len > abuf + alen) 	{ 	  free(rr_name); 	  status = ARES_EBADRESP; 	  break; 	}        if (rr_class == C_IN && rr_type == T_A 	  && rr_len == sizeof(struct in_addr) 	  && strcasecmp(rr_name, hostname) == 0) 	{ 	  memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr)); 	  naddrs++; 	  status = ARES_SUCCESS; 	}        if (rr_class == C_IN && rr_type == T_CNAME) 	{ 	  /* Record the RR name as an alias. */ 	  aliases[naliases] = rr_name; 	  naliases++;  	  /* Decode the RR data and replace the hostname with it. */ 	  status = ares_expand_name(aptr, abuf, alen, &rr_data, &len); 	  if (status != ARES_SUCCESS) 	    break; 	  free(hostname); 	  hostname = rr_data; 	}       else 	free(rr_name);        aptr += rr_len;       if (aptr > abuf + alen) 	{ 	  status = ARES_EBADRESP; 	  break; 	}     }    if (status == ARES_SUCCESS && naddrs == 0)     status = ARES_ENODATA;   if (status == ARES_SUCCESS)     {       /* We got our answer.  Allocate memory to build the host entry. */       aliases[naliases] = NULL;       hostent = malloc(sizeof(struct hostent));       if (hostent) 	{ 	  hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *)); 	  if (hostent->h_addr_list) 	    { 	      /* Fill in the hostent and return successfully. */ 	      hostent->h_name = hostname; 	      hostent->h_aliases = aliases; 	      hostent->h_addrtype = AF_INET; 	      hostent->h_length = sizeof(struct in_addr); 	      for (i = 0; i < naddrs; i++) 		hostent->h_addr_list[i] = (char *) &addrs[i]; 	      hostent->h_addr_list[naddrs] = NULL; 	      *host = hostent; 	      return ARES_SUCCESS; 	    } 	  free(hostent); 	}       status = ARES_ENOMEM;     }   for (i = 0; i < naliases; i++)     free(aliases[i]);   free(aliases);   free(addrs);   free(hostname);   return status; }"
"big_key_init_big_key_cwe-476.c","CWE-476","static int __init big_key_init(void) { 	return register_key_type(&key_type_big_key); }"
"big_key_init_big_key_not_vulnerable.c","not_vulnerable","static int __init big_key_init(void) { 	struct crypto_skcipher *cipher; 	struct crypto_rng *rng; 	int ret;  	rng = crypto_alloc_rng(big_key_rng_name, 0, 0); 	if (IS_ERR(rng)) { 		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng)); 		return PTR_ERR(rng); 	}  	big_key_rng = rng;  	/* seed RNG */ 	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng)); 	if (ret) { 		pr_err(""Can't reset rng: %d\n"", ret); 		goto error_rng; 	}  	/* init block cipher */ 	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC); 	if (IS_ERR(cipher)) { 		ret = PTR_ERR(cipher); 		pr_err(""Can't alloc crypto: %d\n"", ret); 		goto error_rng; 	}  	big_key_skcipher = cipher;  	ret = register_key_type(&key_type_big_key); 	if (ret < 0) { 		pr_err(""Can't register type: %d\n"", ret); 		goto error_cipher; 	}  	return 0;  error_cipher: 	crypto_free_skcipher(big_key_skcipher); error_rng: 	crypto_free_rng(big_key_rng); 	return ret; }"
"bin_symbols_cbin_cwe-078.c","CWE-078","static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) { 	RBinInfo *info = r_bin_get_info (r->bin); 	RList *entries = r_bin_get_entries (r->bin); 	RBinSymbol *symbol; 	RBinAddr *entry; 	RListIter *iter; 	bool firstexp = true; 	bool printHere = false; 	int i = 0, lastfs = 's'; 	bool bin_demangle = r_config_get_i (r->config, ""bin.demangle""); 	if (!info) { 		return 0; 	}  	if (args && *args == '.') { 		printHere = true; 	}  	bool is_arm = info && info->arch && !strncmp (info->arch, ""arm"", 3); 	const char *lang = bin_demangle ? r_config_get (r->config, ""bin.lang"") : NULL;  	RList *symbols = r_bin_get_symbols (r->bin); 	r_spaces_push (&r->anal->meta_spaces, ""bin"");  	if (IS_MODE_JSON (mode) && !printHere) { 		r_cons_printf (""[""); 	} else if (IS_MODE_SET (mode)) { 		r_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS); 	} else if (!at && exponly) { 		if (IS_MODE_RAD (mode)) { 			r_cons_printf (""fs exports\n""); 		} else if (IS_MODE_NORMAL (mode)) { 			r_cons_printf (printHere ? """" : ""[Exports]\n""); 		} 	} else if (!at && !exponly) { 		if (IS_MODE_RAD (mode)) { 			r_cons_printf (""fs symbols\n""); 		} else if (IS_MODE_NORMAL (mode)) { 			r_cons_printf (printHere ? """" : ""[Symbols]\n""); 		} 	} 	if (IS_MODE_NORMAL (mode)) { 		r_cons_printf (""Num Paddr      Vaddr      Bind     Type Size Name\n""); 	}   	size_t count = 0; 	r_list_foreach (symbols, iter, symbol) { 		if (!symbol->name) { 			continue; 		} 		char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true); 		ut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va); 		int len = symbol->size ? symbol->size : 32; 		SymName sn = {0};  		if (exponly && !isAnExport (symbol)) { 			free (r_symbol_name); 			continue; 		} 		if (name && strcmp (r_symbol_name, name)) { 			free (r_symbol_name); 			continue; 		} 		if (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) { 			free (r_symbol_name); 			continue; 		} 		if ((printHere && !is_in_range (r->offset, symbol->paddr, len)) 				&& (printHere && !is_in_range (r->offset, addr, len))) { 			free (r_symbol_name); 			continue; 		} 		count ++; 		snInit (r, &sn, symbol, lang);  		if (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) { 			/* 			 * Skip section symbols because they will have their own flag. 			 * Skip also file symbols because not useful for now. 			 */ 		} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) { 			if (is_arm) { 				handle_arm_special_symbol (r, symbol, va); 			} 		} else if (IS_MODE_SET (mode)) { 			// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata 			if (is_arm) { 				handle_arm_symbol (r, symbol, info, va); 			} 			select_flag_space (r, symbol); 			/* If that's a Classed symbol (method or so) */ 			if (sn.classname) { 				RFlagItem *fi = r_flag_get (r->flags, sn.methflag); 				if (r->bin->prefix) { 					char *prname = r_str_newf (""%s.%s"", r->bin->prefix, sn.methflag); 					r_name_filter (sn.methflag, -1); 					free (sn.methflag); 					sn.methflag = prname; 				} 				if (fi) { 					r_flag_item_set_realname (fi, sn.methname); 					if ((fi->offset - r->flags->base) == addr) { 				//		char *comment = fi->comment ? strdup (fi->comment) : NULL; 						r_flag_unset (r->flags, fi); 					} 				} else { 					fi = r_flag_set (r->flags, sn.methflag, addr, symbol->size); 					char *comment = fi->comment ? strdup (fi->comment) : NULL; 					if (comment) { 						r_flag_item_set_comment (fi, comment); 						R_FREE (comment); 					} 				} 			} else { 				const char *n = sn.demname ? sn.demname : sn.name; 				const char *fn = sn.demflag ? sn.demflag : sn.nameflag; 				char *fnp = (r->bin->prefix) ? 					r_str_newf (""%s.%s"", r->bin->prefix, fn): 					strdup (fn); 				RFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size); 				if (fi) { 					r_flag_item_set_realname (fi, n); 					fi->demangled = (bool)(size_t)sn.demname; 				} else { 					if (fn) { 						eprintf (""[Warning] Can't find flag (%s)\n"", fn); 					} 				} 				free (fnp); 			} 			if (sn.demname) { 				r_meta_add (r->anal, R_META_TYPE_COMMENT, 					addr, symbol->size, sn.demname); 			} 			r_flag_space_pop (r->flags); 		} else if (IS_MODE_JSON (mode)) { 			char *str = r_str_escape_utf8_for_json (r_symbol_name, -1); 			// str = r_str_replace (str, ""\"""", ""\\\"""", 1); 			r_cons_printf (""%s{\""name\"":\""%s\"","" 				""\""demname\"":\""%s\"","" 				""\""flagname\"":\""%s\"","" 				""\""ordinal\"":%d,"" 				""\""bind\"":\""%s\"","" 				""\""size\"":%d,"" 				""\""type\"":\""%s\"","" 				""\""vaddr\"":%""PFMT64d"","" 				""\""paddr\"":%""PFMT64d""}"", 				((exponly && firstexp) || printHere) ? """" : (iter->p ? "","" : """"), 				str, 				sn.demname? sn.demname: """", 				sn.nameflag, 				symbol->ordinal, 				symbol->bind, 				(int)symbol->size, 				symbol->type, 				(ut64)addr, (ut64)symbol->paddr); 			free (str); 		} else if (IS_MODE_SIMPLE (mode)) { 			const char *name = sn.demname? sn.demname: r_symbol_name; 			r_cons_printf (""0x%08""PFMT64x"" %d %s\n"", 				addr, (int)symbol->size, name); 		} else if (IS_MODE_SIMPLEST (mode)) { 			const char *name = sn.demname? sn.demname: r_symbol_name; 			r_cons_printf (""%s\n"", name); 		} else if (IS_MODE_RAD (mode)) { 			/* Skip special symbols because we do not flag them and 			 * they shouldn't be printed in the rad format either */ 			if (is_special_symbol (symbol)) { 				goto next; 			} 			RBinFile *binfile; 			RBinPlugin *plugin; 			const char *name = sn.demname? sn.demname: r_symbol_name; 			if (!name) { 				goto next; 			} 			if (!strncmp (name, ""imp."", 4)) { 				if (lastfs != 'i') { 					r_cons_printf (""fs imports\n""); 				} 				lastfs = 'i'; 			} else { 				if (lastfs != 's') { 					const char *fs = exponly? ""exports"": ""symbols""; 					r_cons_printf (""fs %s\n"", fs); 				} 				lastfs = 's'; 			} 			if (r->bin->prefix || *name) { // we don't want unnamed symbol flags 				char *flagname = construct_symbol_flagname (""sym"", name, MAXFLAG_LEN_DEFAULT); 				if (!flagname) { 					goto next; 				} 				r_cons_printf (""\""f %s%s%s %u 0x%08"" PFMT64x ""\""\n"", 					r->bin->prefix ? r->bin->prefix : """", r->bin->prefix ? ""."" : """", 					flagname, symbol->size, addr); 				free (flagname); 			} 			binfile = r_bin_cur (r->bin); 			plugin = r_bin_file_cur_plugin (binfile); 			if (plugin && plugin->name) { 				if (r_str_startswith (plugin->name, ""pe"")) { 					char *module = strdup (r_symbol_name); 					char *p = strstr (module, "".dll_""); 					if (p && strstr (module, ""imp."")) { 						char *symname = __filterShell (p + 5); 						char *m = __filterShell (module); 						*p = 0; 						if (r->bin->prefix) { 							r_cons_printf (""k bin/pe/%s/%d=%s.%s\n"", 								module, symbol->ordinal, r->bin->prefix, symname); 						} else { 							r_cons_printf (""k bin/pe/%s/%d=%s\n"", 								module, symbol->ordinal, symname); 						} 						free (symname); 						free (m); 					} 					free (module); 				} 			} 		} else { 			const char *bind = symbol->bind? symbol->bind: ""NONE""; 			const char *type = symbol->type? symbol->type: ""NONE""; 			const char *name = r_str_get (sn.demname? sn.demname: r_symbol_name); 			// const char *fwd = r_str_get (symbol->forwarder); 			r_cons_printf (""%03u"", symbol->ordinal); 			if (symbol->paddr == UT64_MAX) { 				r_cons_printf ("" ----------""); 			} else { 				r_cons_printf ("" 0x%08""PFMT64x, symbol->paddr); 			} 			r_cons_printf ("" 0x%08""PFMT64x"" %6s %6s %4d%s%s\n"", 			               addr, bind, type, symbol->size, *name? "" "": """", name); 		} next: 		snFini (&sn); 		i++; 		free (r_symbol_name); 		if (exponly && firstexp) { 			firstexp = false; 		} 		if (printHere) { 			break; 		} 	} 	if (count == 0 && IS_MODE_JSON (mode)) { 		r_cons_printf (""{}""); 	}   	//handle thumb and arm for entry point since they are not present in symbols 	if (is_arm) { 		r_list_foreach (entries, iter, entry) { 			if (IS_MODE_SET (mode)) { 				handle_arm_entry (r, entry, info, va); 			} 		} 	} 	if (IS_MODE_JSON (mode) && !printHere) { 		r_cons_printf (""]""); 	}  	r_spaces_pop (&r->anal->meta_spaces); 	return true; }"
"bin_symbols_cbin_not_vulnerable.c","not_vulnerable","static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) { 	RBinInfo *info = r_bin_get_info (r->bin); 	RList *entries = r_bin_get_entries (r->bin); 	RBinSymbol *symbol; 	RBinAddr *entry; 	RListIter *iter; 	bool firstexp = true; 	bool printHere = false; 	int i = 0, lastfs = 's'; 	bool bin_demangle = r_config_get_i (r->config, ""bin.demangle""); 	if (!info) { 		return 0; 	}  	if (args && *args == '.') { 		printHere = true; 	}  	bool is_arm = info && info->arch && !strncmp (info->arch, ""arm"", 3); 	const char *lang = bin_demangle ? r_config_get (r->config, ""bin.lang"") : NULL;  	RList *symbols = r_bin_get_symbols (r->bin); 	r_spaces_push (&r->anal->meta_spaces, ""bin"");  	if (IS_MODE_JSON (mode) && !printHere) { 		r_cons_printf (""[""); 	} else if (IS_MODE_SET (mode)) { 		r_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS); 	} else if (!at && exponly) { 		if (IS_MODE_RAD (mode)) { 			r_cons_printf (""fs exports\n""); 		} else if (IS_MODE_NORMAL (mode)) { 			r_cons_printf (printHere ? """" : ""[Exports]\n""); 		} 	} else if (!at && !exponly) { 		if (IS_MODE_RAD (mode)) { 			r_cons_printf (""fs symbols\n""); 		} else if (IS_MODE_NORMAL (mode)) { 			r_cons_printf (printHere ? """" : ""[Symbols]\n""); 		} 	} 	if (IS_MODE_NORMAL (mode)) { 		r_cons_printf (""Num Paddr      Vaddr      Bind     Type Size Name\n""); 	}   	size_t count = 0; 	r_list_foreach (symbols, iter, symbol) { 		if (!symbol->name) { 			continue; 		} 		char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true); 		ut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va); 		int len = symbol->size ? symbol->size : 32; 		SymName sn = {0};  		if (exponly && !isAnExport (symbol)) { 			free (r_symbol_name); 			continue; 		} 		if (name && strcmp (r_symbol_name, name)) { 			free (r_symbol_name); 			continue; 		} 		if (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) { 			free (r_symbol_name); 			continue; 		} 		if ((printHere && !is_in_range (r->offset, symbol->paddr, len)) 				&& (printHere && !is_in_range (r->offset, addr, len))) { 			free (r_symbol_name); 			continue; 		} 		count ++; 		snInit (r, &sn, symbol, lang);  		if (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) { 			/* 			 * Skip section symbols because they will have their own flag. 			 * Skip also file symbols because not useful for now. 			 */ 		} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) { 			if (is_arm) { 				handle_arm_special_symbol (r, symbol, va); 			} 		} else if (IS_MODE_SET (mode)) { 			// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata 			if (is_arm) { 				handle_arm_symbol (r, symbol, info, va); 			} 			select_flag_space (r, symbol); 			/* If that's a Classed symbol (method or so) */ 			if (sn.classname) { 				RFlagItem *fi = r_flag_get (r->flags, sn.methflag); 				if (r->bin->prefix) { 					char *prname = r_str_newf (""%s.%s"", r->bin->prefix, sn.methflag); 					r_name_filter (sn.methflag, -1); 					free (sn.methflag); 					sn.methflag = prname; 				} 				if (fi) { 					r_flag_item_set_realname (fi, sn.methname); 					if ((fi->offset - r->flags->base) == addr) { 				//		char *comment = fi->comment ? strdup (fi->comment) : NULL; 						r_flag_unset (r->flags, fi); 					} 				} else { 					fi = r_flag_set (r->flags, sn.methflag, addr, symbol->size); 					char *comment = fi->comment ? strdup (fi->comment) : NULL; 					if (comment) { 						r_flag_item_set_comment (fi, comment); 						R_FREE (comment); 					} 				} 			} else { 				const char *n = sn.demname ? sn.demname : sn.name; 				const char *fn = sn.demflag ? sn.demflag : sn.nameflag; 				char *fnp = (r->bin->prefix) ? 					r_str_newf (""%s.%s"", r->bin->prefix, fn): 					strdup (fn); 				RFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size); 				if (fi) { 					r_flag_item_set_realname (fi, n); 					fi->demangled = (bool)(size_t)sn.demname; 				} else { 					if (fn) { 						eprintf (""[Warning] Can't find flag (%s)\n"", fn); 					} 				} 				free (fnp); 			} 			if (sn.demname) { 				r_meta_add (r->anal, R_META_TYPE_COMMENT, 					addr, symbol->size, sn.demname); 			} 			r_flag_space_pop (r->flags); 		} else if (IS_MODE_JSON (mode)) { 			char *str = r_str_escape_utf8_for_json (r_symbol_name, -1); 			// str = r_str_replace (str, ""\"""", ""\\\"""", 1); 			r_cons_printf (""%s{\""name\"":\""%s\"","" 				""\""demname\"":\""%s\"","" 				""\""flagname\"":\""%s\"","" 				""\""ordinal\"":%d,"" 				""\""bind\"":\""%s\"","" 				""\""size\"":%d,"" 				""\""type\"":\""%s\"","" 				""\""vaddr\"":%""PFMT64d"","" 				""\""paddr\"":%""PFMT64d""}"", 				((exponly && firstexp) || printHere) ? """" : (iter->p ? "","" : """"), 				str, 				sn.demname? sn.demname: """", 				sn.nameflag, 				symbol->ordinal, 				symbol->bind, 				(int)symbol->size, 				symbol->type, 				(ut64)addr, (ut64)symbol->paddr); 			free (str); 		} else if (IS_MODE_SIMPLE (mode)) { 			const char *name = sn.demname? sn.demname: r_symbol_name; 			r_cons_printf (""0x%08""PFMT64x"" %d %s\n"", 				addr, (int)symbol->size, name); 		} else if (IS_MODE_SIMPLEST (mode)) { 			const char *name = sn.demname? sn.demname: r_symbol_name; 			r_cons_printf (""%s\n"", name); 		} else if (IS_MODE_RAD (mode)) { 			/* Skip special symbols because we do not flag them and 			 * they shouldn't be printed in the rad format either */ 			if (is_special_symbol (symbol)) { 				goto next; 			} 			RBinFile *binfile; 			RBinPlugin *plugin; 			const char *name = sn.demname? sn.demname: r_symbol_name; 			if (!name) { 				goto next; 			} 			if (!strncmp (name, ""imp."", 4)) { 				if (lastfs != 'i') { 					r_cons_printf (""fs imports\n""); 				} 				lastfs = 'i'; 			} else { 				if (lastfs != 's') { 					const char *fs = exponly? ""exports"": ""symbols""; 					r_cons_printf (""fs %s\n"", fs); 				} 				lastfs = 's'; 			} 			if (r->bin->prefix || *name) { // we don't want unnamed symbol flags 				char *flagname = construct_symbol_flagname (""sym"", name, MAXFLAG_LEN_DEFAULT); 				if (!flagname) { 					goto next; 				} 				r_cons_printf (""\""f %s%s%s %u 0x%08"" PFMT64x ""\""\n"", 					r->bin->prefix ? r->bin->prefix : """", r->bin->prefix ? ""."" : """", 					flagname, symbol->size, addr); 				free (flagname); 			} 			binfile = r_bin_cur (r->bin); 			plugin = r_bin_file_cur_plugin (binfile); 			if (plugin && plugin->name) { 				if (r_str_startswith (plugin->name, ""pe"")) { 					char *module = strdup (r_symbol_name); 					char *p = strstr (module, "".dll_""); 					if (p && strstr (module, ""imp."")) { 						char *symname = __filterShell (p + 5); 						char *m = __filterShell (module); 						*p = 0; 						if (r->bin->prefix) { 							r_cons_printf (""\""k bin/pe/%s/%d=%s.%s\""\n"", 								module, symbol->ordinal, r->bin->prefix, symname); 						} else { 							r_cons_printf (""\""k bin/pe/%s/%d=%s\""\n"", 								module, symbol->ordinal, symname); 						} 						free (symname); 						free (m); 					} 					free (module); 				} 			} 		} else { 			const char *bind = symbol->bind? symbol->bind: ""NONE""; 			const char *type = symbol->type? symbol->type: ""NONE""; 			const char *name = r_str_get (sn.demname? sn.demname: r_symbol_name); 			// const char *fwd = r_str_get (symbol->forwarder); 			r_cons_printf (""%03u"", symbol->ordinal); 			if (symbol->paddr == UT64_MAX) { 				r_cons_printf ("" ----------""); 			} else { 				r_cons_printf ("" 0x%08""PFMT64x, symbol->paddr); 			} 			r_cons_printf ("" 0x%08""PFMT64x"" %6s %6s %4d%s%s\n"", 			               addr, bind, type, symbol->size, *name? "" "": """", name); 		} next: 		snFini (&sn); 		i++; 		free (r_symbol_name); 		if (exponly && firstexp) { 			firstexp = false; 		} 		if (printHere) { 			break; 		} 	} 	if (count == 0 && IS_MODE_JSON (mode)) { 		r_cons_printf (""{}""); 	}   	//handle thumb and arm for entry point since they are not present in symbols 	if (is_arm) { 		r_list_foreach (entries, iter, entry) { 			if (IS_MODE_SET (mode)) { 				handle_arm_entry (r, entry, info, va); 			} 		} 	} 	if (IS_MODE_JSON (mode) && !printHere) { 		r_cons_printf (""]""); 	}  	r_spaces_pop (&r->anal->meta_spaces); 	return true; }"
"blosc_c_blosc2_cwe-787.c","CWE-787","static int blosc_c(struct thread_context* thread_context, int32_t bsize,                    int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,                    const uint8_t* src, const int32_t offset, uint8_t* dest,                    uint8_t* tmp, uint8_t* tmp2) {   blosc2_context* context = thread_context->parent_context;   int dont_split = (context->header_flags & 0x10) >> 4;   int dict_training = context->use_dict && context->dict_cdict == NULL;   int32_t j, neblock, nstreams;   int32_t cbytes;                   /* number of compressed bytes in split */   int32_t ctbytes = 0;              /* number of compressed bytes in block */   int64_t maxout;   int32_t typesize = context->typesize;   const char* compname;   int accel;   const uint8_t* _src;   uint8_t *_tmp = tmp, *_tmp2 = tmp2;   uint8_t *_tmp3 = thread_context->tmp4;   int last_filter_index = last_filter(context->filters, 'c');   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;    if (last_filter_index >= 0 || context->prefilter != NULL) {     /* Apply the filter pipeline just for the prefilter */     if (memcpyed && context->prefilter != NULL) {       // We only need the prefilter output       _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);        if (_src == NULL) {         return -9;  // signals a problem with the filter pipeline       }       return bsize;     }     /* Apply regular filter pipeline */     _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);      if (_src == NULL) {       return -9;  // signals a problem with the filter pipeline     }   } else {     _src = src + offset;   }    assert(context->clevel > 0);    /* Calculate acceleration for different compressors */   accel = get_accel(context);    /* The number of compressed data streams for this block */   if (!dont_split && !leftoverblock && !dict_training) {     nstreams = (int32_t)typesize;   }   else {     nstreams = 1;   }   neblock = bsize / nstreams;   for (j = 0; j < nstreams; j++) {     if (!dict_training) {       dest += sizeof(int32_t);       ntbytes += sizeof(int32_t);       ctbytes += sizeof(int32_t);     }      // See if we have a run here     const uint8_t* ip = (uint8_t*)_src + j * neblock;     const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;     if (get_run(ip, ipbound)) {       // A run.  Encode the repeated byte as a negative length in the length of the split.       int32_t value = _src[j * neblock];       _sw32(dest - 4, -value);       continue;     }      maxout = neblock;   #if defined(HAVE_SNAPPY)     if (context->compcode == BLOSC_SNAPPY) {       maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);     }   #endif /*  HAVE_SNAPPY */     if (ntbytes + maxout > maxbytes) {       /* avoid buffer * overrun */       maxout = (int64_t)maxbytes - (int64_t)ntbytes;       if (maxout <= 0) {         return 0;                  /* non-compressible block */       }     }     if (dict_training) {       // We are in the build dict state, so don't compress       // TODO: copy only a percentage for sampling       memcpy(dest, _src + j * neblock, (unsigned int)neblock);       cbytes = (int32_t)neblock;     }     else if (context->compcode == BLOSC_BLOSCLZ) {       cbytes = blosclz_compress(context->clevel, _src + j * neblock,                                 (int)neblock, dest, (int)maxout);     }   #if defined(HAVE_LZ4)     else if (context->compcode == BLOSC_LZ4) {       void *hash_table = NULL;     #ifdef HAVE_IPP       hash_table = (void*)thread_context->lz4_hash_table;     #endif       cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                  (char*)dest, (size_t)maxout, accel, hash_table);     }     else if (context->compcode == BLOSC_LZ4HC) {       cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                    (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_LZ4 */   #if defined(HAVE_LIZARD)     else if (context->compcode == BLOSC_LIZARD) {       cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                     (char*)dest, (size_t)maxout, accel);     }   #endif /* HAVE_LIZARD */   #if defined(HAVE_SNAPPY)     else if (context->compcode == BLOSC_SNAPPY) {       cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                     (char*)dest, (size_t)maxout);     }   #endif /* HAVE_SNAPPY */   #if defined(HAVE_ZLIB)     else if (context->compcode == BLOSC_ZLIB) {       cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                   (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_ZLIB */   #if defined(HAVE_ZSTD)     else if (context->compcode == BLOSC_ZSTD) {       cbytes = zstd_wrap_compress(thread_context,                                   (char*)_src + j * neblock, (size_t)neblock,                                   (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_ZSTD */      else {       blosc_compcode_to_compname(context->compcode, &compname);       fprintf(stderr, ""Blosc has not been compiled with '%s' "", compname);       fprintf(stderr, ""compression support.  Please use one having it."");       return -5;    /* signals no compression support */     }      if (cbytes > maxout) {       /* Buffer overrun caused by compression (should never happen) */       return -1;     }     if (cbytes < 0) {       /* cbytes should never be negative */       return -2;     }     if (!dict_training) {       if (cbytes == 0 || cbytes == neblock) {         /* The compressor has been unable to compress data at all. */         /* Before doing the copy, check that we are not running into a            buffer overflow. */         if ((ntbytes + neblock) > maxbytes) {           return 0;    /* Non-compressible data */         }         memcpy(dest, _src + j * neblock, (unsigned int)neblock);         cbytes = neblock;       }       _sw32(dest - 4, cbytes);     }     dest += cbytes;     ntbytes += cbytes;     ctbytes += cbytes;   }  /* Closes j < nstreams */    //printf(""c%d"", ctbytes);   return ctbytes; }"
"blosc_c_blosc2_not_vulnerable.c","not_vulnerable","static int blosc_c(struct thread_context* thread_context, int32_t bsize,                    int32_t leftoverblock, int32_t ntbytes, int32_t destsize,                    const uint8_t* src, const int32_t offset, uint8_t* dest,                    uint8_t* tmp, uint8_t* tmp2) {   blosc2_context* context = thread_context->parent_context;   int dont_split = (context->header_flags & 0x10) >> 4;   int dict_training = context->use_dict && context->dict_cdict == NULL;   int32_t j, neblock, nstreams;   int32_t cbytes;                   /* number of compressed bytes in split */   int32_t ctbytes = 0;              /* number of compressed bytes in block */   int64_t maxout;   int32_t typesize = context->typesize;   const char* compname;   int accel;   const uint8_t* _src;   uint8_t *_tmp = tmp, *_tmp2 = tmp2;   uint8_t *_tmp3 = thread_context->tmp4;   int last_filter_index = last_filter(context->filters, 'c');   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;    if (last_filter_index >= 0 || context->prefilter != NULL) {     /* Apply the filter pipeline just for the prefilter */     if (memcpyed && context->prefilter != NULL) {       // We only need the prefilter output       _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);        if (_src == NULL) {         return -9;  // signals a problem with the filter pipeline       }       return bsize;     }     /* Apply regular filter pipeline */     _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);      if (_src == NULL) {       return -9;  // signals a problem with the filter pipeline     }   } else {     _src = src + offset;   }    assert(context->clevel > 0);    /* Calculate acceleration for different compressors */   accel = get_accel(context);    /* The number of compressed data streams for this block */   if (!dont_split && !leftoverblock && !dict_training) {     nstreams = (int32_t)typesize;   }   else {     nstreams = 1;   }   neblock = bsize / nstreams;   for (j = 0; j < nstreams; j++) {     if (!dict_training) {       dest += sizeof(int32_t);       ntbytes += sizeof(int32_t);       ctbytes += sizeof(int32_t);     }      // See if we have a run here     const uint8_t* ip = (uint8_t*)_src + j * neblock;     const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;     if (get_run(ip, ipbound)) {       // A run.  Encode the repeated byte as a negative length in the length of the split.       int32_t value = _src[j * neblock];       if (ntbytes > destsize) {         /* Not enough space to write out compressed block size */         return -1;       }       _sw32(dest - 4, -value);       continue;     }      maxout = neblock;   #if defined(HAVE_SNAPPY)     if (context->compcode == BLOSC_SNAPPY) {       maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);     }   #endif /*  HAVE_SNAPPY */     if (ntbytes + maxout > destsize) {       /* avoid buffer * overrun */       maxout = (int64_t)destsize - (int64_t)ntbytes;       if (maxout <= 0) {         return 0;                  /* non-compressible block */       }     }     if (dict_training) {       // We are in the build dict state, so don't compress       // TODO: copy only a percentage for sampling       memcpy(dest, _src + j * neblock, (unsigned int)neblock);       cbytes = (int32_t)neblock;     }     else if (context->compcode == BLOSC_BLOSCLZ) {       cbytes = blosclz_compress(context->clevel, _src + j * neblock,                                 (int)neblock, dest, (int)maxout);     }   #if defined(HAVE_LZ4)     else if (context->compcode == BLOSC_LZ4) {       void *hash_table = NULL;     #ifdef HAVE_IPP       hash_table = (void*)thread_context->lz4_hash_table;     #endif       cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                  (char*)dest, (size_t)maxout, accel, hash_table);     }     else if (context->compcode == BLOSC_LZ4HC) {       cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                    (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_LZ4 */   #if defined(HAVE_LIZARD)     else if (context->compcode == BLOSC_LIZARD) {       cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                     (char*)dest, (size_t)maxout, accel);     }   #endif /* HAVE_LIZARD */   #if defined(HAVE_SNAPPY)     else if (context->compcode == BLOSC_SNAPPY) {       cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                     (char*)dest, (size_t)maxout);     }   #endif /* HAVE_SNAPPY */   #if defined(HAVE_ZLIB)     else if (context->compcode == BLOSC_ZLIB) {       cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,                                   (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_ZLIB */   #if defined(HAVE_ZSTD)     else if (context->compcode == BLOSC_ZSTD) {       cbytes = zstd_wrap_compress(thread_context,                                   (char*)_src + j * neblock, (size_t)neblock,                                   (char*)dest, (size_t)maxout, context->clevel);     }   #endif /* HAVE_ZSTD */      else {       blosc_compcode_to_compname(context->compcode, &compname);       fprintf(stderr, ""Blosc has not been compiled with '%s' "", compname);       fprintf(stderr, ""compression support.  Please use one having it."");       return -5;    /* signals no compression support */     }      if (cbytes > maxout) {       /* Buffer overrun caused by compression (should never happen) */       return -1;     }     if (cbytes < 0) {       /* cbytes should never be negative */       return -2;     }     if (!dict_training) {       if (cbytes == 0 || cbytes == neblock) {         /* The compressor has been unable to compress data at all. */         /* Before doing the copy, check that we are not running into a            buffer overflow. */         if ((ntbytes + neblock) > destsize) {           return 0;    /* Non-compressible data */         }         memcpy(dest, _src + j * neblock, (unsigned int)neblock);         cbytes = neblock;       }       _sw32(dest - 4, cbytes);     }     dest += cbytes;     ntbytes += cbytes;     ctbytes += cbytes;   }  /* Closes j < nstreams */    //printf(""c%d"", ctbytes);   return ctbytes; }"
"compose_path_common_cwe-022.c","CWE-022","char *compose_path(ctrl_t *ctrl, char *path) { 	struct stat st; 	static char rpath[PATH_MAX]; 	char *name, *ptr; 	char dir[PATH_MAX] = { 0 };  	strlcpy(dir, ctrl->cwd, sizeof(dir)); 	DBG(""Compose path from cwd: %s, arg: %s"", ctrl->cwd, path ?: """"); 	if (!path || !strlen(path)) 		goto check;  	if (path) { 		if (path[0] != '/') { 			if (dir[strlen(dir) - 1] != '/') 				strlcat(dir, ""/"", sizeof(dir)); 		} 		strlcat(dir, path, sizeof(dir)); 	}  check: 	while ((ptr = strstr(dir, ""//""))) 		memmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);  	if (!chrooted) { 		size_t len = strlen(home);  		DBG(""Server path from CWD: %s"", dir); 		if (len > 0 && home[len - 1] == '/') 			len--; 		memmove(dir + len, dir, strlen(dir) + 1); 		memcpy(dir, home, len); 		DBG(""Resulting non-chroot path: %s"", dir); 	}  	/* 	 * Handle directories slightly differently, since dirname() on a 	 * directory returns the parent directory.  So, just squash .. 	 */ 	if (!stat(dir, &st) && S_ISDIR(st.st_mode)) { 		if (!realpath(dir, rpath)) 			return NULL; 	} else { 		/* 		 * Check realpath() of directory containing the file, a 		 * STOR may want to save a new file.  Then append the 		 * file and return it. 		 */ 		name = basename(path); 		ptr = dirname(dir);  		memset(rpath, 0, sizeof(rpath)); 		if (!realpath(ptr, rpath)) { 			INFO(""Failed realpath(%s): %m"", ptr); 			return NULL; 		}  		if (rpath[1] != 0) 			strlcat(rpath, ""/"", sizeof(rpath)); 		strlcat(rpath, name, sizeof(rpath)); 	}  	if (!chrooted && strncmp(dir, home, strlen(home))) { 		DBG(""Failed non-chroot dir:%s vs home:%s"", dir, home); 		return NULL; 	}  	return rpath; }"
"compose_path_common_not_vulnerable.c","not_vulnerable","char *compose_path(ctrl_t *ctrl, char *path) { 	struct stat st; 	static char rpath[PATH_MAX]; 	char *name, *ptr; 	char dir[PATH_MAX] = { 0 };  	strlcpy(dir, ctrl->cwd, sizeof(dir)); 	DBG(""Compose path from cwd: %s, arg: %s"", ctrl->cwd, path ?: """"); 	if (!path || !strlen(path)) 		goto check;  	if (path) { 		if (path[0] != '/') { 			if (dir[strlen(dir) - 1] != '/') 				strlcat(dir, ""/"", sizeof(dir)); 		} 		strlcat(dir, path, sizeof(dir)); 	}  check: 	while ((ptr = strstr(dir, ""//""))) 		memmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);  	if (!chrooted) { 		size_t len = strlen(home);  		DBG(""Server path from CWD: %s"", dir); 		if (len > 0 && home[len - 1] == '/') 			len--; 		memmove(dir + len, dir, strlen(dir) + 1); 		memcpy(dir, home, len); 		DBG(""Resulting non-chroot path: %s"", dir); 	}  	/* 	 * Handle directories slightly differently, since dirname() on a 	 * directory returns the parent directory.  So, just squash .. 	 */ 	if (!stat(dir, &st) && S_ISDIR(st.st_mode)) { 		if (!realpath(dir, rpath)) 			return NULL; 	} else { 		/* 		 * Check realpath() of directory containing the file, a 		 * STOR may want to save a new file.  Then append the 		 * file and return it. 		 */ 		name = basename(path); 		ptr = dirname(dir);  		memset(rpath, 0, sizeof(rpath)); 		if (!realpath(ptr, rpath)) { 			INFO(""Failed realpath(%s): %m"", ptr); 			return NULL; 		}  		if (rpath[1] != 0) 			strlcat(rpath, ""/"", sizeof(rpath)); 		strlcat(rpath, name, sizeof(rpath)); 	}  	if (!chrooted && strncmp(rpath, home, strlen(home))) { 		DBG(""Failed non-chroot dir:%s vs home:%s"", dir, home); 		return NULL; 	}  	return rpath; }"
"concat_hash_string_ssh_cwe-125.c","CWE-125","static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet, 				   char *buf, u_int8_t client_hash) {   u_int16_t offset = 22, buf_out_len = 0;   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);   offset += 4;    /* -1 for ';' */   if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))     goto invalid_payload;    /* ssh.kex_algorithms [C/S] */   strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);   buf[buf_out_len++] = ';';   offset += len;    /* ssh.server_host_key_algorithms [None] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);   offset += 4 + len;    /* ssh.encryption_algorithms_client_to_server [C] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    /* ssh.encryption_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    /* ssh.mac_algorithms_client_to_server [C] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    /* ssh.mac_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    /* ssh.compression_algorithms_client_to_server [C] */   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     offset += len;   } else     offset += 4 + len;    /* ssh.compression_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     offset += len;   } else     offset += 4 + len;    /* ssh.languages_client_to_server [None] */    /* ssh.languages_server_to_client [None] */  #ifdef SSH_DEBUG   printf(""[SSH] %s\n"", buf); #endif    return(buf_out_len);  invalid_payload:  #ifdef SSH_DEBUG   printf(""[SSH] Invalid packet payload\n""); #endif    return(0); }"
"concat_hash_string_ssh_not_vulnerable.c","not_vulnerable","static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet, 				   char *buf, u_int8_t client_hash) {   u_int16_t offset = 22, buf_out_len = 0;   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);   offset += 4;    /* -1 for ';' */   if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))     goto invalid_payload;    /* ssh.kex_algorithms [C/S] */   strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);   buf[buf_out_len++] = ';';   offset += len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.server_host_key_algorithms [None] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);   offset += 4 + len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.encryption_algorithms_client_to_server [C] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.encryption_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.mac_algorithms_client_to_server [C] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.mac_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     buf[buf_out_len++] = ';';     offset += len;   } else     offset += 4 + len;    /* ssh.compression_algorithms_client_to_server [C] */   if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     offset += len;   } else     offset += 4 + len;    if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)     goto invalid_payload;   /* ssh.compression_algorithms_server_to_client [S] */   len = ntohl(*(u_int32_t*)&packet->payload[offset]);    if(!client_hash) {     offset += 4;      if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))       goto invalid_payload;      strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);     buf_out_len += len;     offset += len;   } else     offset += 4 + len;    /* ssh.languages_client_to_server [None] */    /* ssh.languages_server_to_client [None] */  #ifdef SSH_DEBUG   printf(""[SSH] %s\n"", buf); #endif    return(buf_out_len);  invalid_payload:  #ifdef SSH_DEBUG   printf(""[SSH] Invalid packet payload\n""); #endif    return(0); }"
"create_dump_dir_from_problem_data_create_dump_dir_cwe-022.c","CWE-022","struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name) {     INITIALIZE_LIBREPORT();      char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);      if (!type)     {         error_msg(_(""Missing required item: '%s'""), FILENAME_ANALYZER);         return NULL;     }      uid_t uid = (uid_t)-1L;     char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);      if (uid_str)     {         char *endptr;         errno = 0;         long val = strtol(uid_str, &endptr, 10);          if (errno != 0 || endptr == uid_str || *endptr != '\0' || INT_MAX < val)         {             error_msg(_(""uid value is not valid: '%s'""), uid_str);             return NULL;         }          uid = (uid_t)val;     }      struct timeval tv;     if (gettimeofday(&tv, NULL) < 0)     {         perror_msg(""gettimeofday()"");         return NULL;     }      char *problem_id = xasprintf(""%s-%s.%ld-%lu""NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());      log_info(""Saving to %s/%s with uid %d"", base_dir_name, problem_id, uid);      struct dump_dir *dd;     if (base_dir_name)         dd = try_dd_create(base_dir_name, problem_id, uid);     else     {         /* Try /var/run/abrt */         dd = try_dd_create(LOCALSTATEDIR""/run/abrt"", problem_id, uid);         /* Try $HOME/tmp */         if (!dd)         {             char *home = getenv(""HOME"");             if (home && home[0])             {                 home = concat_path_file(home, ""tmp"");                 /*mkdir(home, 0777); - do we want this? */                 dd = try_dd_create(home, problem_id, uid);                 free(home);             }         } //TODO: try user's home dir obtained by getpwuid(getuid())?         /* Try system temporary directory */         if (!dd)             dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);     }      if (!dd) /* try_dd_create() already emitted the error message */         goto ret;      GHashTableIter iter;     char *name;     struct problem_item *value;     g_hash_table_iter_init(&iter, problem_data);     while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))     {         if (value->flags & CD_FLAG_BIN)         {             char *dest = concat_path_file(dd->dd_dirname, name);             log_info(""copying '%s' to '%s'"", value->content, dest);             off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);             if (copied < 0)                 error_msg(""Can't copy %s to %s"", value->content, dest);             else                 log_info(""copied %li bytes"", (unsigned long)copied);             free(dest);              continue;         }          /* only files should contain '/' and those are handled earlier */         if (name[0] == '.' || strchr(name, '/'))         {             error_msg(""Problem data field name contains disallowed chars: '%s'"", name);             continue;         }          dd_save_text(dd, name, value->content);     }      /* need to create basic files AFTER we save the pd to dump_dir      * otherwise we can't skip already created files like in case when      * reporting from anaconda where we can't read /etc/{system,redhat}-release      * and os_release is taken from anaconda      */     dd_create_basic_files(dd, uid, NULL);      problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\0';     char* new_path = concat_path_file(base_dir_name, problem_id);     log_info(""Renaming from '%s' to '%s'"", dd->dd_dirname, new_path);     dd_rename(dd, new_path);   ret:     free(problem_id);     return dd; }"
"create_dump_dir_from_problem_data_create_dump_dir_not_vulnerable.c","not_vulnerable","struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name) {     INITIALIZE_LIBREPORT();      char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);      if (!type)     {         error_msg(_(""Missing required item: '%s'""), FILENAME_ANALYZER);         return NULL;     }      if (!str_is_correct_filename(type))     {         error_msg(_(""'%s' is not correct file name""), FILENAME_ANALYZER);         return NULL;     }      uid_t uid = (uid_t)-1L;     char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);      if (uid_str)     {         char *endptr;         errno = 0;         long val = strtol(uid_str, &endptr, 10);          if (errno != 0 || endptr == uid_str || *endptr != '\0' || INT_MAX < val)         {             error_msg(_(""uid value is not valid: '%s'""), uid_str);             return NULL;         }          uid = (uid_t)val;     }      struct timeval tv;     if (gettimeofday(&tv, NULL) < 0)     {         perror_msg(""gettimeofday()"");         return NULL;     }      char *problem_id = xasprintf(""%s-%s.%ld-%lu""NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());      log_info(""Saving to %s/%s with uid %d"", base_dir_name, problem_id, uid);      struct dump_dir *dd;     if (base_dir_name)         dd = try_dd_create(base_dir_name, problem_id, uid);     else     {         /* Try /var/run/abrt */         dd = try_dd_create(LOCALSTATEDIR""/run/abrt"", problem_id, uid);         /* Try $HOME/tmp */         if (!dd)         {             char *home = getenv(""HOME"");             if (home && home[0])             {                 home = concat_path_file(home, ""tmp"");                 /*mkdir(home, 0777); - do we want this? */                 dd = try_dd_create(home, problem_id, uid);                 free(home);             }         } //TODO: try user's home dir obtained by getpwuid(getuid())?         /* Try system temporary directory */         if (!dd)             dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);     }      if (!dd) /* try_dd_create() already emitted the error message */         goto ret;      GHashTableIter iter;     char *name;     struct problem_item *value;     g_hash_table_iter_init(&iter, problem_data);     while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))     {         if (!str_is_correct_filename(name))         {             error_msg(""Problem data field name contains disallowed chars: '%s'"", name);             continue;         }          if (value->flags & CD_FLAG_BIN)         {             char *dest = concat_path_file(dd->dd_dirname, name);             log_info(""copying '%s' to '%s'"", value->content, dest);             off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);             if (copied < 0)                 error_msg(""Can't copy %s to %s"", value->content, dest);             else                 log_info(""copied %li bytes"", (unsigned long)copied);             free(dest);              continue;         }          dd_save_text(dd, name, value->content);     }      /* need to create basic files AFTER we save the pd to dump_dir      * otherwise we can't skip already created files like in case when      * reporting from anaconda where we can't read /etc/{system,redhat}-release      * and os_release is taken from anaconda      */     dd_create_basic_files(dd, uid, NULL);      problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\0';     char* new_path = concat_path_file(base_dir_name, problem_id);     log_info(""Renaming from '%s' to '%s'"", dd->dd_dirname, new_path);     dd_rename(dd, new_path);   ret:     free(problem_id);     return dd; }"
"cx24116_send_diseqc_msg_cx24116_cwe-125.c","CWE-125","static int cx24116_send_diseqc_msg(struct dvb_frontend *fe, 	struct dvb_diseqc_master_cmd *d) { 	struct cx24116_state *state = fe->demodulator_priv; 	int i, ret;  	/* Dump DiSEqC message */ 	if (debug) { 		printk(KERN_INFO ""cx24116: %s("", __func__); 		for (i = 0 ; i < d->msg_len ;) { 			printk(KERN_INFO ""0x%02x"", d->msg[i]); 			if (++i < d->msg_len) 				printk(KERN_INFO "", ""); 		} 		printk("") toneburst=%d\n"", toneburst); 	}  	/* Validate length */ 	if (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS)) 		return -EINVAL;  	/* DiSEqC message */ 	for (i = 0; i < d->msg_len; i++) 		state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];  	/* DiSEqC message length */ 	state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;  	/* Command length */ 	state->dsec_cmd.len = CX24116_DISEQC_MSGOFS + 		state->dsec_cmd.args[CX24116_DISEQC_MSGLEN];  	/* DiSEqC toneburst */ 	if (toneburst == CX24116_DISEQC_MESGCACHE) 		/* Message is cached */ 		return 0;  	else if (toneburst == CX24116_DISEQC_TONEOFF) 		/* Message is sent without burst */ 		state->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;  	else if (toneburst == CX24116_DISEQC_TONECACHE) { 		/* 		 * Message is sent with derived else cached burst 		 * 		 * WRITE PORT GROUP COMMAND 38 		 * 		 * 0/A/A: E0 10 38 F0..F3 		 * 1/B/B: E0 10 38 F4..F7 		 * 2/C/A: E0 10 38 F8..FB 		 * 3/D/B: E0 10 38 FC..FF 		 * 		 * databyte[3]= 8421:8421 		 *              ABCD:WXYZ 		 *              CLR :SET 		 * 		 *              WX= PORT SELECT 0..3    (X=TONEBURST) 		 *              Y = VOLTAGE             (0=13V, 1=18V) 		 *              Z = BAND                (0=LOW, 1=HIGH(22K)) 		 */ 		if (d->msg_len >= 4 && d->msg[2] == 0x38) 			state->dsec_cmd.args[CX24116_DISEQC_BURST] = 				((d->msg[3] & 4) >> 2); 		if (debug) 			dprintk(""%s burst=%d\n"", __func__, 				state->dsec_cmd.args[CX24116_DISEQC_BURST]); 	}  	/* Wait for LNB ready */ 	ret = cx24116_wait_for_lnb(fe); 	if (ret != 0) 		return ret;  	/* Wait for voltage/min repeat delay */ 	msleep(100);  	/* Command */ 	ret = cx24116_cmd_execute(fe, &state->dsec_cmd); 	if (ret != 0) 		return ret; 	/* 	 * Wait for send 	 * 	 * Eutelsat spec: 	 * >15ms delay          + (XXX determine if FW does this, see set_tone) 	 *  13.5ms per byte     + 	 * >15ms delay          + 	 *  12.5ms burst        + 	 * >15ms delay            (XXX determine if FW does this, see set_tone) 	 */ 	msleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 		((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));  	return 0; }"
"cx24116_send_diseqc_msg_cx24116_not_vulnerable.c","not_vulnerable","static int cx24116_send_diseqc_msg(struct dvb_frontend *fe, 	struct dvb_diseqc_master_cmd *d) { 	struct cx24116_state *state = fe->demodulator_priv; 	int i, ret;  	/* Validate length */ 	if (d->msg_len > sizeof(d->msg))                 return -EINVAL;  	/* Dump DiSEqC message */ 	if (debug) { 		printk(KERN_INFO ""cx24116: %s("", __func__); 		for (i = 0 ; i < d->msg_len ;) { 			printk(KERN_INFO ""0x%02x"", d->msg[i]); 			if (++i < d->msg_len) 				printk(KERN_INFO "", ""); 		} 		printk("") toneburst=%d\n"", toneburst); 	}  	/* DiSEqC message */ 	for (i = 0; i < d->msg_len; i++) 		state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];  	/* DiSEqC message length */ 	state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;  	/* Command length */ 	state->dsec_cmd.len = CX24116_DISEQC_MSGOFS + 		state->dsec_cmd.args[CX24116_DISEQC_MSGLEN];  	/* DiSEqC toneburst */ 	if (toneburst == CX24116_DISEQC_MESGCACHE) 		/* Message is cached */ 		return 0;  	else if (toneburst == CX24116_DISEQC_TONEOFF) 		/* Message is sent without burst */ 		state->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;  	else if (toneburst == CX24116_DISEQC_TONECACHE) { 		/* 		 * Message is sent with derived else cached burst 		 * 		 * WRITE PORT GROUP COMMAND 38 		 * 		 * 0/A/A: E0 10 38 F0..F3 		 * 1/B/B: E0 10 38 F4..F7 		 * 2/C/A: E0 10 38 F8..FB 		 * 3/D/B: E0 10 38 FC..FF 		 * 		 * databyte[3]= 8421:8421 		 *              ABCD:WXYZ 		 *              CLR :SET 		 * 		 *              WX= PORT SELECT 0..3    (X=TONEBURST) 		 *              Y = VOLTAGE             (0=13V, 1=18V) 		 *              Z = BAND                (0=LOW, 1=HIGH(22K)) 		 */ 		if (d->msg_len >= 4 && d->msg[2] == 0x38) 			state->dsec_cmd.args[CX24116_DISEQC_BURST] = 				((d->msg[3] & 4) >> 2); 		if (debug) 			dprintk(""%s burst=%d\n"", __func__, 				state->dsec_cmd.args[CX24116_DISEQC_BURST]); 	}  	/* Wait for LNB ready */ 	ret = cx24116_wait_for_lnb(fe); 	if (ret != 0) 		return ret;  	/* Wait for voltage/min repeat delay */ 	msleep(100);  	/* Command */ 	ret = cx24116_cmd_execute(fe, &state->dsec_cmd); 	if (ret != 0) 		return ret; 	/* 	 * Wait for send 	 * 	 * Eutelsat spec: 	 * >15ms delay          + (XXX determine if FW does this, see set_tone) 	 *  13.5ms per byte     + 	 * >15ms delay          + 	 *  12.5ms burst        + 	 * >15ms delay            (XXX determine if FW does this, see set_tone) 	 */ 	msleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 		((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));  	return 0; }"
"decode_zbuf_pngdec_cwe-787.c","CWE-787","static int decode_zbuf(AVBPrint *bp, const uint8_t *data,                        const uint8_t *data_end) {     z_stream zstream;     unsigned char *buf;     unsigned buf_size;     int ret;      zstream.zalloc = ff_png_zalloc;     zstream.zfree  = ff_png_zfree;     zstream.opaque = NULL;     if (inflateInit(&zstream) != Z_OK)         return AVERROR_EXTERNAL;     zstream.next_in  = (unsigned char *)data;     zstream.avail_in = data_end - data;     av_bprint_init(bp, 0, -1);      while (zstream.avail_in > 0) {         av_bprint_get_buffer(bp, 1, &buf, &buf_size);         if (!buf_size) {             ret = AVERROR(ENOMEM);             goto fail;         }         zstream.next_out  = buf;         zstream.avail_out = buf_size;         ret = inflate(&zstream, Z_PARTIAL_FLUSH);         if (ret != Z_OK && ret != Z_STREAM_END) {             ret = AVERROR_EXTERNAL;             goto fail;         }         bp->len += zstream.next_out - buf;         if (ret == Z_STREAM_END)             break;     }     inflateEnd(&zstream);     bp->str[bp->len] = 0;     return 0;  fail:     inflateEnd(&zstream);     av_bprint_finalize(bp, NULL);     return ret; }"
"decode_zbuf_pngdec_not_vulnerable.c","not_vulnerable","static int decode_zbuf(AVBPrint *bp, const uint8_t *data,                        const uint8_t *data_end) {     z_stream zstream;     unsigned char *buf;     unsigned buf_size;     int ret;      zstream.zalloc = ff_png_zalloc;     zstream.zfree  = ff_png_zfree;     zstream.opaque = NULL;     if (inflateInit(&zstream) != Z_OK)         return AVERROR_EXTERNAL;     zstream.next_in  = (unsigned char *)data;     zstream.avail_in = data_end - data;     av_bprint_init(bp, 0, -1);      while (zstream.avail_in > 0) {         av_bprint_get_buffer(bp, 2, &buf, &buf_size);         if (buf_size < 2) {             ret = AVERROR(ENOMEM);             goto fail;         }         zstream.next_out  = buf;         zstream.avail_out = buf_size - 1;         ret = inflate(&zstream, Z_PARTIAL_FLUSH);         if (ret != Z_OK && ret != Z_STREAM_END) {             ret = AVERROR_EXTERNAL;             goto fail;         }         bp->len += zstream.next_out - buf;         if (ret == Z_STREAM_END)             break;     }     inflateEnd(&zstream);     bp->str[bp->len] = 0;     return 0;  fail:     inflateEnd(&zstream);     av_bprint_finalize(bp, NULL);     return ret; }"
"dnxhd_find_frame_end_dnxhd_parser_cwe-476.c","CWE-476","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf, int buf_size) {     ParseContext *pc = &dctx->pc;     uint64_t state = pc->state64;     int pic_found = pc->frame_start_found;     int i = 0;      if (!pic_found) {         for (i = 0; i < buf_size; i++) {             state = (state << 8) | buf[i];             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {                 i++;                 pic_found = 1;                 dctx->cur_byte = 0;                 dctx->remaining = 0;                 break;             }         }     }      if (pic_found && !dctx->remaining) {         if (!buf_size) /* EOF considered as end of frame */             return 0;         for (; i < buf_size; i++) {             dctx->cur_byte++;             state = (state << 8) | buf[i];              if (dctx->cur_byte == 24) {                 dctx->h = (state >> 32) & 0xFFFF;             } else if (dctx->cur_byte == 26) {                 dctx->w = (state >> 32) & 0xFFFF;             } else if (dctx->cur_byte == 42) {                 int cid = (state >> 32) & 0xFFFFFFFF;                  if (cid <= 0)                     continue;                  dctx->remaining = avpriv_dnxhd_get_frame_size(cid);                 if (dctx->remaining <= 0) {                     dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);                     if (dctx->remaining <= 0)                         return dctx->remaining;                 }                 if (buf_size - i + 47 >= dctx->remaining) {                     int remaining = dctx->remaining;                      pc->frame_start_found = 0;                     pc->state64 = -1;                     dctx->cur_byte = 0;                     dctx->remaining = 0;                     return remaining;                 } else {                     dctx->remaining -= buf_size;                 }             }         }     } else if (pic_found) {         if (dctx->remaining > buf_size) {             dctx->remaining -= buf_size;         } else {             int remaining = dctx->remaining;              pc->frame_start_found = 0;             pc->state64 = -1;             dctx->cur_byte = 0;             dctx->remaining = 0;             return remaining;         }     }     pc->frame_start_found = pic_found;     pc->state64 = state;     return END_NOT_FOUND; }"
"dnxhd_find_frame_end_dnxhd_parser_not_vulnerable.c","not_vulnerable","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf, int buf_size) {     ParseContext *pc = &dctx->pc;     uint64_t state = pc->state64;     int pic_found = pc->frame_start_found;     int i = 0;      if (!pic_found) {         for (i = 0; i < buf_size; i++) {             state = (state << 8) | buf[i];             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {                 i++;                 pic_found = 1;                 dctx->cur_byte = 0;                 dctx->remaining = 0;                 break;             }         }     }      if (pic_found && !dctx->remaining) {         if (!buf_size) /* EOF considered as end of frame */             return 0;         for (; i < buf_size; i++) {             dctx->cur_byte++;             state = (state << 8) | buf[i];              if (dctx->cur_byte == 24) {                 dctx->h = (state >> 32) & 0xFFFF;             } else if (dctx->cur_byte == 26) {                 dctx->w = (state >> 32) & 0xFFFF;             } else if (dctx->cur_byte == 42) {                 int cid = (state >> 32) & 0xFFFFFFFF;                 int remaining;                  if (cid <= 0)                     continue;                  remaining = avpriv_dnxhd_get_frame_size(cid);                 if (remaining <= 0) {                     remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);                     if (remaining <= 0)                         continue;                 }                 dctx->remaining = remaining;                 if (buf_size - i + 47 >= dctx->remaining) {                     int remaining = dctx->remaining;                      pc->frame_start_found = 0;                     pc->state64 = -1;                     dctx->cur_byte = 0;                     dctx->remaining = 0;                     return remaining;                 } else {                     dctx->remaining -= buf_size;                 }             }         }     } else if (pic_found) {         if (dctx->remaining > buf_size) {             dctx->remaining -= buf_size;         } else {             int remaining = dctx->remaining;              pc->frame_start_found = 0;             pc->state64 = -1;             dctx->cur_byte = 0;             dctx->remaining = 0;             return remaining;         }     }     pc->frame_start_found = pic_found;     pc->state64 = state;     return END_NOT_FOUND; }"
"formUpdateBuffer_form_cwe-476.c","CWE-476","formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form) {     Buffer save;     char *p;     int spos, epos, rows, c_rows, pos, col = 0;     Line *l;      copyBuffer(&save, buf);     gotoLine(buf, a->start.line);     switch (form->type) {     case FORM_TEXTAREA:     case FORM_INPUT_TEXT:     case FORM_INPUT_FILE:     case FORM_INPUT_PASSWORD:     case FORM_INPUT_CHECKBOX:     case FORM_INPUT_RADIO: #ifdef MENU_SELECT     case FORM_SELECT: #endif				/* MENU_SELECT */ 	spos = a->start.pos; 	epos = a->end.pos; 	break;     default: 	spos = a->start.pos + 1; 	epos = a->end.pos - 1;     }     switch (form->type) {     case FORM_INPUT_CHECKBOX:     case FORM_INPUT_RADIO: 	if (buf->currentLine == NULL || 	    spos >= buf->currentLine->len || spos < 0) 	    break; 	if (form->checked) 	    buf->currentLine->lineBuf[spos] = '*'; 	else 	    buf->currentLine->lineBuf[spos] = ' '; 	break;     case FORM_INPUT_TEXT:     case FORM_INPUT_FILE:     case FORM_INPUT_PASSWORD:     case FORM_TEXTAREA: #ifdef MENU_SELECT     case FORM_SELECT: 	if (form->type == FORM_SELECT) { 	    p = form->label->ptr; 	    updateSelectOption(form, form->select_option); 	} 	else #endif				/* MENU_SELECT */ 	{ 	    if (!form->value) 		break; 	    p = form->value->ptr; 	} 	l = buf->currentLine; 	if (!l) 	    break; 	if (form->type == FORM_TEXTAREA) { 	    int n = a->y - buf->currentLine->linenumber; 	    if (n > 0) 		for (; l && n; l = l->prev, n--) ; 	    else if (n < 0) 		for (; l && n; l = l->prev, n++) ; 	    if (!l) 		break; 	} 	rows = form->rows ? form->rows : 1; 	col = COLPOS(l, a->start.pos); 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) { 	    if (rows > 1) { 		pos = columnPos(l, col); 		a = retrieveAnchor(buf->formitem, l->linenumber, pos); 		if (a == NULL) 		    break; 		spos = a->start.pos; 		epos = a->end.pos; 	    } 	    if (a->start.line != a->end.line || spos > epos || epos >= l->len || 		spos < 0 || epos < 0 || COLPOS(l, epos) < col) 		break; 	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col, 				   rows > 1, 				   form->type == FORM_INPUT_PASSWORD); 	    if (pos != epos) { 		shiftAnchorPosition(buf->href, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->name, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->img, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->formitem, buf->hmarklist, 				    a->start.line, spos, pos - epos); 	    } 	} 	break;     }     copyBuffer(buf, &save);     arrangeLine(buf); }"
"formUpdateBuffer_form_not_vulnerable.c","not_vulnerable","formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form) {     Buffer save;     char *p;     int spos, epos, rows, c_rows, pos, col = 0;     Line *l;      copyBuffer(&save, buf);     gotoLine(buf, a->start.line);     switch (form->type) {     case FORM_TEXTAREA:     case FORM_INPUT_TEXT:     case FORM_INPUT_FILE:     case FORM_INPUT_PASSWORD:     case FORM_INPUT_CHECKBOX:     case FORM_INPUT_RADIO: #ifdef MENU_SELECT     case FORM_SELECT: #endif				/* MENU_SELECT */ 	spos = a->start.pos; 	epos = a->end.pos; 	break;     default: 	spos = a->start.pos + 1; 	epos = a->end.pos - 1;     }     switch (form->type) {     case FORM_INPUT_CHECKBOX:     case FORM_INPUT_RADIO: 	if (buf->currentLine == NULL || 	    spos >= buf->currentLine->len || spos < 0) 	    break; 	if (form->checked) 	    buf->currentLine->lineBuf[spos] = '*'; 	else 	    buf->currentLine->lineBuf[spos] = ' '; 	break;     case FORM_INPUT_TEXT:     case FORM_INPUT_FILE:     case FORM_INPUT_PASSWORD:     case FORM_TEXTAREA: #ifdef MENU_SELECT     case FORM_SELECT: 	if (form->type == FORM_SELECT) { 	    p = form->label->ptr; 	    updateSelectOption(form, form->select_option); 	} 	else #endif				/* MENU_SELECT */ 	{ 	    if (!form->value) 		break; 	    p = form->value->ptr; 	} 	l = buf->currentLine; 	if (!l) 	    break; 	if (form->type == FORM_TEXTAREA) { 	    int n = a->y - buf->currentLine->linenumber; 	    if (n > 0) 		for (; l && n; l = l->prev, n--) ; 	    else if (n < 0) 		for (; l && n; l = l->prev, n++) ; 	    if (!l) 		break; 	} 	rows = form->rows ? form->rows : 1; 	col = COLPOS(l, a->start.pos); 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) { 	    if (l == NULL) 		break; 	    if (rows > 1) { 		pos = columnPos(l, col); 		a = retrieveAnchor(buf->formitem, l->linenumber, pos); 		if (a == NULL) 		    break; 		spos = a->start.pos; 		epos = a->end.pos; 	    } 	    if (a->start.line != a->end.line || spos > epos || epos >= l->len || 		spos < 0 || epos < 0 || COLPOS(l, epos) < col) 		break; 	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col, 				   rows > 1, 				   form->type == FORM_INPUT_PASSWORD); 	    if (pos != epos) { 		shiftAnchorPosition(buf->href, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->name, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->img, buf->hmarklist, 				    a->start.line, spos, pos - epos); 		shiftAnchorPosition(buf->formitem, buf->hmarklist, 				    a->start.line, spos, pos - epos); 	    } 	} 	break;     }     copyBuffer(buf, &save);     arrangeLine(buf); }"
"fpm_log_write_fpm_log_cwe-125.c","CWE-125","int fpm_log_write(char *log_format) /* {{{ */ { 	char *s, *b; 	char buffer[FPM_LOG_BUFFER+1]; 	int token, test; 	size_t len, len2; 	struct fpm_scoreboard_proc_s proc, *proc_p; 	struct fpm_scoreboard_s *scoreboard; 	char tmp[129]; 	char format[129]; 	time_t now_epoch; #ifdef HAVE_TIMES 	clock_t tms_total; #endif  	if (!log_format && (!fpm_log_format || fpm_log_fd == -1)) { 		return -1; 	}  	if (!log_format) { 		log_format = fpm_log_format; 		test = 0; 	} else { 		test = 1; 	}  	now_epoch = time(NULL);  	if (!test) { 		scoreboard = fpm_scoreboard_get(); 		if (!scoreboard) { 			zlog(ZLOG_WARNING, ""unable to get scoreboard while preparing the access log""); 			return -1; 		} 		proc_p = fpm_scoreboard_proc_acquire(NULL, -1, 0); 		if (!proc_p) { 			zlog(ZLOG_WARNING, ""[pool %s] Unable to acquire shm slot while preparing the access log"", scoreboard->pool); 			return -1; 		} 		proc = *proc_p; 		fpm_scoreboard_proc_release(proc_p); 	}  	token = 0;  	memset(buffer, '\0', sizeof(buffer)); 	b = buffer; 	len = 0;   	s = log_format;  	while (*s != '\0') { 		/* Test is we have place for 1 more char. */ 		if (len >= FPM_LOG_BUFFER) { 			zlog(ZLOG_NOTICE, ""the log buffer is full (%d). The access log request has been truncated."", FPM_LOG_BUFFER); 			len = FPM_LOG_BUFFER; 			break; 		}  		if (!token && *s == '%') { 			token = 1; 			memset(format, '\0', sizeof(format)); /* reset format */ 			s++; 			continue; 		}  		if (token) { 			token = 0; 			len2 = 0; 			switch (*s) {  				case '%': /* '%' */ 					*b = '%'; 					len2 = 1; 					break;  #ifdef HAVE_TIMES 				case 'C': /* %CPU */ 					if (format[0] == '\0' || !strcasecmp(format, ""total"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_utime + proc.last_request_cpu.tms_stime + proc.last_request_cpu.tms_cutime + proc.last_request_cpu.tms_cstime; 						} 					} else if (!strcasecmp(format, ""user"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_utime + proc.last_request_cpu.tms_cutime; 						} 					} else if (!strcasecmp(format, ""system"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_stime + proc.last_request_cpu.tms_cstime; 						} 					} else { 						zlog(ZLOG_WARNING, ""only 'total', 'user' or 'system' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					}  					format[0] = '\0'; 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.2f"", tms_total / fpm_scoreboard_get_tick() / (proc.cpu_duration.tv_sec + proc.cpu_duration.tv_usec / 1000000.) * 100.); 					} 					break; #endif  				case 'd': /* duration s */ 					/* seconds */ 					if (format[0] == '\0' || !strcasecmp(format, ""seconds"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.3f"", proc.duration.tv_sec + proc.duration.tv_usec / 1000000.); 						}  					/* miliseconds */ 					} else if (!strcasecmp(format, ""miliseconds"") || !strcasecmp(format, ""mili"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.3f"", proc.duration.tv_sec * 1000. + proc.duration.tv_usec / 1000.); 						}  					/* microseconds */ 					} else if (!strcasecmp(format, ""microseconds"") || !strcasecmp(format, ""micro"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.duration.tv_sec * 1000000UL + proc.duration.tv_usec); 						}  					} else { 						zlog(ZLOG_WARNING, ""only 'seconds', 'mili', 'miliseconds', 'micro' or 'microseconds' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					} 					format[0] = '\0'; 					break;  				case 'e': /* fastcgi env  */ 					if (format[0] == '\0') { 						zlog(ZLOG_WARNING, ""the name of the environment variable must be set between embraces for %%%c"", *s); 						return -1; 					}  					if (!test) { 						char *env = fcgi_getenv((fcgi_request*) SG(server_context), format, strlen(format)); 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", env ? env : ""-""); 					} 					format[0] = '\0'; 					break;  				case 'f': /* script */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"",  *proc.script_filename ? proc.script_filename : ""-""); 					} 					break;  				case 'l': /* content length */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%zu"", proc.content_length); 					} 					break;  				case 'm': /* method */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", *proc.request_method ? proc.request_method : ""-""); 					} 					break;  				case 'M': /* memory */ 					/* seconds */ 					if (format[0] == '\0' || !strcasecmp(format, ""bytes"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%zu"", proc.memory); 						}  					/* kilobytes */ 					} else if (!strcasecmp(format, ""kilobytes"") || !strcasecmp(format, ""kilo"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.memory / 1024); 						}  					/* megabytes */ 					} else if (!strcasecmp(format, ""megabytes"") || !strcasecmp(format, ""mega"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.memory / 1024 / 1024); 						}  					} else { 						zlog(ZLOG_WARNING, ""only 'bytes', 'kilo', 'kilobytes', 'mega' or 'megabytes' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					} 					format[0] = '\0'; 					break;  				case 'n': /* pool name */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", scoreboard->pool[0] ? scoreboard->pool : ""-""); 					} 					break;  				case 'o': /* header output  */ 					if (format[0] == '\0') { 						zlog(ZLOG_WARNING, ""the name of the header must be set between embraces for %%%c"", *s); 						return -1; 					} 					if (!test) { 						sapi_header_struct *h; 						zend_llist_position pos; 						sapi_headers_struct *sapi_headers = &SG(sapi_headers); 						size_t format_len = strlen(format);  						h = (sapi_header_struct*)zend_llist_get_first_ex(&sapi_headers->headers, &pos); 						while (h) { 							char *header; 							if (!h->header_len) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							} 							if (!strstr(h->header, format)) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							/* test if enought char after the header name + ': ' */ 							if (h->header_len <= format_len + 2) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							if (h->header[format_len] != ':' || h->header[format_len + 1] != ' ') { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							header = h->header + format_len + 2; 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", header && *header ? header : ""-"");  							/* found, done */ 							break; 						} 						if (!len2) { 							len2 = 1; 							*b = '-'; 						} 					} 					format[0] = '\0'; 					break;  				case 'p': /* PID */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%ld"", (long)getpid()); 					} 					break;  				case 'P': /* PID */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%ld"", (long)getppid()); 					} 					break;  				case 'q': /* query_string */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.query_string); 					} 					break;  				case 'Q': /* '?' */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", *proc.query_string  ? ""?"" : """"); 					} 					break;  				case 'r': /* request URI */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.request_uri); 					} 					break;  				case 'R': /* remote IP address */ 					if (!test) { 						const char *tmp = fcgi_get_last_client_ip(); 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", tmp ? tmp : ""-""); 					} 					break;  				case 's': /* status */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%d"", SG(sapi_headers).http_response_code); 					} 					break;  				case 'T': 				case 't': /* time */ 					if (!test) { 						time_t *t; 						if (*s == 't') { 							t = &proc.accepted_epoch; 						} else { 							t = &now_epoch; 						} 						if (format[0] == '\0') { 							strftime(tmp, sizeof(tmp) - 1, ""%d/%b/%Y:%H:%M:%S %z"", localtime(t)); 						} else { 							strftime(tmp, sizeof(tmp) - 1, format, localtime(t)); 						} 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", tmp); 					} 					format[0] = '\0'; 					break;  				case 'u': /* remote user */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.auth_user); 					} 					break;  				case '{': /* complex var */ 					token = 1; 					{ 						char *start; 						size_t l;  						start = ++s;  						while (*s != '\0') { 							if (*s == '}') { 								l = s - start;  								if (l >= sizeof(format) - 1) { 									l = sizeof(format) - 1; 								}  								memcpy(format, start, l); 								format[l] = '\0'; 								break; 							} 							s++; 						} 						if (s[1] == '\0') { 							zlog(ZLOG_WARNING, ""missing closing embrace in the access.format""); 							return -1; 						} 					} 					break;  				default: 					zlog(ZLOG_WARNING, ""Invalid token in the access.format (%%%c)"", *s); 					return -1; 			}  			if (*s != '}' && format[0] != '\0') { 				zlog(ZLOG_WARNING, ""embrace is not allowed for modifier %%%c"", *s); 				return -1; 			} 			s++; 			if (!test) { 				b += len2; 				len += len2; 			} 			continue; 		}  		if (!test) { 			// push the normal char to the output buffer 			*b = *s; 			b++; 			len++; 		} 		s++; 	}  	if (!test && strlen(buffer) > 0) { 		buffer[len] = '\n'; 		write(fpm_log_fd, buffer, len + 1); 	}  	return 0; }"
"fpm_log_write_fpm_log_not_vulnerable.c","not_vulnerable","int fpm_log_write(char *log_format) /* {{{ */ { 	char *s, *b; 	char buffer[FPM_LOG_BUFFER+1]; 	int token, test; 	size_t len, len2; 	struct fpm_scoreboard_proc_s proc, *proc_p; 	struct fpm_scoreboard_s *scoreboard; 	char tmp[129]; 	char format[129]; 	time_t now_epoch; #ifdef HAVE_TIMES 	clock_t tms_total; #endif  	if (!log_format && (!fpm_log_format || fpm_log_fd == -1)) { 		return -1; 	}  	if (!log_format) { 		log_format = fpm_log_format; 		test = 0; 	} else { 		test = 1; 	}  	now_epoch = time(NULL);  	if (!test) { 		scoreboard = fpm_scoreboard_get(); 		if (!scoreboard) { 			zlog(ZLOG_WARNING, ""unable to get scoreboard while preparing the access log""); 			return -1; 		} 		proc_p = fpm_scoreboard_proc_acquire(NULL, -1, 0); 		if (!proc_p) { 			zlog(ZLOG_WARNING, ""[pool %s] Unable to acquire shm slot while preparing the access log"", scoreboard->pool); 			return -1; 		} 		proc = *proc_p; 		fpm_scoreboard_proc_release(proc_p); 	}  	token = 0;  	memset(buffer, '\0', sizeof(buffer)); 	b = buffer; 	len = 0;   	s = log_format;  	while (*s != '\0') { 		/* Test is we have place for 1 more char. */ 		if (len >= FPM_LOG_BUFFER) { 			zlog(ZLOG_NOTICE, ""the log buffer is full (%d). The access log request has been truncated."", FPM_LOG_BUFFER); 			len = FPM_LOG_BUFFER; 			break; 		}  		if (!token && *s == '%') { 			token = 1; 			memset(format, '\0', sizeof(format)); /* reset format */ 			s++; 			continue; 		}  		if (token) { 			token = 0; 			len2 = 0; 			switch (*s) {  				case '%': /* '%' */ 					*b = '%'; 					len2 = 1; 					break;  #ifdef HAVE_TIMES 				case 'C': /* %CPU */ 					if (format[0] == '\0' || !strcasecmp(format, ""total"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_utime + proc.last_request_cpu.tms_stime + proc.last_request_cpu.tms_cutime + proc.last_request_cpu.tms_cstime; 						} 					} else if (!strcasecmp(format, ""user"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_utime + proc.last_request_cpu.tms_cutime; 						} 					} else if (!strcasecmp(format, ""system"")) { 						if (!test) { 							tms_total = proc.last_request_cpu.tms_stime + proc.last_request_cpu.tms_cstime; 						} 					} else { 						zlog(ZLOG_WARNING, ""only 'total', 'user' or 'system' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					}  					format[0] = '\0'; 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.2f"", tms_total / fpm_scoreboard_get_tick() / (proc.cpu_duration.tv_sec + proc.cpu_duration.tv_usec / 1000000.) * 100.); 					} 					break; #endif  				case 'd': /* duration s */ 					/* seconds */ 					if (format[0] == '\0' || !strcasecmp(format, ""seconds"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.3f"", proc.duration.tv_sec + proc.duration.tv_usec / 1000000.); 						}  					/* miliseconds */ 					} else if (!strcasecmp(format, ""miliseconds"") || !strcasecmp(format, ""mili"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%.3f"", proc.duration.tv_sec * 1000. + proc.duration.tv_usec / 1000.); 						}  					/* microseconds */ 					} else if (!strcasecmp(format, ""microseconds"") || !strcasecmp(format, ""micro"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.duration.tv_sec * 1000000UL + proc.duration.tv_usec); 						}  					} else { 						zlog(ZLOG_WARNING, ""only 'seconds', 'mili', 'miliseconds', 'micro' or 'microseconds' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					} 					format[0] = '\0'; 					break;  				case 'e': /* fastcgi env  */ 					if (format[0] == '\0') { 						zlog(ZLOG_WARNING, ""the name of the environment variable must be set between embraces for %%%c"", *s); 						return -1; 					}  					if (!test) { 						char *env = fcgi_getenv((fcgi_request*) SG(server_context), format, strlen(format)); 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", env ? env : ""-""); 					} 					format[0] = '\0'; 					break;  				case 'f': /* script */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"",  *proc.script_filename ? proc.script_filename : ""-""); 					} 					break;  				case 'l': /* content length */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%zu"", proc.content_length); 					} 					break;  				case 'm': /* method */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", *proc.request_method ? proc.request_method : ""-""); 					} 					break;  				case 'M': /* memory */ 					/* seconds */ 					if (format[0] == '\0' || !strcasecmp(format, ""bytes"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%zu"", proc.memory); 						}  					/* kilobytes */ 					} else if (!strcasecmp(format, ""kilobytes"") || !strcasecmp(format, ""kilo"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.memory / 1024); 						}  					/* megabytes */ 					} else if (!strcasecmp(format, ""megabytes"") || !strcasecmp(format, ""mega"")) { 						if (!test) { 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%lu"", proc.memory / 1024 / 1024); 						}  					} else { 						zlog(ZLOG_WARNING, ""only 'bytes', 'kilo', 'kilobytes', 'mega' or 'megabytes' are allowed as a modifier for %%%c ('%s')"", *s, format); 						return -1; 					} 					format[0] = '\0'; 					break;  				case 'n': /* pool name */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", scoreboard->pool[0] ? scoreboard->pool : ""-""); 					} 					break;  				case 'o': /* header output  */ 					if (format[0] == '\0') { 						zlog(ZLOG_WARNING, ""the name of the header must be set between embraces for %%%c"", *s); 						return -1; 					} 					if (!test) { 						sapi_header_struct *h; 						zend_llist_position pos; 						sapi_headers_struct *sapi_headers = &SG(sapi_headers); 						size_t format_len = strlen(format);  						h = (sapi_header_struct*)zend_llist_get_first_ex(&sapi_headers->headers, &pos); 						while (h) { 							char *header; 							if (!h->header_len) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							} 							if (!strstr(h->header, format)) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							/* test if enought char after the header name + ': ' */ 							if (h->header_len <= format_len + 2) { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							if (h->header[format_len] != ':' || h->header[format_len + 1] != ' ') { 								h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos); 								continue; 							}  							header = h->header + format_len + 2; 							len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", header && *header ? header : ""-"");  							/* found, done */ 							break; 						} 						if (!len2) { 							len2 = 1; 							*b = '-'; 						} 					} 					format[0] = '\0'; 					break;  				case 'p': /* PID */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%ld"", (long)getpid()); 					} 					break;  				case 'P': /* PID */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%ld"", (long)getppid()); 					} 					break;  				case 'q': /* query_string */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.query_string); 					} 					break;  				case 'Q': /* '?' */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", *proc.query_string  ? ""?"" : """"); 					} 					break;  				case 'r': /* request URI */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.request_uri); 					} 					break;  				case 'R': /* remote IP address */ 					if (!test) { 						const char *tmp = fcgi_get_last_client_ip(); 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", tmp ? tmp : ""-""); 					} 					break;  				case 's': /* status */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%d"", SG(sapi_headers).http_response_code); 					} 					break;  				case 'T': 				case 't': /* time */ 					if (!test) { 						time_t *t; 						if (*s == 't') { 							t = &proc.accepted_epoch; 						} else { 							t = &now_epoch; 						} 						if (format[0] == '\0') { 							strftime(tmp, sizeof(tmp) - 1, ""%d/%b/%Y:%H:%M:%S %z"", localtime(t)); 						} else { 							strftime(tmp, sizeof(tmp) - 1, format, localtime(t)); 						} 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", tmp); 					} 					format[0] = '\0'; 					break;  				case 'u': /* remote user */ 					if (!test) { 						len2 = snprintf(b, FPM_LOG_BUFFER - len, ""%s"", proc.auth_user); 					} 					break;  				case '{': /* complex var */ 					token = 1; 					{ 						char *start; 						size_t l;  						start = ++s;  						while (*s != '\0') { 							if (*s == '}') { 								l = s - start;  								if (l >= sizeof(format) - 1) { 									l = sizeof(format) - 1; 								}  								memcpy(format, start, l); 								format[l] = '\0'; 								break; 							} 							s++; 						} 						if (s[1] == '\0') { 							zlog(ZLOG_WARNING, ""missing closing embrace in the access.format""); 							return -1; 						} 					} 					break;  				default: 					zlog(ZLOG_WARNING, ""Invalid token in the access.format (%%%c)"", *s); 					return -1; 			}  			if (*s != '}' && format[0] != '\0') { 				zlog(ZLOG_WARNING, ""embrace is not allowed for modifier %%%c"", *s); 				return -1; 			} 			s++; 			if (!test) { 				b += len2; 				len += len2; 			} 			if (len >= FPM_LOG_BUFFER) { 				zlog(ZLOG_NOTICE, ""the log buffer is full (%d). The access log request has been truncated."", FPM_LOG_BUFFER); 				len = FPM_LOG_BUFFER; 				break; 			} 			continue; 		}  		if (!test) { 			// push the normal char to the output buffer 			*b = *s; 			b++; 			len++; 		} 		s++; 	}  	if (!test && strlen(buffer) > 0) { 		buffer[len] = '\n'; 		write(fpm_log_fd, buffer, len + 1); 	}  	return 0; }"
"gdi_Bitmap_Decompress_graphics_cwe-190.c","CWE-190","static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,                                   const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,                                   UINT32 bpp, UINT32 length, BOOL compressed,                                   UINT32 codecId) { 	UINT32 SrcSize = length; 	rdpGdi* gdi = context->gdi; 	bitmap->compressed = FALSE; 	bitmap->format = gdi->dstFormat; 	bitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format); 	bitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);  	if (!bitmap->data) 		return FALSE;  	if (compressed) 	{ 		if (bpp < 32) 		{ 			if (!interleaved_decompress(context->codecs->interleaved, 			                            pSrcData, SrcSize, 			                            DstWidth, DstHeight, 			                            bpp, 			                            bitmap->data, bitmap->format, 			                            0, 0, 0, DstWidth, DstHeight, 			                            &gdi->palette)) 				return FALSE; 		} 		else 		{ 			if (!planar_decompress(context->codecs->planar, pSrcData, SrcSize, 			                       DstWidth, DstHeight, 			                       bitmap->data, bitmap->format, 0, 0, 0, 			                       DstWidth, DstHeight, TRUE)) 				return FALSE; 		} 	} 	else 	{ 		const UINT32 SrcFormat = gdi_get_pixel_format(bpp); 		const size_t sbpp = GetBytesPerPixel(SrcFormat); 		const size_t dbpp = GetBytesPerPixel(bitmap->format);  		if ((sbpp == 0) || (dbpp == 0)) 			return FALSE; 		else 		{ 			const size_t dstSize = SrcSize * dbpp / sbpp;  			if (dstSize  < bitmap->length) 				return FALSE; 		}  		if (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0, 		                        DstWidth, DstHeight, pSrcData, SrcFormat, 		                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL)) 			return FALSE; 	}  	return TRUE; }"
"gdi_Bitmap_Decompress_graphics_not_vulnerable.c","not_vulnerable","static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,                                   const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,                                   UINT32 bpp, UINT32 length, BOOL compressed,                                   UINT32 codecId) { 	UINT32 SrcSize = length; 	rdpGdi* gdi = context->gdi; 	UINT32 size = DstWidth * DstHeight; 	bitmap->compressed = FALSE; 	bitmap->format = gdi->dstFormat;  	if ((GetBytesPerPixel(bitmap->format) == 0) || 	    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) || 	    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format)))) 		return FALSE;  	size *= GetBytesPerPixel(bitmap->format); 	bitmap->length = size; 	bitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);  	if (!bitmap->data) 		return FALSE;  	if (compressed) 	{ 		if (bpp < 32) 		{ 			if (!interleaved_decompress(context->codecs->interleaved, 			                            pSrcData, SrcSize, 			                            DstWidth, DstHeight, 			                            bpp, 			                            bitmap->data, bitmap->format, 			                            0, 0, 0, DstWidth, DstHeight, 			                            &gdi->palette)) 				return FALSE; 		} 		else 		{ 			if (!planar_decompress(context->codecs->planar, pSrcData, SrcSize, 			                       DstWidth, DstHeight, 			                       bitmap->data, bitmap->format, 0, 0, 0, 			                       DstWidth, DstHeight, TRUE)) 				return FALSE; 		} 	} 	else 	{ 		const UINT32 SrcFormat = gdi_get_pixel_format(bpp); 		const size_t sbpp = GetBytesPerPixel(SrcFormat); 		const size_t dbpp = GetBytesPerPixel(bitmap->format);  		if ((sbpp == 0) || (dbpp == 0)) 			return FALSE; 		else 		{ 			const size_t dstSize = SrcSize * dbpp / sbpp;  			if (dstSize  < bitmap->length) 				return FALSE; 		}  		if (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0, 		                        DstWidth, DstHeight, pSrcData, SrcFormat, 		                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL)) 			return FALSE; 	}  	return TRUE; }"
"getToken_asm_x86_nz_cwe-125.c","CWE-125","static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) { 	// Skip whitespace 	while (begin && isspace ((ut8)str[*begin])) { 		++(*begin); 	}  	if (!str[*begin]) {                // null byte 		*end = *begin; 		return TT_EOF; 	} else if (isalpha ((ut8)str[*begin])) {   // word token 		*end = *begin; 		while (end && isalnum ((ut8)str[*end])) { 			++(*end); 		} 		return TT_WORD; 	} else if (isdigit ((ut8)str[*begin])) {   // number token 		*end = *begin; 		while (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex. 			++(*end); 		} 		return TT_NUMBER; 	} else {                             // special character: [, ], +, *, ... 		*end = *begin + 1; 		return TT_SPECIAL; 	} }"
"getToken_asm_x86_nz_not_vulnerable.c","not_vulnerable","static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) { 	if (*begin > strlen (str)) { 		return TT_EOF; 	} 	// Skip whitespace 	while (begin && str[*begin] && isspace ((ut8)str[*begin])) { 		++(*begin); 	}  	if (!str[*begin]) {                // null byte 		*end = *begin; 		return TT_EOF; 	} 	if (isalpha ((ut8)str[*begin])) {   // word token 		*end = *begin; 		while (end && str[*end] && isalnum ((ut8)str[*end])) { 			++(*end); 		} 		return TT_WORD; 	} 	if (isdigit ((ut8)str[*begin])) {   // number token 		*end = *begin; 		while (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex. 			++(*end); 		} 		return TT_NUMBER; 	} else {                             // special character: [, ], +, *, ... 		*end = *begin + 1; 		return TT_SPECIAL; 	} }"
"handle_PORT_ftpcmd_cwe-787.c","CWE-787","static void handle_PORT(ctrl_t *ctrl, char *str) { 	int a, b, c, d, e, f; 	char addr[INET_ADDRSTRLEN]; 	struct sockaddr_in sin;  	if (ctrl->data_sd > 0) { 		uev_io_stop(&ctrl->data_watcher); 		close(ctrl->data_sd); 		ctrl->data_sd = -1; 	}  	/* Convert PORT command's argument to IP address + port */ 	sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f); 	sprintf(addr, ""%d.%d.%d.%d"", a, b, c, d);  	/* Check IPv4 address using inet_aton(), throw away converted result */ 	if (!inet_aton(addr, &(sin.sin_addr))) { 		ERR(0, ""Invalid address '%s' given to PORT command"", addr); 		send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n""); 		return; 	}  	strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address)); 	ctrl->data_port = e * 256 + f;  	DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port); 	send_msg(ctrl->sd, ""200 PORT command successful.\r\n""); }"
"handle_PORT_ftpcmd_not_vulnerable.c","not_vulnerable","static void handle_PORT(ctrl_t *ctrl, char *str) { 	int a, b, c, d, e, f; 	char addr[INET_ADDRSTRLEN]; 	struct sockaddr_in sin;  	if (ctrl->data_sd > 0) { 		uev_io_stop(&ctrl->data_watcher); 		close(ctrl->data_sd); 		ctrl->data_sd = -1; 	}  	/* Convert PORT command's argument to IP address + port */ 	sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f); 	snprintf(addr, sizeof(addr), ""%d.%d.%d.%d"", a, b, c, d);  	/* Check IPv4 address using inet_aton(), throw away converted result */ 	if (!inet_aton(addr, &(sin.sin_addr))) { 		ERR(0, ""Invalid address '%s' given to PORT command"", addr); 		send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n""); 		return; 	}  	strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address)); 	ctrl->data_port = e * 256 + f;  	DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port); 	send_msg(ctrl->sd, ""200 PORT command successful.\r\n""); }"
"handle_method_call_abrt-dbus_cwe-022.c","CWE-022","static void handle_method_call(GDBusConnection *connection,                         const gchar *caller,                         const gchar *object_path,                         const gchar *interface_name,                         const gchar *method_name,                         GVariant    *parameters,                         GDBusMethodInvocation *invocation,                         gpointer    user_data) {     reset_timeout();      uid_t caller_uid;     GVariant *response;      caller_uid = get_caller_uid(connection, invocation, caller);      log_notice(""caller_uid:%ld method:'%s'"", (long)caller_uid, method_name);      if (caller_uid == (uid_t) -1)         return;      if (g_strcmp0(method_name, ""NewProblem"") == 0)     {         char *error = NULL;         char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);         if (!problem_id)         {             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       error);             free(error);             return;         }         /* else */         response = g_variant_new(""(s)"", problem_id);         g_dbus_method_invocation_return_value(invocation, response);         free(problem_id);          return;     }      if (g_strcmp0(method_name, ""GetProblems"") == 0)     {         GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         //I was told that g_dbus_method frees the response         //g_variant_unref(response);         return;     }      if (g_strcmp0(method_name, ""GetAllProblems"") == 0)     {         /*         - so, we have UID,         - if it's 0, then we don't have to check anything and just return all directories         - if uid != 0 then we want to ask for authorization         */         if (caller_uid != 0)         {             if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes)                 caller_uid = 0;         }          GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);          list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""GetForeignProblems"") == 0)     {         GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""ChownProblemDir"") == 0)     {         const gchar *problem_dir;         g_variant_get(parameters, ""(&s)"", &problem_dir);         log_notice(""problem_dir:'%s'"", problem_dir);          if (!allowed_problem_dir(problem_dir))         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int dir_fd = dd_openfd(problem_dir);         if (dir_fd < 0)         {             perror_msg(""can't open problem directory '%s'"", problem_dir);             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);         if (ddstat < 0)         {             if (errno == ENOTDIR)             {                 log_notice(""requested directory does not exist '%s'"", problem_dir);             }             else             {                 perror_msg(""can't get stat of '%s'"", problem_dir);             }              return_InvalidProblemDir_error(invocation, problem_dir);              close(dir_fd);             return;         }          if (ddstat & DD_STAT_OWNED_BY_UID)         {   //caller seems to be in group with access to this dir, so no action needed             log_notice(""caller has access to the requested directory %s"", problem_dir);             g_dbus_method_invocation_return_value(invocation, NULL);             close(dir_fd);             return;         }          if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&                 polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)         {             log_notice(""not authorized"");             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.AuthFailure"",                                               _(""Not Authorized""));             close(dir_fd);             return;         }          struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);         if (!dd)         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int chown_res = dd_chown(dd, caller_uid);         if (chown_res != 0)             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.ChownError"",                                               _(""Chowning directory failed. Check system logs for more details.""));         else             g_dbus_method_invocation_return_value(invocation, NULL);          dd_close(dd);         return;     }      if (g_strcmp0(method_name, ""GetInfo"") == 0)     {         /* Parameter tuple is (sas) */  	/* Get 1st param - problem dir name */         const gchar *problem_dir;         g_variant_get_child(parameters, 0, ""&s"", &problem_dir);         log_notice(""problem_dir:'%s'"", problem_dir);          if (!allowed_problem_dir(problem_dir))         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int dir_fd = dd_openfd(problem_dir);         if (dir_fd < 0)         {             perror_msg(""can't open problem directory '%s'"", problem_dir);             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))         {             if (errno == ENOTDIR)             {                 log_notice(""Requested directory does not exist '%s'"", problem_dir);                 return_InvalidProblemDir_error(invocation, problem_dir);                 close(dir_fd);                 return;             }              if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)             {                 log_notice(""not authorized"");                 g_dbus_method_invocation_return_dbus_error(invocation,                                                   ""org.freedesktop.problems.AuthFailure"",                                                   _(""Not Authorized""));                 close(dir_fd);                 return;             }         }          struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);         if (!dd)         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }  	/* Get 2nd param - vector of element names */         GVariant *array = g_variant_get_child_value(parameters, 1);         GList *elements = string_list_from_variant(array);         g_variant_unref(array);          GVariantBuilder *builder = NULL;         for (GList *l = elements; l; l = l->next)         {             const char *element_name = (const char*)l->data;             char *value = dd_load_text_ext(dd, element_name, 0                                                 | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE                                                 | DD_FAIL_QUIETLY_ENOENT                                                 | DD_FAIL_QUIETLY_EACCES);             log_notice(""element '%s' %s"", element_name, value ? ""fetched"" : ""not found"");             if (value)             {                 if (!builder)                     builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);                  /* g_variant_builder_add makes a copy. No need to xstrdup here */                 g_variant_builder_add(builder, ""{ss}"", element_name, value);                 free(value);             }         }         list_free_with_free(elements);         dd_close(dd);         /* It is OK to call g_variant_new(""(a{ss})"", NULL) because */         /* G_VARIANT_TYPE_TUPLE allows NULL value */         GVariant *response = g_variant_new(""(a{ss})"", builder);          if (builder)             g_variant_builder_unref(builder);          log_info(""GetInfo: returning value for '%s'"", problem_dir);         g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""SetElement"") == 0)     {         const char *problem_id;         const char *element;         const char *value;          g_variant_get(parameters, ""(&s&s&s)"", &problem_id, &element, &value);          if (element == NULL || element[0] == '\0' || strlen(element) > 64)         {             log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id);             char *error = xasprintf(_(""'%s' is not a valid element name""), element);             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.InvalidElement"",                                               error);              free(error);             return;         }          struct dump_dir *dd = open_directory_for_modification_of_element(                                     invocation, caller_uid, problem_id, element);         if (!dd)             /* Already logged from open_directory_for_modification_of_element() */             return;          /* Is it good idea to make it static? Is it possible to change the max size while a single run? */         const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);         const long item_size = dd_get_item_size(dd, element);         if (item_size < 0)         {             log_notice(""Can't get size of '%s/%s'"", problem_id, element);             char *error = xasprintf(_(""Can't get size of '%s'""), element);             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       error);             return;         }          const double requested_size = (double)strlen(value) - item_size;         /* Don't want to check the size limit in case of reducing of size */         if (requested_size > 0             && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))         {             log_notice(""No problem space left in '%s' (requested Bytes %f)"", problem_id, requested_size);             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       _(""No problem space left""));         }         else         {             dd_save_text(dd, element, value);             g_dbus_method_invocation_return_value(invocation, NULL);         }          dd_close(dd);          return;     }      if (g_strcmp0(method_name, ""DeleteElement"") == 0)     {         const char *problem_id;         const char *element;          g_variant_get(parameters, ""(&s&s)"", &problem_id, &element);          struct dump_dir *dd = open_directory_for_modification_of_element(                                     invocation, caller_uid, problem_id, element);         if (!dd)             /* Already logged from open_directory_for_modification_of_element() */             return;          const int res = dd_delete_item(dd, element);         dd_close(dd);          if (res != 0)         {             log_notice(""Can't delete the element '%s' from the problem directory '%s'"", element, problem_id);             char *error = xasprintf(_(""Can't delete the element '%s' from the problem directory '%s'""), element, problem_id);             g_dbus_method_invocation_return_dbus_error(invocation,                                           ""org.freedesktop.problems.Failure"",                                           error);             free(error);             return;         }           g_dbus_method_invocation_return_value(invocation, NULL);         return;     }      if (g_strcmp0(method_name, ""DeleteProblem"") == 0)     {         /* Dbus parameters are always tuples.          * In this case, it's (as) - a tuple of one element (array of strings).          * Need to fetch the array:          */         GVariant *array = g_variant_get_child_value(parameters, 0);         GList *problem_dirs = string_list_from_variant(array);         g_variant_unref(array);          for (GList *l = problem_dirs; l; l = l->next)         {             const char *dir_name = (const char*)l->data;             log_notice(""dir_name:'%s'"", dir_name);             if (!allowed_problem_dir(dir_name))             {                 return_InvalidProblemDir_error(invocation, dir_name);                 goto ret;             }         }          for (GList *l = problem_dirs; l; l = l->next)         {             const char *dir_name = (const char*)l->data;              int dir_fd = dd_openfd(dir_name);             if (dir_fd < 0)             {                 perror_msg(""can't open problem directory '%s'"", dir_name);                 return_InvalidProblemDir_error(invocation, dir_name);                 return;             }              if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))             {                 if (errno == ENOTDIR)                 {                     log_notice(""Requested directory does not exist '%s'"", dir_name);                     close(dir_fd);                     continue;                 }                  if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)                 { // if user didn't provide correct credentials, just move to the next dir                     close(dir_fd);                     continue;                 }             }              struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);             if (dd)             {                 if (dd_delete(dd) != 0)                 {                     error_msg(""Failed to delete problem directory '%s'"", dir_name);                     dd_close(dd);                 }             }         }          g_dbus_method_invocation_return_value(invocation, NULL);  ret:         list_free_with_free(problem_dirs);         return;     }      if (g_strcmp0(method_name, ""FindProblemByElementInTimeRange"") == 0)     {         const gchar *element;         const gchar *value;         glong timestamp_from;         glong timestamp_to;         gboolean all;          g_variant_get_child(parameters, 0, ""&s"", &element);         g_variant_get_child(parameters, 1, ""&s"", &value);         g_variant_get_child(parameters, 2, ""x"", &timestamp_from);         g_variant_get_child(parameters, 3, ""x"", &timestamp_to);         g_variant_get_child(parameters, 4, ""b"", &all);          if (all && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes)             caller_uid = 0;          GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,                                                         timestamp_to);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""Quit"") == 0)     {         g_dbus_method_invocation_return_value(invocation, NULL);         g_main_loop_quit(loop);         return;     } }"
"handle_method_call_abrt-dbus_not_vulnerable.c","not_vulnerable","static void handle_method_call(GDBusConnection *connection,                         const gchar *caller,                         const gchar *object_path,                         const gchar *interface_name,                         const gchar *method_name,                         GVariant    *parameters,                         GDBusMethodInvocation *invocation,                         gpointer    user_data) {     reset_timeout();      uid_t caller_uid;     GVariant *response;      caller_uid = get_caller_uid(connection, invocation, caller);      log_notice(""caller_uid:%ld method:'%s'"", (long)caller_uid, method_name);      if (caller_uid == (uid_t) -1)         return;      if (g_strcmp0(method_name, ""NewProblem"") == 0)     {         char *error = NULL;         char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);         if (!problem_id)         {             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       error);             free(error);             return;         }         /* else */         response = g_variant_new(""(s)"", problem_id);         g_dbus_method_invocation_return_value(invocation, response);         free(problem_id);          return;     }      if (g_strcmp0(method_name, ""GetProblems"") == 0)     {         GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         //I was told that g_dbus_method frees the response         //g_variant_unref(response);         return;     }      if (g_strcmp0(method_name, ""GetAllProblems"") == 0)     {         /*         - so, we have UID,         - if it's 0, then we don't have to check anything and just return all directories         - if uid != 0 then we want to ask for authorization         */         if (caller_uid != 0)         {             if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes)                 caller_uid = 0;         }          GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);          list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""GetForeignProblems"") == 0)     {         GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""ChownProblemDir"") == 0)     {         const gchar *problem_dir;         g_variant_get(parameters, ""(&s)"", &problem_dir);         log_notice(""problem_dir:'%s'"", problem_dir);          if (!allowed_problem_dir(problem_dir))         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int dir_fd = dd_openfd(problem_dir);         if (dir_fd < 0)         {             perror_msg(""can't open problem directory '%s'"", problem_dir);             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);         if (ddstat < 0)         {             if (errno == ENOTDIR)             {                 log_notice(""requested directory does not exist '%s'"", problem_dir);             }             else             {                 perror_msg(""can't get stat of '%s'"", problem_dir);             }              return_InvalidProblemDir_error(invocation, problem_dir);              close(dir_fd);             return;         }          if (ddstat & DD_STAT_OWNED_BY_UID)         {   //caller seems to be in group with access to this dir, so no action needed             log_notice(""caller has access to the requested directory %s"", problem_dir);             g_dbus_method_invocation_return_value(invocation, NULL);             close(dir_fd);             return;         }          if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&                 polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)         {             log_notice(""not authorized"");             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.AuthFailure"",                                               _(""Not Authorized""));             close(dir_fd);             return;         }          struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);         if (!dd)         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int chown_res = dd_chown(dd, caller_uid);         if (chown_res != 0)             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.ChownError"",                                               _(""Chowning directory failed. Check system logs for more details.""));         else             g_dbus_method_invocation_return_value(invocation, NULL);          dd_close(dd);         return;     }      if (g_strcmp0(method_name, ""GetInfo"") == 0)     {         /* Parameter tuple is (sas) */  	/* Get 1st param - problem dir name */         const gchar *problem_dir;         g_variant_get_child(parameters, 0, ""&s"", &problem_dir);         log_notice(""problem_dir:'%s'"", problem_dir);          if (!allowed_problem_dir(problem_dir))         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          int dir_fd = dd_openfd(problem_dir);         if (dir_fd < 0)         {             perror_msg(""can't open problem directory '%s'"", problem_dir);             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }          if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))         {             if (errno == ENOTDIR)             {                 log_notice(""Requested directory does not exist '%s'"", problem_dir);                 return_InvalidProblemDir_error(invocation, problem_dir);                 close(dir_fd);                 return;             }              if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)             {                 log_notice(""not authorized"");                 g_dbus_method_invocation_return_dbus_error(invocation,                                                   ""org.freedesktop.problems.AuthFailure"",                                                   _(""Not Authorized""));                 close(dir_fd);                 return;             }         }          struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);         if (!dd)         {             return_InvalidProblemDir_error(invocation, problem_dir);             return;         }  	/* Get 2nd param - vector of element names */         GVariant *array = g_variant_get_child_value(parameters, 1);         GList *elements = string_list_from_variant(array);         g_variant_unref(array);          GVariantBuilder *builder = NULL;         for (GList *l = elements; l; l = l->next)         {             const char *element_name = (const char*)l->data;             char *value = dd_load_text_ext(dd, element_name, 0                                                 | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE                                                 | DD_FAIL_QUIETLY_ENOENT                                                 | DD_FAIL_QUIETLY_EACCES);             log_notice(""element '%s' %s"", element_name, value ? ""fetched"" : ""not found"");             if (value)             {                 if (!builder)                     builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);                  /* g_variant_builder_add makes a copy. No need to xstrdup here */                 g_variant_builder_add(builder, ""{ss}"", element_name, value);                 free(value);             }         }         list_free_with_free(elements);         dd_close(dd);         /* It is OK to call g_variant_new(""(a{ss})"", NULL) because */         /* G_VARIANT_TYPE_TUPLE allows NULL value */         GVariant *response = g_variant_new(""(a{ss})"", builder);          if (builder)             g_variant_builder_unref(builder);          log_info(""GetInfo: returning value for '%s'"", problem_dir);         g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""SetElement"") == 0)     {         const char *problem_id;         const char *element;         const char *value;          g_variant_get(parameters, ""(&s&s&s)"", &problem_id, &element, &value);          if (!str_is_correct_filename(element))         {             log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id);             char *error = xasprintf(_(""'%s' is not a valid element name""), element);             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.InvalidElement"",                                               error);              free(error);             return;         }          struct dump_dir *dd = open_directory_for_modification_of_element(                                     invocation, caller_uid, problem_id, element);         if (!dd)             /* Already logged from open_directory_for_modification_of_element() */             return;          /* Is it good idea to make it static? Is it possible to change the max size while a single run? */         const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);         const long item_size = dd_get_item_size(dd, element);         if (item_size < 0)         {             log_notice(""Can't get size of '%s/%s'"", problem_id, element);             char *error = xasprintf(_(""Can't get size of '%s'""), element);             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       error);             return;         }          const double requested_size = (double)strlen(value) - item_size;         /* Don't want to check the size limit in case of reducing of size */         if (requested_size > 0             && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))         {             log_notice(""No problem space left in '%s' (requested Bytes %f)"", problem_id, requested_size);             g_dbus_method_invocation_return_dbus_error(invocation,                                                       ""org.freedesktop.problems.Failure"",                                                       _(""No problem space left""));         }         else         {             dd_save_text(dd, element, value);             g_dbus_method_invocation_return_value(invocation, NULL);         }          dd_close(dd);          return;     }      if (g_strcmp0(method_name, ""DeleteElement"") == 0)     {         const char *problem_id;         const char *element;          g_variant_get(parameters, ""(&s&s)"", &problem_id, &element);          if (!str_is_correct_filename(element))         {             log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id);             char *error = xasprintf(_(""'%s' is not a valid element name""), element);             g_dbus_method_invocation_return_dbus_error(invocation,                                               ""org.freedesktop.problems.InvalidElement"",                                               error);              free(error);             return;         }          struct dump_dir *dd = open_directory_for_modification_of_element(                                     invocation, caller_uid, problem_id, element);         if (!dd)             /* Already logged from open_directory_for_modification_of_element() */             return;          const int res = dd_delete_item(dd, element);         dd_close(dd);          if (res != 0)         {             log_notice(""Can't delete the element '%s' from the problem directory '%s'"", element, problem_id);             char *error = xasprintf(_(""Can't delete the element '%s' from the problem directory '%s'""), element, problem_id);             g_dbus_method_invocation_return_dbus_error(invocation,                                           ""org.freedesktop.problems.Failure"",                                           error);             free(error);             return;         }           g_dbus_method_invocation_return_value(invocation, NULL);         return;     }      if (g_strcmp0(method_name, ""DeleteProblem"") == 0)     {         /* Dbus parameters are always tuples.          * In this case, it's (as) - a tuple of one element (array of strings).          * Need to fetch the array:          */         GVariant *array = g_variant_get_child_value(parameters, 0);         GList *problem_dirs = string_list_from_variant(array);         g_variant_unref(array);          for (GList *l = problem_dirs; l; l = l->next)         {             const char *dir_name = (const char*)l->data;             log_notice(""dir_name:'%s'"", dir_name);             if (!allowed_problem_dir(dir_name))             {                 return_InvalidProblemDir_error(invocation, dir_name);                 goto ret;             }         }          for (GList *l = problem_dirs; l; l = l->next)         {             const char *dir_name = (const char*)l->data;              int dir_fd = dd_openfd(dir_name);             if (dir_fd < 0)             {                 perror_msg(""can't open problem directory '%s'"", dir_name);                 return_InvalidProblemDir_error(invocation, dir_name);                 return;             }              if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))             {                 if (errno == ENOTDIR)                 {                     log_notice(""Requested directory does not exist '%s'"", dir_name);                     close(dir_fd);                     continue;                 }                  if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes)                 { // if user didn't provide correct credentials, just move to the next dir                     close(dir_fd);                     continue;                 }             }              struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);             if (dd)             {                 if (dd_delete(dd) != 0)                 {                     error_msg(""Failed to delete problem directory '%s'"", dir_name);                     dd_close(dd);                 }             }         }          g_dbus_method_invocation_return_value(invocation, NULL);  ret:         list_free_with_free(problem_dirs);         return;     }      if (g_strcmp0(method_name, ""FindProblemByElementInTimeRange"") == 0)     {         const gchar *element;         const gchar *value;         glong timestamp_from;         glong timestamp_to;         gboolean all;          g_variant_get_child(parameters, 0, ""&s"", &element);         g_variant_get_child(parameters, 1, ""&s"", &value);         g_variant_get_child(parameters, 2, ""x"", &timestamp_from);         g_variant_get_child(parameters, 3, ""x"", &timestamp_to);         g_variant_get_child(parameters, 4, ""b"", &all);          if (all && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes)             caller_uid = 0;          GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,                                                         timestamp_to);         response = variant_from_string_list(dirs);         list_free_with_free(dirs);          g_dbus_method_invocation_return_value(invocation, response);         return;     }      if (g_strcmp0(method_name, ""Quit"") == 0)     {         g_dbus_method_invocation_return_value(invocation, NULL);         g_main_loop_quit(loop);         return;     } }"
"hash_accept_algif_hash_cwe-476.c","CWE-476","static int hash_accept(struct socket *sock, struct socket *newsock, int flags) { 	struct sock *sk = sock->sk; 	struct alg_sock *ask = alg_sk(sk); 	struct hash_ctx *ctx = ask->private; 	struct ahash_request *req = &ctx->req; 	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))]; 	struct sock *sk2; 	struct alg_sock *ask2; 	struct hash_ctx *ctx2; 	int err;  	err = crypto_ahash_export(req, state); 	if (err) 		return err;  	err = af_alg_accept(ask->parent, newsock); 	if (err) 		return err;  	sk2 = newsock->sk; 	ask2 = alg_sk(sk2); 	ctx2 = ask2->private; 	ctx2->more = 1;  	err = crypto_ahash_import(&ctx2->req, state); 	if (err) { 		sock_orphan(sk2); 		sock_put(sk2); 	}  	return err; }"
"hash_accept_algif_hash_not_vulnerable.c","not_vulnerable","static int hash_accept(struct socket *sock, struct socket *newsock, int flags) { 	struct sock *sk = sock->sk; 	struct alg_sock *ask = alg_sk(sk); 	struct hash_ctx *ctx = ask->private; 	struct ahash_request *req = &ctx->req; 	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))]; 	struct sock *sk2; 	struct alg_sock *ask2; 	struct hash_ctx *ctx2; 	bool more; 	int err;  	lock_sock(sk); 	more = ctx->more; 	err = more ? crypto_ahash_export(req, state) : 0; 	release_sock(sk);  	if (err) 		return err;  	err = af_alg_accept(ask->parent, newsock); 	if (err) 		return err;  	sk2 = newsock->sk; 	ask2 = alg_sk(sk2); 	ctx2 = ask2->private; 	ctx2->more = more;  	if (!more) 		return err;  	err = crypto_ahash_import(&ctx2->req, state); 	if (err) { 		sock_orphan(sk2); 		sock_put(sk2); 	}  	return err; }"
"inet_rtm_getroute_route_cwe-476.c","CWE-476","static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh, 			     struct netlink_ext_ack *extack) { 	struct net *net = sock_net(in_skb->sk); 	struct rtmsg *rtm; 	struct nlattr *tb[RTA_MAX+1]; 	struct fib_result res = {}; 	struct rtable *rt = NULL; 	struct flowi4 fl4; 	__be32 dst = 0; 	__be32 src = 0; 	u32 iif; 	int err; 	int mark; 	struct sk_buff *skb; 	u32 table_id = RT_TABLE_MAIN; 	kuid_t uid;  	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy, 			  extack); 	if (err < 0) 		goto errout;  	rtm = nlmsg_data(nlh);  	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL); 	if (!skb) { 		err = -ENOBUFS; 		goto errout; 	}  	/* Reserve room for dummy headers, this skb can pass 	   through good chunk of routing engine. 	 */ 	skb_reset_mac_header(skb); 	skb_reset_network_header(skb);  	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0; 	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0; 	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0; 	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0; 	if (tb[RTA_UID]) 		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID])); 	else 		uid = (iif ? INVALID_UID : current_uid());  	/* Bugfix: need to give ip_route_input enough of an IP header to 	 * not gag. 	 */ 	ip_hdr(skb)->protocol = IPPROTO_UDP; 	ip_hdr(skb)->saddr = src; 	ip_hdr(skb)->daddr = dst;  	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));  	memset(&fl4, 0, sizeof(fl4)); 	fl4.daddr = dst; 	fl4.saddr = src; 	fl4.flowi4_tos = rtm->rtm_tos; 	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0; 	fl4.flowi4_mark = mark; 	fl4.flowi4_uid = uid;  	rcu_read_lock();  	if (iif) { 		struct net_device *dev;  		dev = dev_get_by_index_rcu(net, iif); 		if (!dev) { 			err = -ENODEV; 			goto errout_free; 		}  		skb->protocol	= htons(ETH_P_IP); 		skb->dev	= dev; 		skb->mark	= mark; 		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos, 					 dev, &res);  		rt = skb_rtable(skb); 		if (err == 0 && rt->dst.error) 			err = -rt->dst.error; 	} else { 		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb); 		err = 0; 		if (IS_ERR(rt)) 			err = PTR_ERR(rt); 		else 			skb_dst_set(skb, &rt->dst); 	}  	if (err) 		goto errout_free;  	if (rtm->rtm_flags & RTM_F_NOTIFY) 		rt->rt_flags |= RTCF_NOTIFY;  	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE) 		table_id = rt->rt_table_id;  	if (rtm->rtm_flags & RTM_F_FIB_MATCH) 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid, 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id, 				    rt->rt_type, res.prefix, res.prefixlen, 				    fl4.flowi4_tos, res.fi, 0); 	else 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb, 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq); 	if (err < 0) 		goto errout_free;  	rcu_read_unlock();  	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid); errout: 	return err;  errout_free: 	rcu_read_unlock(); 	kfree_skb(skb); 	goto errout; }"
"inet_rtm_getroute_route_not_vulnerable.c","not_vulnerable","static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh, 			     struct netlink_ext_ack *extack) { 	struct net *net = sock_net(in_skb->sk); 	struct rtmsg *rtm; 	struct nlattr *tb[RTA_MAX+1]; 	struct fib_result res = {}; 	struct rtable *rt = NULL; 	struct flowi4 fl4; 	__be32 dst = 0; 	__be32 src = 0; 	u32 iif; 	int err; 	int mark; 	struct sk_buff *skb; 	u32 table_id = RT_TABLE_MAIN; 	kuid_t uid;  	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy, 			  extack); 	if (err < 0) 		goto errout;  	rtm = nlmsg_data(nlh);  	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL); 	if (!skb) { 		err = -ENOBUFS; 		goto errout; 	}  	/* Reserve room for dummy headers, this skb can pass 	   through good chunk of routing engine. 	 */ 	skb_reset_mac_header(skb); 	skb_reset_network_header(skb);  	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0; 	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0; 	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0; 	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0; 	if (tb[RTA_UID]) 		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID])); 	else 		uid = (iif ? INVALID_UID : current_uid());  	/* Bugfix: need to give ip_route_input enough of an IP header to 	 * not gag. 	 */ 	ip_hdr(skb)->protocol = IPPROTO_UDP; 	ip_hdr(skb)->saddr = src; 	ip_hdr(skb)->daddr = dst;  	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));  	memset(&fl4, 0, sizeof(fl4)); 	fl4.daddr = dst; 	fl4.saddr = src; 	fl4.flowi4_tos = rtm->rtm_tos; 	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0; 	fl4.flowi4_mark = mark; 	fl4.flowi4_uid = uid;  	rcu_read_lock();  	if (iif) { 		struct net_device *dev;  		dev = dev_get_by_index_rcu(net, iif); 		if (!dev) { 			err = -ENODEV; 			goto errout_free; 		}  		skb->protocol	= htons(ETH_P_IP); 		skb->dev	= dev; 		skb->mark	= mark; 		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos, 					 dev, &res);  		rt = skb_rtable(skb); 		if (err == 0 && rt->dst.error) 			err = -rt->dst.error; 	} else { 		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb); 		err = 0; 		if (IS_ERR(rt)) 			err = PTR_ERR(rt); 		else 			skb_dst_set(skb, &rt->dst); 	}  	if (err) 		goto errout_free;  	if (rtm->rtm_flags & RTM_F_NOTIFY) 		rt->rt_flags |= RTCF_NOTIFY;  	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE) 		table_id = rt->rt_table_id;  	if (rtm->rtm_flags & RTM_F_FIB_MATCH) { 		if (!res.fi) { 			err = fib_props[res.type].error; 			if (!err) 				err = -EHOSTUNREACH; 			goto errout_free; 		} 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid, 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id, 				    rt->rt_type, res.prefix, res.prefixlen, 				    fl4.flowi4_tos, res.fi, 0); 	} else { 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb, 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq); 	} 	if (err < 0) 		goto errout_free;  	rcu_read_unlock();  	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid); errout: 	return err;  errout_free: 	rcu_read_unlock(); 	kfree_skb(skb); 	goto errout; }"
"java_switch_op_anal_java_cwe-125.c","CWE-125","static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { 	ut8 op_byte = data[0]; 	ut64 offset = addr - java_get_method_start (); 	ut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;  	if (op_byte == 0xaa) { 		// handle a table switch condition 		if (pos + 8 > len) { 			return op->size; 		} 		int min_val = (ut32)(UINT (data, pos + 4)), 			max_val = (ut32)(UINT (data, pos + 8));  		ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0; 		op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc); 		RAnalCaseOp *caseop = NULL; 		pos += 12; 		if (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) { 			//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset); 			for (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) { 				//ut32 value = (ut32)(UINT (data, pos)); 				if (pos + 4 >= len) { 					// switch is too big cant read further 					break; 				} 				int offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos)); 				caseop = r_anal_switch_op_add_case (op->switch_op, 					addr + pos, cur_case + min_val, addr + offset); 				if (caseop) { 					caseop->bb_ref_to = addr+offset; 					caseop->bb_ref_from = addr; // TODO figure this one out 				} 			} 		} else { 			eprintf (""Invalid switch boundaries at 0x%""PFMT64x""\n"", addr); 		} 	} 	op->size = pos; 	return op->size; }"
"java_switch_op_anal_java_not_vulnerable.c","not_vulnerable","static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { 	ut8 op_byte = data[0]; 	ut64 offset = addr - java_get_method_start (); 	ut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;  	if (op_byte == 0xaa) { 		// handle a table switch condition 		if (pos + 8 + 8 > len) { 			return op->size; 		} 		const int min_val = (ut32)(UINT (data, pos + 4)); 		const int max_val = (ut32)(UINT (data, pos + 8));  		ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0; 		op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc); 		RAnalCaseOp *caseop = NULL; 		pos += 12; 		if (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) { 			//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset); 			for (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) { 				//ut32 value = (ut32)(UINT (data, pos)); 				if (pos + 4 >= len) { 					// switch is too big cant read further 					break; 				} 				int offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos)); 				caseop = r_anal_switch_op_add_case (op->switch_op, 					addr + pos, cur_case + min_val, addr + offset); 				if (caseop) { 					caseop->bb_ref_to = addr+offset; 					caseop->bb_ref_from = addr; // TODO figure this one out 				} 			} 		} else { 			eprintf (""Invalid switch boundaries at 0x%""PFMT64x""\n"", addr); 		} 	} 	op->size = pos; 	return op->size; }"
"jbig2_image_compose_jbig2_image_cwe-787.c","CWE-787","jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op) {     uint32_t w, h;     uint32_t shift;     uint32_t leftbyte;     uint8_t *ss;     uint8_t *dd;     uint8_t leftmask, rightmask;     int early = x >= 0;     int late;     uint32_t bytewidth;     uint32_t syoffset = 0;      if (src == NULL)         return 0;      /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */      /* Data is packed msb first within a byte, so with bits numbered: 01234567.      * Second byte is: 89abcdef. So to combine into a run, we use:      *       (s[0]<<8) | s[1] == 0123456789abcdef.      * To read from src into dst at offset 3, we need to read:      *    read:      0123456789abcdef...      *    write:  0123456798abcdef...      * In general, to read from src and write into dst at offset x, we need to shift      * down by (x&7) bits to allow for bit alignment. So shift = x&7.      * So the 'central' part of our runs will see us doing:      *   *d++ op= ((s[0]<<8)|s[1])>>shift;      * with special cases on the left and right edges of the run to mask.      * With the left hand edge, we have to be careful not to 'underread' the start of      * the src image; this is what the early flag is about. Similarly we have to be      * careful not to read off the right hand edge; this is what the late flag is for.      */      /* clip */     w = src->width;     h = src->height;     shift = (x & 7);     ss = src->data - early;      if (x < 0) {         if (w < (uint32_t) -x)             w = 0;         else             w += x;         ss += (-x-1)>>3;         x = 0;     }     if (y < 0) {         if (h < (uint32_t) -y)             h = 0;         else             h += y;         syoffset = -y * src->stride;         y = 0;     }     if ((uint32_t)x + w > dst->width)     {         if (dst->width < (uint32_t)x)             w = 0;         else             w = dst->width - x;     }     if ((uint32_t)y + h > dst->height)     {         if (dst->height < (uint32_t)y)             h = 0;         else             h = dst->height - y;     } #ifdef JBIG2_DEBUG     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y); #endif      /* check for zero clipping region */     if ((w <= 0) || (h <= 0)) { #ifdef JBIG2_DEBUG         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region""); #endif         return 0;     }      leftbyte = (uint32_t) x >> 3;     dd = dst->data + y * dst->stride + leftbyte;     bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;     leftmask = 255>>(x&7);     rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));     if (bytewidth == 1)         leftmask &= rightmask;     late = (ss + bytewidth >= src->data + ((src->width+7)>>3));     ss += syoffset;      switch(op)     {     case JBIG2_COMPOSE_OR:         jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_AND:         jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_XOR:         jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_XNOR:         jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_REPLACE:         jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     }      return 0; }"
"jbig2_image_compose_jbig2_image_not_vulnerable.c","not_vulnerable","jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op) {     uint32_t w, h;     uint32_t shift;     uint32_t leftbyte;     uint8_t *ss;     uint8_t *dd;     uint8_t leftmask, rightmask;     int early = x >= 0;     int late;     uint32_t bytewidth;     uint32_t syoffset = 0;      if (src == NULL)         return 0;      if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||         (UINT32_MAX - src->height < (y > 0 ? y : -y)))     { #ifdef JBIG2_DEBUG         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""overflow in compose_image""); #endif         return 0;     }      /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */      /* Data is packed msb first within a byte, so with bits numbered: 01234567.      * Second byte is: 89abcdef. So to combine into a run, we use:      *       (s[0]<<8) | s[1] == 0123456789abcdef.      * To read from src into dst at offset 3, we need to read:      *    read:      0123456789abcdef...      *    write:  0123456798abcdef...      * In general, to read from src and write into dst at offset x, we need to shift      * down by (x&7) bits to allow for bit alignment. So shift = x&7.      * So the 'central' part of our runs will see us doing:      *   *d++ op= ((s[0]<<8)|s[1])>>shift;      * with special cases on the left and right edges of the run to mask.      * With the left hand edge, we have to be careful not to 'underread' the start of      * the src image; this is what the early flag is about. Similarly we have to be      * careful not to read off the right hand edge; this is what the late flag is for.      */      /* clip */     w = src->width;     h = src->height;     shift = (x & 7);     ss = src->data - early;      if (x < 0) {         if (w < (uint32_t) -x)             w = 0;         else             w += x;         ss += (-x-1)>>3;         x = 0;     }     if (y < 0) {         if (h < (uint32_t) -y)             h = 0;         else             h += y;         syoffset = -y * src->stride;         y = 0;     }     if ((uint32_t)x + w > dst->width)     {         if (dst->width < (uint32_t)x)             w = 0;         else             w = dst->width - x;     }     if ((uint32_t)y + h > dst->height)     {         if (dst->height < (uint32_t)y)             h = 0;         else             h = dst->height - y;     } #ifdef JBIG2_DEBUG     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y); #endif      /* check for zero clipping region */     if ((w <= 0) || (h <= 0)) { #ifdef JBIG2_DEBUG         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region""); #endif         return 0;     }      leftbyte = (uint32_t) x >> 3;     dd = dst->data + y * dst->stride + leftbyte;     bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;     leftmask = 255>>(x&7);     rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));     if (bytewidth == 1)         leftmask &= rightmask;     late = (ss + bytewidth >= src->data + ((src->width+7)>>3));     ss += syoffset;      switch(op)     {     case JBIG2_COMPOSE_OR:         jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_AND:         jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_XOR:         jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_XNOR:         jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     case JBIG2_COMPOSE_REPLACE:         jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);         break;     }      return 0; }"
"kvm_vm_ioctl_check_extension_powerpc_cwe-476.c","CWE-476","int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext) { 	int r; 	/* Assume we're using HV mode when the HV module is loaded */ 	int hv_enabled = kvmppc_hv_ops ? 1 : 0;  	if (kvm) { 		/* 		 * Hooray - we know which VM type we're running on. Depend on 		 * that rather than the guess above. 		 */ 		hv_enabled = is_kvmppc_hv_enabled(kvm); 	}  	switch (ext) { #ifdef CONFIG_BOOKE 	case KVM_CAP_PPC_BOOKE_SREGS: 	case KVM_CAP_PPC_BOOKE_WATCHDOG: 	case KVM_CAP_PPC_EPR: #else 	case KVM_CAP_PPC_SEGSTATE: 	case KVM_CAP_PPC_HIOR: 	case KVM_CAP_PPC_PAPR: #endif 	case KVM_CAP_PPC_UNSET_IRQ: 	case KVM_CAP_PPC_IRQ_LEVEL: 	case KVM_CAP_ENABLE_CAP: 	case KVM_CAP_ENABLE_CAP_VM: 	case KVM_CAP_ONE_REG: 	case KVM_CAP_IOEVENTFD: 	case KVM_CAP_DEVICE_CTRL: 	case KVM_CAP_IMMEDIATE_EXIT: 		r = 1; 		break; 	case KVM_CAP_PPC_PAIRED_SINGLES: 	case KVM_CAP_PPC_OSI: 	case KVM_CAP_PPC_GET_PVINFO: #if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC) 	case KVM_CAP_SW_TLB: #endif 		/* We support this only for PR */ 		r = !hv_enabled; 		break; #ifdef CONFIG_KVM_MPIC 	case KVM_CAP_IRQ_MPIC: 		r = 1; 		break; #endif  #ifdef CONFIG_PPC_BOOK3S_64 	case KVM_CAP_SPAPR_TCE: 	case KVM_CAP_SPAPR_TCE_64: 		/* fallthrough */ 	case KVM_CAP_SPAPR_TCE_VFIO: 	case KVM_CAP_PPC_RTAS: 	case KVM_CAP_PPC_FIXUP_HCALL: 	case KVM_CAP_PPC_ENABLE_HCALL: #ifdef CONFIG_KVM_XICS 	case KVM_CAP_IRQ_XICS: #endif 		r = 1; 		break;  	case KVM_CAP_PPC_ALLOC_HTAB: 		r = hv_enabled; 		break; #endif /* CONFIG_PPC_BOOK3S_64 */ #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_SMT: 		r = 0; 		if (kvm) { 			if (kvm->arch.emul_smt_mode > 1) 				r = kvm->arch.emul_smt_mode; 			else 				r = kvm->arch.smt_mode; 		} else if (hv_enabled) { 			if (cpu_has_feature(CPU_FTR_ARCH_300)) 				r = 1; 			else 				r = threads_per_subcore; 		} 		break; 	case KVM_CAP_PPC_SMT_POSSIBLE: 		r = 1; 		if (hv_enabled) { 			if (!cpu_has_feature(CPU_FTR_ARCH_300)) 				r = ((threads_per_subcore << 1) - 1); 			else 				/* P9 can emulate dbells, so allow any mode */ 				r = 8 | 4 | 2 | 1; 		} 		break; 	case KVM_CAP_PPC_RMA: 		r = 0; 		break; 	case KVM_CAP_PPC_HWRNG: 		r = kvmppc_hwrng_present(); 		break; 	case KVM_CAP_PPC_MMU_RADIX: 		r = !!(hv_enabled && radix_enabled()); 		break; 	case KVM_CAP_PPC_MMU_HASH_V3: 		r = !!(hv_enabled && !radix_enabled() && 		       cpu_has_feature(CPU_FTR_ARCH_300)); 		break; #endif 	case KVM_CAP_SYNC_MMU: #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 		r = hv_enabled; #elif defined(KVM_ARCH_WANT_MMU_NOTIFIER) 		r = 1; #else 		r = 0; #endif 		break; #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_HTAB_FD: 		r = hv_enabled; 		break; #endif 	case KVM_CAP_NR_VCPUS: 		/* 		 * Recommending a number of CPUs is somewhat arbitrary; we 		 * return the number of present CPUs for -HV (since a host 		 * will have secondary threads ""offline""), and for other KVM 		 * implementations just count online CPUs. 		 */ 		if (hv_enabled) 			r = num_present_cpus(); 		else 			r = num_online_cpus(); 		break; 	case KVM_CAP_NR_MEMSLOTS: 		r = KVM_USER_MEM_SLOTS; 		break; 	case KVM_CAP_MAX_VCPUS: 		r = KVM_MAX_VCPUS; 		break; #ifdef CONFIG_PPC_BOOK3S_64 	case KVM_CAP_PPC_GET_SMMU_INFO: 		r = 1; 		break; 	case KVM_CAP_SPAPR_MULTITCE: 		r = 1; 		break; 	case KVM_CAP_SPAPR_RESIZE_HPT: 		/* Disable this on POWER9 until code handles new HPTE format */ 		r = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300); 		break; #endif #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_FWNMI: 		r = hv_enabled; 		break; #endif 	case KVM_CAP_PPC_HTM: 		r = cpu_has_feature(CPU_FTR_TM_COMP) && 		    is_kvmppc_hv_enabled(kvm); 		break; 	default: 		r = 0; 		break; 	} 	return r;  }"
"kvm_vm_ioctl_check_extension_powerpc_not_vulnerable.c","not_vulnerable","int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext) { 	int r; 	/* Assume we're using HV mode when the HV module is loaded */ 	int hv_enabled = kvmppc_hv_ops ? 1 : 0;  	if (kvm) { 		/* 		 * Hooray - we know which VM type we're running on. Depend on 		 * that rather than the guess above. 		 */ 		hv_enabled = is_kvmppc_hv_enabled(kvm); 	}  	switch (ext) { #ifdef CONFIG_BOOKE 	case KVM_CAP_PPC_BOOKE_SREGS: 	case KVM_CAP_PPC_BOOKE_WATCHDOG: 	case KVM_CAP_PPC_EPR: #else 	case KVM_CAP_PPC_SEGSTATE: 	case KVM_CAP_PPC_HIOR: 	case KVM_CAP_PPC_PAPR: #endif 	case KVM_CAP_PPC_UNSET_IRQ: 	case KVM_CAP_PPC_IRQ_LEVEL: 	case KVM_CAP_ENABLE_CAP: 	case KVM_CAP_ENABLE_CAP_VM: 	case KVM_CAP_ONE_REG: 	case KVM_CAP_IOEVENTFD: 	case KVM_CAP_DEVICE_CTRL: 	case KVM_CAP_IMMEDIATE_EXIT: 		r = 1; 		break; 	case KVM_CAP_PPC_PAIRED_SINGLES: 	case KVM_CAP_PPC_OSI: 	case KVM_CAP_PPC_GET_PVINFO: #if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC) 	case KVM_CAP_SW_TLB: #endif 		/* We support this only for PR */ 		r = !hv_enabled; 		break; #ifdef CONFIG_KVM_MPIC 	case KVM_CAP_IRQ_MPIC: 		r = 1; 		break; #endif  #ifdef CONFIG_PPC_BOOK3S_64 	case KVM_CAP_SPAPR_TCE: 	case KVM_CAP_SPAPR_TCE_64: 		/* fallthrough */ 	case KVM_CAP_SPAPR_TCE_VFIO: 	case KVM_CAP_PPC_RTAS: 	case KVM_CAP_PPC_FIXUP_HCALL: 	case KVM_CAP_PPC_ENABLE_HCALL: #ifdef CONFIG_KVM_XICS 	case KVM_CAP_IRQ_XICS: #endif 		r = 1; 		break;  	case KVM_CAP_PPC_ALLOC_HTAB: 		r = hv_enabled; 		break; #endif /* CONFIG_PPC_BOOK3S_64 */ #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_SMT: 		r = 0; 		if (kvm) { 			if (kvm->arch.emul_smt_mode > 1) 				r = kvm->arch.emul_smt_mode; 			else 				r = kvm->arch.smt_mode; 		} else if (hv_enabled) { 			if (cpu_has_feature(CPU_FTR_ARCH_300)) 				r = 1; 			else 				r = threads_per_subcore; 		} 		break; 	case KVM_CAP_PPC_SMT_POSSIBLE: 		r = 1; 		if (hv_enabled) { 			if (!cpu_has_feature(CPU_FTR_ARCH_300)) 				r = ((threads_per_subcore << 1) - 1); 			else 				/* P9 can emulate dbells, so allow any mode */ 				r = 8 | 4 | 2 | 1; 		} 		break; 	case KVM_CAP_PPC_RMA: 		r = 0; 		break; 	case KVM_CAP_PPC_HWRNG: 		r = kvmppc_hwrng_present(); 		break; 	case KVM_CAP_PPC_MMU_RADIX: 		r = !!(hv_enabled && radix_enabled()); 		break; 	case KVM_CAP_PPC_MMU_HASH_V3: 		r = !!(hv_enabled && !radix_enabled() && 		       cpu_has_feature(CPU_FTR_ARCH_300)); 		break; #endif 	case KVM_CAP_SYNC_MMU: #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 		r = hv_enabled; #elif defined(KVM_ARCH_WANT_MMU_NOTIFIER) 		r = 1; #else 		r = 0; #endif 		break; #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_HTAB_FD: 		r = hv_enabled; 		break; #endif 	case KVM_CAP_NR_VCPUS: 		/* 		 * Recommending a number of CPUs is somewhat arbitrary; we 		 * return the number of present CPUs for -HV (since a host 		 * will have secondary threads ""offline""), and for other KVM 		 * implementations just count online CPUs. 		 */ 		if (hv_enabled) 			r = num_present_cpus(); 		else 			r = num_online_cpus(); 		break; 	case KVM_CAP_NR_MEMSLOTS: 		r = KVM_USER_MEM_SLOTS; 		break; 	case KVM_CAP_MAX_VCPUS: 		r = KVM_MAX_VCPUS; 		break; #ifdef CONFIG_PPC_BOOK3S_64 	case KVM_CAP_PPC_GET_SMMU_INFO: 		r = 1; 		break; 	case KVM_CAP_SPAPR_MULTITCE: 		r = 1; 		break; 	case KVM_CAP_SPAPR_RESIZE_HPT: 		/* Disable this on POWER9 until code handles new HPTE format */ 		r = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300); 		break; #endif #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE 	case KVM_CAP_PPC_FWNMI: 		r = hv_enabled; 		break; #endif 	case KVM_CAP_PPC_HTM: 		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled; 		break; 	default: 		r = 0; 		break; 	} 	return r;  }"
"luaD_shrinkstack_ldo_cwe-416.c","CWE-416","void luaD_shrinkstack (lua_State *L) {   int inuse = stackinuse(L);   int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;   if (goodsize > LUAI_MAXSTACK)     goodsize = LUAI_MAXSTACK;  /* respect stack limit */   /* if thread is currently not handling a stack overflow and its      good size is smaller than current size, shrink its stack */   if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&       goodsize < L->stacksize)     luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */   else  /* don't change stack */     condmovestack(L,{},{});  /* (change only for debugging) */   luaE_shrinkCI(L);  /* shrink CI list */ }"
"luaD_shrinkstack_ldo_not_vulnerable.c","not_vulnerable","void luaD_shrinkstack (lua_State *L) {   int inuse = stackinuse(L);   int goodsize = inuse + BASIC_STACK_SIZE;   if (goodsize > LUAI_MAXSTACK)     goodsize = LUAI_MAXSTACK;  /* respect stack limit */   /* if thread is currently not handling a stack overflow and its      good size is smaller than current size, shrink its stack */   if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)     luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */   else  /* don't change stack */     condmovestack(L,{},{});  /* (change only for debugging) */   luaE_shrinkCI(L);  /* shrink CI list */ }"
"lys_restr_dup_tree_schema_cwe-476.c","CWE-476","lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres) {     struct lys_restr *result;     int i;      if (!size) {         return NULL;     }      result = calloc(size, sizeof *result);     LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);      for (i = 0; i < size; i++) {         result[i].ext_size = old[i].ext_size;         lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);         result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);         result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);         result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);         result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);         result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);     }      return result; }"
"lys_restr_dup_tree_schema_not_vulnerable.c","not_vulnerable","lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres) {     struct lys_restr *result;     int i;      if (!size) {         return NULL;     }      result = calloc(size, sizeof *result);     LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);      for (i = 0; i < size; i++) {         /* copying unresolved extensions is not supported */         if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {             result[i].ext_size = old[i].ext_size;             lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);         }         result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);         result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);         result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);         result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);         result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);     }      return result; }"
"make_canonical_parser_cwe-787.c","CWE-787","make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2) {     const uint16_t buf_len = 511;     char buf[buf_len + 1];     struct lys_type_bit **bits = NULL;     struct lyxp_expr *exp;     const char *module_name, *cur_expr, *end;     int i, j, count;     int64_t num;     uint64_t unum;     uint8_t c;  #define LOGBUF(str) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)      switch (type) {     case LY_TYPE_BITS:         bits = (struct lys_type_bit **)data1;         count = *((int *)data2);         /* in canonical form, the bits are ordered by their position */         buf[0] = '\0';         for (i = 0; i < count; i++) {             if (!bits[i]) {                 /* bit not set */                 continue;             }             if (buf[0]) {                 LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);                 sprintf(buf + strlen(buf), "" %s"", bits[i]->name);             } else {                 LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);                 strcpy(buf, bits[i]->name);             }         }         break;      case LY_TYPE_IDENT:         module_name = (const char *)data1;         /* identity must always have a prefix */         if (!strchr(*value, ':')) {             sprintf(buf, ""%s:%s"", module_name, *value);         } else {             strcpy(buf, *value);         }         break;      case LY_TYPE_INST:         exp = lyxp_parse_expr(ctx, *value);         LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);          module_name = NULL;         count = 0;         for (i = 0; (unsigned)i < exp->used; ++i) {             cur_expr = &exp->expr[exp->expr_pos[i]];              /* copy WS */             if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {                 if (count + (cur_expr - end) > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(end);                     return -1;                 }                 strncpy(&buf[count], end, cur_expr - end);                 count += cur_expr - end;             }              if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {                 /* get the module name with "":"" */                 ++end;                 j = end - cur_expr;                  if (!module_name || strncmp(cur_expr, module_name, j)) {                     /* print module name with colon, it does not equal to the parent one */                     if (count + j > buf_len) {                         lyxp_expr_free(exp);                         LOGBUF(cur_expr);                         return -1;                     }                     strncpy(&buf[count], cur_expr, j);                     count += j;                 }                 module_name = cur_expr;                  /* copy the rest */                 if (count + (exp->tok_len[i] - j) > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(end);                     return -1;                 }                 strncpy(&buf[count], end, exp->tok_len[i] - j);                 count += exp->tok_len[i] - j;             } else {                 if (count + exp->tok_len[i] > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(&exp->expr[exp->expr_pos[i]]);                     return -1;                 }                 strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);                 count += exp->tok_len[i];             }         }         if (count > buf_len) {             LOGINT(ctx);             lyxp_expr_free(exp);             return -1;         }         buf[count] = '\0';          lyxp_expr_free(exp);         break;      case LY_TYPE_DEC64:         num = *((int64_t *)data1);         c = *((uint8_t *)data2);         if (num) {             count = sprintf(buf, ""%""PRId64"" "", num);             if ( (num > 0 && (count - 1) <= c)                  || (count - 2) <= c ) {                 /* we have 0. value, print the value with the leading zeros                  * (one for 0. and also keep the correct with of num according                  * to fraction-digits value)                  * for (num<0) - extra character for '-' sign */                 count = sprintf(buf, ""%0*""PRId64"" "", (num > 0) ? (c + 1) : (c + 2), num);             }             for (i = c, j = 1; i > 0 ; i--) {                 if (j && i > 1 && buf[count - 2] == '0') {                     /* we have trailing zero to skip */                     buf[count - 1] = '\0';                 } else {                     j = 0;                     buf[count - 1] = buf[count - 2];                 }                 count--;             }             buf[count - 1] = '.';         } else {             /* zero */             sprintf(buf, ""0.0"");         }         break;      case LY_TYPE_INT8:     case LY_TYPE_INT16:     case LY_TYPE_INT32:     case LY_TYPE_INT64:         num = *((int64_t *)data1);         sprintf(buf, ""%""PRId64, num);         break;      case LY_TYPE_UINT8:     case LY_TYPE_UINT16:     case LY_TYPE_UINT32:     case LY_TYPE_UINT64:         unum = *((uint64_t *)data1);         sprintf(buf, ""%""PRIu64, unum);         break;      default:         /* should not be even called - just do nothing */         return 0;     }      if (strcmp(buf, *value)) {         lydict_remove(ctx, *value);         *value = lydict_insert(ctx, buf, 0);         return 1;     }      return 0;  #undef LOGBUF }"
"make_canonical_parser_not_vulnerable.c","not_vulnerable","make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2) {     const uint16_t buf_len = 511;     char buf[buf_len + 1];     struct lys_type_bit **bits = NULL;     struct lyxp_expr *exp;     const char *module_name, *cur_expr, *end;     int i, j, count;     int64_t num;     uint64_t unum;     uint8_t c;  #define LOGBUF(str) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)      switch (type) {     case LY_TYPE_BITS:         bits = (struct lys_type_bit **)data1;         count = *((int *)data2);         /* in canonical form, the bits are ordered by their position */         buf[0] = '\0';         for (i = 0; i < count; i++) {             if (!bits[i]) {                 /* bit not set */                 continue;             }             if (buf[0]) {                 LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);                 sprintf(buf + strlen(buf), "" %s"", bits[i]->name);             } else {                 LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);                 strcpy(buf, bits[i]->name);             }         }         break;      case LY_TYPE_IDENT:         module_name = (const char *)data1;         /* identity must always have a prefix */         if (!strchr(*value, ':')) {             LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);             sprintf(buf, ""%s:%s"", module_name, *value);         } else {             LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);             strcpy(buf, *value);         }         break;      case LY_TYPE_INST:         exp = lyxp_parse_expr(ctx, *value);         LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);          module_name = NULL;         count = 0;         for (i = 0; (unsigned)i < exp->used; ++i) {             cur_expr = &exp->expr[exp->expr_pos[i]];              /* copy WS */             if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {                 if (count + (cur_expr - end) > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(end);                     return -1;                 }                 strncpy(&buf[count], end, cur_expr - end);                 count += cur_expr - end;             }              if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {                 /* get the module name with "":"" */                 ++end;                 j = end - cur_expr;                  if (!module_name || strncmp(cur_expr, module_name, j)) {                     /* print module name with colon, it does not equal to the parent one */                     if (count + j > buf_len) {                         lyxp_expr_free(exp);                         LOGBUF(cur_expr);                         return -1;                     }                     strncpy(&buf[count], cur_expr, j);                     count += j;                 }                 module_name = cur_expr;                  /* copy the rest */                 if (count + (exp->tok_len[i] - j) > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(end);                     return -1;                 }                 strncpy(&buf[count], end, exp->tok_len[i] - j);                 count += exp->tok_len[i] - j;             } else {                 if (count + exp->tok_len[i] > buf_len) {                     lyxp_expr_free(exp);                     LOGBUF(&exp->expr[exp->expr_pos[i]]);                     return -1;                 }                 strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);                 count += exp->tok_len[i];             }         }         if (count > buf_len) {             LOGINT(ctx);             lyxp_expr_free(exp);             return -1;         }         buf[count] = '\0';          lyxp_expr_free(exp);         break;      case LY_TYPE_DEC64:         num = *((int64_t *)data1);         c = *((uint8_t *)data2);         if (num) {             count = sprintf(buf, ""%""PRId64"" "", num);             if ( (num > 0 && (count - 1) <= c)                  || (count - 2) <= c ) {                 /* we have 0. value, print the value with the leading zeros                  * (one for 0. and also keep the correct with of num according                  * to fraction-digits value)                  * for (num<0) - extra character for '-' sign */                 count = sprintf(buf, ""%0*""PRId64"" "", (num > 0) ? (c + 1) : (c + 2), num);             }             for (i = c, j = 1; i > 0 ; i--) {                 if (j && i > 1 && buf[count - 2] == '0') {                     /* we have trailing zero to skip */                     buf[count - 1] = '\0';                 } else {                     j = 0;                     buf[count - 1] = buf[count - 2];                 }                 count--;             }             buf[count - 1] = '.';         } else {             /* zero */             sprintf(buf, ""0.0"");         }         break;      case LY_TYPE_INT8:     case LY_TYPE_INT16:     case LY_TYPE_INT32:     case LY_TYPE_INT64:         num = *((int64_t *)data1);         sprintf(buf, ""%""PRId64, num);         break;      case LY_TYPE_UINT8:     case LY_TYPE_UINT16:     case LY_TYPE_UINT32:     case LY_TYPE_UINT64:         unum = *((uint64_t *)data1);         sprintf(buf, ""%""PRIu64, unum);         break;      default:         /* should not be even called - just do nothing */         return 0;     }      if (strcmp(buf, *value)) {         lydict_remove(ctx, *value);         *value = lydict_insert(ctx, buf, 0);         return 1;     }      return 0;  #undef LOGBUF }"
"matchCurrentInput_lou_translateString_cwe-125.c","CWE-125","matchCurrentInput( 		const InString *input, int pos, const widechar *passInstructions, int passIC) { 	int k; 	int kk = pos; 	for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++) 		if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++]) 			return 0; 	return 1; }"
"matchCurrentInput_lou_translateString_not_vulnerable.c","not_vulnerable","matchCurrentInput( 		const InString *input, int pos, const widechar *passInstructions, int passIC) { 	int k; 	int kk = pos; 	for (k = passIC + 2; 			((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length)); 			k++) 		if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++]) 			return 0; 	return 1; }"
"megasas_alloc_cmds_megaraid_sas_base_cwe-476.c","CWE-476","int megasas_alloc_cmds(struct megasas_instance *instance) { 	int i; 	int j; 	u16 max_cmd; 	struct megasas_cmd *cmd;  	max_cmd = instance->max_mfi_cmds;  	/* 	 * instance->cmd_list is an array of struct megasas_cmd pointers. 	 * Allocate the dynamic array first and then allocate individual 	 * commands. 	 */ 	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);  	if (!instance->cmd_list) { 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n""); 		return -ENOMEM; 	}  	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);  	for (i = 0; i < max_cmd; i++) { 		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd), 						GFP_KERNEL);  		if (!instance->cmd_list[i]) {  			for (j = 0; j < i; j++) 				kfree(instance->cmd_list[j]);  			kfree(instance->cmd_list); 			instance->cmd_list = NULL;  			return -ENOMEM; 		} 	}  	for (i = 0; i < max_cmd; i++) { 		cmd = instance->cmd_list[i]; 		memset(cmd, 0, sizeof(struct megasas_cmd)); 		cmd->index = i; 		cmd->scmd = NULL; 		cmd->instance = instance;  		list_add_tail(&cmd->list, &instance->cmd_pool); 	}  	/* 	 * Create a frame pool and assign one frame to each cmd 	 */ 	if (megasas_create_frame_pool(instance)) { 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n""); 		megasas_free_cmds(instance); 	}  	return 0; }"
"megasas_alloc_cmds_megaraid_sas_base_not_vulnerable.c","not_vulnerable","int megasas_alloc_cmds(struct megasas_instance *instance) { 	int i; 	int j; 	u16 max_cmd; 	struct megasas_cmd *cmd;  	max_cmd = instance->max_mfi_cmds;  	/* 	 * instance->cmd_list is an array of struct megasas_cmd pointers. 	 * Allocate the dynamic array first and then allocate individual 	 * commands. 	 */ 	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);  	if (!instance->cmd_list) { 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n""); 		return -ENOMEM; 	}  	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);  	for (i = 0; i < max_cmd; i++) { 		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd), 						GFP_KERNEL);  		if (!instance->cmd_list[i]) {  			for (j = 0; j < i; j++) 				kfree(instance->cmd_list[j]);  			kfree(instance->cmd_list); 			instance->cmd_list = NULL;  			return -ENOMEM; 		} 	}  	for (i = 0; i < max_cmd; i++) { 		cmd = instance->cmd_list[i]; 		memset(cmd, 0, sizeof(struct megasas_cmd)); 		cmd->index = i; 		cmd->scmd = NULL; 		cmd->instance = instance;  		list_add_tail(&cmd->list, &instance->cmd_pool); 	}  	/* 	 * Create a frame pool and assign one frame to each cmd 	 */ 	if (megasas_create_frame_pool(instance)) { 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n""); 		megasas_free_cmds(instance); 		return -ENOMEM; 	}  	return 0; }"
"mpol_parse_str_mempolicy_cwe-787.c","CWE-787","int mpol_parse_str(char *str, struct mempolicy **mpol) { 	struct mempolicy *new = NULL; 	unsigned short mode_flags; 	nodemask_t nodes; 	char *nodelist = strchr(str, ':'); 	char *flags = strchr(str, '='); 	int err = 1, mode;  	if (flags) 		*flags++ = '\0';	/* terminate mode string */  	if (nodelist) { 		/* NUL-terminate mode or flags string */ 		*nodelist++ = '\0'; 		if (nodelist_parse(nodelist, nodes)) 			goto out; 		if (!nodes_subset(nodes, node_states[N_MEMORY])) 			goto out; 	} else 		nodes_clear(nodes);  	mode = match_string(policy_modes, MPOL_MAX, str); 	if (mode < 0) 		goto out;  	switch (mode) { 	case MPOL_PREFERRED: 		/* 		 * Insist on a nodelist of one node only 		 */ 		if (nodelist) { 			char *rest = nodelist; 			while (isdigit(*rest)) 				rest++; 			if (*rest) 				goto out; 		} 		break; 	case MPOL_INTERLEAVE: 		/* 		 * Default to online nodes with memory if no nodelist 		 */ 		if (!nodelist) 			nodes = node_states[N_MEMORY]; 		break; 	case MPOL_LOCAL: 		/* 		 * Don't allow a nodelist;  mpol_new() checks flags 		 */ 		if (nodelist) 			goto out; 		mode = MPOL_PREFERRED; 		break; 	case MPOL_DEFAULT: 		/* 		 * Insist on a empty nodelist 		 */ 		if (!nodelist) 			err = 0; 		goto out; 	case MPOL_BIND: 		/* 		 * Insist on a nodelist 		 */ 		if (!nodelist) 			goto out; 	}  	mode_flags = 0; 	if (flags) { 		/* 		 * Currently, we only support two mutually exclusive 		 * mode flags. 		 */ 		if (!strcmp(flags, ""static"")) 			mode_flags |= MPOL_F_STATIC_NODES; 		else if (!strcmp(flags, ""relative"")) 			mode_flags |= MPOL_F_RELATIVE_NODES; 		else 			goto out; 	}  	new = mpol_new(mode, mode_flags, &nodes); 	if (IS_ERR(new)) 		goto out;  	/* 	 * Save nodes for mpol_to_str() to show the tmpfs mount options 	 * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo. 	 */ 	if (mode != MPOL_PREFERRED) 		new->v.nodes = nodes; 	else if (nodelist) 		new->v.preferred_node = first_node(nodes); 	else 		new->flags |= MPOL_F_LOCAL;  	/* 	 * Save nodes for contextualization: this will be used to ""clone"" 	 * the mempolicy in a specific context [cpuset] at a later time. 	 */ 	new->w.user_nodemask = nodes;  	err = 0;  out: 	/* Restore string for error message */ 	if (nodelist) 		*--nodelist = ':'; 	if (flags) 		*--flags = '='; 	if (!err) 		*mpol = new; 	return err; }"
"mpol_parse_str_mempolicy_not_vulnerable.c","not_vulnerable","int mpol_parse_str(char *str, struct mempolicy **mpol) { 	struct mempolicy *new = NULL; 	unsigned short mode_flags; 	nodemask_t nodes; 	char *nodelist = strchr(str, ':'); 	char *flags = strchr(str, '='); 	int err = 1, mode;  	if (flags) 		*flags++ = '\0';	/* terminate mode string */  	if (nodelist) { 		/* NUL-terminate mode or flags string */ 		*nodelist++ = '\0'; 		if (nodelist_parse(nodelist, nodes)) 			goto out; 		if (!nodes_subset(nodes, node_states[N_MEMORY])) 			goto out; 	} else 		nodes_clear(nodes);  	mode = match_string(policy_modes, MPOL_MAX, str); 	if (mode < 0) 		goto out;  	switch (mode) { 	case MPOL_PREFERRED: 		/* 		 * Insist on a nodelist of one node only, although later 		 * we use first_node(nodes) to grab a single node, so here 		 * nodelist (or nodes) cannot be empty. 		 */ 		if (nodelist) { 			char *rest = nodelist; 			while (isdigit(*rest)) 				rest++; 			if (*rest) 				goto out; 			if (nodes_empty(nodes)) 				goto out; 		} 		break; 	case MPOL_INTERLEAVE: 		/* 		 * Default to online nodes with memory if no nodelist 		 */ 		if (!nodelist) 			nodes = node_states[N_MEMORY]; 		break; 	case MPOL_LOCAL: 		/* 		 * Don't allow a nodelist;  mpol_new() checks flags 		 */ 		if (nodelist) 			goto out; 		mode = MPOL_PREFERRED; 		break; 	case MPOL_DEFAULT: 		/* 		 * Insist on a empty nodelist 		 */ 		if (!nodelist) 			err = 0; 		goto out; 	case MPOL_BIND: 		/* 		 * Insist on a nodelist 		 */ 		if (!nodelist) 			goto out; 	}  	mode_flags = 0; 	if (flags) { 		/* 		 * Currently, we only support two mutually exclusive 		 * mode flags. 		 */ 		if (!strcmp(flags, ""static"")) 			mode_flags |= MPOL_F_STATIC_NODES; 		else if (!strcmp(flags, ""relative"")) 			mode_flags |= MPOL_F_RELATIVE_NODES; 		else 			goto out; 	}  	new = mpol_new(mode, mode_flags, &nodes); 	if (IS_ERR(new)) 		goto out;  	/* 	 * Save nodes for mpol_to_str() to show the tmpfs mount options 	 * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo. 	 */ 	if (mode != MPOL_PREFERRED) 		new->v.nodes = nodes; 	else if (nodelist) 		new->v.preferred_node = first_node(nodes); 	else 		new->flags |= MPOL_F_LOCAL;  	/* 	 * Save nodes for contextualization: this will be used to ""clone"" 	 * the mempolicy in a specific context [cpuset] at a later time. 	 */ 	new->w.user_nodemask = nodes;  	err = 0;  out: 	/* Restore string for error message */ 	if (nodelist) 		*--nodelist = ':'; 	if (flags) 		*--flags = '='; 	if (!err) 		*mpol = new; 	return err; }"
"mxf_parse_structural_metadata_mxfdec_cwe-125.c","CWE-125","static int mxf_parse_structural_metadata(MXFContext *mxf) {     MXFPackage *material_package = NULL;     int i, j, k, ret;      av_log(mxf->fc, AV_LOG_TRACE, ""metadata sets count %d\n"", mxf->metadata_sets_count);     /* TODO: handle multiple material packages (OP3x) */     for (i = 0; i < mxf->packages_count; i++) {         material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);         if (material_package) break;     }     if (!material_package) {         av_log(mxf->fc, AV_LOG_ERROR, ""no material package found\n"");         return AVERROR_INVALIDDATA;     }      mxf_add_umid_metadata(&mxf->fc->metadata, ""material_package_umid"", material_package);     if (material_package->name && material_package->name[0])         av_dict_set(&mxf->fc->metadata, ""material_package_name"", material_package->name, 0);     mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);      for (i = 0; i < material_package->tracks_count; i++) {         MXFPackage *source_package = NULL;         MXFTrack *material_track = NULL;         MXFTrack *source_track = NULL;         MXFTrack *temp_track = NULL;         MXFDescriptor *descriptor = NULL;         MXFStructuralComponent *component = NULL;         MXFTimecodeComponent *mxf_tc = NULL;         UID *essence_container_ul = NULL;         const MXFCodecUL *codec_ul = NULL;         const MXFCodecUL *container_ul = NULL;         const MXFCodecUL *pix_fmt_ul = NULL;         AVStream *st;         AVTimecode tc;         int flags;          if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track strong ref\n"");             continue;         }          if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {             mxf_tc = (MXFTimecodeComponent*)component;             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);             }         }          if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track sequence strong ref\n"");             continue;         }          for (j = 0; j < material_track->sequence->structural_components_count; j++) {             component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);             if (!component)                 continue;              mxf_tc = (MXFTimecodeComponent*)component;             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);                 break;             }         }          /* TODO: handle multiple source clips, only finds first valid source clip */         if(material_track->sequence->structural_components_count > 1)             av_log(mxf->fc, AV_LOG_WARNING, ""material track %d: has %d components\n"",                        material_track->track_id, material_track->sequence->structural_components_count);          for (j = 0; j < material_track->sequence->structural_components_count; j++) {             component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);             if (!component)                 continue;              source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);             if (!source_package) {                 av_log(mxf->fc, AV_LOG_TRACE, ""material track %d: no corresponding source package found\n"", material_track->track_id);                 continue;             }             for (k = 0; k < source_package->tracks_count; k++) {                 if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {                     av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track strong ref\n"");                     ret = AVERROR_INVALIDDATA;                     goto fail_and_free;                 }                 if (temp_track->track_id == component->source_track_id) {                     source_track = temp_track;                     break;                 }             }             if (!source_track) {                 av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source track found\n"", material_track->track_id);                 break;             }              for (k = 0; k < mxf->essence_container_data_count; k++) {                 MXFEssenceContainerData *essence_data;                  if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {                     av_log(mxf, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");                     continue;                 }                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {                     source_track->body_sid = essence_data->body_sid;                     source_track->index_sid = essence_data->index_sid;                     break;                 }             }              if(source_track && component)                 break;         }         if (!source_track || !component || !source_package) {             if((ret = mxf_add_metadata_stream(mxf, material_track)))                 goto fail_and_free;             continue;         }          if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track sequence strong ref\n"");             ret = AVERROR_INVALIDDATA;             goto fail_and_free;         }          /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf          * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */         if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {             av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: DataDefinition mismatch\n"", material_track->track_id);             continue;         }          st = avformat_new_stream(mxf->fc, NULL);         if (!st) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not allocate stream\n"");             ret = AVERROR(ENOMEM);             goto fail_and_free;         }         st->id = material_track->track_id;         st->priv_data = source_track;          source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);         descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);          /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many          * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */         if (descriptor && descriptor->duration != AV_NOPTS_VALUE)             source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);         else             source_track->original_duration = st->duration = component->duration;          if (st->duration == -1)             st->duration = AV_NOPTS_VALUE;         st->start_time = component->start_position;         if (material_track->edit_rate.num <= 0 ||             material_track->edit_rate.den <= 0) {             av_log(mxf->fc, AV_LOG_WARNING,                    ""Invalid edit rate (%d/%d) found on stream #%d, ""                    ""defaulting to 25/1\n"",                    material_track->edit_rate.num,                    material_track->edit_rate.den, st->index);             material_track->edit_rate = (AVRational){25, 1};         }         avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);          /* ensure SourceTrack EditRate == MaterialTrack EditRate since only          * the former is accessible via st->priv_data */         source_track->edit_rate = material_track->edit_rate;          PRINT_KEY(mxf->fc, ""data definition   ul"", source_track->sequence->data_definition_ul);         codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);         st->codecpar->codec_type = codec_ul->id;          if (!descriptor) {             av_log(mxf->fc, AV_LOG_INFO, ""source track %d: stream %d, no descriptor found\n"", source_track->track_id, st->index);             continue;         }         PRINT_KEY(mxf->fc, ""essence codec     ul"", descriptor->essence_codec_ul);         PRINT_KEY(mxf->fc, ""essence container ul"", descriptor->essence_container_ul);         essence_container_ul = &descriptor->essence_container_ul;         source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);         if (source_track->wrapping == UnknownWrapped)             av_log(mxf->fc, AV_LOG_INFO, ""wrapping of stream %d is unknown\n"", st->index);         /* HACK: replacing the original key with mxf_encrypted_essence_container          * is not allowed according to s429-6, try to find correct information anyway */         if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {             av_log(mxf->fc, AV_LOG_INFO, ""broken encrypted mxf file\n"");             for (k = 0; k < mxf->metadata_sets_count; k++) {                 MXFMetadataSet *metadata = mxf->metadata_sets[k];                 if (metadata->type == CryptoContext) {                     essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;                     break;                 }             }         }          /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */         codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);         st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;         if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {             codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);             st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;         }          av_log(mxf->fc, AV_LOG_VERBOSE, ""%s: Universal Label: "",                avcodec_get_name(st->codecpar->codec_id));         for (k = 0; k < 16; k++) {             av_log(mxf->fc, AV_LOG_VERBOSE, ""%.2x"",                    descriptor->essence_codec_ul[k]);             if (!(k+1 & 19) || k == 5)                 av_log(mxf->fc, AV_LOG_VERBOSE, ""."");         }         av_log(mxf->fc, AV_LOG_VERBOSE, ""\n"");          mxf_add_umid_metadata(&st->metadata, ""file_package_umid"", source_package);         if (source_package->name && source_package->name[0])             av_dict_set(&st->metadata, ""file_package_name"", source_package->name, 0);         if (material_track->name && material_track->name[0])             av_dict_set(&st->metadata, ""track_name"", material_track->name, 0);          mxf_parse_physical_source_package(mxf, source_track, st);          if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {             source_track->intra_only = mxf_is_intra_only(descriptor);             container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)                 st->codecpar->codec_id = container_ul->id;             st->codecpar->width = descriptor->width;             st->codecpar->height = descriptor->height; /* Field height, not frame height */             switch (descriptor->frame_layout) {                 case FullFrame:                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;                     break;                 case OneField:                     /* Every other line is stored and needs to be duplicated. */                     av_log(mxf->fc, AV_LOG_INFO, ""OneField frame layout isn't currently supported\n"");                     break; /* The correct thing to do here is fall through, but by breaking we might be                               able to decode some streams at half the vertical resolution, rather than not al all.                               It's also for compatibility with the old behavior. */                 case MixedFields:                     break;                 case SegmentedFrame:                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;                 case SeparateFields:                     av_log(mxf->fc, AV_LOG_DEBUG, ""video_line_map: (%d, %d), field_dominance: %d\n"",                            descriptor->video_line_map[0], descriptor->video_line_map[1],                            descriptor->field_dominance);                     if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {                         /* Detect coded field order from VideoLineMap:                          *  (even, even) => bottom field coded first                          *  (even, odd)  => top field coded first                          *  (odd, even)  => top field coded first                          *  (odd, odd)   => bottom field coded first                          */                         if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {                             switch (descriptor->field_dominance) {                                 case MXF_FIELD_DOMINANCE_DEFAULT:                                 case MXF_FIELD_DOMINANCE_FF:                                     st->codecpar->field_order = AV_FIELD_TT;                                     break;                                 case MXF_FIELD_DOMINANCE_FL:                                     st->codecpar->field_order = AV_FIELD_TB;                                     break;                                 default:                                     avpriv_request_sample(mxf->fc,                                                           ""Field dominance %d support"",                                                           descriptor->field_dominance);                             }                         } else {                             switch (descriptor->field_dominance) {                                 case MXF_FIELD_DOMINANCE_DEFAULT:                                 case MXF_FIELD_DOMINANCE_FF:                                     st->codecpar->field_order = AV_FIELD_BB;                                     break;                                 case MXF_FIELD_DOMINANCE_FL:                                     st->codecpar->field_order = AV_FIELD_BT;                                     break;                                 default:                                     avpriv_request_sample(mxf->fc,                                                           ""Field dominance %d support"",                                                           descriptor->field_dominance);                             }                         }                     }                     /* Turn field height into frame height. */                     st->codecpar->height *= 2;                     break;                 default:                     av_log(mxf->fc, AV_LOG_INFO, ""Unknown frame layout type: %d\n"", descriptor->frame_layout);             }             if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {                 st->codecpar->format = descriptor->pix_fmt;                 if (st->codecpar->format == AV_PIX_FMT_NONE) {                     pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,                                                   &descriptor->essence_codec_ul);                     st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;                     if (st->codecpar->format== AV_PIX_FMT_NONE) {                         st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,                                                                    &descriptor->essence_codec_ul)->id;                         if (!st->codecpar->codec_tag) {                             /* support files created before RP224v10 by defaulting to UYVY422                                if subsampling is 4:2:2 and component depth is 8-bit */                             if (descriptor->horiz_subsampling == 2 &&                                 descriptor->vert_subsampling == 1 &&                                 descriptor->component_depth == 8) {                                 st->codecpar->format = AV_PIX_FMT_UYVY422;                             }                         }                     }                 }             }             st->need_parsing = AVSTREAM_PARSE_HEADERS;             if (material_track->sequence->origin) {                 av_dict_set_int(&st->metadata, ""material_track_origin"", material_track->sequence->origin, 0);             }             if (source_track->sequence->origin) {                 av_dict_set_int(&st->metadata, ""source_track_origin"", source_track->sequence->origin, 0);             }             if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)                 st->display_aspect_ratio = descriptor->aspect_ratio;         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {             container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);             /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */             if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))                 st->codecpar->codec_id = (enum AVCodecID)container_ul->id;             st->codecpar->channels = descriptor->channels;             st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;              if (descriptor->sample_rate.den > 0) {                 st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;                 avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);             } else {                 av_log(mxf->fc, AV_LOG_WARNING, ""invalid sample rate (%d/%d) ""                        ""found for stream #%d, time base forced to 1/48000\n"",                        descriptor->sample_rate.num, descriptor->sample_rate.den,                        st->index);                 avpriv_set_pts_info(st, 64, 1, 48000);             }              /* if duration is set, rescale it from EditRate to SampleRate */             if (st->duration != AV_NOPTS_VALUE)                 st->duration = av_rescale_q(st->duration,                                             av_inv_q(material_track->edit_rate),                                             st->time_base);              /* TODO: implement AV_CODEC_ID_RAWAUDIO */             if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;                 else if (descriptor->bits_per_sample == 32)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;             } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;                 else if (descriptor->bits_per_sample == 32)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;             } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {                 st->need_parsing = AVSTREAM_PARSE_FULL;             }         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {             enum AVMediaType type;             container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)                 st->codecpar->codec_id = container_ul->id;             type = avcodec_get_type(st->codecpar->codec_id);             if (type == AVMEDIA_TYPE_SUBTITLE)                 st->codecpar->codec_type = type;             if (container_ul->desc)                 av_dict_set(&st->metadata, ""data_type"", container_ul->desc, 0);         }         if (descriptor->extradata) {             if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {                 memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);             }         } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {             int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,                                                &descriptor->essence_codec_ul)->id;             if (coded_width)                 st->codecpar->width = coded_width;             ret = ff_generate_avci_extradata(st);             if (ret < 0)                 return ret;         }         if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {             /* TODO: decode timestamps */             st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;         }     }      ret = 0; fail_and_free:     return ret; }"
"mxf_parse_structural_metadata_mxfdec_not_vulnerable.c","not_vulnerable","static int mxf_parse_structural_metadata(MXFContext *mxf) {     MXFPackage *material_package = NULL;     int i, j, k, ret;      av_log(mxf->fc, AV_LOG_TRACE, ""metadata sets count %d\n"", mxf->metadata_sets_count);     /* TODO: handle multiple material packages (OP3x) */     for (i = 0; i < mxf->packages_count; i++) {         material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);         if (material_package) break;     }     if (!material_package) {         av_log(mxf->fc, AV_LOG_ERROR, ""no material package found\n"");         return AVERROR_INVALIDDATA;     }      mxf_add_umid_metadata(&mxf->fc->metadata, ""material_package_umid"", material_package);     if (material_package->name && material_package->name[0])         av_dict_set(&mxf->fc->metadata, ""material_package_name"", material_package->name, 0);     mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);      for (i = 0; i < material_package->tracks_count; i++) {         MXFPackage *source_package = NULL;         MXFTrack *material_track = NULL;         MXFTrack *source_track = NULL;         MXFTrack *temp_track = NULL;         MXFDescriptor *descriptor = NULL;         MXFStructuralComponent *component = NULL;         MXFTimecodeComponent *mxf_tc = NULL;         UID *essence_container_ul = NULL;         const MXFCodecUL *codec_ul = NULL;         const MXFCodecUL *container_ul = NULL;         const MXFCodecUL *pix_fmt_ul = NULL;         AVStream *st;         AVTimecode tc;         int flags;          if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track strong ref\n"");             continue;         }          if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {             mxf_tc = (MXFTimecodeComponent*)component;             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);             }         }          if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track sequence strong ref\n"");             continue;         }          for (j = 0; j < material_track->sequence->structural_components_count; j++) {             component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);             if (!component)                 continue;              mxf_tc = (MXFTimecodeComponent*)component;             flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;             if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {                 mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc);                 break;             }         }          /* TODO: handle multiple source clips, only finds first valid source clip */         if(material_track->sequence->structural_components_count > 1)             av_log(mxf->fc, AV_LOG_WARNING, ""material track %d: has %d components\n"",                        material_track->track_id, material_track->sequence->structural_components_count);          for (j = 0; j < material_track->sequence->structural_components_count; j++) {             component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);             if (!component)                 continue;              source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);             if (!source_package) {                 av_log(mxf->fc, AV_LOG_TRACE, ""material track %d: no corresponding source package found\n"", material_track->track_id);                 continue;             }             for (k = 0; k < source_package->tracks_count; k++) {                 if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {                     av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track strong ref\n"");                     ret = AVERROR_INVALIDDATA;                     goto fail_and_free;                 }                 if (temp_track->track_id == component->source_track_id) {                     source_track = temp_track;                     break;                 }             }             if (!source_track) {                 av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source track found\n"", material_track->track_id);                 break;             }              for (k = 0; k < mxf->essence_container_data_count; k++) {                 MXFEssenceContainerData *essence_data;                  if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {                     av_log(mxf->fc, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");                     continue;                 }                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {                     source_track->body_sid = essence_data->body_sid;                     source_track->index_sid = essence_data->index_sid;                     break;                 }             }              if(source_track && component)                 break;         }         if (!source_track || !component || !source_package) {             if((ret = mxf_add_metadata_stream(mxf, material_track)))                 goto fail_and_free;             continue;         }          if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track sequence strong ref\n"");             ret = AVERROR_INVALIDDATA;             goto fail_and_free;         }          /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf          * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */         if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {             av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: DataDefinition mismatch\n"", material_track->track_id);             continue;         }          st = avformat_new_stream(mxf->fc, NULL);         if (!st) {             av_log(mxf->fc, AV_LOG_ERROR, ""could not allocate stream\n"");             ret = AVERROR(ENOMEM);             goto fail_and_free;         }         st->id = material_track->track_id;         st->priv_data = source_track;          source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);         descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);          /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many          * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */         if (descriptor && descriptor->duration != AV_NOPTS_VALUE)             source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);         else             source_track->original_duration = st->duration = component->duration;          if (st->duration == -1)             st->duration = AV_NOPTS_VALUE;         st->start_time = component->start_position;         if (material_track->edit_rate.num <= 0 ||             material_track->edit_rate.den <= 0) {             av_log(mxf->fc, AV_LOG_WARNING,                    ""Invalid edit rate (%d/%d) found on stream #%d, ""                    ""defaulting to 25/1\n"",                    material_track->edit_rate.num,                    material_track->edit_rate.den, st->index);             material_track->edit_rate = (AVRational){25, 1};         }         avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);          /* ensure SourceTrack EditRate == MaterialTrack EditRate since only          * the former is accessible via st->priv_data */         source_track->edit_rate = material_track->edit_rate;          PRINT_KEY(mxf->fc, ""data definition   ul"", source_track->sequence->data_definition_ul);         codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);         st->codecpar->codec_type = codec_ul->id;          if (!descriptor) {             av_log(mxf->fc, AV_LOG_INFO, ""source track %d: stream %d, no descriptor found\n"", source_track->track_id, st->index);             continue;         }         PRINT_KEY(mxf->fc, ""essence codec     ul"", descriptor->essence_codec_ul);         PRINT_KEY(mxf->fc, ""essence container ul"", descriptor->essence_container_ul);         essence_container_ul = &descriptor->essence_container_ul;         source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);         if (source_track->wrapping == UnknownWrapped)             av_log(mxf->fc, AV_LOG_INFO, ""wrapping of stream %d is unknown\n"", st->index);         /* HACK: replacing the original key with mxf_encrypted_essence_container          * is not allowed according to s429-6, try to find correct information anyway */         if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {             av_log(mxf->fc, AV_LOG_INFO, ""broken encrypted mxf file\n"");             for (k = 0; k < mxf->metadata_sets_count; k++) {                 MXFMetadataSet *metadata = mxf->metadata_sets[k];                 if (metadata->type == CryptoContext) {                     essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;                     break;                 }             }         }          /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */         codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);         st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;         if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {             codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);             st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;         }          av_log(mxf->fc, AV_LOG_VERBOSE, ""%s: Universal Label: "",                avcodec_get_name(st->codecpar->codec_id));         for (k = 0; k < 16; k++) {             av_log(mxf->fc, AV_LOG_VERBOSE, ""%.2x"",                    descriptor->essence_codec_ul[k]);             if (!(k+1 & 19) || k == 5)                 av_log(mxf->fc, AV_LOG_VERBOSE, ""."");         }         av_log(mxf->fc, AV_LOG_VERBOSE, ""\n"");          mxf_add_umid_metadata(&st->metadata, ""file_package_umid"", source_package);         if (source_package->name && source_package->name[0])             av_dict_set(&st->metadata, ""file_package_name"", source_package->name, 0);         if (material_track->name && material_track->name[0])             av_dict_set(&st->metadata, ""track_name"", material_track->name, 0);          mxf_parse_physical_source_package(mxf, source_track, st);          if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {             source_track->intra_only = mxf_is_intra_only(descriptor);             container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)                 st->codecpar->codec_id = container_ul->id;             st->codecpar->width = descriptor->width;             st->codecpar->height = descriptor->height; /* Field height, not frame height */             switch (descriptor->frame_layout) {                 case FullFrame:                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;                     break;                 case OneField:                     /* Every other line is stored and needs to be duplicated. */                     av_log(mxf->fc, AV_LOG_INFO, ""OneField frame layout isn't currently supported\n"");                     break; /* The correct thing to do here is fall through, but by breaking we might be                               able to decode some streams at half the vertical resolution, rather than not al all.                               It's also for compatibility with the old behavior. */                 case MixedFields:                     break;                 case SegmentedFrame:                     st->codecpar->field_order = AV_FIELD_PROGRESSIVE;                 case SeparateFields:                     av_log(mxf->fc, AV_LOG_DEBUG, ""video_line_map: (%d, %d), field_dominance: %d\n"",                            descriptor->video_line_map[0], descriptor->video_line_map[1],                            descriptor->field_dominance);                     if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {                         /* Detect coded field order from VideoLineMap:                          *  (even, even) => bottom field coded first                          *  (even, odd)  => top field coded first                          *  (odd, even)  => top field coded first                          *  (odd, odd)   => bottom field coded first                          */                         if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {                             switch (descriptor->field_dominance) {                                 case MXF_FIELD_DOMINANCE_DEFAULT:                                 case MXF_FIELD_DOMINANCE_FF:                                     st->codecpar->field_order = AV_FIELD_TT;                                     break;                                 case MXF_FIELD_DOMINANCE_FL:                                     st->codecpar->field_order = AV_FIELD_TB;                                     break;                                 default:                                     avpriv_request_sample(mxf->fc,                                                           ""Field dominance %d support"",                                                           descriptor->field_dominance);                             }                         } else {                             switch (descriptor->field_dominance) {                                 case MXF_FIELD_DOMINANCE_DEFAULT:                                 case MXF_FIELD_DOMINANCE_FF:                                     st->codecpar->field_order = AV_FIELD_BB;                                     break;                                 case MXF_FIELD_DOMINANCE_FL:                                     st->codecpar->field_order = AV_FIELD_BT;                                     break;                                 default:                                     avpriv_request_sample(mxf->fc,                                                           ""Field dominance %d support"",                                                           descriptor->field_dominance);                             }                         }                     }                     /* Turn field height into frame height. */                     st->codecpar->height *= 2;                     break;                 default:                     av_log(mxf->fc, AV_LOG_INFO, ""Unknown frame layout type: %d\n"", descriptor->frame_layout);             }             if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {                 st->codecpar->format = descriptor->pix_fmt;                 if (st->codecpar->format == AV_PIX_FMT_NONE) {                     pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,                                                   &descriptor->essence_codec_ul);                     st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;                     if (st->codecpar->format== AV_PIX_FMT_NONE) {                         st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,                                                                    &descriptor->essence_codec_ul)->id;                         if (!st->codecpar->codec_tag) {                             /* support files created before RP224v10 by defaulting to UYVY422                                if subsampling is 4:2:2 and component depth is 8-bit */                             if (descriptor->horiz_subsampling == 2 &&                                 descriptor->vert_subsampling == 1 &&                                 descriptor->component_depth == 8) {                                 st->codecpar->format = AV_PIX_FMT_UYVY422;                             }                         }                     }                 }             }             st->need_parsing = AVSTREAM_PARSE_HEADERS;             if (material_track->sequence->origin) {                 av_dict_set_int(&st->metadata, ""material_track_origin"", material_track->sequence->origin, 0);             }             if (source_track->sequence->origin) {                 av_dict_set_int(&st->metadata, ""source_track_origin"", source_track->sequence->origin, 0);             }             if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)                 st->display_aspect_ratio = descriptor->aspect_ratio;         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {             container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);             /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */             if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))                 st->codecpar->codec_id = (enum AVCodecID)container_ul->id;             st->codecpar->channels = descriptor->channels;             st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;              if (descriptor->sample_rate.den > 0) {                 st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;                 avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);             } else {                 av_log(mxf->fc, AV_LOG_WARNING, ""invalid sample rate (%d/%d) ""                        ""found for stream #%d, time base forced to 1/48000\n"",                        descriptor->sample_rate.num, descriptor->sample_rate.den,                        st->index);                 avpriv_set_pts_info(st, 64, 1, 48000);             }              /* if duration is set, rescale it from EditRate to SampleRate */             if (st->duration != AV_NOPTS_VALUE)                 st->duration = av_rescale_q(st->duration,                                             av_inv_q(material_track->edit_rate),                                             st->time_base);              /* TODO: implement AV_CODEC_ID_RAWAUDIO */             if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;                 else if (descriptor->bits_per_sample == 32)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;             } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {                 if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;                 else if (descriptor->bits_per_sample == 32)                     st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;             } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {                 st->need_parsing = AVSTREAM_PARSE_FULL;             }         } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {             enum AVMediaType type;             container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);             if (st->codecpar->codec_id == AV_CODEC_ID_NONE)                 st->codecpar->codec_id = container_ul->id;             type = avcodec_get_type(st->codecpar->codec_id);             if (type == AVMEDIA_TYPE_SUBTITLE)                 st->codecpar->codec_type = type;             if (container_ul->desc)                 av_dict_set(&st->metadata, ""data_type"", container_ul->desc, 0);         }         if (descriptor->extradata) {             if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {                 memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);             }         } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {             int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,                                                &descriptor->essence_codec_ul)->id;             if (coded_width)                 st->codecpar->width = coded_width;             ret = ff_generate_avci_extradata(st);             if (ret < 0)                 return ret;         }         if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {             /* TODO: decode timestamps */             st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;         }     }      ret = 0; fail_and_free:     return ret; }"
"name_parse_evdns_cwe-125.c","CWE-125","name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { 	int name_end = -1; 	int j = *idx; 	int ptr_count = 0; #define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0) #define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0) #define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)  	char *cp = name_out; 	const char *const end = name_out + name_out_len;  	/* Normally, names are a series of length prefixed strings terminated */ 	/* with a length of 0 (the lengths are u8's < 63). */ 	/* However, the length can start with a pair of 1 bits and that */ 	/* means that the next 14 bits are a pointer within the current */ 	/* packet. */  	for (;;) { 		u8 label_len; 		if (j >= length) return -1; 		GET8(label_len); 		if (!label_len) break; 		if (label_len & 0xc0) { 			u8 ptr_low; 			GET8(ptr_low); 			if (name_end < 0) name_end = j; 			j = (((int)label_len & 0x3f) << 8) + ptr_low; 			/* Make sure that the target offset is in-bounds. */ 			if (j < 0 || j >= length) return -1; 			/* If we've jumped more times than there are characters in the 			 * message, we must have a loop. */ 			if (++ptr_count > length) return -1; 			continue; 		} 		if (label_len > 63) return -1; 		if (cp != name_out) { 			if (cp + 1 >= end) return -1; 			*cp++ = '.'; 		} 		if (cp + label_len >= end) return -1; 		memcpy(cp, packet + j, label_len); 		cp += label_len; 		j += label_len; 	} 	if (cp >= end) return -1; 	*cp = '\0'; 	if (name_end < 0) 		*idx = j; 	else 		*idx = name_end; 	return 0;  err: 	return -1; }"
"name_parse_evdns_not_vulnerable.c","not_vulnerable","name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { 	int name_end = -1; 	int j = *idx; 	int ptr_count = 0; #define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0) #define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0) #define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)  	char *cp = name_out; 	const char *const end = name_out + name_out_len;  	/* Normally, names are a series of length prefixed strings terminated */ 	/* with a length of 0 (the lengths are u8's < 63). */ 	/* However, the length can start with a pair of 1 bits and that */ 	/* means that the next 14 bits are a pointer within the current */ 	/* packet. */  	for (;;) { 		u8 label_len; 		GET8(label_len); 		if (!label_len) break; 		if (label_len & 0xc0) { 			u8 ptr_low; 			GET8(ptr_low); 			if (name_end < 0) name_end = j; 			j = (((int)label_len & 0x3f) << 8) + ptr_low; 			/* Make sure that the target offset is in-bounds. */ 			if (j < 0 || j >= length) return -1; 			/* If we've jumped more times than there are characters in the 			 * message, we must have a loop. */ 			if (++ptr_count > length) return -1; 			continue; 		} 		if (label_len > 63) return -1; 		if (cp != name_out) { 			if (cp + 1 >= end) return -1; 			*cp++ = '.'; 		} 		if (cp + label_len >= end) return -1; 		if (j + label_len > length) return -1; 		memcpy(cp, packet + j, label_len); 		cp += label_len; 		j += label_len; 	} 	if (cp >= end) return -1; 	*cp = '\0'; 	if (name_end < 0) 		*idx = j; 	else 		*idx = name_end; 	return 0;  err: 	return -1; }"
"next_line_archive_read_support_format_mtree_cwe-125.c","CWE-125","next_line(struct archive_read *a,     const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl) { 	ssize_t len; 	int quit; 	 	quit = 0; 	if (*avail == 0) { 		*nl = 0; 		len = 0; 	} else 		len = get_line_size(*b, *avail, nl); 	/* 	 * Read bytes more while it does not reach the end of line. 	 */ 	while (*nl == 0 && len == *avail && !quit) { 		ssize_t diff = *ravail - *avail; 		size_t nbytes_req = (*ravail+1023) & ~1023U; 		ssize_t tested;  		/* Increase reading bytes if it is not enough to at least 		 * new two lines. */ 		if (nbytes_req < (size_t)*ravail + 160) 			nbytes_req <<= 1;  		*b = __archive_read_ahead(a, nbytes_req, avail); 		if (*b == NULL) { 			if (*ravail >= *avail) 				return (0); 			/* Reading bytes reaches the end of file. */ 			*b = __archive_read_ahead(a, *avail, avail); 			quit = 1; 		} 		*ravail = *avail; 		*b += diff; 		*avail -= diff; 		tested = len;/* Skip some bytes we already determinated. */ 		len = get_line_size(*b, *avail, nl); 		if (len >= 0) 			len += tested; 	} 	return (len); }"
"next_line_archive_read_support_format_mtree_not_vulnerable.c","not_vulnerable","next_line(struct archive_read *a,     const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl) { 	ssize_t len; 	int quit; 	 	quit = 0; 	if (*avail == 0) { 		*nl = 0; 		len = 0; 	} else 		len = get_line_size(*b, *avail, nl); 	/* 	 * Read bytes more while it does not reach the end of line. 	 */ 	while (*nl == 0 && len == *avail && !quit) { 		ssize_t diff = *ravail - *avail; 		size_t nbytes_req = (*ravail+1023) & ~1023U; 		ssize_t tested;  		/* Increase reading bytes if it is not enough to at least 		 * new two lines. */ 		if (nbytes_req < (size_t)*ravail + 160) 			nbytes_req <<= 1;  		*b = __archive_read_ahead(a, nbytes_req, avail); 		if (*b == NULL) { 			if (*ravail >= *avail) 				return (0); 			/* Reading bytes reaches the end of file. */ 			*b = __archive_read_ahead(a, *avail, avail); 			quit = 1; 		} 		*ravail = *avail; 		*b += diff; 		*avail -= diff; 		tested = len;/* Skip some bytes we already determinated. */ 		len = get_line_size(*b + len, *avail - len, nl); 		if (len >= 0) 			len += tested; 	} 	return (len); }"
"nntp_hcache_namer_newsrc_cwe-022.c","CWE-022","static int nntp_hcache_namer(const char *path, char *dest, size_t destlen) {   return snprintf(dest, destlen, ""%s.hcache"", path); }"
"nntp_hcache_namer_newsrc_not_vulnerable.c","not_vulnerable","static int nntp_hcache_namer(const char *path, char *dest, size_t destlen) {   int count = snprintf(dest, destlen, ""%s.hcache"", path);    /* Strip out any directories in the path */   char *first = strchr(dest, '/');   char *last = strrchr(dest, '/');   if (first && last && (last > first))   {     memmove(first, last, strlen(last) + 1);     count -= (last - first);   }    return count; }"
"parse_hid_report_descriptor_gtco_cwe-125.c","CWE-125","static void parse_hid_report_descriptor(struct gtco *device, char * report, 					int length) { 	struct device *ddev = &device->intf->dev; 	int   x, i = 0;  	/* Tag primitive vars */ 	__u8   prefix; 	__u8   size; 	__u8   tag; 	__u8   type; 	__u8   data   = 0; 	__u16  data16 = 0; 	__u32  data32 = 0;  	/* For parsing logic */ 	int   inputnum = 0; 	__u32 usage = 0;  	/* Global Values, indexed by TAG */ 	__u32 globalval[TAG_GLOB_MAX]; 	__u32 oldval[TAG_GLOB_MAX];  	/* Debug stuff */ 	char  maintype = 'x'; 	char  globtype[12]; 	int   indent = 0; 	char  indentstr[10] = """";   	dev_dbg(ddev, ""======>>>>>>PARSE<<<<<<======\n"");  	/* Walk  this report and pull out the info we need */ 	while (i < length) { 		prefix = report[i];  		/* Skip over prefix */ 		i++;  		/* Determine data size and save the data in the proper variable */ 		size = PREF_SIZE(prefix); 		switch (size) { 		case 1: 			data = report[i]; 			break; 		case 2: 			data16 = get_unaligned_le16(&report[i]); 			break; 		case 3: 			size = 4; 			data32 = get_unaligned_le32(&report[i]); 			break; 		}  		/* Skip size of data */ 		i += size;  		/* What we do depends on the tag type */ 		tag  = PREF_TAG(prefix); 		type = PREF_TYPE(prefix); 		switch (type) { 		case TYPE_MAIN: 			strcpy(globtype, """"); 			switch (tag) {  			case TAG_MAIN_INPUT: 				/* 				 * The INPUT MAIN tag signifies this is 				 * information from a report.  We need to 				 * figure out what it is and store the 				 * min/max values 				 */  				maintype = 'I'; 				if (data == 2) 					strcpy(globtype, ""Variable""); 				else if (data == 3) 					strcpy(globtype, ""Var|Const"");  				dev_dbg(ddev, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"", 					globalval[TAG_GLOB_REPORT_ID], inputnum, 					globalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX], 					globalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN], 					globalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);   				/* 				  We can assume that the first two input items 				  are always the X and Y coordinates.  After 				  that, we look for everything else by 				  local usage value 				 */ 				switch (inputnum) { 				case 0:  /* X coord */ 					dev_dbg(ddev, ""GER: X Usage: 0x%x\n"", usage); 					if (device->max_X == 0) { 						device->max_X = globalval[TAG_GLOB_LOG_MAX]; 						device->min_X = globalval[TAG_GLOB_LOG_MIN]; 					} 					break;  				case 1:  /* Y coord */ 					dev_dbg(ddev, ""GER: Y Usage: 0x%x\n"", usage); 					if (device->max_Y == 0) { 						device->max_Y = globalval[TAG_GLOB_LOG_MAX]; 						device->min_Y = globalval[TAG_GLOB_LOG_MIN]; 					} 					break;  				default: 					/* Tilt X */ 					if (usage == DIGITIZER_USAGE_TILT_X) { 						if (device->maxtilt_X == 0) { 							device->maxtilt_X = globalval[TAG_GLOB_LOG_MAX]; 							device->mintilt_X = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					/* Tilt Y */ 					if (usage == DIGITIZER_USAGE_TILT_Y) { 						if (device->maxtilt_Y == 0) { 							device->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX]; 							device->mintilt_Y = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					/* Pressure */ 					if (usage == DIGITIZER_USAGE_TIP_PRESSURE) { 						if (device->maxpressure == 0) { 							device->maxpressure = globalval[TAG_GLOB_LOG_MAX]; 							device->minpressure = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					break; 				}  				inputnum++; 				break;  			case TAG_MAIN_OUTPUT: 				maintype = 'O'; 				break;  			case TAG_MAIN_FEATURE: 				maintype = 'F'; 				break;  			case TAG_MAIN_COL_START: 				maintype = 'S';  				if (data == 0) { 					dev_dbg(ddev, ""======>>>>>> Physical\n""); 					strcpy(globtype, ""Physical""); 				} else 					dev_dbg(ddev, ""======>>>>>>\n"");  				/* Indent the debug output */ 				indent++; 				for (x = 0; x < indent; x++) 					indentstr[x] = '-'; 				indentstr[x] = 0;  				/* Save global tags */ 				for (x = 0; x < TAG_GLOB_MAX; x++) 					oldval[x] = globalval[x];  				break;  			case TAG_MAIN_COL_END: 				dev_dbg(ddev, ""<<<<<<======\n""); 				maintype = 'E'; 				indent--; 				for (x = 0; x < indent; x++) 					indentstr[x] = '-'; 				indentstr[x] = 0;  				/* Copy global tags back */ 				for (x = 0; x < TAG_GLOB_MAX; x++) 					globalval[x] = oldval[x];  				break; 			}  			switch (size) { 			case 1: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data); 				break;  			case 2: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data16); 				break;  			case 4: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data32); 				break; 			} 			break;  		case TYPE_GLOBAL: 			switch (tag) { 			case TAG_GLOB_USAGE: 				/* 				 * First time we hit the global usage tag, 				 * it should tell us the type of device 				 */ 				if (device->usage == 0) 					device->usage = data;  				strcpy(globtype, ""USAGE""); 				break;  			case TAG_GLOB_LOG_MIN: 				strcpy(globtype, ""LOG_MIN""); 				break;  			case TAG_GLOB_LOG_MAX: 				strcpy(globtype, ""LOG_MAX""); 				break;  			case TAG_GLOB_PHYS_MIN: 				strcpy(globtype, ""PHYS_MIN""); 				break;  			case TAG_GLOB_PHYS_MAX: 				strcpy(globtype, ""PHYS_MAX""); 				break;  			case TAG_GLOB_UNIT_EXP: 				strcpy(globtype, ""EXP""); 				break;  			case TAG_GLOB_UNIT: 				strcpy(globtype, ""UNIT""); 				break;  			case TAG_GLOB_REPORT_SZ: 				strcpy(globtype, ""REPORT_SZ""); 				break;  			case TAG_GLOB_REPORT_ID: 				strcpy(globtype, ""REPORT_ID""); 				/* New report, restart numbering */ 				inputnum = 0; 				break;  			case TAG_GLOB_REPORT_CNT: 				strcpy(globtype, ""REPORT_CNT""); 				break;  			case TAG_GLOB_PUSH: 				strcpy(globtype, ""PUSH""); 				break;  			case TAG_GLOB_POP: 				strcpy(globtype, ""POP""); 				break; 			}  			/* Check to make sure we have a good tag number 			   so we don't overflow array */ 			if (tag < TAG_GLOB_MAX) { 				switch (size) { 				case 1: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data); 					globalval[tag] = data; 					break;  				case 2: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data16); 					globalval[tag] = data16; 					break;  				case 4: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data32); 					globalval[tag] = data32; 					break; 				} 			} else { 				dev_dbg(ddev, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"", 					indentstr, tag, size); 			} 			break;  		case TYPE_LOCAL: 			switch (tag) { 			case TAG_GLOB_USAGE: 				strcpy(globtype, ""USAGE""); 				/* Always 1 byte */ 				usage = data; 				break;  			case TAG_GLOB_LOG_MIN: 				strcpy(globtype, ""MIN""); 				break;  			case TAG_GLOB_LOG_MAX: 				strcpy(globtype, ""MAX""); 				break;  			default: 				strcpy(globtype, ""UNKNOWN""); 				break; 			}  			switch (size) { 			case 1: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data); 				break;  			case 2: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data16); 				break;  			case 4: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data32); 				break; 			}  			break; 		} 	} }"
"parse_hid_report_descriptor_gtco_not_vulnerable.c","not_vulnerable","static void parse_hid_report_descriptor(struct gtco *device, char * report, 					int length) { 	struct device *ddev = &device->intf->dev; 	int   x, i = 0;  	/* Tag primitive vars */ 	__u8   prefix; 	__u8   size; 	__u8   tag; 	__u8   type; 	__u8   data   = 0; 	__u16  data16 = 0; 	__u32  data32 = 0;  	/* For parsing logic */ 	int   inputnum = 0; 	__u32 usage = 0;  	/* Global Values, indexed by TAG */ 	__u32 globalval[TAG_GLOB_MAX]; 	__u32 oldval[TAG_GLOB_MAX];  	/* Debug stuff */ 	char  maintype = 'x'; 	char  globtype[12]; 	int   indent = 0; 	char  indentstr[10] = """";   	dev_dbg(ddev, ""======>>>>>>PARSE<<<<<<======\n"");  	/* Walk  this report and pull out the info we need */ 	while (i < length) { 		prefix = report[i++];  		/* Determine data size and save the data in the proper variable */ 		size = (1U << PREF_SIZE(prefix)) >> 1; 		if (i + size > length) { 			dev_err(ddev, 				""Not enough data (need %d, have %d)\n"", 				i + size, length); 			break; 		}  		switch (size) { 		case 1: 			data = report[i]; 			break; 		case 2: 			data16 = get_unaligned_le16(&report[i]); 			break; 		case 4: 			data32 = get_unaligned_le32(&report[i]); 			break; 		}  		/* Skip size of data */ 		i += size;  		/* What we do depends on the tag type */ 		tag  = PREF_TAG(prefix); 		type = PREF_TYPE(prefix); 		switch (type) { 		case TYPE_MAIN: 			strcpy(globtype, """"); 			switch (tag) {  			case TAG_MAIN_INPUT: 				/* 				 * The INPUT MAIN tag signifies this is 				 * information from a report.  We need to 				 * figure out what it is and store the 				 * min/max values 				 */  				maintype = 'I'; 				if (data == 2) 					strcpy(globtype, ""Variable""); 				else if (data == 3) 					strcpy(globtype, ""Var|Const"");  				dev_dbg(ddev, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"", 					globalval[TAG_GLOB_REPORT_ID], inputnum, 					globalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX], 					globalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN], 					globalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);   				/* 				  We can assume that the first two input items 				  are always the X and Y coordinates.  After 				  that, we look for everything else by 				  local usage value 				 */ 				switch (inputnum) { 				case 0:  /* X coord */ 					dev_dbg(ddev, ""GER: X Usage: 0x%x\n"", usage); 					if (device->max_X == 0) { 						device->max_X = globalval[TAG_GLOB_LOG_MAX]; 						device->min_X = globalval[TAG_GLOB_LOG_MIN]; 					} 					break;  				case 1:  /* Y coord */ 					dev_dbg(ddev, ""GER: Y Usage: 0x%x\n"", usage); 					if (device->max_Y == 0) { 						device->max_Y = globalval[TAG_GLOB_LOG_MAX]; 						device->min_Y = globalval[TAG_GLOB_LOG_MIN]; 					} 					break;  				default: 					/* Tilt X */ 					if (usage == DIGITIZER_USAGE_TILT_X) { 						if (device->maxtilt_X == 0) { 							device->maxtilt_X = globalval[TAG_GLOB_LOG_MAX]; 							device->mintilt_X = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					/* Tilt Y */ 					if (usage == DIGITIZER_USAGE_TILT_Y) { 						if (device->maxtilt_Y == 0) { 							device->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX]; 							device->mintilt_Y = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					/* Pressure */ 					if (usage == DIGITIZER_USAGE_TIP_PRESSURE) { 						if (device->maxpressure == 0) { 							device->maxpressure = globalval[TAG_GLOB_LOG_MAX]; 							device->minpressure = globalval[TAG_GLOB_LOG_MIN]; 						} 					}  					break; 				}  				inputnum++; 				break;  			case TAG_MAIN_OUTPUT: 				maintype = 'O'; 				break;  			case TAG_MAIN_FEATURE: 				maintype = 'F'; 				break;  			case TAG_MAIN_COL_START: 				maintype = 'S';  				if (data == 0) { 					dev_dbg(ddev, ""======>>>>>> Physical\n""); 					strcpy(globtype, ""Physical""); 				} else 					dev_dbg(ddev, ""======>>>>>>\n"");  				/* Indent the debug output */ 				indent++; 				for (x = 0; x < indent; x++) 					indentstr[x] = '-'; 				indentstr[x] = 0;  				/* Save global tags */ 				for (x = 0; x < TAG_GLOB_MAX; x++) 					oldval[x] = globalval[x];  				break;  			case TAG_MAIN_COL_END: 				dev_dbg(ddev, ""<<<<<<======\n""); 				maintype = 'E'; 				indent--; 				for (x = 0; x < indent; x++) 					indentstr[x] = '-'; 				indentstr[x] = 0;  				/* Copy global tags back */ 				for (x = 0; x < TAG_GLOB_MAX; x++) 					globalval[x] = oldval[x];  				break; 			}  			switch (size) { 			case 1: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data); 				break;  			case 2: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data16); 				break;  			case 4: 				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"", 					indentstr, tag, maintype, size, globtype, data32); 				break; 			} 			break;  		case TYPE_GLOBAL: 			switch (tag) { 			case TAG_GLOB_USAGE: 				/* 				 * First time we hit the global usage tag, 				 * it should tell us the type of device 				 */ 				if (device->usage == 0) 					device->usage = data;  				strcpy(globtype, ""USAGE""); 				break;  			case TAG_GLOB_LOG_MIN: 				strcpy(globtype, ""LOG_MIN""); 				break;  			case TAG_GLOB_LOG_MAX: 				strcpy(globtype, ""LOG_MAX""); 				break;  			case TAG_GLOB_PHYS_MIN: 				strcpy(globtype, ""PHYS_MIN""); 				break;  			case TAG_GLOB_PHYS_MAX: 				strcpy(globtype, ""PHYS_MAX""); 				break;  			case TAG_GLOB_UNIT_EXP: 				strcpy(globtype, ""EXP""); 				break;  			case TAG_GLOB_UNIT: 				strcpy(globtype, ""UNIT""); 				break;  			case TAG_GLOB_REPORT_SZ: 				strcpy(globtype, ""REPORT_SZ""); 				break;  			case TAG_GLOB_REPORT_ID: 				strcpy(globtype, ""REPORT_ID""); 				/* New report, restart numbering */ 				inputnum = 0; 				break;  			case TAG_GLOB_REPORT_CNT: 				strcpy(globtype, ""REPORT_CNT""); 				break;  			case TAG_GLOB_PUSH: 				strcpy(globtype, ""PUSH""); 				break;  			case TAG_GLOB_POP: 				strcpy(globtype, ""POP""); 				break; 			}  			/* Check to make sure we have a good tag number 			   so we don't overflow array */ 			if (tag < TAG_GLOB_MAX) { 				switch (size) { 				case 1: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data); 					globalval[tag] = data; 					break;  				case 2: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data16); 					globalval[tag] = data16; 					break;  				case 4: 					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"", 						indentstr, globtype, tag, size, data32); 					globalval[tag] = data32; 					break; 				} 			} else { 				dev_dbg(ddev, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"", 					indentstr, tag, size); 			} 			break;  		case TYPE_LOCAL: 			switch (tag) { 			case TAG_GLOB_USAGE: 				strcpy(globtype, ""USAGE""); 				/* Always 1 byte */ 				usage = data; 				break;  			case TAG_GLOB_LOG_MIN: 				strcpy(globtype, ""MIN""); 				break;  			case TAG_GLOB_LOG_MAX: 				strcpy(globtype, ""MAX""); 				break;  			default: 				strcpy(globtype, ""UNKNOWN""); 				break; 			}  			switch (size) { 			case 1: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data); 				break;  			case 2: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data16); 				break;  			case 4: 				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"", 					indentstr, tag, globtype, size, data32); 				break; 			}  			break; 		} 	} }"
"parse_string_cJSON_cwe-125.c","CWE-125","static const char *parse_string(cJSON *item,const char *str,const char **ep) { 	const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2; 	if (*str!='\""') {*ep=str;return 0;}	/* not a string! */ 	 	while (*end_ptr!='\""' && *end_ptr && ++len) if (*end_ptr++ == '\\') end_ptr++;	/* Skip escaped quotes. */ 	 	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */ 	if (!out) return 0; 	item->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */ 	item->type=cJSON_String; 	 	ptr=str+1;ptr2=out; 	while (ptr < end_ptr) 	{ 		if (*ptr!='\\') *ptr2++=*ptr++; 		else 		{ 			ptr++; 			switch (*ptr) 			{ 				case 'b': *ptr2++='\b';	break; 				case 'f': *ptr2++='\f';	break; 				case 'n': *ptr2++='\n';	break; 				case 'r': *ptr2++='\r';	break; 				case 't': *ptr2++='\t';	break; 				case 'u':	 /* transcode utf16 to utf8. */ 					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */ 					if (ptr >= end_ptr) {*ep=str;return 0;}	/* invalid */ 					 					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}	/* check for invalid.   */ 					 					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/ 					{ 						if (ptr+6 > end_ptr)    {*ep=str;return 0;}	/* invalid */ 						if (ptr[1]!='\\' || ptr[2]!='u')    {*ep=str;return 0;}	/* missing second-half of surrogate.    */ 						uc2=parse_hex4(ptr+3);ptr+=6; 						if (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}	/* invalid second-half of surrogate.    */ 						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF)); 					}  					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len; 					 					switch (len) { 						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 1: *--ptr2 =(uc | firstByteMark[len]); 					} 					ptr2+=len; 					break; 				default:  *ptr2++=*ptr; break; 			} 			ptr++; 		} 	} 	*ptr2=0; 	if (*ptr=='\""') ptr++; 	return ptr; }"
"parse_string_cJSON_not_vulnerable.c","not_vulnerable","static const char *parse_string(cJSON *item,const char *str,const char **ep) { 	const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2; 	if (*str!='\""') {*ep=str;return 0;}	/* not a string! */  	while (*end_ptr!='\""' && *end_ptr && ++len) 	{ 	    if (*end_ptr++ == '\\') 	    { 		if (*end_ptr == '\0') 		{ 		    /* prevent buffer overflow when last input character is a backslash */ 		    return 0; 		} 		end_ptr++;	/* Skip escaped quotes. */ 	    } 	}  	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */ 	if (!out) return 0; 	item->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */ 	item->type=cJSON_String; 	 	ptr=str+1;ptr2=out; 	while (ptr < end_ptr) 	{ 		if (*ptr!='\\') *ptr2++=*ptr++; 		else 		{ 			ptr++; 			switch (*ptr) 			{ 				case 'b': *ptr2++='\b';	break; 				case 'f': *ptr2++='\f';	break; 				case 'n': *ptr2++='\n';	break; 				case 'r': *ptr2++='\r';	break; 				case 't': *ptr2++='\t';	break; 				case 'u':	 /* transcode utf16 to utf8. */ 					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */ 					if (ptr >= end_ptr) {*ep=str;return 0;}	/* invalid */ 					 					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}	/* check for invalid.   */ 					 					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/ 					{ 						if (ptr+6 > end_ptr)    {*ep=str;return 0;}	/* invalid */ 						if (ptr[1]!='\\' || ptr[2]!='u')    {*ep=str;return 0;}	/* missing second-half of surrogate.    */ 						uc2=parse_hex4(ptr+3);ptr+=6; 						if (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}	/* invalid second-half of surrogate.    */ 						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF)); 					}  					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len; 					 					switch (len) { 						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6; 						case 1: *--ptr2 =(uc | firstByteMark[len]); 					} 					ptr2+=len; 					break; 				default:  *ptr2++=*ptr; break; 			} 			ptr++; 		} 	} 	*ptr2=0; 	if (*ptr=='\""') ptr++; 	return ptr; }"
"patch_core_cwe-787.c","CWE-787","static PyObject* patch(PyObject* self, PyObject* args) {     char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;     Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;     PyObject *controlTuples, *tuple, *results;     off_t oldpos, newpos, x, y, z;     int i, j, numTuples;      if (!PyArg_ParseTuple(args, ""s#nO!s#s#"",                           &origData, &origDataLength, &newDataLength,                           &PyList_Type, &controlTuples,                           &diffBlock, &diffBlockLength,                           &extraBlock, &extraBlockLength))         return NULL;      /* allocate the memory for the new data */     newData = PyMem_Malloc(newDataLength + 1);     if (!newData)         return PyErr_NoMemory();      oldpos = 0;     newpos = 0;     diffPtr = diffBlock;     extraPtr = extraBlock;     numTuples = PyList_GET_SIZE(controlTuples);     for (i = 0; i < numTuples; i++) {         tuple = PyList_GET_ITEM(controlTuples, i);         if (!PyTuple_Check(tuple)) {             PyMem_Free(newData);             PyErr_SetString(PyExc_TypeError, ""expecting tuple"");             return NULL;         }         if (PyTuple_GET_SIZE(tuple) != 3) {             PyMem_Free(newData);             PyErr_SetString(PyExc_TypeError, ""expecting tuple of size 3"");             return NULL;         }         x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));         y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));         z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));         if (newpos + x > newDataLength ||                 diffPtr + x > diffBlock + diffBlockLength ||                 extraPtr + y > extraBlock + extraBlockLength) {             PyMem_Free(newData);             PyErr_SetString(PyExc_ValueError, ""corrupt patch (overflow)"");             return NULL;         }         memcpy(newData + newpos, diffPtr, x);         diffPtr += x;         for (j = 0; j < x; j++)             if ((oldpos + j >= 0) && (oldpos + j < origDataLength))                 newData[newpos + j] += origData[oldpos + j];         newpos += x;         oldpos += x;         memcpy(newData + newpos, extraPtr, y);         extraPtr += y;         newpos += y;         oldpos += z;     }      /* confirm that a valid patch was applied */     if (newpos != newDataLength ||             diffPtr != diffBlock + diffBlockLength ||             extraPtr != extraBlock + extraBlockLength) {         PyMem_Free(newData);         PyErr_SetString(PyExc_ValueError, ""corrupt patch (underflow)"");         return NULL;     }      results = PyBytes_FromStringAndSize(newData, newDataLength);     PyMem_Free(newData);     return results; }"
"patch_core_not_vulnerable.c","not_vulnerable","static PyObject* patch(PyObject* self, PyObject* args) {     char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;     Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;     PyObject *controlTuples, *tuple, *results;     off_t oldpos, newpos, x, y, z;     int i, j, numTuples;      if (!PyArg_ParseTuple(args, ""s#nO!s#s#"",                           &origData, &origDataLength, &newDataLength,                           &PyList_Type, &controlTuples,                           &diffBlock, &diffBlockLength,                           &extraBlock, &extraBlockLength))         return NULL;      /* allocate the memory for the new data */     newData = PyMem_Malloc(newDataLength + 1);     if (!newData)         return PyErr_NoMemory();      oldpos = 0;     newpos = 0;     diffPtr = diffBlock;     extraPtr = extraBlock;     numTuples = PyList_GET_SIZE(controlTuples);     for (i = 0; i < numTuples; i++) {         tuple = PyList_GET_ITEM(controlTuples, i);         if (!PyTuple_Check(tuple)) {             PyMem_Free(newData);             PyErr_SetString(PyExc_TypeError, ""expecting tuple"");             return NULL;         }         if (PyTuple_GET_SIZE(tuple) != 3) {             PyMem_Free(newData);             PyErr_SetString(PyExc_TypeError, ""expecting tuple of size 3"");             return NULL;         }         x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));         y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));         z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));         if (newpos + x > newDataLength ||                 diffPtr + x > diffBlock + diffBlockLength) {             PyMem_Free(newData);             PyErr_SetString(PyExc_ValueError, ""corrupt patch (overflow)"");             return NULL;         }         memcpy(newData + newpos, diffPtr, x);         diffPtr += x;         for (j = 0; j < x; j++)             if ((oldpos + j >= 0) && (oldpos + j < origDataLength))                 newData[newpos + j] += origData[oldpos + j];         newpos += x;         oldpos += x;         if (newpos + y > newDataLength ||                 extraPtr + y > extraBlock + extraBlockLength) {             PyMem_Free(newData);             PyErr_SetString(PyExc_ValueError, ""corrupt patch (overflow)"");             return NULL;         }         memcpy(newData + newpos, extraPtr, y);         extraPtr += y;         newpos += y;         oldpos += z;     }      /* confirm that a valid patch was applied */     if (newpos != newDataLength ||             diffPtr != diffBlock + diffBlockLength ||             extraPtr != extraBlock + extraBlockLength) {         PyMem_Free(newData);         PyErr_SetString(PyExc_ValueError, ""corrupt patch (underflow)"");         return NULL;     }      results = PyBytes_FromStringAndSize(newData, newDataLength);     PyMem_Free(newData);     return results; }"
"pgxtoimage_convert_cwe-787.c","CWE-787","opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters) {     FILE *f = NULL;     int w, h, prec;     int i, numcomps, max;     OPJ_COLOR_SPACE color_space;     opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */     opj_image_t * image = NULL;     int adjustS, ushift, dshift, force8;      char endian1, endian2, sign;     char signtmp[32];      char temp[32];     int bigendian;     opj_image_comp_t *comp = NULL;      numcomps = 1;     color_space = OPJ_CLRSPC_GRAY;      memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));      max = 0;      f = fopen(filename, ""rb"");     if (!f) {         fprintf(stderr, ""Failed to open %s for reading !\n"", filename);         return NULL;     }      fseek(f, 0, SEEK_SET);     if (fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1,                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {         fclose(f);         fprintf(stderr,                 ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");         return NULL;     }      i = 0;     sign = '+';     while (signtmp[i] != '\0') {         if (signtmp[i] == '-') {             sign = '-';         }         i++;     }      fgetc(f);     if (endian1 == 'M' && endian2 == 'L') {         bigendian = 1;     } else if (endian2 == 'M' && endian1 == 'L') {         bigendian = 0;     } else {         fclose(f);         fprintf(stderr, ""Bad pgx header, please check input file\n"");         return NULL;     }      /* initialize image component */      cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;     cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;     cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +                  1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx                  + 1;     cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +                  1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy                  + 1;      if (sign == '-') {         cmptparm.sgnd = 1;     } else {         cmptparm.sgnd = 0;     }     if (prec < 8) {         force8 = 1;         ushift = 8 - prec;         dshift = prec - ushift;         if (cmptparm.sgnd) {             adjustS = (1 << (prec - 1));         } else {             adjustS = 0;         }         cmptparm.sgnd = 0;         prec = 8;     } else {         ushift = dshift = force8 = adjustS = 0;     }      cmptparm.prec = (OPJ_UINT32)prec;     cmptparm.bpp = (OPJ_UINT32)prec;     cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;     cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;      /* create the image */     image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);     if (!image) {         fclose(f);         return NULL;     }     /* set image offset and reference grid */     image->x0 = cmptparm.x0;     image->y0 = cmptparm.x0;     image->x1 = cmptparm.w;     image->y1 = cmptparm.h;      /* set image data */      comp = &image->comps[0];      for (i = 0; i < w * h; i++) {         int v;         if (force8) {             v = readuchar(f) + adjustS;             v = (v << ushift) + (v >> dshift);             comp->data[i] = (unsigned char)v;              if (v > max) {                 max = v;             }              continue;         }         if (comp->prec == 8) {             if (!comp->sgnd) {                 v = readuchar(f);             } else {                 v = (char) readuchar(f);             }         } else if (comp->prec <= 16) {             if (!comp->sgnd) {                 v = readushort(f, bigendian);             } else {                 v = (short) readushort(f, bigendian);             }         } else {             if (!comp->sgnd) {                 v = (int)readuint(f, bigendian);             } else {                 v = (int) readuint(f, bigendian);             }         }         if (v > max) {             max = v;         }         comp->data[i] = v;     }     fclose(f);     comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;      return image; }"
"pgxtoimage_convert_not_vulnerable.c","not_vulnerable","opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters) {     FILE *f = NULL;     int w, h, prec;     int i, numcomps, max;     OPJ_COLOR_SPACE color_space;     opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */     opj_image_t * image = NULL;     int adjustS, ushift, dshift, force8;      char endian1, endian2, sign;     char signtmp[32];      char temp[32];     int bigendian;     opj_image_comp_t *comp = NULL;      numcomps = 1;     color_space = OPJ_CLRSPC_GRAY;      memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));      max = 0;      f = fopen(filename, ""rb"");     if (!f) {         fprintf(stderr, ""Failed to open %s for reading !\n"", filename);         return NULL;     }      fseek(f, 0, SEEK_SET);     if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {         fclose(f);         fprintf(stderr,                 ""ERROR: Failed to read the right number of element from the fscanf() function!\n"");         return NULL;     }      i = 0;     sign = '+';     while (signtmp[i] != '\0') {         if (signtmp[i] == '-') {             sign = '-';         }         i++;     }      fgetc(f);     if (endian1 == 'M' && endian2 == 'L') {         bigendian = 1;     } else if (endian2 == 'M' && endian1 == 'L') {         bigendian = 0;     } else {         fclose(f);         fprintf(stderr, ""Bad pgx header, please check input file\n"");         return NULL;     }      /* initialize image component */      cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;     cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;     cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +                  1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx                  + 1;     cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +                  1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy                  + 1;      if (sign == '-') {         cmptparm.sgnd = 1;     } else {         cmptparm.sgnd = 0;     }     if (prec < 8) {         force8 = 1;         ushift = 8 - prec;         dshift = prec - ushift;         if (cmptparm.sgnd) {             adjustS = (1 << (prec - 1));         } else {             adjustS = 0;         }         cmptparm.sgnd = 0;         prec = 8;     } else {         ushift = dshift = force8 = adjustS = 0;     }      cmptparm.prec = (OPJ_UINT32)prec;     cmptparm.bpp = (OPJ_UINT32)prec;     cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;     cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;      /* create the image */     image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);     if (!image) {         fclose(f);         return NULL;     }     /* set image offset and reference grid */     image->x0 = cmptparm.x0;     image->y0 = cmptparm.x0;     image->x1 = cmptparm.w;     image->y1 = cmptparm.h;      /* set image data */      comp = &image->comps[0];      for (i = 0; i < w * h; i++) {         int v;         if (force8) {             v = readuchar(f) + adjustS;             v = (v << ushift) + (v >> dshift);             comp->data[i] = (unsigned char)v;              if (v > max) {                 max = v;             }              continue;         }         if (comp->prec == 8) {             if (!comp->sgnd) {                 v = readuchar(f);             } else {                 v = (char) readuchar(f);             }         } else if (comp->prec <= 16) {             if (!comp->sgnd) {                 v = readushort(f, bigendian);             } else {                 v = (short) readushort(f, bigendian);             }         } else {             if (!comp->sgnd) {                 v = (int)readuint(f, bigendian);             } else {                 v = (int) readuint(f, bigendian);             }         }         if (v > max) {             max = v;         }         comp->data[i] = v;     }     fclose(f);     comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;      return image; }"
"php_wddx_pop_element_wddx_cwe-476.c","CWE-476"," */ static void php_wddx_pop_element(void *user_data, const XML_Char *name) { 	st_entry 			*ent1, *ent2; 	wddx_stack 			*stack = (wddx_stack *)user_data; 	HashTable 			*target_hash; 	zend_class_entry 	**pce; 	zval				*obj; 	zval				*tmp; 	TSRMLS_FETCH();  /* OBJECTS_FIXME */ 	if (stack->top == 0) { 		return; 	}  	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) || 		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) || 	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) || 		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) || 		!strcmp(name, EL_DATETIME)) { 		wddx_stack_top(stack, (void**)&ent1);  		if (!ent1->data) { 			if (stack->top > 1) { 				stack->top--; 			} else { 				stack->done = 1; 			} 			efree(ent1); 			return; 		}  		if (!strcmp(name, EL_BINARY)) { 			int new_len=0; 			unsigned char *new_str;  			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len); 			STR_FREE(Z_STRVAL_P(ent1->data)); 			Z_STRVAL_P(ent1->data) = new_str; 			Z_STRLEN_P(ent1->data) = new_len; 		}  		/* Call __wakeup() method on the object. */ 		if (Z_TYPE_P(ent1->data) == IS_OBJECT) { 			zval *fname, *retval = NULL;  			MAKE_STD_ZVAL(fname); 			ZVAL_STRING(fname, ""__wakeup"", 1);  			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);  			zval_dtor(fname); 			FREE_ZVAL(fname); 			if (retval) { 				zval_ptr_dtor(&retval); 			} 		}  		if (stack->top > 1) { 			stack->top--; 			wddx_stack_top(stack, (void**)&ent2);  			/* if non-existent field */ 			if (ent2->type == ST_FIELD && ent2->data == NULL) { 				zval_ptr_dtor(&ent1->data); 				efree(ent1); 				return; 			}  			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) { 				target_hash = HASH_OF(ent2->data);  				if (ent1->varname) { 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) && 						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) && 						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) { 						zend_bool incomplete_class = 0;  						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data), 										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) { 							incomplete_class = 1; 							pce = &PHP_IC_ENTRY; 						}  						/* Initialize target object */ 						MAKE_STD_ZVAL(obj); 						object_init_ex(obj, *pce);  						/* Merge current hashtable with object's default properties */ 						zend_hash_merge(Z_OBJPROP_P(obj), 										Z_ARRVAL_P(ent2->data), 										(void (*)(void *)) zval_add_ref, 										(void *) &tmp, sizeof(zval *), 0);  						if (incomplete_class) { 							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						}  						/* Clean up old array entry */ 						zval_ptr_dtor(&ent2->data);  						/* Set stack entry to point to the newly created object */ 						ent2->data = obj;  						/* Clean up class name var entry */ 						zval_ptr_dtor(&ent1->data); 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) { 						zend_class_entry *old_scope = EG(scope);  						EG(scope) = Z_OBJCE_P(ent2->data); 						Z_DELREF_P(ent1->data); 						add_property_zval(ent2->data, ent1->varname, ent1->data); 						EG(scope) = old_scope; 					} else { 						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL); 					} 					efree(ent1->varname); 				} else	{ 					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL); 				} 			} 			efree(ent1); 		} else { 			stack->done = 1; 		} 	} else if (!strcmp(name, EL_VAR) && stack->varname) { 		efree(stack->varname); 		stack->varname = NULL; 	} else if (!strcmp(name, EL_FIELD)) { 		st_entry *ent; 		wddx_stack_top(stack, (void **)&ent); 		efree(ent); 		stack->top--; 	}"
"php_wddx_pop_element_wddx_not_vulnerable.c","not_vulnerable"," */ static void php_wddx_pop_element(void *user_data, const XML_Char *name) { 	st_entry 			*ent1, *ent2; 	wddx_stack 			*stack = (wddx_stack *)user_data; 	HashTable 			*target_hash; 	zend_class_entry 	**pce; 	zval				*obj; 	zval				*tmp; 	TSRMLS_FETCH();  /* OBJECTS_FIXME */ 	if (stack->top == 0) { 		return; 	}  	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) || 		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) || 	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) || 		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) || 		!strcmp(name, EL_DATETIME)) { 		wddx_stack_top(stack, (void**)&ent1);  		if (!ent1->data) { 			if (stack->top > 1) { 				stack->top--; 			} else { 				stack->done = 1; 			} 			efree(ent1); 			return; 		}  		if (!strcmp(name, EL_BINARY)) { 			int new_len=0; 			unsigned char *new_str;  			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len); 			STR_FREE(Z_STRVAL_P(ent1->data)); 			if (new_str) { 				Z_STRVAL_P(ent1->data) = new_str; 				Z_STRLEN_P(ent1->data) = new_len; 			} else { 				ZVAL_EMPTY_STRING(ent1->data); 			} 		}  		/* Call __wakeup() method on the object. */ 		if (Z_TYPE_P(ent1->data) == IS_OBJECT) { 			zval *fname, *retval = NULL;  			MAKE_STD_ZVAL(fname); 			ZVAL_STRING(fname, ""__wakeup"", 1);  			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);  			zval_dtor(fname); 			FREE_ZVAL(fname); 			if (retval) { 				zval_ptr_dtor(&retval); 			} 		}  		if (stack->top > 1) { 			stack->top--; 			wddx_stack_top(stack, (void**)&ent2);  			/* if non-existent field */ 			if (ent2->type == ST_FIELD && ent2->data == NULL) { 				zval_ptr_dtor(&ent1->data); 				efree(ent1); 				return; 			}  			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) { 				target_hash = HASH_OF(ent2->data);  				if (ent1->varname) { 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) && 						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) && 						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) { 						zend_bool incomplete_class = 0;  						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data), 										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) { 							incomplete_class = 1; 							pce = &PHP_IC_ENTRY; 						}  						/* Initialize target object */ 						MAKE_STD_ZVAL(obj); 						object_init_ex(obj, *pce);  						/* Merge current hashtable with object's default properties */ 						zend_hash_merge(Z_OBJPROP_P(obj), 										Z_ARRVAL_P(ent2->data), 										(void (*)(void *)) zval_add_ref, 										(void *) &tmp, sizeof(zval *), 0);  						if (incomplete_class) { 							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						}  						/* Clean up old array entry */ 						zval_ptr_dtor(&ent2->data);  						/* Set stack entry to point to the newly created object */ 						ent2->data = obj;  						/* Clean up class name var entry */ 						zval_ptr_dtor(&ent1->data); 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) { 						zend_class_entry *old_scope = EG(scope);  						EG(scope) = Z_OBJCE_P(ent2->data); 						Z_DELREF_P(ent1->data); 						add_property_zval(ent2->data, ent1->varname, ent1->data); 						EG(scope) = old_scope; 					} else { 						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL); 					} 					efree(ent1->varname); 				} else	{ 					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL); 				} 			} 			efree(ent1); 		} else { 			stack->done = 1; 		} 	} else if (!strcmp(name, EL_VAR) && stack->varname) { 		efree(stack->varname); 		stack->varname = NULL; 	} else if (!strcmp(name, EL_FIELD)) { 		st_entry *ent; 		wddx_stack_top(stack, (void **)&ent); 		efree(ent); 		stack->top--; 	}"
"r_pkcs7_parse_cms_r_pkcs7_cwe-476.c","CWE-476","RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) { 	RASN1Object *object; 	RCMS *container; 	if (!buffer || !length) { 		return NULL; 	} 	container = R_NEW0 (RCMS); 	if (!container) { 		return NULL; 	} 	object = r_asn1_create_object (buffer, length); 	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) { 		r_asn1_free_object (object); 		free (container); 		return NULL; 	} 	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length); 	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]); 	r_asn1_free_object (object); 	return container; }"
"r_pkcs7_parse_cms_r_pkcs7_not_vulnerable.c","not_vulnerable","RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) { 	RASN1Object *object; 	RCMS *container; 	if (!buffer || !length) { 		return NULL; 	} 	container = R_NEW0 (RCMS); 	if (!container) { 		return NULL; 	} 	object = r_asn1_create_object (buffer, length); 	if (!object || object->list.length != 2 || !object->list.objects || 		!object->list.objects[0] || !object->list.objects[1] || 		object->list.objects[1]->list.length != 1) { 		r_asn1_free_object (object); 		free (container); 		return NULL; 	} 	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length); 	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]); 	r_asn1_free_object (object); 	return container; }"
"rds_cmsg_atomic_rdma_cwe-476.c","CWE-476","int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm, 		    struct cmsghdr *cmsg) { 	struct page *page = NULL; 	struct rds_atomic_args *args; 	int ret = 0;  	if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args)) 	 || rm->atomic.op_active) 		return -EINVAL;  	args = CMSG_DATA(cmsg);  	/* Nonmasked & masked cmsg ops converted to masked hw ops */ 	switch (cmsg->cmsg_type) { 	case RDS_CMSG_ATOMIC_FADD: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; 		rm->atomic.op_m_fadd.add = args->fadd.add; 		rm->atomic.op_m_fadd.nocarry_mask = 0; 		break; 	case RDS_CMSG_MASKED_ATOMIC_FADD: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; 		rm->atomic.op_m_fadd.add = args->m_fadd.add; 		rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask; 		break; 	case RDS_CMSG_ATOMIC_CSWP: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; 		rm->atomic.op_m_cswp.compare = args->cswp.compare; 		rm->atomic.op_m_cswp.swap = args->cswp.swap; 		rm->atomic.op_m_cswp.compare_mask = ~0; 		rm->atomic.op_m_cswp.swap_mask = ~0; 		break; 	case RDS_CMSG_MASKED_ATOMIC_CSWP: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; 		rm->atomic.op_m_cswp.compare = args->m_cswp.compare; 		rm->atomic.op_m_cswp.swap = args->m_cswp.swap; 		rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask; 		rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask; 		break; 	default: 		BUG(); /* should never happen */ 	}  	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME); 	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT); 	rm->atomic.op_active = 1; 	rm->atomic.op_recverr = rs->rs_recverr; 	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1); 	if (!rm->atomic.op_sg) { 		ret = -ENOMEM; 		goto err; 	}  	/* verify 8 byte-aligned */ 	if (args->local_addr & 0x7) { 		ret = -EFAULT; 		goto err; 	}  	ret = rds_pin_pages(args->local_addr, 1, &page, 1); 	if (ret != 1) 		goto err; 	ret = 0;  	sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));  	if (rm->atomic.op_notify || rm->atomic.op_recverr) { 		/* We allocate an uninitialized notifier here, because 		 * we don't want to do that in the completion handler. We 		 * would have to use GFP_ATOMIC there, and don't want to deal 		 * with failed allocations. 		 */ 		rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL); 		if (!rm->atomic.op_notifier) { 			ret = -ENOMEM; 			goto err; 		}  		rm->atomic.op_notifier->n_user_token = args->user_token; 		rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS; 	}  	rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie); 	rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);  	return ret; err: 	if (page) 		put_page(page); 	kfree(rm->atomic.op_notifier);  	return ret; }"
"rds_cmsg_atomic_rdma_not_vulnerable.c","not_vulnerable","int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm, 		    struct cmsghdr *cmsg) { 	struct page *page = NULL; 	struct rds_atomic_args *args; 	int ret = 0;  	if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args)) 	 || rm->atomic.op_active) 		return -EINVAL;  	args = CMSG_DATA(cmsg);  	/* Nonmasked & masked cmsg ops converted to masked hw ops */ 	switch (cmsg->cmsg_type) { 	case RDS_CMSG_ATOMIC_FADD: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; 		rm->atomic.op_m_fadd.add = args->fadd.add; 		rm->atomic.op_m_fadd.nocarry_mask = 0; 		break; 	case RDS_CMSG_MASKED_ATOMIC_FADD: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; 		rm->atomic.op_m_fadd.add = args->m_fadd.add; 		rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask; 		break; 	case RDS_CMSG_ATOMIC_CSWP: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; 		rm->atomic.op_m_cswp.compare = args->cswp.compare; 		rm->atomic.op_m_cswp.swap = args->cswp.swap; 		rm->atomic.op_m_cswp.compare_mask = ~0; 		rm->atomic.op_m_cswp.swap_mask = ~0; 		break; 	case RDS_CMSG_MASKED_ATOMIC_CSWP: 		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; 		rm->atomic.op_m_cswp.compare = args->m_cswp.compare; 		rm->atomic.op_m_cswp.swap = args->m_cswp.swap; 		rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask; 		rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask; 		break; 	default: 		BUG(); /* should never happen */ 	}  	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME); 	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT); 	rm->atomic.op_active = 1; 	rm->atomic.op_recverr = rs->rs_recverr; 	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1); 	if (!rm->atomic.op_sg) { 		ret = -ENOMEM; 		goto err; 	}  	/* verify 8 byte-aligned */ 	if (args->local_addr & 0x7) { 		ret = -EFAULT; 		goto err; 	}  	ret = rds_pin_pages(args->local_addr, 1, &page, 1); 	if (ret != 1) 		goto err; 	ret = 0;  	sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));  	if (rm->atomic.op_notify || rm->atomic.op_recverr) { 		/* We allocate an uninitialized notifier here, because 		 * we don't want to do that in the completion handler. We 		 * would have to use GFP_ATOMIC there, and don't want to deal 		 * with failed allocations. 		 */ 		rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL); 		if (!rm->atomic.op_notifier) { 			ret = -ENOMEM; 			goto err; 		}  		rm->atomic.op_notifier->n_user_token = args->user_token; 		rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS; 	}  	rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie); 	rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);  	return ret; err: 	if (page) 		put_page(page); 	rm->atomic.op_active = 0; 	kfree(rm->atomic.op_notifier);  	return ret; }"
"rds_tcp_kill_sock_tcp_cwe-476.c","CWE-476","static void rds_tcp_kill_sock(struct net *net) { 	struct rds_tcp_connection *tc, *_tc; 	struct sock *sk; 	LIST_HEAD(tmp_list); 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);  	rds_tcp_listen_stop(rtn->rds_tcp_listen_sock); 	rtn->rds_tcp_listen_sock = NULL; 	flush_work(&rtn->rds_tcp_accept_w); 	spin_lock_irq(&rds_tcp_conn_lock); 	list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) { 		struct net *c_net = read_pnet(&tc->conn->c_net);  		if (net != c_net) 			continue; 		list_move_tail(&tc->t_tcp_node, &tmp_list); 	} 	spin_unlock_irq(&rds_tcp_conn_lock); 	list_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) { 		sk = tc->t_sock->sk; 		sk->sk_prot->disconnect(sk, 0); 		tcp_done(sk); 		if (tc->conn->c_passive) 			rds_conn_destroy(tc->conn->c_passive); 		rds_conn_destroy(tc->conn); 	} }"
"rds_tcp_kill_sock_tcp_not_vulnerable.c","not_vulnerable","static void rds_tcp_kill_sock(struct net *net) { 	struct rds_tcp_connection *tc, *_tc; 	struct sock *sk; 	LIST_HEAD(tmp_list); 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);  	rds_tcp_listen_stop(rtn->rds_tcp_listen_sock); 	rtn->rds_tcp_listen_sock = NULL; 	flush_work(&rtn->rds_tcp_accept_w); 	spin_lock_irq(&rds_tcp_conn_lock); 	list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) { 		struct net *c_net = read_pnet(&tc->conn->c_net);  		if (net != c_net) 			continue; 		list_move_tail(&tc->t_tcp_node, &tmp_list); 	} 	spin_unlock_irq(&rds_tcp_conn_lock); 	list_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) { 		if (tc->t_sock) { 			sk = tc->t_sock->sk; 			sk->sk_prot->disconnect(sk, 0); 			tcp_done(sk); 		} 		if (tc->conn->c_passive) 			rds_conn_destroy(tc->conn->c_passive); 		rds_conn_destroy(tc->conn); 	} }"
"rfbHandleAuthResult_rfbproto_cwe-787.c","CWE-787","rfbHandleAuthResult(rfbClient* client) {     uint32_t authResult=0, reasonLen=0;     char *reason=NULL;      if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;      authResult = rfbClientSwap32IfLE(authResult);      switch (authResult) {     case rfbVncAuthOK:       rfbClientLog(""VNC authentication succeeded\n"");       return TRUE;       break;     case rfbVncAuthFailed:       if (client->major==3 && client->minor>7)       {         /* we have an error following */         if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;         reasonLen = rfbClientSwap32IfLE(reasonLen);         reason = malloc((uint64_t)reasonLen+1);         if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }         reason[reasonLen]=0;         rfbClientLog(""VNC connection failed: %s\n"",reason);         free(reason);         return FALSE;       }       rfbClientLog(""VNC authentication failed\n"");       return FALSE;     case rfbVncAuthTooMany:       rfbClientLog(""VNC authentication failed - too many tries\n"");       return FALSE;     }      rfbClientLog(""Unknown VNC authentication result: %d\n"",                  (int)authResult);     return FALSE; }"
"rfbHandleAuthResult_rfbproto_not_vulnerable.c","not_vulnerable","rfbHandleAuthResult(rfbClient* client) {     uint32_t authResult=0;      if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;      authResult = rfbClientSwap32IfLE(authResult);      switch (authResult) {     case rfbVncAuthOK:       rfbClientLog(""VNC authentication succeeded\n"");       return TRUE;       break;     case rfbVncAuthFailed:       if (client->major==3 && client->minor>7)       {         /* we have an error following */         ReadReason(client);         return FALSE;       }       rfbClientLog(""VNC authentication failed\n"");       return FALSE;     case rfbVncAuthTooMany:       rfbClientLog(""VNC authentication failed - too many tries\n"");       return FALSE;     }      rfbClientLog(""Unknown VNC authentication result: %d\n"",                  (int)authResult);     return FALSE; }"
"sc_oberthur_read_file_pkcs15-oberthur_cwe-787.c","CWE-787","sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path, 		unsigned char **out, size_t *out_len, 		int verify_pin) { 	struct sc_context *ctx = p15card->card->ctx; 	struct sc_card *card = p15card->card; 	struct sc_file *file = NULL; 	struct sc_path path; 	size_t sz; 	int rv;  	LOG_FUNC_CALLED(ctx); 	if (!in_path || !out || !out_len) 		LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file"");  	sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin);  	*out = NULL; 	*out_len = 0;  	sc_format_path(in_path, &path); 	rv = sc_select_file(card, &path, &file); 	if (rv != SC_SUCCESS) { 		sc_file_free(file); 		LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read""); 	}  	if (file->ef_structure == SC_FILE_EF_TRANSPARENT) 		sz = file->size; 	else 		sz = (file->record_length + 2) * file->record_count;  	*out = calloc(sz, 1); 	if (*out == NULL) { 		sc_file_free(file); 		LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file""); 	}  	if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   { 		rv = sc_read_binary(card, 0, *out, sz, 0); 	} 	else	{ 		int rec; 		int offs = 0; 		int rec_len = file->record_length;  		for (rec = 1; ; rec++)   { 			rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR); 			if (rv == SC_ERROR_RECORD_NOT_FOUND)   { 				rv = 0; 				break; 			} 			else if (rv < 0)   { 				break; 			}  			rec_len = rv;  			*(*out + offs) = 'R'; 			*(*out + offs + 1) = rv;  			offs += rv + 2; 		}  		sz = offs; 	}  	sc_log(ctx, ""read oberthur file result %i"", rv); 	if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   { 		struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL; 		const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ); 		int ii;  		rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10); 		if (rv != SC_SUCCESS) { 			sc_file_free(file); 			LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error""); 		}  		for (ii=0; ii<rv; ii++)   { 			struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data; 			sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"", 					auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method); 			if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   { 				pin_obj = objs[ii]; 				break; 			} 		}  		if (!pin_obj || !pin_obj->content.value)    { 			rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED; 		} 		else    { 			rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len); 			if (!rv) 				rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0); 		} 	};  	sc_file_free(file);  	if (rv < 0)   { 		free(*out); 		*out = NULL; 		*out_len = 0; 	}  	*out_len = sz;  	LOG_FUNC_RETURN(ctx, rv); }"
"sc_oberthur_read_file_pkcs15-oberthur_not_vulnerable.c","not_vulnerable","sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path, 		unsigned char **out, size_t *out_len, 		int verify_pin) { 	struct sc_context *ctx = p15card->card->ctx; 	struct sc_card *card = p15card->card; 	struct sc_file *file = NULL; 	struct sc_path path; 	size_t sz; 	int rv;  	LOG_FUNC_CALLED(ctx); 	if (!in_path || !out || !out_len) 		LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file"");  	sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin);  	*out = NULL; 	*out_len = 0;  	sc_format_path(in_path, &path); 	rv = sc_select_file(card, &path, &file); 	if (rv != SC_SUCCESS) { 		sc_file_free(file); 		LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read""); 	}  	if (file->ef_structure == SC_FILE_EF_TRANSPARENT) 		sz = file->size; 	else 		sz = (file->record_length + 2) * file->record_count;  	*out = calloc(sz, 1); 	if (*out == NULL) { 		sc_file_free(file); 		LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file""); 	}  	if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   { 		rv = sc_read_binary(card, 0, *out, sz, 0); 	} 	else	{ 		size_t rec; 		size_t offs = 0; 		size_t rec_len = file->record_length;  		for (rec = 1; ; rec++)   { 			if (rec > file->record_count) { 				rv = 0; 				break; 			} 			rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR); 			if (rv == SC_ERROR_RECORD_NOT_FOUND)   { 				rv = 0; 				break; 			} 			else if (rv < 0)   { 				break; 			}  			rec_len = rv;  			*(*out + offs) = 'R'; 			*(*out + offs + 1) = rv;  			offs += rv + 2; 		}  		sz = offs; 	}  	sc_log(ctx, ""read oberthur file result %i"", rv); 	if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   { 		struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL; 		const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ); 		int ii;  		rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10); 		if (rv != SC_SUCCESS) { 			sc_file_free(file); 			LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error""); 		}  		for (ii=0; ii<rv; ii++)   { 			struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data; 			sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"", 					auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method); 			if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   { 				pin_obj = objs[ii]; 				break; 			} 		}  		if (!pin_obj || !pin_obj->content.value)    { 			rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED; 		} 		else    { 			rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len); 			if (!rv) 				rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0); 		} 	};  	sc_file_free(file);  	if (rv < 0)   { 		free(*out); 		*out = NULL; 		*out_len = 0; 	}  	*out_len = sz;  	LOG_FUNC_RETURN(ctx, rv); }"
"set_geometry_floppy_cwe-190.c","CWE-190","static int set_geometry(unsigned int cmd, struct floppy_struct *g, 			       int drive, int type, struct block_device *bdev) { 	int cnt;  	/* sanity checking for parameters. */ 	if (g->sect <= 0 || 	    g->head <= 0 || 	    /* check for zero in F_SECT_PER_TRACK */ 	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 || 	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) || 	    /* check if reserved bits are set */ 	    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0) 		return -EINVAL; 	if (type) { 		if (!capable(CAP_SYS_ADMIN)) 			return -EPERM; 		mutex_lock(&open_lock); 		if (lock_fdc(drive)) { 			mutex_unlock(&open_lock); 			return -EINTR; 		} 		floppy_type[type] = *g; 		floppy_type[type].name = ""user format""; 		for (cnt = type << 2; cnt < (type << 2) + 4; cnt++) 			floppy_sizes[cnt] = floppy_sizes[cnt + 0x80] = 			    floppy_type[type].size + 1; 		process_fd_request(); 		for (cnt = 0; cnt < N_DRIVE; cnt++) { 			struct block_device *bdev = opened_bdev[cnt]; 			if (!bdev || ITYPE(drive_state[cnt].fd_device) != type) 				continue; 			__invalidate_device(bdev, true); 		} 		mutex_unlock(&open_lock); 	} else { 		int oldStretch;  		if (lock_fdc(drive)) 			return -EINTR; 		if (cmd != FDDEFPRM) { 			/* notice a disk change immediately, else 			 * we lose our settings immediately*/ 			if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR) 				return -EINTR; 		} 		oldStretch = g->stretch; 		user_params[drive] = *g; 		if (buffer_drive == drive) 			SUPBOUND(buffer_max, user_params[drive].sect); 		current_type[drive] = &user_params[drive]; 		floppy_sizes[drive] = user_params[drive].size; 		if (cmd == FDDEFPRM) 			DRS->keep_data = -1; 		else 			DRS->keep_data = 1; 		/* invalidation. Invalidate only when needed, i.e. 		 * when there are already sectors in the buffer cache 		 * whose number will change. This is useful, because 		 * mtools often changes the geometry of the disk after 		 * looking at the boot block */ 		if (DRS->maxblock > user_params[drive].sect || 		    DRS->maxtrack || 		    ((user_params[drive].sect ^ oldStretch) & 		     (FD_SWAPSIDES | FD_SECTBASEMASK))) 			invalidate_drive(bdev); 		else 			process_fd_request(); 	} 	return 0; }"
"set_geometry_floppy_not_vulnerable.c","not_vulnerable","static int set_geometry(unsigned int cmd, struct floppy_struct *g, 			       int drive, int type, struct block_device *bdev) { 	int cnt;  	/* sanity checking for parameters. */ 	if ((int)g->sect <= 0 || 	    (int)g->head <= 0 || 	    /* check for overflow in max_sector */ 	    (int)(g->sect * g->head) <= 0 || 	    /* check for zero in F_SECT_PER_TRACK */ 	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 || 	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) || 	    /* check if reserved bits are set */ 	    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0) 		return -EINVAL; 	if (type) { 		if (!capable(CAP_SYS_ADMIN)) 			return -EPERM; 		mutex_lock(&open_lock); 		if (lock_fdc(drive)) { 			mutex_unlock(&open_lock); 			return -EINTR; 		} 		floppy_type[type] = *g; 		floppy_type[type].name = ""user format""; 		for (cnt = type << 2; cnt < (type << 2) + 4; cnt++) 			floppy_sizes[cnt] = floppy_sizes[cnt + 0x80] = 			    floppy_type[type].size + 1; 		process_fd_request(); 		for (cnt = 0; cnt < N_DRIVE; cnt++) { 			struct block_device *bdev = opened_bdev[cnt]; 			if (!bdev || ITYPE(drive_state[cnt].fd_device) != type) 				continue; 			__invalidate_device(bdev, true); 		} 		mutex_unlock(&open_lock); 	} else { 		int oldStretch;  		if (lock_fdc(drive)) 			return -EINTR; 		if (cmd != FDDEFPRM) { 			/* notice a disk change immediately, else 			 * we lose our settings immediately*/ 			if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR) 				return -EINTR; 		} 		oldStretch = g->stretch; 		user_params[drive] = *g; 		if (buffer_drive == drive) 			SUPBOUND(buffer_max, user_params[drive].sect); 		current_type[drive] = &user_params[drive]; 		floppy_sizes[drive] = user_params[drive].size; 		if (cmd == FDDEFPRM) 			DRS->keep_data = -1; 		else 			DRS->keep_data = 1; 		/* invalidation. Invalidate only when needed, i.e. 		 * when there are already sectors in the buffer cache 		 * whose number will change. This is useful, because 		 * mtools often changes the geometry of the disk after 		 * looking at the boot block */ 		if (DRS->maxblock > user_params[drive].sect || 		    DRS->maxtrack || 		    ((user_params[drive].sect ^ oldStretch) & 		     (FD_SWAPSIDES | FD_SECTBASEMASK))) 			invalidate_drive(bdev); 		else 			process_fd_request(); 	} 	return 0; }"
"skb_segment_skbuff_cwe-416.c","CWE-416","struct sk_buff *skb_segment(struct sk_buff *head_skb, 			    netdev_features_t features) { 	struct sk_buff *segs = NULL; 	struct sk_buff *tail = NULL; 	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list; 	skb_frag_t *frag = skb_shinfo(head_skb)->frags; 	unsigned int mss = skb_shinfo(head_skb)->gso_size; 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb); 	unsigned int offset = doffset; 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb); 	unsigned int headroom; 	unsigned int len; 	__be16 proto; 	bool csum; 	int sg = !!(features & NETIF_F_SG); 	int nfrags = skb_shinfo(head_skb)->nr_frags; 	int err = -ENOMEM; 	int i = 0; 	int pos;  	proto = skb_network_protocol(head_skb); 	if (unlikely(!proto)) 		return ERR_PTR(-EINVAL);  	csum = !!can_checksum_protocol(features, proto); 	__skb_push(head_skb, doffset); 	headroom = skb_headroom(head_skb); 	pos = skb_headlen(head_skb);  	do { 		struct sk_buff *nskb; 		skb_frag_t *nskb_frag; 		int hsize; 		int size;  		len = head_skb->len - offset; 		if (len > mss) 			len = mss;  		hsize = skb_headlen(head_skb) - offset; 		if (hsize < 0) 			hsize = 0; 		if (hsize > len || !sg) 			hsize = len;  		if (!hsize && i >= nfrags && skb_headlen(list_skb) && 		    (skb_headlen(list_skb) == len || sg)) { 			BUG_ON(skb_headlen(list_skb) > len);  			i = 0; 			nfrags = skb_shinfo(list_skb)->nr_frags; 			frag = skb_shinfo(list_skb)->frags; 			pos += skb_headlen(list_skb);  			while (pos < offset + len) { 				BUG_ON(i >= nfrags);  				size = skb_frag_size(frag); 				if (pos + size > offset + len) 					break;  				i++; 				pos += size; 				frag++; 			}  			nskb = skb_clone(list_skb, GFP_ATOMIC); 			list_skb = list_skb->next;  			if (unlikely(!nskb)) 				goto err;  			if (unlikely(pskb_trim(nskb, len))) { 				kfree_skb(nskb); 				goto err; 			}  			hsize = skb_end_offset(nskb); 			if (skb_cow_head(nskb, doffset + headroom)) { 				kfree_skb(nskb); 				goto err; 			}  			nskb->truesize += skb_end_offset(nskb) - hsize; 			skb_release_head_state(nskb); 			__skb_push(nskb, doffset); 		} else { 			nskb = __alloc_skb(hsize + doffset + headroom, 					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb), 					   NUMA_NO_NODE);  			if (unlikely(!nskb)) 				goto err;  			skb_reserve(nskb, headroom); 			__skb_put(nskb, doffset); 		}  		if (segs) 			tail->next = nskb; 		else 			segs = nskb; 		tail = nskb;  		__copy_skb_header(nskb, head_skb); 		nskb->mac_len = head_skb->mac_len;  		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);  		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen, 						 nskb->data - tnl_hlen, 						 doffset + tnl_hlen);  		if (nskb->len == len + doffset) 			goto perform_csum_check;  		if (!sg) { 			nskb->ip_summed = CHECKSUM_NONE; 			nskb->csum = skb_copy_and_csum_bits(head_skb, offset, 							    skb_put(nskb, len), 							    len, 0); 			continue; 		}  		nskb_frag = skb_shinfo(nskb)->frags;  		skb_copy_from_linear_data_offset(head_skb, offset, 						 skb_put(nskb, hsize), hsize);  		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags & 			SKBTX_SHARED_FRAG;  		while (pos < offset + len) { 			if (i >= nfrags) { 				BUG_ON(skb_headlen(list_skb));  				i = 0; 				nfrags = skb_shinfo(list_skb)->nr_frags; 				frag = skb_shinfo(list_skb)->frags;  				BUG_ON(!nfrags);  				list_skb = list_skb->next; 			}  			if (unlikely(skb_shinfo(nskb)->nr_frags >= 				     MAX_SKB_FRAGS)) { 				net_warn_ratelimited( 					""skb_segment: too many frags: %u %u\n"", 					pos, mss); 				goto err; 			}  			*nskb_frag = *frag; 			__skb_frag_ref(nskb_frag); 			size = skb_frag_size(nskb_frag);  			if (pos < offset) { 				nskb_frag->page_offset += offset - pos; 				skb_frag_size_sub(nskb_frag, offset - pos); 			}  			skb_shinfo(nskb)->nr_frags++;  			if (pos + size <= offset + len) { 				i++; 				frag++; 				pos += size; 			} else { 				skb_frag_size_sub(nskb_frag, pos + size - (offset + len)); 				goto skip_fraglist; 			}  			nskb_frag++; 		}  skip_fraglist: 		nskb->data_len = len - hsize; 		nskb->len += nskb->data_len; 		nskb->truesize += nskb->data_len;  perform_csum_check: 		if (!csum) { 			nskb->csum = skb_checksum(nskb, doffset, 						  nskb->len - doffset, 0); 			nskb->ip_summed = CHECKSUM_NONE; 		} 	} while ((offset += len) < head_skb->len);  	return segs;  err: 	kfree_skb_list(segs); 	return ERR_PTR(err); }"
"skb_segment_skbuff_not_vulnerable.c","not_vulnerable","struct sk_buff *skb_segment(struct sk_buff *head_skb, 			    netdev_features_t features) { 	struct sk_buff *segs = NULL; 	struct sk_buff *tail = NULL; 	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list; 	skb_frag_t *frag = skb_shinfo(head_skb)->frags; 	unsigned int mss = skb_shinfo(head_skb)->gso_size; 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb); 	struct sk_buff *frag_skb = head_skb; 	unsigned int offset = doffset; 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb); 	unsigned int headroom; 	unsigned int len; 	__be16 proto; 	bool csum; 	int sg = !!(features & NETIF_F_SG); 	int nfrags = skb_shinfo(head_skb)->nr_frags; 	int err = -ENOMEM; 	int i = 0; 	int pos;  	proto = skb_network_protocol(head_skb); 	if (unlikely(!proto)) 		return ERR_PTR(-EINVAL);  	csum = !!can_checksum_protocol(features, proto); 	__skb_push(head_skb, doffset); 	headroom = skb_headroom(head_skb); 	pos = skb_headlen(head_skb);  	do { 		struct sk_buff *nskb; 		skb_frag_t *nskb_frag; 		int hsize; 		int size;  		len = head_skb->len - offset; 		if (len > mss) 			len = mss;  		hsize = skb_headlen(head_skb) - offset; 		if (hsize < 0) 			hsize = 0; 		if (hsize > len || !sg) 			hsize = len;  		if (!hsize && i >= nfrags && skb_headlen(list_skb) && 		    (skb_headlen(list_skb) == len || sg)) { 			BUG_ON(skb_headlen(list_skb) > len);  			i = 0; 			nfrags = skb_shinfo(list_skb)->nr_frags; 			frag = skb_shinfo(list_skb)->frags; 			frag_skb = list_skb; 			pos += skb_headlen(list_skb);  			while (pos < offset + len) { 				BUG_ON(i >= nfrags);  				size = skb_frag_size(frag); 				if (pos + size > offset + len) 					break;  				i++; 				pos += size; 				frag++; 			}  			nskb = skb_clone(list_skb, GFP_ATOMIC); 			list_skb = list_skb->next;  			if (unlikely(!nskb)) 				goto err;  			if (unlikely(pskb_trim(nskb, len))) { 				kfree_skb(nskb); 				goto err; 			}  			hsize = skb_end_offset(nskb); 			if (skb_cow_head(nskb, doffset + headroom)) { 				kfree_skb(nskb); 				goto err; 			}  			nskb->truesize += skb_end_offset(nskb) - hsize; 			skb_release_head_state(nskb); 			__skb_push(nskb, doffset); 		} else { 			nskb = __alloc_skb(hsize + doffset + headroom, 					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb), 					   NUMA_NO_NODE);  			if (unlikely(!nskb)) 				goto err;  			skb_reserve(nskb, headroom); 			__skb_put(nskb, doffset); 		}  		if (segs) 			tail->next = nskb; 		else 			segs = nskb; 		tail = nskb;  		__copy_skb_header(nskb, head_skb); 		nskb->mac_len = head_skb->mac_len;  		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);  		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen, 						 nskb->data - tnl_hlen, 						 doffset + tnl_hlen);  		if (nskb->len == len + doffset) 			goto perform_csum_check;  		if (!sg) { 			nskb->ip_summed = CHECKSUM_NONE; 			nskb->csum = skb_copy_and_csum_bits(head_skb, offset, 							    skb_put(nskb, len), 							    len, 0); 			continue; 		}  		nskb_frag = skb_shinfo(nskb)->frags;  		skb_copy_from_linear_data_offset(head_skb, offset, 						 skb_put(nskb, hsize), hsize);  		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags & 			SKBTX_SHARED_FRAG;  		while (pos < offset + len) { 			if (i >= nfrags) { 				BUG_ON(skb_headlen(list_skb));  				i = 0; 				nfrags = skb_shinfo(list_skb)->nr_frags; 				frag = skb_shinfo(list_skb)->frags; 				frag_skb = list_skb;  				BUG_ON(!nfrags);  				list_skb = list_skb->next; 			}  			if (unlikely(skb_shinfo(nskb)->nr_frags >= 				     MAX_SKB_FRAGS)) { 				net_warn_ratelimited( 					""skb_segment: too many frags: %u %u\n"", 					pos, mss); 				goto err; 			}  			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC))) 				goto err;  			*nskb_frag = *frag; 			__skb_frag_ref(nskb_frag); 			size = skb_frag_size(nskb_frag);  			if (pos < offset) { 				nskb_frag->page_offset += offset - pos; 				skb_frag_size_sub(nskb_frag, offset - pos); 			}  			skb_shinfo(nskb)->nr_frags++;  			if (pos + size <= offset + len) { 				i++; 				frag++; 				pos += size; 			} else { 				skb_frag_size_sub(nskb_frag, pos + size - (offset + len)); 				goto skip_fraglist; 			}  			nskb_frag++; 		}  skip_fraglist: 		nskb->data_len = len - hsize; 		nskb->len += nskb->data_len; 		nskb->truesize += nskb->data_len;  perform_csum_check: 		if (!csum) { 			nskb->csum = skb_checksum(nskb, doffset, 						  nskb->len - doffset, 0); 			nskb->ip_summed = CHECKSUM_NONE; 		} 	} while ((offset += len) < head_skb->len);  	return segs;  err: 	kfree_skb_list(segs); 	return ERR_PTR(err); }"
"snd_usb_create_streams_card_cwe-125.c","CWE-125","static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif) { 	struct usb_device *dev = chip->dev; 	struct usb_host_interface *host_iface; 	struct usb_interface_descriptor *altsd; 	void *control_header; 	int i, protocol;  	/* find audiocontrol interface */ 	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0]; 	control_header = snd_usb_find_csint_desc(host_iface->extra, 						 host_iface->extralen, 						 NULL, UAC_HEADER); 	altsd = get_iface_desc(host_iface); 	protocol = altsd->bInterfaceProtocol;  	if (!control_header) { 		dev_err(&dev->dev, ""cannot find UAC_HEADER\n""); 		return -EINVAL; 	}  	switch (protocol) { 	default: 		dev_warn(&dev->dev, 			 ""unknown interface protocol %#02x, assuming v1\n"", 			 protocol); 		/* fall through */  	case UAC_VERSION_1: { 		struct uac1_ac_header_descriptor *h1 = control_header;  		if (!h1->bInCollection) { 			dev_info(&dev->dev, ""skipping empty audio interface (v1)\n""); 			return -EINVAL; 		}  		if (h1->bLength < sizeof(*h1) + h1->bInCollection) { 			dev_err(&dev->dev, ""invalid UAC_HEADER (v1)\n""); 			return -EINVAL; 		}  		for (i = 0; i < h1->bInCollection; i++) 			snd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);  		break; 	}  	case UAC_VERSION_2: { 		struct usb_interface_assoc_descriptor *assoc = 			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;  		if (!assoc) { 			/* 			 * Firmware writers cannot count to three.  So to find 			 * the IAD on the NuForce UDH-100, also check the next 			 * interface. 			 */ 			struct usb_interface *iface = 				usb_ifnum_to_if(dev, ctrlif + 1); 			if (iface && 			    iface->intf_assoc && 			    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO && 			    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2) 				assoc = iface->intf_assoc; 		}  		if (!assoc) { 			dev_err(&dev->dev, ""Audio class v2 interfaces need an interface association\n""); 			return -EINVAL; 		}  		for (i = 0; i < assoc->bInterfaceCount; i++) { 			int intf = assoc->bFirstInterface + i;  			if (intf != ctrlif) 				snd_usb_create_stream(chip, ctrlif, intf); 		}  		break; 	} 	}  	return 0; }"
"snd_usb_create_streams_card_not_vulnerable.c","not_vulnerable","static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif) { 	struct usb_device *dev = chip->dev; 	struct usb_host_interface *host_iface; 	struct usb_interface_descriptor *altsd; 	void *control_header; 	int i, protocol; 	int rest_bytes;  	/* find audiocontrol interface */ 	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0]; 	control_header = snd_usb_find_csint_desc(host_iface->extra, 						 host_iface->extralen, 						 NULL, UAC_HEADER); 	altsd = get_iface_desc(host_iface); 	protocol = altsd->bInterfaceProtocol;  	if (!control_header) { 		dev_err(&dev->dev, ""cannot find UAC_HEADER\n""); 		return -EINVAL; 	}  	rest_bytes = (void *)(host_iface->extra + host_iface->extralen) - 		control_header;  	/* just to be sure -- this shouldn't hit at all */ 	if (rest_bytes <= 0) { 		dev_err(&dev->dev, ""invalid control header\n""); 		return -EINVAL; 	}  	switch (protocol) { 	default: 		dev_warn(&dev->dev, 			 ""unknown interface protocol %#02x, assuming v1\n"", 			 protocol); 		/* fall through */  	case UAC_VERSION_1: { 		struct uac1_ac_header_descriptor *h1 = control_header;  		if (rest_bytes < sizeof(*h1)) { 			dev_err(&dev->dev, ""too short v1 buffer descriptor\n""); 			return -EINVAL; 		}  		if (!h1->bInCollection) { 			dev_info(&dev->dev, ""skipping empty audio interface (v1)\n""); 			return -EINVAL; 		}  		if (rest_bytes < h1->bLength) { 			dev_err(&dev->dev, ""invalid buffer length (v1)\n""); 			return -EINVAL; 		}  		if (h1->bLength < sizeof(*h1) + h1->bInCollection) { 			dev_err(&dev->dev, ""invalid UAC_HEADER (v1)\n""); 			return -EINVAL; 		}  		for (i = 0; i < h1->bInCollection; i++) 			snd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);  		break; 	}  	case UAC_VERSION_2: { 		struct usb_interface_assoc_descriptor *assoc = 			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;  		if (!assoc) { 			/* 			 * Firmware writers cannot count to three.  So to find 			 * the IAD on the NuForce UDH-100, also check the next 			 * interface. 			 */ 			struct usb_interface *iface = 				usb_ifnum_to_if(dev, ctrlif + 1); 			if (iface && 			    iface->intf_assoc && 			    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO && 			    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2) 				assoc = iface->intf_assoc; 		}  		if (!assoc) { 			dev_err(&dev->dev, ""Audio class v2 interfaces need an interface association\n""); 			return -EINVAL; 		}  		for (i = 0; i < assoc->bInterfaceCount; i++) { 			int intf = assoc->bFirstInterface + i;  			if (intf != ctrlif) 				snd_usb_create_stream(chip, ctrlif, intf); 		}  		break; 	} 	}  	return 0; }"
"ssl_parse_server_psk_hint_ssl_cli_cwe-125.c","CWE-125","static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,                                       unsigned char **p,                                       unsigned char *end ) {     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;     size_t  len;     ((void) ssl);      /*      * PSK parameters:      *      * opaque psk_identity_hint<0..2^16-1>;      */     if( (*p) > end - 2 )     {         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""                                     ""(psk_identity_hint length)"" ) );         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );     }     len = (*p)[0] << 8 | (*p)[1];     *p += 2;      if( (*p) + len > end )     {         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""                                     ""(psk_identity_hint length)"" ) );         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );     }      /*      * Note: we currently ignore the PKS identity hint, as we only allow one      * PSK to be provisionned on the client. This could be changed later if      * someone needs that feature.      */     *p += len;     ret = 0;      return( ret ); }"
"ssl_parse_server_psk_hint_ssl_cli_not_vulnerable.c","not_vulnerable","static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,                                       unsigned char **p,                                       unsigned char *end ) {     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;     size_t  len;     ((void) ssl);      /*      * PSK parameters:      *      * opaque psk_identity_hint<0..2^16-1>;      */     if( (*p) > end - 2 )     {         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""                                     ""(psk_identity_hint length)"" ) );         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );     }     len = (*p)[0] << 8 | (*p)[1];     *p += 2;      if( (*p) > end - len )     {         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""                                     ""(psk_identity_hint length)"" ) );         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );     }      /*      * Note: we currently ignore the PKS identity hint, as we only allow one      * PSK to be provisionned on the client. This could be changed later if      * someone needs that feature.      */     *p += len;     ret = 0;      return( ret ); }"
"tcos_decipher_card-tcos_cwe-787.c","CWE-787","static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen) { 	sc_context_t *ctx; 	sc_apdu_t apdu; 	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE]; 	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE]; 	tcos_data *data; 	int tcos3, r;  	assert(card != NULL && crgram != NULL && out != NULL); 	ctx = card->ctx; 	tcos3=(card->type==SC_CARD_TYPE_TCOS_V3); 	data=(tcos_data *)card->drv_data;  	LOG_FUNC_CALLED(ctx); 	sc_log(ctx, 		""TCOS3:%d PKCS1:%d\n"",tcos3, 		!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));  	sc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86); 	apdu.resp = rbuf; 	apdu.resplen = sizeof(rbuf); 	apdu.le = crgram_len;  	apdu.data = sbuf; 	apdu.lc = apdu.datalen = crgram_len+1; 	sbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02); 	memcpy(sbuf+1, crgram, crgram_len);  	r = sc_transmit_apdu(card, &apdu); 	LOG_TEST_RET(card->ctx, r, ""APDU transmit failed"");  	if (apdu.sw1==0x90 && apdu.sw2==0x00) { 		size_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen; 		unsigned int offset=0; 		if(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) { 			offset=2; while(offset<len && apdu.resp[offset]!=0) ++offset; 			offset=(offset<len-1) ? offset+1 : 0; 		} 		memcpy(out, apdu.resp+offset, len-offset); 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset); 	} 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2)); }"
"tcos_decipher_card-tcos_not_vulnerable.c","not_vulnerable","static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen) { 	sc_context_t *ctx; 	sc_apdu_t apdu; 	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE]; 	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE]; 	tcos_data *data; 	int tcos3, r;  	assert(card != NULL && crgram != NULL && out != NULL); 	ctx = card->ctx; 	tcos3=(card->type==SC_CARD_TYPE_TCOS_V3); 	data=(tcos_data *)card->drv_data;  	LOG_FUNC_CALLED(ctx); 	sc_log(ctx, 		""TCOS3:%d PKCS1:%d\n"",tcos3, 		!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));  	sc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86); 	apdu.resp = rbuf; 	apdu.resplen = sizeof(rbuf); 	apdu.le = crgram_len;  	apdu.data = sbuf; 	apdu.lc = apdu.datalen = crgram_len+1; 	sbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02); 	if (sizeof sbuf - 1 < crgram_len) 		return SC_ERROR_INVALID_ARGUMENTS; 	memcpy(sbuf+1, crgram, crgram_len);  	r = sc_transmit_apdu(card, &apdu); 	LOG_TEST_RET(card->ctx, r, ""APDU transmit failed"");  	if (apdu.sw1==0x90 && apdu.sw2==0x00) { 		size_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen; 		unsigned int offset=0; 		if(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) { 			offset=2; while(offset<len && apdu.resp[offset]!=0) ++offset; 			offset=(offset<len-1) ? offset+1 : 0; 		} 		memcpy(out, apdu.resp+offset, len-offset); 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset); 	} 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2)); }"
"update_read_bitmap_data_update_cwe-125.c","CWE-125","static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData) { 	WINPR_UNUSED(update); 	if (Stream_GetRemainingLength(s) < 18) 		return FALSE;  	Stream_Read_UINT16(s, bitmapData->destLeft); 	Stream_Read_UINT16(s, bitmapData->destTop); 	Stream_Read_UINT16(s, bitmapData->destRight); 	Stream_Read_UINT16(s, bitmapData->destBottom); 	Stream_Read_UINT16(s, bitmapData->width); 	Stream_Read_UINT16(s, bitmapData->height); 	Stream_Read_UINT16(s, bitmapData->bitsPerPixel); 	Stream_Read_UINT16(s, bitmapData->flags); 	Stream_Read_UINT16(s, bitmapData->bitmapLength);  	if (bitmapData->flags & BITMAP_COMPRESSION) 	{ 		if (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR)) 		{ 			Stream_Read_UINT16(s, 			                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */ 			Stream_Read_UINT16(s, 			                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */ 			Stream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */ 			Stream_Read_UINT16(s, 			                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */ 			bitmapData->bitmapLength = bitmapData->cbCompMainBodySize; 		}  		bitmapData->compressed = TRUE; 	} 	else 		bitmapData->compressed = FALSE;  	if (Stream_GetRemainingLength(s) < bitmapData->bitmapLength) 		return FALSE;  	if (bitmapData->bitmapLength > 0) 	{ 		bitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);  		if (!bitmapData->bitmapDataStream) 			return FALSE;  		memcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength); 		Stream_Seek(s, bitmapData->bitmapLength); 	}  	return TRUE; }"
"update_read_bitmap_data_update_not_vulnerable.c","not_vulnerable","static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData) { 	WINPR_UNUSED(update); 	if (Stream_GetRemainingLength(s) < 18) 		return FALSE;  	Stream_Read_UINT16(s, bitmapData->destLeft); 	Stream_Read_UINT16(s, bitmapData->destTop); 	Stream_Read_UINT16(s, bitmapData->destRight); 	Stream_Read_UINT16(s, bitmapData->destBottom); 	Stream_Read_UINT16(s, bitmapData->width); 	Stream_Read_UINT16(s, bitmapData->height); 	Stream_Read_UINT16(s, bitmapData->bitsPerPixel); 	Stream_Read_UINT16(s, bitmapData->flags); 	Stream_Read_UINT16(s, bitmapData->bitmapLength);  	if (bitmapData->flags & BITMAP_COMPRESSION) 	{ 		if (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR)) 		{ 			if (Stream_GetRemainingLength(s) < 8) 				return FALSE;  			Stream_Read_UINT16(s, 			                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */ 			Stream_Read_UINT16(s, 			                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */ 			Stream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */ 			Stream_Read_UINT16(s, 			                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */ 			bitmapData->bitmapLength = bitmapData->cbCompMainBodySize; 		}  		bitmapData->compressed = TRUE; 	} 	else 		bitmapData->compressed = FALSE;  	if (Stream_GetRemainingLength(s) < bitmapData->bitmapLength) 		return FALSE;  	if (bitmapData->bitmapLength > 0) 	{ 		bitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);  		if (!bitmapData->bitmapDataStream) 			return FALSE;  		memcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength); 		Stream_Seek(s, bitmapData->bitmapLength); 	}  	return TRUE; }"
"update_read_icon_info_window_cwe-125.c","CWE-125","static BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo) { 	BYTE* newBitMask;  	if (Stream_GetRemainingLength(s) < 8) 		return FALSE;  	Stream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */ 	Stream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */ 	Stream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */  	if ((iconInfo->bpp < 1) || (iconInfo->bpp > 32)) 	{ 		WLog_ERR(TAG, ""invalid bpp value %"" PRIu32 """", iconInfo->bpp); 		return FALSE; 	}  	Stream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */ 	Stream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */  	/* cbColorTable is only present when bpp is 1, 4 or 8 */ 	switch (iconInfo->bpp) 	{ 		case 1: 		case 4: 		case 8: 			if (Stream_GetRemainingLength(s) < 2) 				return FALSE;  			Stream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */ 			break;  		default: 			iconInfo->cbColorTable = 0; 			break; 	}  	if (Stream_GetRemainingLength(s) < 4) 		return FALSE;  	Stream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */ 	Stream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */  	if (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor) 		return FALSE;  	/* bitsMask */ 	newBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);  	if (!newBitMask) 	{ 		free(iconInfo->bitsMask); 		iconInfo->bitsMask = NULL; 		return FALSE; 	}  	iconInfo->bitsMask = newBitMask; 	Stream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);  	/* colorTable */ 	if (iconInfo->colorTable == NULL) 	{ 		if (iconInfo->cbColorTable) 		{ 			iconInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);  			if (!iconInfo->colorTable) 				return FALSE; 		} 	} 	else if (iconInfo->cbColorTable) 	{ 		BYTE* new_tab; 		new_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);  		if (!new_tab) 		{ 			free(iconInfo->colorTable); 			iconInfo->colorTable = NULL; 			return FALSE; 		}  		iconInfo->colorTable = new_tab; 	} 	else 	{ 		free(iconInfo->colorTable); 		iconInfo->colorTable = NULL; 	}  	if (iconInfo->colorTable) 		Stream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);  	/* bitsColor */ 	newBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);  	if (!newBitMask) 	{ 		free(iconInfo->bitsColor); 		iconInfo->bitsColor = NULL; 		return FALSE; 	}  	iconInfo->bitsColor = newBitMask; 	Stream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor); 	return TRUE; }"
"update_read_icon_info_window_not_vulnerable.c","not_vulnerable","static BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo) { 	BYTE* newBitMask;  	if (Stream_GetRemainingLength(s) < 8) 		return FALSE;  	Stream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */ 	Stream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */ 	Stream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */  	if ((iconInfo->bpp < 1) || (iconInfo->bpp > 32)) 	{ 		WLog_ERR(TAG, ""invalid bpp value %"" PRIu32 """", iconInfo->bpp); 		return FALSE; 	}  	Stream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */ 	Stream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */  	/* cbColorTable is only present when bpp is 1, 4 or 8 */ 	switch (iconInfo->bpp) 	{ 		case 1: 		case 4: 		case 8: 			if (Stream_GetRemainingLength(s) < 2) 				return FALSE;  			Stream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */ 			break;  		default: 			iconInfo->cbColorTable = 0; 			break; 	}  	if (Stream_GetRemainingLength(s) < 4) 		return FALSE;  	Stream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */ 	Stream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */  	/* bitsMask */ 	newBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);  	if (!newBitMask) 	{ 		free(iconInfo->bitsMask); 		iconInfo->bitsMask = NULL; 		return FALSE; 	}  	iconInfo->bitsMask = newBitMask; 	if (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask) 		return FALSE; 	Stream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);  	/* colorTable */ 	if (iconInfo->colorTable == NULL) 	{ 		if (iconInfo->cbColorTable) 		{ 			iconInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);  			if (!iconInfo->colorTable) 				return FALSE; 		} 	} 	else if (iconInfo->cbColorTable) 	{ 		BYTE* new_tab; 		new_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);  		if (!new_tab) 		{ 			free(iconInfo->colorTable); 			iconInfo->colorTable = NULL; 			return FALSE; 		}  		iconInfo->colorTable = new_tab; 	} 	else 	{ 		free(iconInfo->colorTable); 		iconInfo->colorTable = NULL; 	}  	if (iconInfo->colorTable) 	{ 		if (Stream_GetRemainingLength(s) < iconInfo->cbColorTable) 			return FALSE; 		Stream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable); 	}  	/* bitsColor */ 	newBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);  	if (!newBitMask) 	{ 		free(iconInfo->bitsColor); 		iconInfo->bitsColor = NULL; 		return FALSE; 	}  	iconInfo->bitsColor = newBitMask; 	if (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor) 		return FALSE; 	Stream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor); 	return TRUE; }"
"usb_audio_probe_card_cwe-416.c","CWE-416","static int usb_audio_probe(struct usb_interface *intf, 			   const struct usb_device_id *usb_id) { 	struct usb_device *dev = interface_to_usbdev(intf); 	const struct snd_usb_audio_quirk *quirk = 		(const struct snd_usb_audio_quirk *)usb_id->driver_info; 	struct snd_usb_audio *chip; 	int i, err; 	struct usb_host_interface *alts; 	int ifnum; 	u32 id;  	alts = &intf->altsetting[0]; 	ifnum = get_iface_desc(alts)->bInterfaceNumber; 	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor), 		    le16_to_cpu(dev->descriptor.idProduct)); 	if (get_alias_id(dev, &id)) 		quirk = get_alias_quirk(dev, id); 	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum) 		return -ENXIO;  	err = snd_usb_apply_boot_quirk(dev, intf, quirk, id); 	if (err < 0) 		return err;  	/* 	 * found a config.  now register to ALSA 	 */  	/* check whether it's already registered */ 	chip = NULL; 	mutex_lock(&register_mutex); 	for (i = 0; i < SNDRV_CARDS; i++) { 		if (usb_chip[i] && usb_chip[i]->dev == dev) { 			if (atomic_read(&usb_chip[i]->shutdown)) { 				dev_err(&dev->dev, ""USB device is in the shutdown state, cannot create a card instance\n""); 				err = -EIO; 				goto __error; 			} 			chip = usb_chip[i]; 			atomic_inc(&chip->active); /* avoid autopm */ 			break; 		} 	} 	if (! chip) { 		/* it's a fresh one. 		 * now look for an empty slot and create a new card instance 		 */ 		for (i = 0; i < SNDRV_CARDS; i++) 			if (!usb_chip[i] && 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) && 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) { 				if (enable[i]) { 					err = snd_usb_audio_create(intf, dev, i, quirk, 								   id, &chip); 					if (err < 0) 						goto __error; 					chip->pm_intf = intf; 					break; 				} else if (vid[i] != -1 || pid[i] != -1) { 					dev_info(&dev->dev, 						 ""device (%04x:%04x) is disabled\n"", 						 USB_ID_VENDOR(id), 						 USB_ID_PRODUCT(id)); 					err = -ENOENT; 					goto __error; 				} 			} 		if (!chip) { 			dev_err(&dev->dev, ""no available usb audio device\n""); 			err = -ENODEV; 			goto __error; 		} 	} 	dev_set_drvdata(&dev->dev, chip);  	/* 	 * For devices with more than one control interface, we assume the 	 * first contains the audio controls. We might need a more specific 	 * check here in the future. 	 */ 	if (!chip->ctrl_intf) 		chip->ctrl_intf = alts;  	chip->txfr_quirk = 0; 	err = 1; /* continue */ 	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) { 		/* need some special handlings */ 		err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk); 		if (err < 0) 			goto __error; 	}  	if (err > 0) { 		/* create normal USB audio interfaces */ 		err = snd_usb_create_streams(chip, ifnum); 		if (err < 0) 			goto __error; 		err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error); 		if (err < 0) 			goto __error; 	}  	/* we are allowed to call snd_card_register() many times */ 	err = snd_card_register(chip->card); 	if (err < 0) 		goto __error;  	usb_chip[chip->index] = chip; 	chip->num_interfaces++; 	usb_set_intfdata(intf, chip); 	atomic_dec(&chip->active); 	mutex_unlock(&register_mutex); 	return 0;   __error: 	if (chip) { 		if (!chip->num_interfaces) 			snd_card_free(chip->card); 		atomic_dec(&chip->active); 	} 	mutex_unlock(&register_mutex); 	return err; }"
"usb_audio_probe_card_not_vulnerable.c","not_vulnerable","static int usb_audio_probe(struct usb_interface *intf, 			   const struct usb_device_id *usb_id) { 	struct usb_device *dev = interface_to_usbdev(intf); 	const struct snd_usb_audio_quirk *quirk = 		(const struct snd_usb_audio_quirk *)usb_id->driver_info; 	struct snd_usb_audio *chip; 	int i, err; 	struct usb_host_interface *alts; 	int ifnum; 	u32 id;  	alts = &intf->altsetting[0]; 	ifnum = get_iface_desc(alts)->bInterfaceNumber; 	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor), 		    le16_to_cpu(dev->descriptor.idProduct)); 	if (get_alias_id(dev, &id)) 		quirk = get_alias_quirk(dev, id); 	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum) 		return -ENXIO;  	err = snd_usb_apply_boot_quirk(dev, intf, quirk, id); 	if (err < 0) 		return err;  	/* 	 * found a config.  now register to ALSA 	 */  	/* check whether it's already registered */ 	chip = NULL; 	mutex_lock(&register_mutex); 	for (i = 0; i < SNDRV_CARDS; i++) { 		if (usb_chip[i] && usb_chip[i]->dev == dev) { 			if (atomic_read(&usb_chip[i]->shutdown)) { 				dev_err(&dev->dev, ""USB device is in the shutdown state, cannot create a card instance\n""); 				err = -EIO; 				goto __error; 			} 			chip = usb_chip[i]; 			atomic_inc(&chip->active); /* avoid autopm */ 			break; 		} 	} 	if (! chip) { 		/* it's a fresh one. 		 * now look for an empty slot and create a new card instance 		 */ 		for (i = 0; i < SNDRV_CARDS; i++) 			if (!usb_chip[i] && 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) && 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) { 				if (enable[i]) { 					err = snd_usb_audio_create(intf, dev, i, quirk, 								   id, &chip); 					if (err < 0) 						goto __error; 					chip->pm_intf = intf; 					break; 				} else if (vid[i] != -1 || pid[i] != -1) { 					dev_info(&dev->dev, 						 ""device (%04x:%04x) is disabled\n"", 						 USB_ID_VENDOR(id), 						 USB_ID_PRODUCT(id)); 					err = -ENOENT; 					goto __error; 				} 			} 		if (!chip) { 			dev_err(&dev->dev, ""no available usb audio device\n""); 			err = -ENODEV; 			goto __error; 		} 	} 	dev_set_drvdata(&dev->dev, chip);  	/* 	 * For devices with more than one control interface, we assume the 	 * first contains the audio controls. We might need a more specific 	 * check here in the future. 	 */ 	if (!chip->ctrl_intf) 		chip->ctrl_intf = alts;  	chip->txfr_quirk = 0; 	err = 1; /* continue */ 	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) { 		/* need some special handlings */ 		err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk); 		if (err < 0) 			goto __error; 	}  	if (err > 0) { 		/* create normal USB audio interfaces */ 		err = snd_usb_create_streams(chip, ifnum); 		if (err < 0) 			goto __error; 		err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error); 		if (err < 0) 			goto __error; 	}  	/* we are allowed to call snd_card_register() many times */ 	err = snd_card_register(chip->card); 	if (err < 0) 		goto __error;  	usb_chip[chip->index] = chip; 	chip->num_interfaces++; 	usb_set_intfdata(intf, chip); 	atomic_dec(&chip->active); 	mutex_unlock(&register_mutex); 	return 0;   __error: 	if (chip) { 		/* chip->active is inside the chip->card object, 		 * decrement before memory is possibly returned. 		 */ 		atomic_dec(&chip->active); 		if (!chip->num_interfaces) 			snd_card_free(chip->card); 	} 	mutex_unlock(&register_mutex); 	return err; }"
"wrap_lines_smart_ass_render_cwe-125.c","CWE-125","wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width) {     int i;     GlyphInfo *cur, *s1, *e1, *s2, *s3;     int last_space;     int break_type;     int exit;     double pen_shift_x;     double pen_shift_y;     int cur_line;     int run_offset;     TextInfo *text_info = &render_priv->text_info;      last_space = -1;     text_info->n_lines = 1;     break_type = 0;     s1 = text_info->glyphs;     // current line start     for (i = 0; i < text_info->length; ++i) {         int break_at = -1;         double s_offset, len;         cur = text_info->glyphs + i;         s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);         len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;          if (cur->symbol == '\n') {             break_type = 2;             break_at = i;             ass_msg(render_priv->library, MSGL_DBG2,                     ""forced line break at %d"", break_at);         } else if (cur->symbol == ' ') {             last_space = i;         } else if (len >= max_text_width                    && (render_priv->state.wrap_style != 2)) {             break_type = 1;             break_at = last_space;             if (break_at >= 0)                 ass_msg(render_priv->library, MSGL_DBG2, ""line break at %d"",                         break_at);         }          if (break_at != -1) {             // need to use one more line             // marking break_at+1 as start of a new line             int lead = break_at + 1;    // the first symbol of the new line             if (text_info->n_lines >= text_info->max_lines) {                 // Raise maximum number of lines                 text_info->max_lines *= 2;                 text_info->lines = realloc(text_info->lines,                                            sizeof(LineInfo) *                                            text_info->max_lines);             }             if (lead < text_info->length) {                 text_info->glyphs[lead].linebreak = break_type;                 last_space = -1;                 s1 = text_info->glyphs + lead;                 text_info->n_lines++;             }         }     } #define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))     exit = 0;     while (!exit && render_priv->state.wrap_style != 1) {         exit = 1;         s3 = text_info->glyphs;         s1 = s2 = 0;         for (i = 0; i <= text_info->length; ++i) {             cur = text_info->glyphs + i;             if ((i == text_info->length) || cur->linebreak) {                 s1 = s2;                 s2 = s3;                 s3 = cur;                 if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'                     double l1, l2, l1_new, l2_new;                     GlyphInfo *w = s2;                      do {                         --w;                     } while ((w > s1) && (w->symbol == ' '));                     while ((w > s1) && (w->symbol != ' ')) {                         --w;                     }                     e1 = w;                     while ((e1 > s1) && (e1->symbol == ' ')) {                         --e1;                     }                     if (w->symbol == ' ')                         ++w;                      l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -                         (s1->bbox.xMin + s1->pos.x));                     l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -                         (s2->bbox.xMin + s2->pos.x));                     l1_new = d6_to_double(                         (e1->bbox.xMax + e1->pos.x) -                         (s1->bbox.xMin + s1->pos.x));                     l2_new = d6_to_double(                         ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -                         (w->bbox.xMin + w->pos.x));                      if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {                         w->linebreak = 1;                         s2->linebreak = 0;                         exit = 0;                     }                 }             }             if (i == text_info->length)                 break;         }      }     assert(text_info->n_lines >= 1); #undef DIFF      measure_text(render_priv);     trim_whitespace(render_priv);      cur_line = 1;     run_offset = 0;      i = 0;     cur = text_info->glyphs + i;     while (i < text_info->length && cur->skip)         cur = text_info->glyphs + ++i;     pen_shift_x = d6_to_double(-cur->pos.x);     pen_shift_y = 0.;      for (i = 0; i < text_info->length; ++i) {         cur = text_info->glyphs + i;         if (cur->linebreak) {             while (i < text_info->length && cur->skip && cur->symbol != '\n')                 cur = text_info->glyphs + ++i;             double height =                 text_info->lines[cur_line - 1].desc +                 text_info->lines[cur_line].asc;             text_info->lines[cur_line - 1].len = i -                 text_info->lines[cur_line - 1].offset;             text_info->lines[cur_line].offset = i;             cur_line++;             run_offset++;             pen_shift_x = d6_to_double(-cur->pos.x);             pen_shift_y += height + render_priv->settings.line_spacing;         }         cur->pos.x += double_to_d6(pen_shift_x);         cur->pos.y += double_to_d6(pen_shift_y);     }     text_info->lines[cur_line - 1].len =         text_info->length - text_info->lines[cur_line - 1].offset;  #if 0     // print line info     for (i = 0; i < text_info->n_lines; i++) {         printf(""line %d offset %d length %d\n"", i, text_info->lines[i].offset,                 text_info->lines[i].len);     } #endif }"
"wrap_lines_smart_ass_render_not_vulnerable.c","not_vulnerable","wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width) {     int i;     GlyphInfo *cur, *s1, *e1, *s2, *s3;     int last_space;     int break_type;     int exit;     double pen_shift_x;     double pen_shift_y;     int cur_line;     int run_offset;     TextInfo *text_info = &render_priv->text_info;      last_space = -1;     text_info->n_lines = 1;     break_type = 0;     s1 = text_info->glyphs;     // current line start     for (i = 0; i < text_info->length; ++i) {         int break_at = -1;         double s_offset, len;         cur = text_info->glyphs + i;         s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);         len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;          if (cur->symbol == '\n') {             break_type = 2;             break_at = i;             ass_msg(render_priv->library, MSGL_DBG2,                     ""forced line break at %d"", break_at);         } else if (cur->symbol == ' ') {             last_space = i;         } else if (len >= max_text_width                    && (render_priv->state.wrap_style != 2)) {             break_type = 1;             break_at = last_space;             if (break_at >= 0)                 ass_msg(render_priv->library, MSGL_DBG2, ""line break at %d"",                         break_at);         }          if (break_at != -1) {             // need to use one more line             // marking break_at+1 as start of a new line             int lead = break_at + 1;    // the first symbol of the new line             if (text_info->n_lines >= text_info->max_lines) {                 // Raise maximum number of lines                 text_info->max_lines *= 2;                 text_info->lines = realloc(text_info->lines,                                            sizeof(LineInfo) *                                            text_info->max_lines);             }             if (lead < text_info->length) {                 text_info->glyphs[lead].linebreak = break_type;                 last_space = -1;                 s1 = text_info->glyphs + lead;                 text_info->n_lines++;             }         }     } #define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))     exit = 0;     while (!exit && render_priv->state.wrap_style != 1) {         exit = 1;         s3 = text_info->glyphs;         s1 = s2 = 0;         for (i = 0; i <= text_info->length; ++i) {             cur = text_info->glyphs + i;             if ((i == text_info->length) || cur->linebreak) {                 s1 = s2;                 s2 = s3;                 s3 = cur;                 if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'                     double l1, l2, l1_new, l2_new;                     GlyphInfo *w = s2;                      do {                         --w;                     } while ((w > s1) && (w->symbol == ' '));                     while ((w > s1) && (w->symbol != ' ')) {                         --w;                     }                     e1 = w;                     while ((e1 > s1) && (e1->symbol == ' ')) {                         --e1;                     }                     if (w->symbol == ' ')                         ++w;                      l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -                         (s1->bbox.xMin + s1->pos.x));                     l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -                         (s2->bbox.xMin + s2->pos.x));                     l1_new = d6_to_double(                         (e1->bbox.xMax + e1->pos.x) -                         (s1->bbox.xMin + s1->pos.x));                     l2_new = d6_to_double(                         ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -                         (w->bbox.xMin + w->pos.x));                      if (DIFF(l1_new, l2_new) < DIFF(l1, l2) && w > text_info->glyphs) {                         if (w->linebreak)                             text_info->n_lines--;                         w->linebreak = 1;                         s2->linebreak = 0;                         exit = 0;                     }                 }             }             if (i == text_info->length)                 break;         }      }     assert(text_info->n_lines >= 1); #undef DIFF      measure_text(render_priv);     trim_whitespace(render_priv);      cur_line = 1;     run_offset = 0;      i = 0;     cur = text_info->glyphs + i;     while (i < text_info->length && cur->skip)         cur = text_info->glyphs + ++i;     pen_shift_x = d6_to_double(-cur->pos.x);     pen_shift_y = 0.;      for (i = 0; i < text_info->length; ++i) {         cur = text_info->glyphs + i;         if (cur->linebreak) {             while (i < text_info->length && cur->skip && cur->symbol != '\n')                 cur = text_info->glyphs + ++i;             double height =                 text_info->lines[cur_line - 1].desc +                 text_info->lines[cur_line].asc;             text_info->lines[cur_line - 1].len = i -                 text_info->lines[cur_line - 1].offset;             text_info->lines[cur_line].offset = i;             cur_line++;             run_offset++;             pen_shift_x = d6_to_double(-cur->pos.x);             pen_shift_y += height + render_priv->settings.line_spacing;         }         cur->pos.x += double_to_d6(pen_shift_x);         cur->pos.y += double_to_d6(pen_shift_y);     }     text_info->lines[cur_line - 1].len =         text_info->length - text_info->lines[cur_line - 1].offset;  #if 0     // print line info     for (i = 0; i < text_info->n_lines; i++) {         printf(""line %d offset %d length %d\n"", i, text_info->lines[i].offset,                 text_info->lines[i].len);     } #endif }"
"x86_decode_insn_emulate_cwe-476.c","CWE-476","int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) { 	int rc = X86EMUL_CONTINUE; 	int mode = ctxt->mode; 	int def_op_bytes, def_ad_bytes, goffset, simd_prefix; 	bool op_prefix = false; 	bool has_seg_override = false; 	struct opcode opcode;  	ctxt->memop.type = OP_NONE; 	ctxt->memopp = NULL; 	ctxt->_eip = ctxt->eip; 	ctxt->fetch.ptr = ctxt->fetch.data; 	ctxt->fetch.end = ctxt->fetch.data + insn_len; 	ctxt->opcode_len = 1; 	if (insn_len > 0) 		memcpy(ctxt->fetch.data, insn, insn_len); 	else { 		rc = __do_insn_fetch_bytes(ctxt, 1); 		if (rc != X86EMUL_CONTINUE) 			return rc; 	}  	switch (mode) { 	case X86EMUL_MODE_REAL: 	case X86EMUL_MODE_VM86: 	case X86EMUL_MODE_PROT16: 		def_op_bytes = def_ad_bytes = 2; 		break; 	case X86EMUL_MODE_PROT32: 		def_op_bytes = def_ad_bytes = 4; 		break; #ifdef CONFIG_X86_64 	case X86EMUL_MODE_PROT64: 		def_op_bytes = 4; 		def_ad_bytes = 8; 		break; #endif 	default: 		return EMULATION_FAILED; 	}  	ctxt->op_bytes = def_op_bytes; 	ctxt->ad_bytes = def_ad_bytes;  	/* Legacy prefixes. */ 	for (;;) { 		switch (ctxt->b = insn_fetch(u8, ctxt)) { 		case 0x66:	/* operand-size override */ 			op_prefix = true; 			/* switch between 2/4 bytes */ 			ctxt->op_bytes = def_op_bytes ^ 6; 			break; 		case 0x67:	/* address-size override */ 			if (mode == X86EMUL_MODE_PROT64) 				/* switch between 4/8 bytes */ 				ctxt->ad_bytes = def_ad_bytes ^ 12; 			else 				/* switch between 2/4 bytes */ 				ctxt->ad_bytes = def_ad_bytes ^ 6; 			break; 		case 0x26:	/* ES override */ 		case 0x2e:	/* CS override */ 		case 0x36:	/* SS override */ 		case 0x3e:	/* DS override */ 			has_seg_override = true; 			ctxt->seg_override = (ctxt->b >> 3) & 3; 			break; 		case 0x64:	/* FS override */ 		case 0x65:	/* GS override */ 			has_seg_override = true; 			ctxt->seg_override = ctxt->b & 7; 			break; 		case 0x40 ... 0x4f: /* REX */ 			if (mode != X86EMUL_MODE_PROT64) 				goto done_prefixes; 			ctxt->rex_prefix = ctxt->b; 			continue; 		case 0xf0:	/* LOCK */ 			ctxt->lock_prefix = 1; 			break; 		case 0xf2:	/* REPNE/REPNZ */ 		case 0xf3:	/* REP/REPE/REPZ */ 			ctxt->rep_prefix = ctxt->b; 			break; 		default: 			goto done_prefixes; 		}  		/* Any legacy prefix after a REX prefix nullifies its effect. */  		ctxt->rex_prefix = 0; 	}  done_prefixes:  	/* REX prefix. */ 	if (ctxt->rex_prefix & 8) 		ctxt->op_bytes = 8;	/* REX.W */  	/* Opcode byte(s). */ 	opcode = opcode_table[ctxt->b]; 	/* Two-byte opcode? */ 	if (ctxt->b == 0x0f) { 		ctxt->opcode_len = 2; 		ctxt->b = insn_fetch(u8, ctxt); 		opcode = twobyte_table[ctxt->b];  		/* 0F_38 opcode map */ 		if (ctxt->b == 0x38) { 			ctxt->opcode_len = 3; 			ctxt->b = insn_fetch(u8, ctxt); 			opcode = opcode_map_0f_38[ctxt->b]; 		} 	} 	ctxt->d = opcode.flags;  	if (ctxt->d & ModRM) 		ctxt->modrm = insn_fetch(u8, ctxt);  	/* vex-prefix instructions are not implemented */ 	if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) && 	    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) { 		ctxt->d = NotImpl; 	}  	while (ctxt->d & GroupMask) { 		switch (ctxt->d & GroupMask) { 		case Group: 			goffset = (ctxt->modrm >> 3) & 7; 			opcode = opcode.u.group[goffset]; 			break; 		case GroupDual: 			goffset = (ctxt->modrm >> 3) & 7; 			if ((ctxt->modrm >> 6) == 3) 				opcode = opcode.u.gdual->mod3[goffset]; 			else 				opcode = opcode.u.gdual->mod012[goffset]; 			break; 		case RMExt: 			goffset = ctxt->modrm & 7; 			opcode = opcode.u.group[goffset]; 			break; 		case Prefix: 			if (ctxt->rep_prefix && op_prefix) 				return EMULATION_FAILED; 			simd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix; 			switch (simd_prefix) { 			case 0x00: opcode = opcode.u.gprefix->pfx_no; break; 			case 0x66: opcode = opcode.u.gprefix->pfx_66; break; 			case 0xf2: opcode = opcode.u.gprefix->pfx_f2; break; 			case 0xf3: opcode = opcode.u.gprefix->pfx_f3; break; 			} 			break; 		case Escape: 			if (ctxt->modrm > 0xbf) 				opcode = opcode.u.esc->high[ctxt->modrm - 0xc0]; 			else 				opcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7]; 			break; 		case InstrDual: 			if ((ctxt->modrm >> 6) == 3) 				opcode = opcode.u.idual->mod3; 			else 				opcode = opcode.u.idual->mod012; 			break; 		case ModeDual: 			if (ctxt->mode == X86EMUL_MODE_PROT64) 				opcode = opcode.u.mdual->mode64; 			else 				opcode = opcode.u.mdual->mode32; 			break; 		default: 			return EMULATION_FAILED; 		}  		ctxt->d &= ~(u64)GroupMask; 		ctxt->d |= opcode.flags; 	}  	/* Unrecognised? */ 	if (ctxt->d == 0) 		return EMULATION_FAILED;  	ctxt->execute = opcode.u.execute;  	if (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD))) 		return EMULATION_FAILED;  	if (unlikely(ctxt->d & 	    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch| 	     No16))) { 		/* 		 * These are copied unconditionally here, and checked unconditionally 		 * in x86_emulate_insn. 		 */ 		ctxt->check_perm = opcode.check_perm; 		ctxt->intercept = opcode.intercept;  		if (ctxt->d & NotImpl) 			return EMULATION_FAILED;  		if (mode == X86EMUL_MODE_PROT64) { 			if (ctxt->op_bytes == 4 && (ctxt->d & Stack)) 				ctxt->op_bytes = 8; 			else if (ctxt->d & NearBranch) 				ctxt->op_bytes = 8; 		}  		if (ctxt->d & Op3264) { 			if (mode == X86EMUL_MODE_PROT64) 				ctxt->op_bytes = 8; 			else 				ctxt->op_bytes = 4; 		}  		if ((ctxt->d & No16) && ctxt->op_bytes == 2) 			ctxt->op_bytes = 4;  		if (ctxt->d & Sse) 			ctxt->op_bytes = 16; 		else if (ctxt->d & Mmx) 			ctxt->op_bytes = 8; 	}  	/* ModRM and SIB bytes. */ 	if (ctxt->d & ModRM) { 		rc = decode_modrm(ctxt, &ctxt->memop); 		if (!has_seg_override) { 			has_seg_override = true; 			ctxt->seg_override = ctxt->modrm_seg; 		} 	} else if (ctxt->d & MemAbs) 		rc = decode_abs(ctxt, &ctxt->memop); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	if (!has_seg_override) 		ctxt->seg_override = VCPU_SREG_DS;  	ctxt->memop.addr.mem.seg = ctxt->seg_override;  	/* 	 * Decode and fetch the source operand: register, memory 	 * or immediate. 	 */ 	rc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	/* 	 * Decode and fetch the second source operand: register, memory 	 * or immediate. 	 */ 	rc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	/* Decode and fetch the destination operand: register or memory. */ 	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);  	if (ctxt->rip_relative) 		ctxt->memopp->addr.mem.ea = address_mask(ctxt, 					ctxt->memopp->addr.mem.ea + ctxt->_eip);  done: 	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK; }"
"x86_decode_insn_emulate_not_vulnerable.c","not_vulnerable","int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) { 	int rc = X86EMUL_CONTINUE; 	int mode = ctxt->mode; 	int def_op_bytes, def_ad_bytes, goffset, simd_prefix; 	bool op_prefix = false; 	bool has_seg_override = false; 	struct opcode opcode;  	ctxt->memop.type = OP_NONE; 	ctxt->memopp = NULL; 	ctxt->_eip = ctxt->eip; 	ctxt->fetch.ptr = ctxt->fetch.data; 	ctxt->fetch.end = ctxt->fetch.data + insn_len; 	ctxt->opcode_len = 1; 	if (insn_len > 0) 		memcpy(ctxt->fetch.data, insn, insn_len); 	else { 		rc = __do_insn_fetch_bytes(ctxt, 1); 		if (rc != X86EMUL_CONTINUE) 			return rc; 	}  	switch (mode) { 	case X86EMUL_MODE_REAL: 	case X86EMUL_MODE_VM86: 	case X86EMUL_MODE_PROT16: 		def_op_bytes = def_ad_bytes = 2; 		break; 	case X86EMUL_MODE_PROT32: 		def_op_bytes = def_ad_bytes = 4; 		break; #ifdef CONFIG_X86_64 	case X86EMUL_MODE_PROT64: 		def_op_bytes = 4; 		def_ad_bytes = 8; 		break; #endif 	default: 		return EMULATION_FAILED; 	}  	ctxt->op_bytes = def_op_bytes; 	ctxt->ad_bytes = def_ad_bytes;  	/* Legacy prefixes. */ 	for (;;) { 		switch (ctxt->b = insn_fetch(u8, ctxt)) { 		case 0x66:	/* operand-size override */ 			op_prefix = true; 			/* switch between 2/4 bytes */ 			ctxt->op_bytes = def_op_bytes ^ 6; 			break; 		case 0x67:	/* address-size override */ 			if (mode == X86EMUL_MODE_PROT64) 				/* switch between 4/8 bytes */ 				ctxt->ad_bytes = def_ad_bytes ^ 12; 			else 				/* switch between 2/4 bytes */ 				ctxt->ad_bytes = def_ad_bytes ^ 6; 			break; 		case 0x26:	/* ES override */ 		case 0x2e:	/* CS override */ 		case 0x36:	/* SS override */ 		case 0x3e:	/* DS override */ 			has_seg_override = true; 			ctxt->seg_override = (ctxt->b >> 3) & 3; 			break; 		case 0x64:	/* FS override */ 		case 0x65:	/* GS override */ 			has_seg_override = true; 			ctxt->seg_override = ctxt->b & 7; 			break; 		case 0x40 ... 0x4f: /* REX */ 			if (mode != X86EMUL_MODE_PROT64) 				goto done_prefixes; 			ctxt->rex_prefix = ctxt->b; 			continue; 		case 0xf0:	/* LOCK */ 			ctxt->lock_prefix = 1; 			break; 		case 0xf2:	/* REPNE/REPNZ */ 		case 0xf3:	/* REP/REPE/REPZ */ 			ctxt->rep_prefix = ctxt->b; 			break; 		default: 			goto done_prefixes; 		}  		/* Any legacy prefix after a REX prefix nullifies its effect. */  		ctxt->rex_prefix = 0; 	}  done_prefixes:  	/* REX prefix. */ 	if (ctxt->rex_prefix & 8) 		ctxt->op_bytes = 8;	/* REX.W */  	/* Opcode byte(s). */ 	opcode = opcode_table[ctxt->b]; 	/* Two-byte opcode? */ 	if (ctxt->b == 0x0f) { 		ctxt->opcode_len = 2; 		ctxt->b = insn_fetch(u8, ctxt); 		opcode = twobyte_table[ctxt->b];  		/* 0F_38 opcode map */ 		if (ctxt->b == 0x38) { 			ctxt->opcode_len = 3; 			ctxt->b = insn_fetch(u8, ctxt); 			opcode = opcode_map_0f_38[ctxt->b]; 		} 	} 	ctxt->d = opcode.flags;  	if (ctxt->d & ModRM) 		ctxt->modrm = insn_fetch(u8, ctxt);  	/* vex-prefix instructions are not implemented */ 	if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) && 	    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) { 		ctxt->d = NotImpl; 	}  	while (ctxt->d & GroupMask) { 		switch (ctxt->d & GroupMask) { 		case Group: 			goffset = (ctxt->modrm >> 3) & 7; 			opcode = opcode.u.group[goffset]; 			break; 		case GroupDual: 			goffset = (ctxt->modrm >> 3) & 7; 			if ((ctxt->modrm >> 6) == 3) 				opcode = opcode.u.gdual->mod3[goffset]; 			else 				opcode = opcode.u.gdual->mod012[goffset]; 			break; 		case RMExt: 			goffset = ctxt->modrm & 7; 			opcode = opcode.u.group[goffset]; 			break; 		case Prefix: 			if (ctxt->rep_prefix && op_prefix) 				return EMULATION_FAILED; 			simd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix; 			switch (simd_prefix) { 			case 0x00: opcode = opcode.u.gprefix->pfx_no; break; 			case 0x66: opcode = opcode.u.gprefix->pfx_66; break; 			case 0xf2: opcode = opcode.u.gprefix->pfx_f2; break; 			case 0xf3: opcode = opcode.u.gprefix->pfx_f3; break; 			} 			break; 		case Escape: 			if (ctxt->modrm > 0xbf) 				opcode = opcode.u.esc->high[ctxt->modrm - 0xc0]; 			else 				opcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7]; 			break; 		case InstrDual: 			if ((ctxt->modrm >> 6) == 3) 				opcode = opcode.u.idual->mod3; 			else 				opcode = opcode.u.idual->mod012; 			break; 		case ModeDual: 			if (ctxt->mode == X86EMUL_MODE_PROT64) 				opcode = opcode.u.mdual->mode64; 			else 				opcode = opcode.u.mdual->mode32; 			break; 		default: 			return EMULATION_FAILED; 		}  		ctxt->d &= ~(u64)GroupMask; 		ctxt->d |= opcode.flags; 	}  	/* Unrecognised? */ 	if (ctxt->d == 0) 		return EMULATION_FAILED;  	ctxt->execute = opcode.u.execute;  	if (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD))) 		return EMULATION_FAILED;  	if (unlikely(ctxt->d & 	    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch| 	     No16))) { 		/* 		 * These are copied unconditionally here, and checked unconditionally 		 * in x86_emulate_insn. 		 */ 		ctxt->check_perm = opcode.check_perm; 		ctxt->intercept = opcode.intercept;  		if (ctxt->d & NotImpl) 			return EMULATION_FAILED;  		if (mode == X86EMUL_MODE_PROT64) { 			if (ctxt->op_bytes == 4 && (ctxt->d & Stack)) 				ctxt->op_bytes = 8; 			else if (ctxt->d & NearBranch) 				ctxt->op_bytes = 8; 		}  		if (ctxt->d & Op3264) { 			if (mode == X86EMUL_MODE_PROT64) 				ctxt->op_bytes = 8; 			else 				ctxt->op_bytes = 4; 		}  		if ((ctxt->d & No16) && ctxt->op_bytes == 2) 			ctxt->op_bytes = 4;  		if (ctxt->d & Sse) 			ctxt->op_bytes = 16; 		else if (ctxt->d & Mmx) 			ctxt->op_bytes = 8; 	}  	/* ModRM and SIB bytes. */ 	if (ctxt->d & ModRM) { 		rc = decode_modrm(ctxt, &ctxt->memop); 		if (!has_seg_override) { 			has_seg_override = true; 			ctxt->seg_override = ctxt->modrm_seg; 		} 	} else if (ctxt->d & MemAbs) 		rc = decode_abs(ctxt, &ctxt->memop); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	if (!has_seg_override) 		ctxt->seg_override = VCPU_SREG_DS;  	ctxt->memop.addr.mem.seg = ctxt->seg_override;  	/* 	 * Decode and fetch the source operand: register, memory 	 * or immediate. 	 */ 	rc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	/* 	 * Decode and fetch the second source operand: register, memory 	 * or immediate. 	 */ 	rc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask); 	if (rc != X86EMUL_CONTINUE) 		goto done;  	/* Decode and fetch the destination operand: register or memory. */ 	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);  	if (ctxt->rip_relative && likely(ctxt->memopp)) 		ctxt->memopp->addr.mem.ea = address_mask(ctxt, 					ctxt->memopp->addr.mem.ea + ctxt->_eip);  done: 	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK; }"
"xc2028_set_config_tuner-xc2028_cwe-416.c","CWE-416","static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) { 	struct xc2028_data *priv = fe->tuner_priv; 	struct xc2028_ctrl *p    = priv_cfg; 	int                 rc   = 0;  	tuner_dbg(""%s called\n"", __func__);  	mutex_lock(&priv->lock);  	/* 	 * Copy the config data. 	 * For the firmware name, keep a local copy of the string, 	 * in order to avoid troubles during device release. 	 */ 	kfree(priv->ctrl.fname); 	memcpy(&priv->ctrl, p, sizeof(priv->ctrl)); 	if (p->fname) { 		priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL); 		if (priv->ctrl.fname == NULL) 			rc = -ENOMEM; 	}  	/* 	 * If firmware name changed, frees firmware. As free_firmware will 	 * reset the status to NO_FIRMWARE, this forces a new request_firmware 	 */ 	if (!firmware_name[0] && p->fname && 	    priv->fname && strcmp(p->fname, priv->fname)) 		free_firmware(priv);  	if (priv->ctrl.max_len < 9) 		priv->ctrl.max_len = 13;  	if (priv->state == XC2028_NO_FIRMWARE) { 		if (!firmware_name[0]) 			priv->fname = priv->ctrl.fname; 		else 			priv->fname = firmware_name;  		rc = request_firmware_nowait(THIS_MODULE, 1, 					     priv->fname, 					     priv->i2c_props.adap->dev.parent, 					     GFP_KERNEL, 					     fe, load_firmware_cb); 		if (rc < 0) { 			tuner_err(""Failed to request firmware %s\n"", 				  priv->fname); 			priv->state = XC2028_NODEV; 		} else 			priv->state = XC2028_WAITING_FIRMWARE; 	} 	mutex_unlock(&priv->lock);  	return rc; }"
"xc2028_set_config_tuner-xc2028_not_vulnerable.c","not_vulnerable","static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) { 	struct xc2028_data *priv = fe->tuner_priv; 	struct xc2028_ctrl *p    = priv_cfg; 	int                 rc   = 0;  	tuner_dbg(""%s called\n"", __func__);  	mutex_lock(&priv->lock);  	/* 	 * Copy the config data. 	 * For the firmware name, keep a local copy of the string, 	 * in order to avoid troubles during device release. 	 */ 	kfree(priv->ctrl.fname); 	priv->ctrl.fname = NULL; 	memcpy(&priv->ctrl, p, sizeof(priv->ctrl)); 	if (p->fname) { 		priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL); 		if (priv->ctrl.fname == NULL) 			return -ENOMEM; 	}  	/* 	 * If firmware name changed, frees firmware. As free_firmware will 	 * reset the status to NO_FIRMWARE, this forces a new request_firmware 	 */ 	if (!firmware_name[0] && p->fname && 	    priv->fname && strcmp(p->fname, priv->fname)) 		free_firmware(priv);  	if (priv->ctrl.max_len < 9) 		priv->ctrl.max_len = 13;  	if (priv->state == XC2028_NO_FIRMWARE) { 		if (!firmware_name[0]) 			priv->fname = priv->ctrl.fname; 		else 			priv->fname = firmware_name;  		rc = request_firmware_nowait(THIS_MODULE, 1, 					     priv->fname, 					     priv->i2c_props.adap->dev.parent, 					     GFP_KERNEL, 					     fe, load_firmware_cb); 		if (rc < 0) { 			tuner_err(""Failed to request firmware %s\n"", 				  priv->fname); 			priv->state = XC2028_NODEV; 		} else 			priv->state = XC2028_WAITING_FIRMWARE; 	} 	mutex_unlock(&priv->lock);  	return rc; }"
"xfs_attr_shortform_to_leaf_xfs_attr_leaf_cwe-476.c","CWE-476","xfs_attr_shortform_to_leaf( 	struct xfs_da_args	*args, 	struct xfs_buf		**leaf_bp) { 	xfs_inode_t *dp; 	xfs_attr_shortform_t *sf; 	xfs_attr_sf_entry_t *sfe; 	xfs_da_args_t nargs; 	char *tmpbuffer; 	int error, i, size; 	xfs_dablk_t blkno; 	struct xfs_buf *bp; 	xfs_ifork_t *ifp;  	trace_xfs_attr_sf_to_leaf(args);  	dp = args->dp; 	ifp = dp->i_afp; 	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data; 	size = be16_to_cpu(sf->hdr.totsize); 	tmpbuffer = kmem_alloc(size, KM_SLEEP); 	ASSERT(tmpbuffer != NULL); 	memcpy(tmpbuffer, ifp->if_u1.if_data, size); 	sf = (xfs_attr_shortform_t *)tmpbuffer;  	xfs_idata_realloc(dp, -size, XFS_ATTR_FORK); 	xfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);  	bp = NULL; 	error = xfs_da_grow_inode(args, &blkno); 	if (error) { 		/* 		 * If we hit an IO error middle of the transaction inside 		 * grow_inode(), we may have inconsistent data. Bail out. 		 */ 		if (error == -EIO) 			goto out; 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */ 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */ 		goto out; 	}  	ASSERT(blkno == 0); 	error = xfs_attr3_leaf_create(args, blkno, &bp); 	if (error) { 		error = xfs_da_shrink_inode(args, 0, bp); 		bp = NULL; 		if (error) 			goto out; 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */ 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */ 		goto out; 	}  	memset((char *)&nargs, 0, sizeof(nargs)); 	nargs.dp = dp; 	nargs.geo = args->geo; 	nargs.firstblock = args->firstblock; 	nargs.dfops = args->dfops; 	nargs.total = args->total; 	nargs.whichfork = XFS_ATTR_FORK; 	nargs.trans = args->trans; 	nargs.op_flags = XFS_DA_OP_OKNOENT;  	sfe = &sf->list[0]; 	for (i = 0; i < sf->hdr.count; i++) { 		nargs.name = sfe->nameval; 		nargs.namelen = sfe->namelen; 		nargs.value = &sfe->nameval[nargs.namelen]; 		nargs.valuelen = sfe->valuelen; 		nargs.hashval = xfs_da_hashname(sfe->nameval, 						sfe->namelen); 		nargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags); 		error = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */ 		ASSERT(error == -ENOATTR); 		error = xfs_attr3_leaf_add(bp, &nargs); 		ASSERT(error != -ENOSPC); 		if (error) 			goto out; 		sfe = XFS_ATTR_SF_NEXTENTRY(sfe); 	} 	error = 0; 	*leaf_bp = bp; out: 	kmem_free(tmpbuffer); 	return error; }"
"xfs_attr_shortform_to_leaf_xfs_attr_leaf_not_vulnerable.c","not_vulnerable","xfs_attr_shortform_to_leaf( 	struct xfs_da_args	*args, 	struct xfs_buf		**leaf_bp) { 	xfs_inode_t *dp; 	xfs_attr_shortform_t *sf; 	xfs_attr_sf_entry_t *sfe; 	xfs_da_args_t nargs; 	char *tmpbuffer; 	int error, i, size; 	xfs_dablk_t blkno; 	struct xfs_buf *bp; 	xfs_ifork_t *ifp;  	trace_xfs_attr_sf_to_leaf(args);  	dp = args->dp; 	ifp = dp->i_afp; 	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data; 	size = be16_to_cpu(sf->hdr.totsize); 	tmpbuffer = kmem_alloc(size, KM_SLEEP); 	ASSERT(tmpbuffer != NULL); 	memcpy(tmpbuffer, ifp->if_u1.if_data, size); 	sf = (xfs_attr_shortform_t *)tmpbuffer;  	xfs_idata_realloc(dp, -size, XFS_ATTR_FORK); 	xfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);  	bp = NULL; 	error = xfs_da_grow_inode(args, &blkno); 	if (error) { 		/* 		 * If we hit an IO error middle of the transaction inside 		 * grow_inode(), we may have inconsistent data. Bail out. 		 */ 		if (error == -EIO) 			goto out; 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */ 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */ 		goto out; 	}  	ASSERT(blkno == 0); 	error = xfs_attr3_leaf_create(args, blkno, &bp); 	if (error) { 		/* xfs_attr3_leaf_create may not have instantiated a block */ 		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0)) 			goto out; 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */ 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */ 		goto out; 	}  	memset((char *)&nargs, 0, sizeof(nargs)); 	nargs.dp = dp; 	nargs.geo = args->geo; 	nargs.firstblock = args->firstblock; 	nargs.dfops = args->dfops; 	nargs.total = args->total; 	nargs.whichfork = XFS_ATTR_FORK; 	nargs.trans = args->trans; 	nargs.op_flags = XFS_DA_OP_OKNOENT;  	sfe = &sf->list[0]; 	for (i = 0; i < sf->hdr.count; i++) { 		nargs.name = sfe->nameval; 		nargs.namelen = sfe->namelen; 		nargs.value = &sfe->nameval[nargs.namelen]; 		nargs.valuelen = sfe->valuelen; 		nargs.hashval = xfs_da_hashname(sfe->nameval, 						sfe->namelen); 		nargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags); 		error = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */ 		ASSERT(error == -ENOATTR); 		error = xfs_attr3_leaf_add(bp, &nargs); 		ASSERT(error != -ENOSPC); 		if (error) 			goto out; 		sfe = XFS_ATTR_SF_NEXTENTRY(sfe); 	} 	error = 0; 	*leaf_bp = bp; out: 	kmem_free(tmpbuffer); 	return error; }"
