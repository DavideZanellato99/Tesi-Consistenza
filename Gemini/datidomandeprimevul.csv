"101665_not_vulnerable.cpp","not_vulnerable","void WebProcessProxy::didBecomeUnresponsive(ResponsivenessTimer*) {     Vector<RefPtr<WebPageProxy> > pages;     copyValuesToVector(m_pageMap, pages);     for (size_t i = 0, size = pages.size(); i < size; ++i)         pages[i]->processDidBecomeUnresponsive(); } "
"139236_not_vulnerable.cpp","not_vulnerable","void OverlayWindowViews::OnNativeWidgetDestroyed() {   controller_->OnWindowDestroyed(); } "
"175684_not_vulnerable.cpp","not_vulnerable","  virtual void ConnectToCellularNetwork(const CellularNetwork* network) {     DCHECK(network);     if (!EnsureCrosLoaded())       return;     if (network && ConnectToNetwork(network->service_path().c_str(), NULL)) {       CellularNetwork* cellular = GetWirelessNetworkByPath(           cellular_networks_, network->service_path());       if (cellular) {         cellular->set_connecting(true);         cellular_ = cellular;       }       NotifyNetworkManagerChanged();     }   } "
"194963_CWE-704.c","CWE-704","static MagickBooleanType GetEXIFProperty(const Image *image,   const char *property) { #define MaxDirectoryStack  16 #define EXIF_DELIMITER  ""\n"" #define EXIF_NUM_FORMATS  12 #define EXIF_FMT_BYTE  1 #define EXIF_FMT_STRING  2 #define EXIF_FMT_USHORT  3 #define EXIF_FMT_ULONG  4 #define EXIF_FMT_URATIONAL  5 #define EXIF_FMT_SBYTE  6 #define EXIF_FMT_UNDEFINED  7 #define EXIF_FMT_SSHORT  8 #define EXIF_FMT_SLONG  9 #define EXIF_FMT_SRATIONAL  10 #define EXIF_FMT_SINGLE  11 #define EXIF_FMT_DOUBLE  12 #define TAG_EXIF_OFFSET  0x8769 #define TAG_GPS_OFFSET  0x8825 #define TAG_INTEROP_OFFSET  0xa005  #define EXIFMultipleValues(size,format,arg) \ { \    ssize_t \      component; \  \    size_t \      length; \  \    unsigned char \      *p1; \  \    length=0; \    p1=p; \    for (component=0; component < components; component++) \    { \      length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \        format"", "",arg); \      if (length >= (MaxTextExtent-1)) \        length=MaxTextExtent-1; \      p1+=size; \    } \    if (length > 1) \      buffer[length-2]='\0'; \    value=AcquireString(buffer); \ }  #define EXIFMultipleFractions(size,format,arg1,arg2) \ { \    ssize_t \      component; \  \    size_t \      length; \  \    unsigned char \      *p1; \  \    length=0; \    p1=p; \    for (component=0; component < components; component++) \    { \      length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \        format"", "",(arg1),(arg2)); \      if (length >= (MaxTextExtent-1)) \        length=MaxTextExtent-1; \      p1+=size; \    } \    if (length > 1) \      buffer[length-2]='\0'; \    value=AcquireString(buffer); \ }    typedef struct _DirectoryInfo   {     const unsigned char       *directory;      size_t       entry;      ssize_t       offset;   } DirectoryInfo;    typedef struct _TagInfo   {     size_t       tag;      const char       description[36];   } TagInfo;    static const TagInfo     EXIFTag[] =     {       {  0x001, ""exif:InteroperabilityIndex"" },       {  0x002, ""exif:InteroperabilityVersion"" },       {  0x100, ""exif:ImageWidth"" },       {  0x101, ""exif:ImageLength"" },       {  0x102, ""exif:BitsPerSample"" },       {  0x103, ""exif:Compression"" },       {  0x106, ""exif:PhotometricInterpretation"" },       {  0x10a, ""exif:FillOrder"" },       {  0x10d, ""exif:DocumentName"" },       {  0x10e, ""exif:ImageDescription"" },       {  0x10f, ""exif:Make"" },       {  0x110, ""exif:Model"" },       {  0x111, ""exif:StripOffsets"" },       {  0x112, ""exif:Orientation"" },       {  0x115, ""exif:SamplesPerPixel"" },       {  0x116, ""exif:RowsPerStrip"" },       {  0x117, ""exif:StripByteCounts"" },       {  0x11a, ""exif:XResolution"" },       {  0x11b, ""exif:YResolution"" },       {  0x11c, ""exif:PlanarConfiguration"" },       {  0x11d, ""exif:PageName"" },       {  0x11e, ""exif:XPosition"" },       {  0x11f, ""exif:YPosition"" },       {  0x118, ""exif:MinSampleValue"" },       {  0x119, ""exif:MaxSampleValue"" },       {  0x120, ""exif:FreeOffsets"" },       {  0x121, ""exif:FreeByteCounts"" },       {  0x122, ""exif:GrayResponseUnit"" },       {  0x123, ""exif:GrayResponseCurve"" },       {  0x124, ""exif:T4Options"" },       {  0x125, ""exif:T6Options"" },       {  0x128, ""exif:ResolutionUnit"" },       {  0x12d, ""exif:TransferFunction"" },       {  0x131, ""exif:Software"" },       {  0x132, ""exif:DateTime"" },       {  0x13b, ""exif:Artist"" },       {  0x13e, ""exif:WhitePoint"" },       {  0x13f, ""exif:PrimaryChromaticities"" },       {  0x140, ""exif:ColorMap"" },       {  0x141, ""exif:HalfToneHints"" },       {  0x142, ""exif:TileWidth"" },       {  0x143, ""exif:TileLength"" },       {  0x144, ""exif:TileOffsets"" },       {  0x145, ""exif:TileByteCounts"" },       {  0x14a, ""exif:SubIFD"" },       {  0x14c, ""exif:InkSet"" },       {  0x14d, ""exif:InkNames"" },       {  0x14e, ""exif:NumberOfInks"" },       {  0x150, ""exif:DotRange"" },       {  0x151, ""exif:TargetPrinter"" },       {  0x152, ""exif:ExtraSample"" },       {  0x153, ""exif:SampleFormat"" },       {  0x154, ""exif:SMinSampleValue"" },       {  0x155, ""exif:SMaxSampleValue"" },       {  0x156, ""exif:TransferRange"" },       {  0x157, ""exif:ClipPath"" },       {  0x158, ""exif:XClipPathUnits"" },       {  0x159, ""exif:YClipPathUnits"" },       {  0x15a, ""exif:Indexed"" },       {  0x15b, ""exif:JPEGTables"" },       {  0x15f, ""exif:OPIProxy"" },       {  0x200, ""exif:JPEGProc"" },       {  0x201, ""exif:JPEGInterchangeFormat"" },       {  0x202, ""exif:JPEGInterchangeFormatLength"" },       {  0x203, ""exif:JPEGRestartInterval"" },       {  0x205, ""exif:JPEGLosslessPredictors"" },       {  0x206, ""exif:JPEGPointTransforms"" },       {  0x207, ""exif:JPEGQTables"" },       {  0x208, ""exif:JPEGDCTables"" },       {  0x209, ""exif:JPEGACTables"" },       {  0x211, ""exif:YCbCrCoefficients"" },       {  0x212, ""exif:YCbCrSubSampling"" },       {  0x213, ""exif:YCbCrPositioning"" },       {  0x214, ""exif:ReferenceBlackWhite"" },       {  0x2bc, ""exif:ExtensibleMetadataPlatform"" },       {  0x301, ""exif:Gamma"" },       {  0x302, ""exif:ICCProfileDescriptor"" },       {  0x303, ""exif:SRGBRenderingIntent"" },       {  0x320, ""exif:ImageTitle"" },       {  0x5001, ""exif:ResolutionXUnit"" },       {  0x5002, ""exif:ResolutionYUnit"" },       {  0x5003, ""exif:ResolutionXLengthUnit"" },       {  0x5004, ""exif:ResolutionYLengthUnit"" },       {  0x5005, ""exif:PrintFlags"" },       {  0x5006, ""exif:PrintFlagsVersion"" },       {  0x5007, ""exif:PrintFlagsCrop"" },       {  0x5008, ""exif:PrintFlagsBleedWidth"" },       {  0x5009, ""exif:PrintFlagsBleedWidthScale"" },       {  0x500A, ""exif:HalftoneLPI"" },       {  0x500B, ""exif:HalftoneLPIUnit"" },       {  0x500C, ""exif:HalftoneDegree"" },       {  0x500D, ""exif:HalftoneShape"" },       {  0x500E, ""exif:HalftoneMisc"" },       {  0x500F, ""exif:HalftoneScreen"" },       {  0x5010, ""exif:JPEGQuality"" },       {  0x5011, ""exif:GridSize"" },       {  0x5012, ""exif:ThumbnailFormat"" },       {  0x5013, ""exif:ThumbnailWidth"" },       {  0x5014, ""exif:ThumbnailHeight"" },       {  0x5015, ""exif:ThumbnailColorDepth"" },       {  0x5016, ""exif:ThumbnailPlanes"" },       {  0x5017, ""exif:ThumbnailRawBytes"" },       {  0x5018, ""exif:ThumbnailSize"" },       {  0x5019, ""exif:ThumbnailCompressedSize"" },       {  0x501a, ""exif:ColorTransferFunction"" },       {  0x501b, ""exif:ThumbnailData"" },       {  0x5020, ""exif:ThumbnailImageWidth"" },       {  0x5021, ""exif:ThumbnailImageHeight"" },       {  0x5022, ""exif:ThumbnailBitsPerSample"" },       {  0x5023, ""exif:ThumbnailCompression"" },       {  0x5024, ""exif:ThumbnailPhotometricInterp"" },       {  0x5025, ""exif:ThumbnailImageDescription"" },       {  0x5026, ""exif:ThumbnailEquipMake"" },       {  0x5027, ""exif:ThumbnailEquipModel"" },       {  0x5028, ""exif:ThumbnailStripOffsets"" },       {  0x5029, ""exif:ThumbnailOrientation"" },       {  0x502a, ""exif:ThumbnailSamplesPerPixel"" },       {  0x502b, ""exif:ThumbnailRowsPerStrip"" },       {  0x502c, ""exif:ThumbnailStripBytesCount"" },       {  0x502d, ""exif:ThumbnailResolutionX"" },       {  0x502e, ""exif:ThumbnailResolutionY"" },       {  0x502f, ""exif:ThumbnailPlanarConfig"" },       {  0x5030, ""exif:ThumbnailResolutionUnit"" },       {  0x5031, ""exif:ThumbnailTransferFunction"" },       {  0x5032, ""exif:ThumbnailSoftwareUsed"" },       {  0x5033, ""exif:ThumbnailDateTime"" },       {  0x5034, ""exif:ThumbnailArtist"" },       {  0x5035, ""exif:ThumbnailWhitePoint"" },       {  0x5036, ""exif:ThumbnailPrimaryChromaticities"" },       {  0x5037, ""exif:ThumbnailYCbCrCoefficients"" },       {  0x5038, ""exif:ThumbnailYCbCrSubsampling"" },       {  0x5039, ""exif:ThumbnailYCbCrPositioning"" },       {  0x503A, ""exif:ThumbnailRefBlackWhite"" },       {  0x503B, ""exif:ThumbnailCopyRight"" },       {  0x5090, ""exif:LuminanceTable"" },       {  0x5091, ""exif:ChrominanceTable"" },       {  0x5100, ""exif:FrameDelay"" },       {  0x5101, ""exif:LoopCount"" },       {  0x5110, ""exif:PixelUnit"" },       {  0x5111, ""exif:PixelPerUnitX"" },       {  0x5112, ""exif:PixelPerUnitY"" },       {  0x5113, ""exif:PaletteHistogram"" },       {  0x1000, ""exif:RelatedImageFileFormat"" },       {  0x1001, ""exif:RelatedImageLength"" },       {  0x1002, ""exif:RelatedImageWidth"" },       {  0x800d, ""exif:ImageID"" },       {  0x80e3, ""exif:Matteing"" },       {  0x80e4, ""exif:DataType"" },       {  0x80e5, ""exif:ImageDepth"" },       {  0x80e6, ""exif:TileDepth"" },       {  0x828d, ""exif:CFARepeatPatternDim"" },       {  0x828e, ""exif:CFAPattern2"" },       {  0x828f, ""exif:BatteryLevel"" },       {  0x8298, ""exif:Copyright"" },       {  0x829a, ""exif:ExposureTime"" },       {  0x829d, ""exif:FNumber"" },       {  0x83bb, ""exif:IPTC/NAA"" },       {  0x84e3, ""exif:IT8RasterPadding"" },       {  0x84e5, ""exif:IT8ColorTable"" },       {  0x8649, ""exif:ImageResourceInformation"" },       {  0x8769, ""exif:ExifOffset"" },  /* specs as ""Exif IFD Pointer""? */       {  0x8773, ""exif:InterColorProfile"" },       {  0x8822, ""exif:ExposureProgram"" },       {  0x8824, ""exif:SpectralSensitivity"" },       {  0x8825, ""exif:GPSInfo"" }, /* specs as ""GPSInfo IFD Pointer""? */       {  0x8827, ""exif:PhotographicSensitivity"" },       {  0x8828, ""exif:OECF"" },       {  0x8829, ""exif:Interlace"" },             {  0x882a, ""exif:TimeZoneOffset"" },       {  0x882b, ""exif:SelfTimerMode"" },       {  0x8830, ""exif:SensitivityType"" },       {  0x8831, ""exif:StandardOutputSensitivity"" },       {  0x8832, ""exif:RecommendedExposureIndex"" },       {  0x8833, ""exif:ISOSpeed"" },       {  0x8834, ""exif:ISOSpeedLatitudeyyy"" },       {  0x8835, ""exif:ISOSpeedLatitudezzz"" },       {  0x9000, ""exif:ExifVersion"" },       {  0x9003, ""exif:DateTimeOriginal"" },       {  0x9004, ""exif:DateTimeDigitized"" },       {  0x9010, ""exif:OffsetTime"" },       {  0x9011, ""exif:OffsetTimeOriginal"" },       {  0x9012, ""exif:OffsetTimeDigitized"" },       {  0x9101, ""exif:ComponentsConfiguration"" },       {  0x9102, ""exif:CompressedBitsPerPixel"" },       {  0x9201, ""exif:ShutterSpeedValue"" },       {  0x9202, ""exif:ApertureValue"" },       {  0x9203, ""exif:BrightnessValue"" },       {  0x9204, ""exif:ExposureBiasValue"" },       {  0x9205, ""exif:MaxApertureValue"" },       {  0x9206, ""exif:SubjectDistance"" },       {  0x9207, ""exif:MeteringMode"" },       {  0x9208, ""exif:LightSource"" },       {  0x9209, ""exif:Flash"" },       {  0x920a, ""exif:FocalLength"" },       {  0x920b, ""exif:FlashEnergy"" },       {  0x920c, ""exif:SpatialFrequencyResponse"" },       {  0x920d, ""exif:Noise"" },       {  0x9214, ""exif:SubjectArea"" },       {  0x9290, ""exif:SubSecTime"" },       {  0x9291, ""exif:SubSecTimeOriginal"" },       {  0x9292, ""exif:SubSecTimeDigitized"" },           {  0x9211, ""exif:ImageNumber"" },       {  0x9212, ""exif:SecurityClassification"" },       {  0x9213, ""exif:ImageHistory"" },       {  0x9214, ""exif:SubjectArea"" },       {  0x9215, ""exif:ExposureIndex"" },       {  0x9216, ""exif:TIFF-EPStandardID"" },       {  0x927c, ""exif:MakerNote"" },       {  0x9286, ""exif:UserComment"" },       {  0x9290, ""exif:SubSecTime"" },       {  0x9291, ""exif:SubSecTimeOriginal"" },       {  0x9292, ""exif:SubSecTimeDigitized"" },           {  0x9400, ""exif:Temperature"" },       {  0x9401, ""exif:Humidity"" },       {  0x9402, ""exif:Pressure"" },       {  0x9403, ""exif:WaterDepth"" },       {  0x9404, ""exif:Acceleration"" },       {  0x9405, ""exif:CameraElevationAngle"" },           {  0x9C9b, ""exif:WinXP-Title"" },       {  0x9C9c, ""exif:WinXP-Comments"" },       {  0x9C9d, ""exif:WinXP-Author"" },       {  0x9C9e, ""exif:WinXP-Keywords"" },       {  0x9C9f, ""exif:WinXP-Subject"" },             {  0xa000, ""exif:FlashPixVersion"" },       {  0xa001, ""exif:ColorSpace"" },       {  0xa002, ""exif:PixelXDimension"" },       {  0xa003, ""exif:PixelYDimension"" },       {  0xa004, ""exif:RelatedSoundFile"" },       {  0xa005, ""exif:InteroperabilityOffset"" },       {  0xa20b, ""exif:FlashEnergy"" },       {  0xa20c, ""exif:SpatialFrequencyResponse"" },       {  0xa20d, ""exif:Noise"" },       {  0xa20e, ""exif:FocalPlaneXResolution"" },       {  0xa20f, ""exif:FocalPlaneYResolution"" },       {  0xa210, ""exif:FocalPlaneResolutionUnit"" },       {  0xa214, ""exif:SubjectLocation"" },       {  0xa215, ""exif:ExposureIndex"" },       {  0xa216, ""exif:TIFF/EPStandardID"" },       {  0xa217, ""exif:SensingMethod"" },       {  0xa300, ""exif:FileSource"" },       {  0xa301, ""exif:SceneType"" },       {  0xa302, ""exif:CFAPattern"" },       {  0xa401, ""exif:CustomRendered"" },       {  0xa402, ""exif:ExposureMode"" },       {  0xa403, ""exif:WhiteBalance"" },       {  0xa404, ""exif:DigitalZoomRatio"" },       {  0xa405, ""exif:FocalLengthIn35mmFilm"" },       {  0xa406, ""exif:SceneCaptureType"" },       {  0xa407, ""exif:GainControl"" },       {  0xa408, ""exif:Contrast"" },       {  0xa409, ""exif:Saturation"" },       {  0xa40a, ""exif:Sharpness"" },       {  0xa40b, ""exif:DeviceSettingDescription"" },       {  0xa40c, ""exif:SubjectDistanceRange"" },       {  0xa420, ""exif:ImageUniqueID"" },       {  0xa430, ""exif:CameraOwnerName"" },       {  0xa431, ""exif:BodySerialNumber"" },       {  0xa432, ""exif:LensSpecification"" },       {  0xa433, ""exif:LensMake"" },       {  0xa434, ""exif:LensModel"" },       {  0xa435, ""exif:LensSerialNumber"" },       {  0xc4a5, ""exif:PrintImageMatching"" },       {  0xa500, ""exif:Gamma"" },       {  0xc640, ""exif:CR2Slice"" },       { 0x10000, ""exif:GPSVersionID"" },       { 0x10001, ""exif:GPSLatitudeRef"" },       { 0x10002, ""exif:GPSLatitude"" },       { 0x10003, ""exif:GPSLongitudeRef"" },       { 0x10004, ""exif:GPSLongitude"" },       { 0x10005, ""exif:GPSAltitudeRef"" },       { 0x10006, ""exif:GPSAltitude"" },       { 0x10007, ""exif:GPSTimeStamp"" },       { 0x10008, ""exif:GPSSatellites"" },       { 0x10009, ""exif:GPSStatus"" },       { 0x1000a, ""exif:GPSMeasureMode"" },       { 0x1000b, ""exif:GPSDop"" },       { 0x1000c, ""exif:GPSSpeedRef"" },       { 0x1000d, ""exif:GPSSpeed"" },       { 0x1000e, ""exif:GPSTrackRef"" },       { 0x1000f, ""exif:GPSTrack"" },       { 0x10010, ""exif:GPSImgDirectionRef"" },       { 0x10011, ""exif:GPSImgDirection"" },       { 0x10012, ""exif:GPSMapDatum"" },       { 0x10013, ""exif:GPSDestLatitudeRef"" },       { 0x10014, ""exif:GPSDestLatitude"" },       { 0x10015, ""exif:GPSDestLongitudeRef"" },       { 0x10016, ""exif:GPSDestLongitude"" },       { 0x10017, ""exif:GPSDestBearingRef"" },       { 0x10018, ""exif:GPSDestBearing"" },       { 0x10019, ""exif:GPSDestDistanceRef"" },       { 0x1001a, ""exif:GPSDestDistance"" },       { 0x1001b, ""exif:GPSProcessingMethod"" },       { 0x1001c, ""exif:GPSAreaInformation"" },       { 0x1001d, ""exif:GPSDateStamp"" },       { 0x1001e, ""exif:GPSDifferential"" },       { 0x1001f, ""exif:GPSHPositioningError"" },       { 0x00000, """" }     };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf */    const StringInfo     *profile;    const unsigned char     *directory,     *exif;    DirectoryInfo     directory_stack[MaxDirectoryStack];    EndianType     endian;    MagickBooleanType     status;    ssize_t     i;    size_t     entry,     length,     number_entries,     tag,     tag_value;    SplayTreeInfo     *exif_resources;    ssize_t     all,     id,     level,     offset,     tag_offset;    static int     tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};    /*     If EXIF data exists, then try to parse the request for a tag.   */   profile=GetImageProfile(image,""exif"");   if (profile == (const StringInfo *) NULL)     return(MagickFalse);   if ((property == (const char *) NULL) || (*property == '\0'))     return(MagickFalse);   while (isspace((int) ((unsigned char) *property)) != 0)     property++;   if (strlen(property) <= 5)     return(MagickFalse);   all=0;   tag=(~0UL);   switch (*(property+5))   {     case '*':     {       /*         Caller has asked for all the tags in the EXIF data.       */       tag=0;       all=1; /* return the data in description=value format */       break;     }     case '!':     {       tag=0;       all=2; /* return the data in tagid=value format */       break;     }     case '#':     case '@':     {       int         c;        size_t         n;        /*         Check for a hex based tag specification first.       */       tag=(*(property+5) == '@') ? 1UL : 0UL;       property+=6;       n=strlen(property);       if (n != 4)         return(MagickFalse);       /*         Parse tag specification as a hex number.       */       n/=4;       do       {         for (i=(ssize_t) n-1L; i >= 0; i--)         {           c=(*property++);           tag<<=4;           if ((c >= '0') && (c <= '9'))             tag|=(c-'0');           else             if ((c >= 'A') && (c <= 'F'))               tag|=(c-('A'-10));             else               if ((c >= 'a') && (c <= 'f'))                 tag|=(c-('a'-10));               else                 return(MagickFalse);         }       } while (*property != '\0');       break;     }     default:     {       /*         Try to match the text with a tag name instead.       */       for (i=0; ; i++)       {         if (EXIFTag[i].tag == 0)           break;         if (LocaleCompare(EXIFTag[i].description,property) == 0)           {             tag=(size_t) EXIFTag[i].tag;             break;           }       }       break;     }   }   if (tag == (~0UL))     return(MagickFalse);   length=GetStringInfoLength(profile);   if (length < 6)     return(MagickFalse);   exif=GetStringInfoDatum(profile);   while (length != 0)   {     if (ReadPropertyByte(&exif,&length) != 0x45)       continue;     if (ReadPropertyByte(&exif,&length) != 0x78)       continue;     if (ReadPropertyByte(&exif,&length) != 0x69)       continue;     if (ReadPropertyByte(&exif,&length) != 0x66)       continue;     if (ReadPropertyByte(&exif,&length) != 0x00)       continue;     if (ReadPropertyByte(&exif,&length) != 0x00)       continue;     break;   }   if (length < 16)     return(MagickFalse);   id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);   endian=LSBEndian;   if (id == 0x4949)     endian=LSBEndian;   else     if (id == 0x4D4D)       endian=MSBEndian;     else       return(MagickFalse);   if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)     return(MagickFalse);   /*     This the offset to the first IFD.   */   offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);   if ((offset < 0) || (size_t) offset >= length)     return(MagickFalse);   /*     Set the pointer to the first IFD and follow it were it leads.   */   status=MagickFalse;   directory=exif+offset;   level=0;   entry=0;   tag_offset=0;   exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,     (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);   do   {     /*       If there is anything on the stack then pop it off.     */     if (level > 0)       {         level--;         directory=directory_stack[level].directory;         entry=directory_stack[level].entry;         tag_offset=directory_stack[level].offset;       }     if ((directory < exif) || (directory > (exif+length-2)))       break;     /*       Determine how many entries there are in the current IFD.     */     number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);     for ( ; entry < number_entries; entry++)     {       unsigned char         *p,         *q;        size_t         format;        ssize_t         number_bytes,         components;        q=(unsigned char *) (directory+(12*entry)+2);       if (q > (exif+length-12))         break;  /* corrupt EXIF */       if (GetValueFromSplayTree(exif_resources,q) == q)         break;       (void) AddValueToSplayTree(exif_resources,q,q);       tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;       format=(size_t) ReadPropertyUnsignedShort(endian,q+2);       if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))         break;       if (format == 0)         break;  /* corrupt EXIF */       components=(ssize_t) ReadPropertySignedLong(endian,q+4);       if (components < 0)         break;  /* corrupt EXIF */       number_bytes=(size_t) components*tag_bytes[format];       if (number_bytes < components)         break;  /* prevent overflow */       if (number_bytes <= 4)         p=q+8;       else         {           ssize_t             dir_offset;            /*             The directory entry contains an offset.           */           dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);           if ((dir_offset < 0) || (size_t) dir_offset >= length)             continue;           if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)             continue;  /* prevent overflow */           if (((size_t) dir_offset+number_bytes) > length)             continue;           p=(unsigned char *) (exif+dir_offset);         }       if ((all != 0) || (tag == (size_t) tag_value))         {           char             buffer[MaxTextExtent],             *value;            if ((p < exif) || (p > (exif+length-tag_bytes[format])))             break;           value=(char *) NULL;           *buffer='\0';           switch (format)           {             case EXIF_FMT_BYTE:             case EXIF_FMT_UNDEFINED:             {               value=(char *) NULL;               if (~((size_t) number_bytes) >= 1)                 value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,                   sizeof(*value));               if (value != (char *) NULL)                 {                   for (i=0; i < (ssize_t) number_bytes; i++)                   {                     value[i]='.';                     if (isprint((int) p[i]) != 0)                        value[i]=(char) p[i];                   }                   value[i]='\0';                 }               break;             }             case EXIF_FMT_SBYTE:             {               EXIFMultipleValues(1,""%.20g"",(double) (*(signed char *) p1));               break;             }             case EXIF_FMT_SSHORT:             {               EXIFMultipleValues(2,""%hd"",ReadPropertySignedShort(endian,p1));               break;             }             case EXIF_FMT_USHORT:             {               EXIFMultipleValues(2,""%hu"",ReadPropertyUnsignedShort(endian,p1));               break;             }             case EXIF_FMT_ULONG:             {               EXIFMultipleValues(4,""%.20g"",(double)                 ReadPropertyUnsignedLong(endian,p1));               break;             }             case EXIF_FMT_SLONG:             {               EXIFMultipleValues(4,""%.20g"",(double)                 ReadPropertySignedLong(endian,p1));               break;             }             case EXIF_FMT_URATIONAL:             {               EXIFMultipleFractions(8,""%.20g/%.20g"",(double)                 ReadPropertyUnsignedLong(endian,p1),(double)                 ReadPropertyUnsignedLong(endian,p1+4));               break;             }             case EXIF_FMT_SRATIONAL:             {               EXIFMultipleFractions(8,""%.20g/%.20g"",(double)                 ReadPropertySignedLong(endian,p1),(double)                 ReadPropertySignedLong(endian,p1+4));               break;             }             case EXIF_FMT_SINGLE:             {               EXIFMultipleValues(4,""%f"",(double) *(float *) p1);               break;             }             case EXIF_FMT_DOUBLE:             {               EXIFMultipleValues(8,""%f"",*(double *) p1);               break;             }             case EXIF_FMT_STRING:             default:             {               if ((p < exif) || (p > (exif+length-number_bytes)))                 break;               value=(char *) NULL;               if (~((size_t) number_bytes) >= 1)                 value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,                   sizeof(*value));               if (value != (char *) NULL)                 {                   ssize_t                     i;                    for (i=0; i < (ssize_t) number_bytes; i++)                   {                     value[i]='.';                     if ((isprint((int) p[i]) != 0) || (p[i] == '\0'))                       value[i]=(char) p[i];                   }                   value[i]='\0';                 }               break;             }           }           if (value != (char *) NULL)             {               char                 *key;                const char                 *p;                key=AcquireString(property);               switch (all)               {                 case 1:                 {                   const char                     *description;                    ssize_t                     i;                    description=""unknown"";                   for (i=0; ; i++)                   {                     if (EXIFTag[i].tag == 0)                       break;                     if (EXIFTag[i].tag == tag_value)                       {                         description=EXIFTag[i].description;                         break;                       }                   }                   (void) FormatLocaleString(key,MaxTextExtent,""%s"",                     description);                   if (level == 2)                     (void) SubstituteString(&key,""exif:"",""exif:thumbnail:"");                   break;                 }                 case 2:                 {                   if (tag_value < 0x10000)                     (void) FormatLocaleString(key,MaxTextExtent,""#%04lx"",                       (unsigned long) tag_value);                   else                     if (tag_value < 0x20000)                       (void) FormatLocaleString(key,MaxTextExtent,""@%04lx"",                         (unsigned long) (tag_value & 0xffff));                     else                       (void) FormatLocaleString(key,MaxTextExtent,""unknown"");                   break;                 }                 default:                 {                   if (level == 2)                     (void) SubstituteString(&key,""exif:"",""exif:thumbnail:"");                 }               }               p=(const char *) NULL;               if (image->properties != (void *) NULL)                 p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)                   image->properties,key);               if (p == (const char *) NULL)                 (void) SetImageProperty((Image *) image,key,value);               value=DestroyString(value);               key=DestroyString(key);               status=MagickTrue;             }         }         if ((tag_value == TAG_EXIF_OFFSET) ||             (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))           {             ssize_t               offset;              offset=(ssize_t) ReadPropertySignedLong(endian,p);             if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))               {                 ssize_t                   tag_offset1;                  tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :                   0);                 directory_stack[level].directory=directory;                 entry++;                 directory_stack[level].entry=entry;                 directory_stack[level].offset=tag_offset;                 level++;                 /*                   Check for duplicate tag.                 */                 for (i=0; i < level; i++)                   if (directory_stack[i].directory == (exif+tag_offset1))                     break;                 if (i < level)                   break;  /* duplicate tag */                 directory_stack[level].directory=exif+offset;                 directory_stack[level].offset=tag_offset1;                 directory_stack[level].entry=0;                 level++;                 if ((directory+2+(12*number_entries)+4) > (exif+length))                   break;                 offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*                   number_entries));                 if ((offset != 0) && ((size_t) offset < length) &&                     (level < (MaxDirectoryStack-2)))                   {                     directory_stack[level].directory=exif+offset;                     directory_stack[level].entry=0;                     directory_stack[level].offset=tag_offset1;                     level++;                   }               }             break;           }     }   } while (level > 0);   exif_resources=DestroySplayTree(exif_resources);   return(status); }"
"194989_CWE-190.c","CWE-190","static MagickBooleanType ReadPSDChannelPixels(Image *image,   const size_t channels,const ssize_t row,const ssize_t type,   const unsigned char *pixels,ExceptionInfo *exception) {   Quantum     pixel;    const unsigned char     *p;    IndexPacket     *indexes;    PixelPacket     *q;    ssize_t     x;    size_t     packet_size;    unsigned short     nibble;    p=pixels;   q=GetAuthenticPixels(image,0,row,image->columns,1,exception);   if (q == (PixelPacket *) NULL)     return MagickFalse;   indexes=GetAuthenticIndexQueue(image);   packet_size=GetPSDPacketSize(image);   for (x=0; x < (ssize_t) image->columns; x++)   {     if (packet_size == 1)       pixel=ScaleCharToQuantum(*p++);     else       if (packet_size == 2)         {           p=PushShortPixel(MSBEndian,p,&nibble);           pixel=ScaleShortToQuantum(nibble);         }       else         {           MagickFloatType             nibble;            p=PushFloatPixel(MSBEndian,p,&nibble);           pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);         }     if (image->depth > 1)       {         SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);         q++;       }     else       {         ssize_t           bit,           number_bits;          number_bits=(ssize_t) image->columns-x;         if (number_bits > 8)           number_bits=8;         for (bit=0; bit < number_bits; bit++)         {           SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)             & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);         }         if (x != (ssize_t) image->columns)           x--;         continue;       }   }   return(SyncAuthenticPixels(image,exception)); }"
"194994_CWE-401.cc","CWE-401","Status ImmutableExecutorState::Initialize(const Graph& graph) {   TF_RETURN_IF_ERROR(gview_.Initialize(&graph));    // Build the information about frames in this subgraph.   ControlFlowInfo cf_info;   TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));    for (auto& it : cf_info.unique_frame_names) {     EnsureFrameInfo(it)->nodes =         absl::make_unique<std::vector<const NodeItem*>>();   }   root_frame_info_ = frame_info_[""""].get();    pending_ids_.resize(gview_.num_nodes());    // Preprocess every node in the graph to create an instance of op   // kernel for each node.   requires_control_flow_ = false;   for (const Node* n : graph.nodes()) {     if (IsSink(n)) continue;     if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {       requires_control_flow_ = true;     } else if (IsRecv(n)) {       // A Recv node from a different device may produce dead tensors from       // non-local control-flow nodes.       //       // TODO(mrry): Track whether control flow was present in the       // pre-partitioned graph, and enable the caller (e.g.       // `DirectSession`) to relax this constraint.       string send_device;       string recv_device;       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""send_device"", &send_device));       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""recv_device"", &recv_device));       if (send_device != recv_device) {         requires_control_flow_ = true;       }     }      const int id = n->id();     const string& frame_name = cf_info.frame_names[id];     FrameInfo* frame_info = EnsureFrameInfo(frame_name);      NodeItem* item = gview_.node(id);     item->node_id = id;      item->input_start = frame_info->total_inputs;     frame_info->total_inputs += n->num_inputs();      Status s = params_.create_kernel(n->properties(), &item->kernel);     if (!s.ok()) {       item->kernel = nullptr;       s = AttachDef(s, *n);       return s;     }     CHECK(item->kernel);     item->kernel_is_async = (item->kernel->AsAsync() != nullptr);     item->is_merge = IsMerge(n);     item->is_any_consumer_merge_or_control_trigger = false;     for (const Node* consumer : n->out_nodes()) {       if (IsMerge(consumer) || IsControlTrigger(consumer)) {         item->is_any_consumer_merge_or_control_trigger = true;         break;       }     }     const Tensor* const_tensor = item->kernel->const_tensor();     if (const_tensor) {       // Hold onto a shallow copy of the constant tensor in `*this` so that the       // reference count does not drop to 1. This prevents the constant tensor       // from being forwarded, and its buffer reused.       const_tensors_.emplace_back(*const_tensor);     }     item->const_tensor = const_tensor;     item->is_noop = (item->kernel->type_string_view() == ""NoOp"");     item->is_enter = IsEnter(n);     if (item->is_enter) {       bool is_constant_enter;       TF_RETURN_IF_ERROR(           GetNodeAttr(n->attrs(), ""is_constant"", &is_constant_enter));       item->is_constant_enter = is_constant_enter;        string frame_name;       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &frame_name));       FrameInfo* frame_info = frame_info_[frame_name].get();        int parallel_iterations;       TF_RETURN_IF_ERROR(           GetNodeAttr(n->attrs(), ""parallel_iterations"", &parallel_iterations));        if (frame_info->parallel_iterations == -1) {         frame_info->parallel_iterations = parallel_iterations;       } else if (frame_info->parallel_iterations != parallel_iterations) {         LOG(WARNING) << ""Loop frame \"""" << frame_name                      << ""\"" had two different values for parallel_iterations: ""                      << frame_info->parallel_iterations << "" vs. ""                      << parallel_iterations << ""."";       }        if (enter_frame_info_.size() <= id) {         enter_frame_info_.resize(id + 1);       }       enter_frame_info_[id] = frame_info;     } else {       item->is_constant_enter = false;     }     item->is_exit = IsExit(n);     item->is_control_trigger = IsControlTrigger(n);     item->is_source = IsSource(n);     item->is_enter_exit_or_next_iter =         (IsEnter(n) || IsExit(n) || IsNextIteration(n));     item->is_transfer_node = IsTransferNode(n);     item->is_initialization_op = IsInitializationOp(n);     item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);     item->is_next_iteration = IsNextIteration(n);     item->is_distributed_communication = IsDistributedCommunication(n);      // Compute the maximum values we'll store for this node in the     // pending counts data structure, and allocate a handle in     // that frame's pending counts data structure that has enough     // space to store these maximal count values.     size_t max_pending, max_dead;     GetMaxPendingCounts(n, &max_pending, &max_dead);     pending_ids_[id] =         frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);      // See if this node is a root node, and if so, add item to root_nodes_.     if (n->in_edges().empty()) {       root_nodes_.push_back(item);     }      // Initialize static information about the frames in the graph.     frame_info->nodes->push_back(item);     if (item->is_enter) {       string enter_name;       TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &enter_name));       EnsureFrameInfo(enter_name)->input_count++;     }      // Record information about whether each output of the op is used.     std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);     std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);     int32_t unused_outputs = n->num_outputs();     for (const Edge* e : n->out_edges()) {       if (IsSink(e->dst())) continue;       if (e->src_output() >= 0) {         if (!outputs_required[e->src_output()]) {           --unused_outputs;           outputs_required[e->src_output()] = true;         }       }     }     if (unused_outputs > 0) {       for (int i = 0; i < n->num_outputs(); ++i) {         if (!outputs_required[i]) {           metrics::RecordUnusedOutput(n->type_string());         }       }       item->outputs_required = std::move(outputs_required);     }   }    // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input   // location.   for (const Node* n : graph.nodes()) {     if (IsSink(n)) continue;     const int id = n->id();     NodeItem* item = gview_.node(id);      for (EdgeInfo& e : item->mutable_output_edges()) {       const int dst_id = e.dst_id;       NodeItem* dst_item = gview_.node(dst_id);       e.input_slot += dst_item->input_start;     }   }    // Initialize PendingCounts only after pending_ids_[node.id] is initialized   // for all nodes.   InitializePending(&graph, cf_info);   return gview_.SetAllocAttrs(&graph, params_.device); }"
"194996_CWE-476.cc","CWE-476","Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,                  string* init_op_name) {   const auto& sig_def_map = meta_graph_def.signature_def();   const auto& init_op_sig_it =       meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);   if (init_op_sig_it != sig_def_map.end()) {     *init_op_name = init_op_sig_it->second.outputs()                         .find(kSavedModelInitOpSignatureKey)                         ->second.name();     return Status::OK();   }    const auto& collection_def_map = meta_graph_def.collection_def();   string init_op_collection_key;   if (collection_def_map.find(kSavedModelMainOpKey) !=       collection_def_map.end()) {     init_op_collection_key = kSavedModelMainOpKey;   } else {     init_op_collection_key = kSavedModelLegacyInitOpKey;   }    const auto init_op_it = collection_def_map.find(init_op_collection_key);   if (init_op_it != collection_def_map.end()) {     if (init_op_it->second.node_list().value_size() != 1) {       return errors::FailedPrecondition(           strings::StrCat(""Expected exactly one main op in : "", export_dir));     }     *init_op_name = init_op_it->second.node_list().value(0);   }   return Status::OK(); }"
"194998_CWE-617.cc","CWE-617","Status ConstantFolding::IsSimplifiableReshape(     const NodeDef& node, const GraphProperties& properties) const {   if (!IsReshape(node)) {     return errors::Internal(""Node "", node.name(), "" is not a Reshape node"");   }   if (2 > node.input_size()) {     return errors::Internal(""Node "", node.name(),                             "" must have at most 2 inputs but has "",                             node.input_size());   }   const NodeDef* new_shape = node_map_->GetNode(node.input(1));   if (!IsReallyConstant(*new_shape)) {     return errors::Internal(""Node "", node.name(), "" has shape "",                             new_shape->DebugString(),                             "" which is not a constant"");   }   TensorVector outputs;   auto outputs_cleanup = gtl::MakeCleanup([&outputs] {     for (const auto& output : outputs) {       delete output.tensor;     }   });    Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);   if (!s.ok()) {     return errors::Internal(""Could not evaluate node "", node.name());   }   if (outputs.size() != 1) {     return errors::Internal(""Node "", node.name(),                             "" must have exactly 1 output but has "",                             outputs.size());   }    const std::vector<OpInfo::TensorProperties>& props =       properties.GetInputProperties(node.name());   if (props.empty()) {     return errors::Internal(""Node "", node.name(), "" has no properties"");   }   const OpInfo::TensorProperties& prop = props[0];   if (prop.dtype() == DT_INVALID) {     return errors::Internal(""Node "", node.name(), "" has property "",                             prop.DebugString(), "" with invalid dtype"");   }   const PartialTensorShape shape(prop.shape());   if (!shape.IsFullyDefined()) {     return errors::Internal(""Node "", node.name(), "" has property "",                             prop.DebugString(), "" with shape "",                             shape.DebugString(), "" which is not fully defined"");   }    PartialTensorShape new_dims;   if (outputs[0]->dtype() == DT_INT32) {     std::vector<int32> shp;     for (int i = 0; i < outputs[0]->NumElements(); ++i) {       int32_t dim = outputs[0]->flat<int32>()(i);       shp.push_back(dim);     }     TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));   } else {     std::vector<int64_t> shp;     for (int i = 0; i < outputs[0]->NumElements(); ++i) {       int64_t dim = outputs[0]->flat<int64_t>()(i);       shp.push_back(dim);     }     TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));   }    if (!shape.IsCompatibleWith(new_dims)) {     return errors::Internal(""Expected shape "", shape.DebugString(),                             ""to be compatible with "", new_dims.DebugString());   }    return Status::OK(); }"
"195017_CWE-476.c","CWE-476","u32 GetHintFormat(GF_TrackBox *trak) { 	GF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader; 	if (hmhd->type != GF_ISOM_BOX_TYPE_HMHD) 		return 0; 		 	if (!hmhd || !hmhd->subType) { 		GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0); 		if (!hmhd) return a ? a->type : 0; 		if (a) hmhd->subType = a->type; 		return hmhd->subType; 	} 	return hmhd->subType; }"
"195019_CWE-617.cc","CWE-617","Status ConstantFolding::EvaluateOneFoldable(const NodeDef& node,                                             std::vector<NodeDef>* outputs,                                             bool* result_too_large) {   TensorVector inputs;   TensorVector output_tensors;   auto inputs_cleanup = gtl::MakeCleanup([&inputs, &output_tensors] {     for (const auto& input : inputs) {       delete input.tensor;     }     for (const auto& output : output_tensors) {       if (output.tensor) {         delete output.tensor;       }     }   });    size_t total_inputs_size = 0;   for (const auto& input : node.input()) {     const TensorId input_tensor = ParseTensorName(input);     if (input_tensor.index() < 0) {       // Control dependency       break;     }     const NodeDef* input_node = node_map_->GetNode(input);     if (!IsReallyConstant(*input_node)) {       return Status(error::INVALID_ARGUMENT,                     strings::StrCat(""Can't fold "", node.name(), "", its "", input,                                     "" isn't constant""));     }     TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, ""value""));     const TensorProto& raw_val = input_node->attr().at(""value"").tensor();     if (raw_val.dtype() == DT_INVALID) {       return Status(           error::INVALID_ARGUMENT,           strings::StrCat(""A tensor in the input node, with TensorId of "",                           input_tensor.ToString(),                           "" has a dtype of DT_INVALID.""));     }     Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());     if (!value->FromProto(raw_val)) {       delete (value);       return errors::InvalidArgument(""Unable to make Tensor from proto for "",                                      node.name(), "" with shape "",                                      raw_val.tensor_shape().DebugString());     }     inputs.emplace_back(value);     total_inputs_size += value->TotalBytes();   }    TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, &output_tensors));   if (output_tensors.empty()) {     return Status(error::INVALID_ARGUMENT, ""Expected at least one output."");   }    outputs->resize(output_tensors.size());   for (size_t i = 0; i < output_tensors.size(); i++) {     string node_name = OptimizedNodeName(node, ""-folded"");     if (output_tensors.size() > 1) {       node_name = strings::StrCat(node_name, ""-"", i);     }     if (output_tensors[i].tensor) {       Status s = CreateNodeDef(node_name, output_tensors[i], &outputs->at(i),                                total_inputs_size);       if (!s.ok()) {         *result_too_large = true;         return s;       }     } else {       // Create an empty NodeDef to identify dead outputs (e.g. the output of a       // switch that's not selected by the switch predicate).       outputs->at(i) = NodeDef();     }   }   return Status::OK(); }"
"195022_CWE-287.c","CWE-287","int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {   struct config_elements * config = (struct config_elements *)user_data;   json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;   const char * ip_source = get_ip_source(request);   char * issued_for = get_client_hostname(request);   char * session_uid, expires[129];   time_t now;   struct tm ts;      time(&now);   now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;   gmtime_r(&now, &ts);   strftime(expires, 128, ""%a, %d %b %Y %T %Z"", &ts);   if (j_param != NULL) {     if (json_string_length(json_object_get(j_param, ""username""))) {       if (json_object_get(j_param, ""scheme_type"") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, ""scheme_type"")), ""password"")) {         if (json_string_length(json_object_get(j_param, ""password""))) {           j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, ""username"")), json_string_value(json_object_get(j_param, ""password"")));           if (check_result_value(j_result, G_OK)) {             if ((session_uid = get_session_id(config, request)) == NULL) {               session_uid = generate_session_id();             }             if (user_session_update(config, session_uid, u_map_get_case(request->map_header, ""user-agent""), issued_for, json_string_value(json_object_get(j_param, ""username"")), NULL, 1) != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error user_session_update (1)"");               response->status = 500;             } else {               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, ""/"", config->cookie_secure, 0);               y_log_message(Y_LOG_LEVEL_INFO, ""Event - User '%s' authenticated with password"", json_string_value(json_object_get(j_param, ""username"")));             }             o_free(session_uid);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, ""scheme_type"", ""password"", NULL);           } else {             if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {               y_log_message(Y_LOG_LEVEL_WARNING, ""Security - Authorization invalid for username %s at IP Address %s"", json_string_value(json_object_get(j_param, ""username"")), ip_source);             }             if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, ""user-agent""), issued_for, json_string_value(json_object_get(j_param, ""username"")), NULL, 1) != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error user_session_update (2)"");             }             o_free(session_uid);             response->status = 401;             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, ""scheme_type"", ""password"", NULL);           }           json_decref(j_result);         } else if (json_object_get(j_param, ""password"") != NULL && !json_is_string(json_object_get(j_param, ""password""))) {           ulfius_set_string_body_response(response, 400, ""password must be a string"");         } else {           session_uid = get_session_id(config, request);           j_result = get_users_for_session(config, session_uid);           if (check_result_value(j_result, G_OK)) {             // Refresh username to set as default             if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, ""user-agent""), issued_for, json_string_value(json_object_get(j_param, ""username"")), NULL, 0) != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error user_session_update (3)"");               response->status = 500;             } else {               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, ""/"", config->cookie_secure, 0);             }           } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {             response->status = 401;           } else {             y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error get_users_for_session"");             response->status = 500;           }           o_free(session_uid);           json_decref(j_result);         }       } else {         if (json_string_length(json_object_get(j_param, ""scheme_type"")) && json_string_length(json_object_get(j_param, ""scheme_name"")) && json_is_object(json_object_get(j_param, ""value""))) {           j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, ""scheme_type"")), json_string_value(json_object_get(j_param, ""scheme_name"")), json_string_value(json_object_get(j_param, ""username"")), json_object_get(j_param, ""value""), request);           if (check_result_value(j_result, G_ERROR_PARAM)) {             ulfius_set_string_body_response(response, 400, ""bad scheme response"");           } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {             y_log_message(Y_LOG_LEVEL_WARNING, ""Security - Authorization invalid for username %s at IP Address %s"", json_string_value(json_object_get(j_param, ""username"")), ip_source);             response->status = 401;             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, ""scheme_type"", json_string_value(json_object_get(j_param, ""scheme_type"")), ""scheme_name"", json_string_value(json_object_get(j_param, ""scheme_name"")), NULL);           } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {             response->status = 404;           } else if (check_result_value(j_result, G_OK)) {             if ((session_uid = get_session_id(config, request)) == NULL) {               session_uid = generate_session_id();             }             if (user_session_update(config, session_uid, u_map_get_case(request->map_header, ""user-agent""), issued_for, json_string_value(json_object_get(j_param, ""username"")), json_string_value(json_object_get(j_param, ""scheme_name"")), 1) != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error user_session_update (4)"");               response->status = 500;             } else {               ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, ""/"", config->cookie_secure, 0);               y_log_message(Y_LOG_LEVEL_INFO, ""Event - User '%s' authenticated with scheme '%s/%s'"", json_string_value(json_object_get(j_param, ""username"")), json_string_value(json_object_get(j_param, ""scheme_type"")), json_string_value(json_object_get(j_param, ""scheme_name"")));             }             o_free(session_uid);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, ""scheme_type"", json_string_value(json_object_get(j_param, ""scheme_type"")), ""scheme_name"", json_string_value(json_object_get(j_param, ""scheme_name"")), NULL);           } else {             y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error auth_check_user_scheme"");             response->status = 500;           }           json_decref(j_result);         } else {           ulfius_set_string_body_response(response, 400, ""scheme_type, scheme_name and value are mandatory"");         }       }     } else {       if (json_string_length(json_object_get(j_param, ""scheme_type"")) && json_string_length(json_object_get(j_param, ""scheme_name"")) && json_is_object(json_object_get(j_param, ""value""))) {         j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, ""scheme_type"")), json_string_value(json_object_get(j_param, ""scheme_name"")), json_object_get(j_param, ""value""), request);         if (check_result_value(j_result, G_ERROR_PARAM)) {           ulfius_set_string_body_response(response, 400, ""bad scheme response"");         } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {           y_log_message(Y_LOG_LEVEL_WARNING, ""Security - Authorization invalid for username <UNKNOWN> at IP Address %s"", ip_source);           response->status = 401;         } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {           response->status = 404;         } else if (check_result_value(j_result, G_OK)) {           if ((session_uid = get_session_id(config, request)) == NULL) {             session_uid = generate_session_id();           }           if (user_session_update(config, session_uid, u_map_get_case(request->map_header, ""user-agent""), issued_for, json_string_value(json_object_get(j_result, ""username"")), json_string_value(json_object_get(j_param, ""scheme_name"")), 1) != G_OK) {             y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error user_session_update (4)"");             response->status = 500;           } else {             ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, ""/"", config->cookie_secure, 0);             y_log_message(Y_LOG_LEVEL_INFO, ""Event - User '%s' authenticated with scheme '%s/%s'"", json_string_value(json_object_get(j_result, ""username"")), json_string_value(json_object_get(j_param, ""scheme_type"")), json_string_value(json_object_get(j_param, ""scheme_name"")));           }           o_free(session_uid);         } else {           y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_auth - Error auth_check_user_scheme"");           response->status = 500;         }         json_decref(j_result);       } else {         ulfius_set_string_body_response(response, 400, ""username is mandatory"");       }     }   } else {     ulfius_set_string_body_response(response, 400, ""Input parameters must be in JSON format"");   }   json_decref(j_param);   o_free(issued_for);    return U_CALLBACK_CONTINUE; }"
"195023_CWE-190.cc","CWE-190","  void Compute(OpKernelContext* context) override {     const Tensor* input_indices;     const Tensor* input_values;     const Tensor* input_shape;     SparseTensorsMap* map;      OP_REQUIRES_OK(context, context->input(""sparse_indices"", &input_indices));     OP_REQUIRES_OK(context, context->input(""sparse_values"", &input_values));     OP_REQUIRES_OK(context, context->input(""sparse_shape"", &input_shape));     OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),                 errors::InvalidArgument(                     ""Input indices should be a matrix but received shape "",                     input_indices->shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),                 errors::InvalidArgument(                     ""Input values should be a vector but received shape "",                     input_values->shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),                 errors::InvalidArgument(                     ""Input shape should be a vector but received shape "",                     input_shape->shape().DebugString()));     OP_REQUIRES(         context,         input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),         errors::InvalidArgument(             ""Number of values must match first dimension of indices. "", ""Got "",             input_values->shape().dim_size(0),             "" values, indices shape: "", input_indices->shape().DebugString()));     OP_REQUIRES(         context,         input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),         errors::InvalidArgument(             ""Number of dimensions must match second dimension of indices. "",             ""Got "", input_shape->shape().dim_size(0),             "" dimensions, indices shape: "",             input_indices->shape().DebugString()));      int rank = input_shape->NumElements();      OP_REQUIRES(         context, rank > 1,         errors::InvalidArgument(             ""Rank of input SparseTensor should be > 1, but saw rank: "", rank));      auto input_shape_vec = input_shape->vec<int64_t>();     int new_num_elements = 1;     bool overflow_ocurred = false;     for (int i = 0; i < input_shape_vec.size(); i++) {       new_num_elements =           MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));       if (new_num_elements < 0) {         overflow_ocurred = true;         break;       }     }      OP_REQUIRES(         context, !overflow_ocurred,         errors::Internal(""Encountered overflow from large input shape.""));      TensorShape tensor_input_shape(input_shape_vec);     gtl::InlinedVector<int64_t, 8> std_order(rank);     std::iota(std_order.begin(), std_order.end(), 0);     SparseTensor input_st;     OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,                                                  tensor_input_shape, std_order,                                                  &input_st));      const int64_t N = input_shape_vec(0);      Tensor sparse_handles(DT_INT64, TensorShape({N}));     auto sparse_handles_t = sparse_handles.vec<int64_t>();      OP_REQUIRES_OK(context, input_st.IndicesValid());      // We can generate the output shape proto string now, for all     // minibatch entries.     TensorShape output_shape;     OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(                                 input_shape_vec.data() + 1,                                 input_shape->NumElements() - 1, &output_shape));      // Get groups by minibatch dimension     std::unordered_set<int64_t> visited;     sparse::GroupIterable minibatch = input_st.group({0});     for (const auto& subset : minibatch) {       const int64_t b = subset.group()[0];       visited.insert(b);       OP_REQUIRES(           context, b > -1 && b < N,           errors::InvalidArgument(               ""Received unexpected column 0 value in input SparseTensor: "", b,               "" < 0 or >= N (= "", N, "")""));        const auto indices = subset.indices();       const auto values = subset.values<T>();       const int64_t num_entries = values.size();        Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});       Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});        auto output_indices_t = output_indices.matrix<int64_t>();       auto output_values_t = output_values.vec<T>();        for (int i = 0; i < num_entries; ++i) {         for (int d = 1; d < rank; ++d) {           output_indices_t(i, d - 1) = indices(i, d);         }         output_values_t(i) = values(i);       }        SparseTensor st_i;       OP_REQUIRES_OK(context,                      SparseTensor::Create(output_indices, output_values,                                           output_shape, &st_i));       int64_t handle;       OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));       sparse_handles_t(b) = handle;     }      // Fill in any gaps; we must provide an empty ST for batch entries     // the grouper didn't find.     if (visited.size() < N) {       Tensor empty_indices(DT_INT64, {0, rank - 1});       Tensor empty_values(DataTypeToEnum<T>::value, {0});       SparseTensor empty_st;       OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,                                                    output_shape, &empty_st));        for (int64_t b = 0; b < N; ++b) {         // We skipped this batch entry.         if (visited.find(b) == visited.end()) {           int64_t handle;           OP_REQUIRES_OK(context,                          map->AddSparseTensor(context, empty_st, &handle));           sparse_handles_t(b) = handle;         }       }     }      context->set_output(0, sparse_handles);   }"
"195026_CWE-909.c","CWE-909","nfs4_file_open(struct inode *inode, struct file *filp) { 	struct nfs_open_context *ctx; 	struct dentry *dentry = file_dentry(filp); 	struct dentry *parent = NULL; 	struct inode *dir; 	unsigned openflags = filp->f_flags; 	struct iattr attr; 	int err;  	/* 	 * If no cached dentry exists or if it's negative, NFSv4 handled the 	 * opens in ->lookup() or ->create(). 	 * 	 * We only get this far for a cached positive dentry.  We skipped 	 * revalidation, so handle it here by dropping the dentry and returning 	 * -EOPENSTALE.  The VFS will retry the lookup/create/open. 	 */  	dprintk(""NFS: open file(%pd2)\n"", dentry);  	err = nfs_check_flags(openflags); 	if (err) 		return err;  	if ((openflags & O_ACCMODE) == 3) 		return nfs_open(inode, filp);  	/* We can't create new files here */ 	openflags &= ~(O_CREAT|O_EXCL);  	parent = dget_parent(dentry); 	dir = d_inode(parent);  	ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp); 	err = PTR_ERR(ctx); 	if (IS_ERR(ctx)) 		goto out;  	attr.ia_valid = ATTR_OPEN; 	if (openflags & O_TRUNC) { 		attr.ia_valid |= ATTR_SIZE; 		attr.ia_size = 0; 		filemap_write_and_wait(inode->i_mapping); 	}  	inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL); 	if (IS_ERR(inode)) { 		err = PTR_ERR(inode); 		switch (err) { 		default: 			goto out_put_ctx; 		case -ENOENT: 		case -ESTALE: 		case -EISDIR: 		case -ENOTDIR: 		case -ELOOP: 			goto out_drop; 		} 	} 	if (inode != d_inode(dentry)) 		goto out_drop;  	nfs_file_set_open_context(filp, ctx); 	nfs_fscache_open_file(inode, filp); 	err = 0;  out_put_ctx: 	put_nfs_open_context(ctx); out: 	dput(parent); 	return err;  out_drop: 	d_drop(dentry); 	err = -EOPENSTALE; 	goto out_put_ctx; }"
"195028_CWE-401.cc","CWE-401","  void DecodePngV2(OpKernelContext* context, StringPiece input) {     int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;     png::DecodeContext decode;     OP_REQUIRES(         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),         errors::InvalidArgument(""Invalid PNG. Failed to initialize decoder.""));      // Verify that width and height are not too large:     // - verify width and height don't overflow int.     // - width can later be multiplied by channels_ and sizeof(uint16), so     //   verify single dimension is not too large.     // - verify when width and height are multiplied together, there are a few     //   bits to spare as well.     const int width = static_cast<int>(decode.width);     const int height = static_cast<int>(decode.height);     const int64_t total_size =         static_cast<int64_t>(width) * static_cast<int64_t>(height);     if (width != static_cast<int64_t>(decode.width) || width <= 0 ||         width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||         height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {       OP_REQUIRES(context, false,                   errors::InvalidArgument(""PNG size too large for int: "",                                           decode.width, "" by "", decode.height));     }      Tensor* output = nullptr;     // By the existing API, we support decoding PNG with `DecodeGif` op.     // We need to make sure to return 4-D shapes when using `DecodeGif`.     if (op_type_ == ""DecodeGif"") {       OP_REQUIRES_OK(           context,           context->allocate_output(               0, TensorShape({1, height, width, decode.channels}), &output));     } else {       OP_REQUIRES_OK(           context,           context->allocate_output(               0, TensorShape({height, width, decode.channels}), &output));     }      if (op_type_ == ""DecodeBmp"") {       // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here       // because currently `decode_(jpeg|png|gif)` ops can decode any one of       // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode       // anything but bmp formats. This behavior needs to be revisited. For more       // details, please refer to the bug.       OP_REQUIRES(context, false,                   errors::InvalidArgument(                       ""Trying to decode PNG format using DecodeBmp op. Use ""                       ""`decode_png` or `decode_image` instead.""));     } else if (op_type_ == ""DecodeAndCropJpeg"") {       OP_REQUIRES(context, false,                   errors::InvalidArgument(                       ""DecodeAndCropJpeg operation can run on JPEG only, but ""                       ""detected PNG.""));     }      if (data_type_ == DataType::DT_UINT8) {       OP_REQUIRES(           context,           png::CommonFinishDecode(               reinterpret_cast<png_bytep>(output->flat<uint8>().data()),               decode.channels * width * sizeof(uint8), &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));     } else if (data_type_ == DataType::DT_UINT16) {       OP_REQUIRES(           context,           png::CommonFinishDecode(               reinterpret_cast<png_bytep>(output->flat<uint16>().data()),               decode.channels * width * sizeof(uint16), &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));     } else if (data_type_ == DataType::DT_FLOAT) {       // `png::CommonFinishDecode` does not support `float`. First allocate       // uint16 buffer for the image and decode in uint16 (lossless). Wrap the       // buffer in `unique_ptr` so that we don't forget to delete the buffer.       std::unique_ptr<uint16[]> buffer(           new uint16[height * width * decode.channels]);       OP_REQUIRES(           context,           png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),                                   decode.channels * width * sizeof(uint16),                                   &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));        // Convert uint16 image data to desired data type.       // Use eigen threadpooling to speed up the copy operation.       const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();       TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,                                                   decode.channels);       float scale = 1. / std::numeric_limits<uint16>::max();       // Fill output tensor with desired dtype.       output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;     }   }"
"195029_CWE-125.cc","CWE-125","void Node::RunForwardTypeInference() {   VLOG(4) << ""Forward type inference: "" << props_->node_def.DebugString();    if (props_->fwd_type_fn == nullptr) {     return;   }    std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);   std::vector<int> input_idx(props_->input_types.size(), 0);   for (const auto& edge : in_edges_) {     if (edge->IsControlEdge()) {       continue;     }     DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();     int i = edge->dst_input();     input_nodes.at(i) = edge->src();     input_idx.at(i) = edge->src_output();   }    // Note: technically, we could use a very generic type when some of the inputs   // are unknown. But there is an expectation that a node will have complete   // inputs soon, so updating intermediate types is largely unnecessary.    for (const auto* node : input_nodes) {     if (node == nullptr) {       // Incomplete inputs, bail.       ClearTypeInfo();       return;     }   }    static FullTypeDef* no_type = new FullTypeDef();    std::vector<std::reference_wrapper<const FullTypeDef>> input_types;   for (int i = 0; i < input_nodes.size(); i++) {     const auto* node = input_nodes[i];     if (node->def().has_experimental_type()) {       const auto& node_t = node->def().experimental_type();       if (node_t.type_id() != TFT_UNSET) {         int ix = input_idx[i];         DCHECK(ix < node_t.args_size())             << ""input "" << i << "" should have an output "" << ix             << "" but instead only has "" << node_t.args_size()             << "" outputs: "" << node_t.DebugString();         input_types.emplace_back(node_t.args(ix));       } else {         input_types.emplace_back(*no_type);       }     } else {       // Incomplete inputs, bail.       ClearTypeInfo();       return;     }   }    const auto infer_type = props_->fwd_type_fn(input_types);   const FullTypeDef infer_typedef = infer_type.ValueOrDie();   if (infer_typedef.type_id() != TFT_UNSET) {     MaybeCopyOnWrite();     *(props_->node_def.mutable_experimental_type()) = infer_typedef;   } }"
"195037_CWE-190.cc","CWE-190","  void Compute(OpKernelContext* context) override {     const Tensor* input_indices;     const Tensor* input_values;     const Tensor* input_shape;     SparseTensorsMap* map;      OP_REQUIRES_OK(context, context->input(""sparse_indices"", &input_indices));     OP_REQUIRES_OK(context, context->input(""sparse_values"", &input_values));     OP_REQUIRES_OK(context, context->input(""sparse_shape"", &input_shape));     OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),                 errors::InvalidArgument(                     ""Input indices should be a matrix but received shape "",                     input_indices->shape().DebugString()));      OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),                 errors::InvalidArgument(                     ""Input values should be a vector but received shape "",                     input_values->shape().DebugString()));      OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),                 errors::InvalidArgument(                     ""Input shape should be a vector but received shape "",                     input_shape->shape().DebugString()));      int rank = input_shape->NumElements();      OP_REQUIRES(         context, rank > 1,         errors::InvalidArgument(             ""Rank of input SparseTensor should be > 1, but saw rank: "", rank));      auto input_shape_vec = input_shape->vec<int64_t>();     int new_num_elements = 1;     bool overflow_ocurred = false;     for (int i = 0; i < input_shape_vec.size(); i++) {       new_num_elements =           MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));       if (new_num_elements < 0) {         overflow_ocurred = true;         break;       }     }      OP_REQUIRES(         context, !overflow_ocurred,         errors::Internal(""Encountered overflow from large input shape.""));      TensorShape tensor_input_shape(input_shape_vec);     gtl::InlinedVector<int64_t, 8> std_order(rank);     std::iota(std_order.begin(), std_order.end(), 0);     SparseTensor input_st;     OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,                                                  tensor_input_shape, std_order,                                                  &input_st));      const int64_t N = input_shape_vec(0);      Tensor sparse_handles(DT_INT64, TensorShape({N}));     auto sparse_handles_t = sparse_handles.vec<int64_t>();      OP_REQUIRES_OK(context, input_st.IndicesValid());      // We can generate the output shape proto string now, for all     // minibatch entries.     TensorShape output_shape;     OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(                                 input_shape_vec.data() + 1,                                 input_shape->NumElements() - 1, &output_shape));      // Get groups by minibatch dimension     std::unordered_set<int64_t> visited;     sparse::GroupIterable minibatch = input_st.group({0});     for (const auto& subset : minibatch) {       const int64_t b = subset.group()[0];       visited.insert(b);       OP_REQUIRES(           context, b > -1 && b < N,           errors::InvalidArgument(               ""Received unexpected column 0 value in input SparseTensor: "", b,               "" < 0 or >= N (= "", N, "")""));        const auto indices = subset.indices();       const auto values = subset.values<T>();       const int64_t num_entries = values.size();        Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});       Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});        auto output_indices_t = output_indices.matrix<int64_t>();       auto output_values_t = output_values.vec<T>();        for (int i = 0; i < num_entries; ++i) {         for (int d = 1; d < rank; ++d) {           output_indices_t(i, d - 1) = indices(i, d);         }         output_values_t(i) = values(i);       }        SparseTensor st_i;       OP_REQUIRES_OK(context,                      SparseTensor::Create(output_indices, output_values,                                           output_shape, &st_i));       int64_t handle;       OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));       sparse_handles_t(b) = handle;     }      // Fill in any gaps; we must provide an empty ST for batch entries     // the grouper didn't find.     if (visited.size() < N) {       Tensor empty_indices(DT_INT64, {0, rank - 1});       Tensor empty_values(DataTypeToEnum<T>::value, {0});       SparseTensor empty_st;       OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,                                                    output_shape, &empty_st));        for (int64_t b = 0; b < N; ++b) {         // We skipped this batch entry.         if (visited.find(b) == visited.end()) {           int64_t handle;           OP_REQUIRES_OK(context,                          map->AddSparseTensor(context, empty_st, &handle));           sparse_handles_t(b) = handle;         }       }     }      context->set_output(0, sparse_handles);   }"
"195038_CWE-476.c","CWE-476","mrb_ary_shift_m(mrb_state *mrb, mrb_value self) {   struct RArray *a = mrb_ary_ptr(self);   mrb_int len = ARY_LEN(a);   mrb_int n;   mrb_value val;    if (mrb_get_args(mrb, ""|i"", &n) == 0) {     return mrb_ary_shift(mrb, self);   };   ary_modify_check(mrb, a);   if (len == 0 || n == 0) return mrb_ary_new(mrb);   if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, ""negative array shift"");   if (n > len) n = len;   val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));   if (ARY_SHARED_P(a)) {   L_SHIFT:     a->as.heap.ptr+=n;     a->as.heap.len-=n;     return val;   }   if (len > ARY_SHIFT_SHARED_MIN) {     ary_make_shared(mrb, a);     goto L_SHIFT;   }   else if (len == n) {     ARY_SET_LEN(a, 0);   }   else {     mrb_value *ptr = ARY_PTR(a);     mrb_int size = len-n;      while (size--) {       *ptr = *(ptr+n);       ++ptr;     }     ARY_SET_LEN(a, len-n);   }   return val; }"
"195039_CWE-354.cc","CWE-354","  void operator()(OpKernelContext* ctx, const Tensor& input,                   const Tensor& filter, int row_stride, int col_stride,                   int row_dilation, int col_dilation, const Padding& padding,                   const std::vector<int64_t>& explicit_paddings, Tensor* output,                   TensorFormat data_format) {     DCHECK(data_format == FORMAT_NHWC)         << ""Grouped conv implementation only ""            ""supports NHWC tensor format for now."";      const int64_t in_depth = input.dim_size(3);     const int64_t patch_depth = filter.dim_size(2);     const int64_t num_groups = in_depth / patch_depth;      // Shuffle input/filter tensors to have group as a leading dimension.     std::array<int64_t, 5> shuffle({3, 0, 1, 2, 4});      // Compute pre shuffle dimemnsions.     auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {       return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),               num_groups, tensor.dim_size(3) / num_groups};     };      // Compute post shuffle dimemnsions.     auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {       return {num_groups, tensor.dim_size(0), tensor.dim_size(1),               tensor.dim_size(2), tensor.dim_size(3) / num_groups};     };      auto& device = ctx->eigen_device<CPUDevice>();      absl::BlockingCounter shuffles_completed(2);     auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };      // Shuffle input into temporary tensor.     Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));     input_shuffled.tensor<T, 5>().device(device, on_shuffled) =         input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);      // Shuffle filter into temporary tensor.     Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));     filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =         filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);      // Wait for the completion of input/filter shuffles.     shuffles_completed.Wait();      // Write group convolution results into temporary output tensor.     Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));      for (int64_t i = 0; i < num_groups; ++i) {       // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor       // will lead to deadlock, SpatialConvolution has to use async Eigen       // assignment). This requires small changes to Eigen to support async       // exeuction for tensor chipping operation.        // TODO(ezhulenev): Grouped convolution should also support 1x1 filter       // optimization.        auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);       auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);       auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);        if (padding == EXPLICIT) {         functor::SpatialConvolution<CPUDevice, T>()(             ctx->eigen_device<CPUDevice>(), output_slice, input_slice,             filter_slice, row_stride, col_stride, row_dilation, col_dilation,             static_cast<int>(explicit_paddings[2]),             static_cast<int>(explicit_paddings[3]),             static_cast<int>(explicit_paddings[4]),             static_cast<int>(explicit_paddings[5]));       } else {         functor::SpatialConvolution<CPUDevice, T>()(             ctx->eigen_device<CPUDevice>(), output_slice, input_slice,             filter_slice, row_stride, col_stride, row_dilation, col_dilation,             BrainPadding2EigenPadding(padding));       }     }      // Shuffle temporary output back into pre-shuffled shape.     std::array<int64_t, 5> rev_shuffle({1, 2, 3, 0, 4});     output->shaped<T, 5>(pre_shuffle(*output)).device(device) =         output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);   }"
"195040_CWE-476.cc","CWE-476","Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,                                 const XlaPlatformInfo& platform_info,                                 XlaCompilationCache** cache) {   if (platform_info.xla_device_metadata()) {     *cache = new XlaCompilationCache(         platform_info.xla_device_metadata()->client(),         platform_info.xla_device_metadata()->jit_device_type());     return Status::OK();   }    auto platform =       se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());   if (!platform.ok()) {     return platform.status();   }    StatusOr<xla::Compiler*> compiler_for_platform =       xla::Compiler::GetForPlatform(platform.ValueOrDie());   if (!compiler_for_platform.ok()) {     // In some rare cases (usually in unit tests with very small clusters) we     // may end up transforming an XLA cluster with at least one GPU operation     // (which would normally force the cluster to be compiled using XLA:GPU)     // into an XLA cluster with no GPU operations (i.e. containing only CPU     // operations).  Such a cluster can fail compilation (in way that     // MarkForCompilation could not have detected) if the CPU JIT is not linked     // in.     //     // So bail out of _XlaCompile in this case, and let the executor handle the     // situation for us.     const Status& status = compiler_for_platform.status();     if (status.code() == error::NOT_FOUND) {       return errors::Unimplemented(""Could not find compiler for platform "",                                    platform.ValueOrDie()->Name(), "": "",                                    status.ToString());     }   }    xla::LocalClientOptions client_options;   client_options.set_platform(platform.ValueOrDie());   client_options.set_intra_op_parallelism_threads(       device->tensorflow_cpu_worker_threads()->num_threads);    string allowed_gpus =       flr->config_proto()->gpu_options().visible_device_list();   TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,                       ParseVisibleDeviceList(allowed_gpus));   client_options.set_allowed_devices(gpu_ids);    auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);   if (!client.ok()) {     return client.status();   }   const XlaOpRegistry::DeviceRegistration* registration;   if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),                                            &registration)) {     return errors::InvalidArgument(""No JIT device registered for "",                                    platform_info.device_type().type());   }   *cache = new XlaCompilationCache(       client.ValueOrDie(), DeviceType(registration->compilation_device_name));   return Status::OK(); }"
"195055_CWE-787.cc","CWE-787","  void Compute(OpKernelContext* context) override {     const Tensor& indices = context->input(0);     const Tensor& values = context->input(1);     const Tensor& shape = context->input(2);     const Tensor& weights = context->input(3);     bool use_weights = weights.NumElements() > 0;      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),                 errors::InvalidArgument(                     ""Input indices must be a 2-dimensional tensor. Got: "",                     indices.shape().DebugString()));      if (use_weights) {       OP_REQUIRES(           context, weights.shape() == values.shape(),           errors::InvalidArgument(               ""Weights and values must have the same shape. Weight shape: "",               weights.shape().DebugString(),               ""; values shape: "", values.shape().DebugString()));     }      OP_REQUIRES(context, shape.NumElements() != 0,                 errors::InvalidArgument(                     ""The shape argument requires at least one element.""));      bool is_1d = shape.NumElements() == 1;     auto shape_vector = shape.flat<int64_t>();     int num_batches = is_1d ? 1 : shape_vector(0);     int num_values = values.NumElements();      for (int b = 0; b < shape_vector.size(); b++) {       OP_REQUIRES(context, shape_vector(b) >= 0,                   errors::InvalidArgument(                       ""Elements in dense_shape must be >= 0. Instead got:"",                       shape.DebugString()));     }      OP_REQUIRES(context, num_values == indices.shape().dim_size(0),                 errors::InvalidArgument(                     ""Number of values must match first dimension of indices."",                     ""Got "", num_values,                     "" values, indices shape: "", indices.shape().DebugString()));      const auto indices_values = indices.matrix<int64_t>();     const auto values_values = values.flat<T>();     const auto weight_values = weights.flat<W>();      auto per_batch_counts = BatchedMap<W>(num_batches);      T max_value = 0;      OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),                 errors::InvalidArgument(                     ""The first dimension of indices must be equal to or ""                     ""greather than number of values. ( "",                     indices.shape().dim_size(0), "" vs. "", num_values, "" )""));     OP_REQUIRES(context, indices.shape().dim_size(1) > 0,                 errors::InvalidArgument(""The second dimension of indices must ""                                         ""be greater than 0. Received: "",                                         indices.shape().dim_size(1)));      for (int idx = 0; idx < num_values; ++idx) {       int batch = is_1d ? 0 : indices_values(idx, 0);       if (batch >= num_batches) {         OP_REQUIRES(context, batch < num_batches,                     errors::InvalidArgument(                         ""Indices value along the first dimension must be "",                         ""lower than the first index of the shape."", ""Got "",                         batch, "" as batch and "", num_batches,                         "" as the first dimension of the shape.""));       }       const auto& value = values_values(idx);       if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {         if (binary_output_) {           per_batch_counts[batch][value] = 1;         } else if (use_weights) {           per_batch_counts[batch][value] += weight_values(idx);         } else {           per_batch_counts[batch][value]++;         }         if (value > max_value) {           max_value = value;         }       }     }      int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,                                             is_1d, context));   }"
"195056_CWE-369.h","CWE-369","inline void BiasAndClamp(float clamp_min, float clamp_max, int bias_size,                          const float* bias_data, int array_size,                          float* array_data) {   // Note: see b/132215220: in May 2019 we thought it would be OK to replace   // this with the Eigen one-liner:   //   return (array.colwise() + bias).cwiseMin(clamp_max).cwiseMin(clamp_max).   // This turned out to severely regress performance: +4ms (i.e. 8%) on   // MobileNet v2 / 1.0 / 224. So we keep custom NEON code for now.   TFLITE_DCHECK_EQ((array_size % bias_size), 0); #ifdef USE_NEON   float* array_ptr = array_data;   float* array_end_ptr = array_ptr + array_size;   const auto clamp_min_vec = vdupq_n_f32(clamp_min);   const auto clamp_max_vec = vdupq_n_f32(clamp_max);   for (; array_ptr != array_end_ptr; array_ptr += bias_size) {     int i = 0;     for (; i <= bias_size - 16; i += 16) {       auto b0 = vld1q_f32(bias_data + i);       auto b1 = vld1q_f32(bias_data + i + 4);       auto b2 = vld1q_f32(bias_data + i + 8);       auto b3 = vld1q_f32(bias_data + i + 12);       auto a0 = vld1q_f32(array_ptr + i);       auto a1 = vld1q_f32(array_ptr + i + 4);       auto a2 = vld1q_f32(array_ptr + i + 8);       auto a3 = vld1q_f32(array_ptr + i + 12);       auto x0 = vaddq_f32(a0, b0);       auto x1 = vaddq_f32(a1, b1);       auto x2 = vaddq_f32(a2, b2);       auto x3 = vaddq_f32(a3, b3);       x0 = vmaxq_f32(clamp_min_vec, x0);       x1 = vmaxq_f32(clamp_min_vec, x1);       x2 = vmaxq_f32(clamp_min_vec, x2);       x3 = vmaxq_f32(clamp_min_vec, x3);       x0 = vminq_f32(clamp_max_vec, x0);       x1 = vminq_f32(clamp_max_vec, x1);       x2 = vminq_f32(clamp_max_vec, x2);       x3 = vminq_f32(clamp_max_vec, x3);       vst1q_f32(array_ptr + i, x0);       vst1q_f32(array_ptr + i + 4, x1);       vst1q_f32(array_ptr + i + 8, x2);       vst1q_f32(array_ptr + i + 12, x3);     }     for (; i <= bias_size - 4; i += 4) {       auto b = vld1q_f32(bias_data + i);       auto a = vld1q_f32(array_ptr + i);       auto x = vaddq_f32(a, b);       x = vmaxq_f32(clamp_min_vec, x);       x = vminq_f32(clamp_max_vec, x);       vst1q_f32(array_ptr + i, x);     }     for (; i < bias_size; i++) {       array_ptr[i] = ActivationFunctionWithMinMax(array_ptr[i] + bias_data[i],                                                   clamp_min, clamp_max);     }   } #else  // not NEON   for (int array_offset = 0; array_offset < array_size;        array_offset += bias_size) {     for (int i = 0; i < bias_size; i++) {       array_data[array_offset + i] = ActivationFunctionWithMinMax(           array_data[array_offset + i] + bias_data[i], clamp_min, clamp_max);     }   } #endif }"
"195059_CWE-617.cc","CWE-617","bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {   if (!IsIdentity(node) && !IsIdentityN(node)) {     return true;   }    if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {     return false;   }   if (!fetch_nodes_known_) {     // The output values of this node may be needed.     return false;   }    if (node.input_size() < 1) {     // Node lacks input, is invalid     return false;   }    const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));   CHECK(input != nullptr) << ""node = "" << node.name()                           << "" input = "" << node.input(0);   // Don't remove Identity nodes corresponding to Variable reads or following   // Recv.   if (IsVariable(*input) || IsRecv(*input)) {     return false;   }   for (const auto& consumer : node_map_->GetOutputs(node.name())) {     if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {       return false;     }     if (IsSwitch(*input)) {       for (const string& consumer_input : consumer->input()) {         if (consumer_input == AsControlDependency(node.name())) {           return false;         }       }     }   }   return true; }"
"195063_CWE-476.c","CWE-476","GF_Err mpgviddmx_process(GF_Filter *filter) { 	GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter); 	GF_FilterPacket *pck, *dst_pck; 	u64 byte_offset; 	s64 vosh_start = -1; 	s64 vosh_end = -1; 	GF_Err e; 	char *data; 	u8 *start; 	u32 pck_size; 	s32 remain;  	//always reparse duration 	if (!ctx->duration.num) 		mpgviddmx_check_dur(filter, ctx);  	pck = gf_filter_pid_get_packet(ctx->ipid); 	if (!pck) { 		if (gf_filter_pid_is_eos(ctx->ipid)) { 			mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE); 			if (ctx->opid) 				gf_filter_pid_set_eos(ctx->opid); 			if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); 			ctx->src_pck = NULL; 			return GF_EOS; 		} 		return GF_OK; 	}  	data = (char *) gf_filter_pck_get_data(pck, &pck_size); 	byte_offset = gf_filter_pck_get_byte_offset(pck);  	start = data; 	remain = pck_size;  	//input pid sets some timescale - we flushed pending data , update cts 	if (!ctx->resume_from && ctx->timescale) { 		u64 ts = gf_filter_pck_get_cts(pck); 		if (ts != GF_FILTER_NO_TS) { 			if (!ctx->cts || !ctx->recompute_cts) 				ctx->cts = ts; 		} 		ts = gf_filter_pck_get_dts(pck); 		if (ts != GF_FILTER_NO_TS) { 			if (!ctx->dts || !ctx->recompute_cts) 				ctx->dts = ts;  			if (!ctx->prev_dts) ctx->prev_dts = ts; 			else if (ctx->prev_dts != ts) { 				u64 diff = ts; 				diff -= ctx->prev_dts; 				if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff; 				else if (ctx->cur_fps.den > diff) 					ctx->cur_fps.den = (u32) diff; 			} 		} 		gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end); 		//this will force CTS recomput of each frame 		if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE; 		if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); 		ctx->src_pck = pck; 		gf_filter_pck_ref_props(&ctx->src_pck); 	}  	//we stored some data to find the complete vosh, aggregate this packet with current one 	if (!ctx->resume_from && ctx->hdr_store_size) { 		if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) { 			ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size; 			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); 		} 		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size); 		if (byte_offset != GF_FILTER_NO_BO) { 			if (byte_offset >= ctx->hdr_store_size) 				byte_offset -= ctx->hdr_store_size; 			else 				byte_offset = GF_FILTER_NO_BO; 		} 		ctx->hdr_store_size += pck_size; 		start = data = ctx->hdr_store; 		remain = pck_size = ctx->hdr_store_size; 	}  	if (ctx->resume_from) { 		if (gf_filter_pid_would_block(ctx->opid)) 			return GF_OK;  		//resume from data copied internally 		if (ctx->hdr_store_size) { 			assert(ctx->resume_from <= ctx->hdr_store_size); 			start = data = ctx->hdr_store + ctx->resume_from; 			remain = pck_size = ctx->hdr_store_size - ctx->resume_from; 		} else { 			assert(remain >= (s32) ctx->resume_from); 			start += ctx->resume_from; 			remain -= ctx->resume_from; 		} 		ctx->resume_from = 0; 	}  	if (!ctx->bs) { 		ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ); 	} else { 		gf_bs_reassign_buffer(ctx->bs, start, remain); 	} 	if (!ctx->vparser) { 		ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12); 	}   	while (remain) { 		Bool full_frame; 		u8 *pck_data; 		s32 current; 		u8 sc_type, forced_sc_type=0; 		Bool sc_type_forced = GF_FALSE; 		Bool skip_pck = GF_FALSE; 		u8 ftype; 		u32 tinc; 		u64 size=0; 		u64 fstart; 		Bool is_coded; 		u32 bytes_from_store = 0; 		u32 hdr_offset = 0; 		Bool copy_last_bytes = GF_FALSE;  		//not enough bytes to parse start code 		if (remain<5) { 			memcpy(ctx->hdr_store, start, remain); 			ctx->bytes_in_header = remain; 			break; 		} 		current = -1;  		//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code. 		//if not, dispatch these bytes as continuation of the data 		if (ctx->bytes_in_header) {  			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header); 			current = mpgviddmx_next_start_code(ctx->hdr_store, 8);  			//no start code in stored buffer 			if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  { 				if (ctx->opid) { 					dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data); 					if (!dst_pck) return GF_OUT_OF_MEM;  					if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); 					gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); 					gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); 					memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header); 					gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);  					if (byte_offset != GF_FILTER_NO_BO) { 						gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header); 					}  					mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); 				}  				if (current<0) current = -1; 				else current -= ctx->bytes_in_header; 				ctx->bytes_in_header = 0; 			} else { 				//we have a valid start code, check which byte in our store or in the packet payload is the start code type 				//and remember its location to reinit the parser from there 				hdr_offset = 4 - ctx->bytes_in_header + current; 				//bytes still to dispatch 				bytes_from_store = ctx->bytes_in_header; 				ctx->bytes_in_header = 0; 				if (!hdr_offset) { 					forced_sc_type = ctx->hdr_store[current+3]; 				} else { 					forced_sc_type = start[hdr_offset-1]; 				} 				sc_type_forced = GF_TRUE; 			} 		} 		//no starcode in store, look for startcode in packet 		if (current == -1) { 			//locate next start code 			current = mpgviddmx_next_start_code(start, remain); 			//no start code, dispatch the block 			if (current<0) { 				u8 b3, b2, b1; 				if (! ctx->frame_started) { 					GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" )); 					break; 				} 				size = remain; 				b3 = start[remain-3]; 				b2 = start[remain-2]; 				b1 = start[remain-1]; 				//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes ! 				if (!b1 || !b2 || !b3) { 					copy_last_bytes = GF_TRUE; 					assert(size >= 3); 					size -= 3; 					ctx->bytes_in_header = 3; 				}  				dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); 				if (!dst_pck) return GF_OUT_OF_MEM;  				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); 				memcpy(pck_data, start, (size_t) size); 				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); 				gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); 				gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);  				if (byte_offset != GF_FILTER_NO_BO) { 					gf_filter_pck_set_byte_offset(dst_pck, byte_offset); 				}  				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); 				if (copy_last_bytes) { 					memcpy(ctx->hdr_store, start+remain-3, 3); 				} 				break; 			} 		}  		assert(current>=0);  		//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed 		if ((vosh_start>=0) && current) { 			assert(remain>=current); 			start += current; 			remain -= current; 			current = 0; 		} 		//also skip if no output pid 		if (!ctx->opid && current) { 			assert(remain>=current); 			start += current; 			remain -= current; 			current = 0; 		} 		//dispatch remaining bytes 		if (current>0) { 			//flush remaining 			dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data); 			if (!dst_pck) return GF_OUT_OF_MEM;  			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); 			gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); 			gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); 			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE); 			//bytes were partly in store, partly in packet 			if (bytes_from_store) { 				if (byte_offset != GF_FILTER_NO_BO) { 					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); 				} 				assert(bytes_from_store>=(u32) current); 				bytes_from_store -= current; 				memcpy(pck_data, ctx->hdr_store, current); 			} else { 				//bytes were only in packet 				if (byte_offset != GF_FILTER_NO_BO) { 					gf_filter_pck_set_byte_offset(dst_pck, byte_offset); 				} 				memcpy(pck_data, start, current); 				assert(remain>=current); 				start += current; 				remain -= current; 				current = 0; 			} 			gf_filter_pck_set_carousel_version(dst_pck, 1);  			mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); 		}  		//parse headers  		//we have a start code loaded, eg the data packet does not have a full start code at the beginning 		if (sc_type_forced) { 			gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset); 			sc_type = forced_sc_type; 		} else { 			gf_bs_reassign_buffer(ctx->bs, start, remain); 			gf_bs_read_int(ctx->bs, 24); 			sc_type = gf_bs_read_int(ctx->bs, 8); 		}  		if (ctx->is_mpg12) { 			switch (sc_type) { 			case M2V_SEQ_START_CODE: 			case M2V_EXT_START_CODE: 				gf_bs_reassign_buffer(ctx->bs, start, remain); 				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); 				//not enough data, accumulate until we can parse the full header 				if (e==GF_EOS) { 					if (vosh_start<0) vosh_start = 0; 					if (data == ctx->hdr_store) { 						memmove(ctx->hdr_store, start, remain); 						ctx->hdr_store_size = remain; 					} else { 						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { 							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start); 							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); 						} 						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); 						ctx->hdr_store_size += pck_size - (u32) vosh_start; 					} 					gf_filter_pid_drop_packet(ctx->ipid); 					return GF_OK; 				} else if (e != GF_OK) { 					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); 				} else { 					mpgviddmx_check_pid(filter, ctx, 0, NULL); 				} 				break; 			case M2V_PIC_START_CODE: 				break; 			default: 				break; 			}  		} else { 			u8 PL; 			switch (sc_type) { 			case M4V_VOS_START_CODE: 				ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs); 				vosh_start = start - (u8 *)data; 				skip_pck = GF_TRUE; 				assert(remain>=5); 				start += 5; 				remain -= 5; 				break; 			case M4V_VOL_START_CODE: 				gf_bs_reassign_buffer(ctx->bs, start, remain); 				PL = ctx->dsi.VideoPL; 				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); 				ctx->dsi.VideoPL = PL; 				//not enough data, accumulate until we can parse the full header 				if (e==GF_EOS) { 					if (vosh_start<0) vosh_start = 0; 					if (data == ctx->hdr_store) { 						memmove(ctx->hdr_store, start, remain); 						ctx->hdr_store_size = remain; 					} else { 						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { 							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start); 							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); 						} 						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); 						ctx->hdr_store_size += pck_size - (u32) vosh_start; 					} 					gf_filter_pid_drop_packet(ctx->ipid); 					return GF_OK; 				} else if (e != GF_OK) { 					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); 				} else { 					u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); 					if (vosh_start<0) vosh_start = 0; 					vosh_end = start - (u8 *)data + obj_size; 					vosh_end -= vosh_start; 					mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); 					skip_pck = GF_TRUE; 					assert(remain>=(s32) obj_size); 					start += obj_size; 					remain -= obj_size; 				} 				break; 			case M4V_VOP_START_CODE: 			case M4V_GOV_START_CODE: 				break;  			case M4V_VO_START_CODE: 			case M4V_VISOBJ_START_CODE: 			default: 				if (vosh_start>=0) { 					skip_pck = GF_TRUE; 					assert(remain>=4); 					start += 4; 					remain -= 4; 				} 				break; 			} 		}  		if (skip_pck) { 			continue; 		}  		if (!ctx->opid) { 			assert(remain>=4); 			start += 4; 			remain -= 4; 			continue; 		}  		if (!ctx->is_playing) { 			ctx->resume_from = (u32) ((char *)start -  (char *)data); 			return GF_OK; 		} 		//at this point, we no longer reaggregate packets 		ctx->hdr_store_size = 0;  		if (ctx->in_seek) { 			u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num); 			if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) { 				//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek; 				ctx->in_seek = GF_FALSE; 			} 		} 		//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes 		if (remain<5) 			continue;  		//good to go 		gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0); 		size = 0; 		e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded); 		//true if we strip VO and VISOBJ assert(!fstart);  		//we skipped bytes already in store + end of start code present in packet, so the size of the first object 		//needs adjustement 		if (bytes_from_store) { 			size += bytes_from_store + hdr_offset; 		}  		if ((e == GF_EOS) && !ctx->input_is_au_end) { 			u8 b3 = start[remain-3]; 			u8 b2 = start[remain-2]; 			u8 b1 = start[remain-1];  			//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes ! 			if (!b1 || !b2 || !b3) { 				copy_last_bytes = GF_TRUE; 				assert(size >= 3); 				size -= 3; 				ctx->bytes_in_header = 3; 			} 			full_frame = GF_FALSE; 		} else { 			full_frame = GF_TRUE; 		}  		if (!is_coded) { 			/*if prev is B and we're parsing a packed bitstream discard n-vop*/ 			if (ctx->forced_packed && ctx->b_frames) { 				ctx->is_packed = GF_TRUE; 				assert(remain>=size); 				start += size; 				remain -= (s32) size; 				continue; 			} 			/*policy is to import at variable frame rate, skip*/ 			if (ctx->vfr) { 				ctx->is_vfr = GF_TRUE; 				mpgviddmx_update_time(ctx); 				assert(remain>=size); 				start += size; 				remain -= (s32) size; 				continue; 			} 			/*policy is to keep non coded frame (constant frame rate), add*/ 		}  		if (ftype==2) { 			//count number of B-frames since last ref 			ctx->b_frames++; 			ctx->nb_b++; 		} else { 			//flush all pending packets 			mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE); 			//remeber the CTS of the last ref 			ctx->last_ref_cts = ctx->cts; 			if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames; 			 			ctx->b_frames = 0; 			if (ftype) 				ctx->nb_p++; 			else 				ctx->nb_i++; 		} 		ctx->nb_frames++;  		dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); 		if (!dst_pck) return GF_OUT_OF_MEM;  		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); 		//bytes come from both our store and the data packet 		if (bytes_from_store) { 			memcpy(pck_data, ctx->hdr_store+current, bytes_from_store); 			assert(size >= bytes_from_store); 			size -= bytes_from_store; 			if (byte_offset != GF_FILTER_NO_BO) { 				gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); 			} 			memcpy(pck_data + bytes_from_store, start, (size_t) size); 		} else { 			//bytes only come the data packet 			memcpy(pck_data, start, (size_t) size); 			if (byte_offset != GF_FILTER_NO_BO) { 				gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data); 			} 		} 		assert(pck_data[0] == 0); 		assert(pck_data[1] == 0); 		assert(pck_data[2] == 0x01);  		gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE); 		gf_filter_pck_set_cts(dst_pck, ctx->cts); 		gf_filter_pck_set_dts(dst_pck, ctx->dts); 		if (ctx->input_is_au_start) { 			ctx->input_is_au_start = GF_FALSE; 		} else { 			//we use the carousel flag temporarly to indicate the cts must be recomputed 			gf_filter_pck_set_carousel_version(dst_pck, 1); 		} 		gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1); 		gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den); 		if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE); 		ctx->frame_started = GF_TRUE;  		mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);  		mpgviddmx_update_time(ctx);  		if (!full_frame) { 			if (copy_last_bytes) { 				memcpy(ctx->hdr_store, start+remain-3, 3); 			} 			break; 		} 		assert(remain>=size); 		start += size; 		remain -= (s32) size; 	} 	gf_filter_pid_drop_packet(ctx->ipid);  	return GF_OK; }"
"195067_CWE-617.cc","CWE-617","StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,                                      const OpDef& op_def) {   FullTypeDef ft;   ft.set_type_id(TFT_PRODUCT);    for (int i = 0; i < op_def.output_arg_size(); i++) {     auto* t = ft.add_args();      *t = op_def.output_arg(i).experimental_full_type();      // Resolve dependent types. The convention for op registrations is to use     // attributes as type variables.     // See https://www.tensorflow.org/guide/create_op#type_polymorphism.     // Once the op signature can be defined entirely in FullType, this     // convention can be deprecated.     //     // Note: While this code performs some basic verifications, it generally     // assumes consistent op defs and attributes. If more complete     // verifications are needed, they should be done by separately, and in a     // way that can be reused for type inference.     for (int j = 0; j < t->args_size(); j++) {       auto* arg = t->mutable_args(i);       if (arg->type_id() == TFT_VAR) {         const auto* attr = attrs.Find(arg->s());         DCHECK(attr != nullptr);         if (attr->value_case() == AttrValue::kList) {           const auto& attr_list = attr->list();           arg->set_type_id(TFT_PRODUCT);           for (int i = 0; i < attr_list.type_size(); i++) {             map_dtype_to_tensor(attr_list.type(i), arg->add_args());           }          } else if (attr->value_case() == AttrValue::kType) {           map_dtype_to_tensor(attr->type(), arg);          } else {           return Status(error::UNIMPLEMENTED,                         absl::StrCat(""unknown attribute type"",                                      attrs.DebugString(), "" key="", arg->s()));         }          arg->clear_s();       }     }   }    return ft; }"
"195069_CWE-120.c","CWE-120","static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si) { 	s32 pps_id;  	/*s->current_picture.reference= h->nal_ref_idc != 0;*/ 	gf_bs_read_ue_log(bs, ""first_mb_in_slice""); 	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); 	if (si->slice_type > 9) return -1;  	pps_id = gf_bs_read_ue_log(bs, ""pps_id""); 	if (pps_id > 255) 		return -1; 	si->pps = &avc->pps[pps_id]; 	si->pps->id = pps_id; 	if (!si->pps->slice_group_count) 		return -2; 	si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT]; 	if (!si->sps->log2_max_frame_num) 		return -2;  	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");  	si->field_pic_flag = 0; 	if (si->sps->frame_mbs_only_flag) { 		/*s->picture_structure= PICT_FRAME;*/ 	} 	else { 		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); 		if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); 	} 	if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag) 		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");  	if (si->sps->poc_type == 0) { 		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); 		if (si->pps->pic_order_present && !si->field_pic_flag) { 			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom""); 		} 	} 	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { 		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); 		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) 			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); 	} 	if (si->pps->redundant_pic_cnt_present) { 		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); 	} 	return 0; }"
"195073_CWE-416.cc","CWE-416","  void DecodePngV2(OpKernelContext* context, StringPiece input) {     int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;     png::DecodeContext decode;     OP_REQUIRES(         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),         errors::InvalidArgument(""Invalid PNG. Failed to initialize decoder.""));      // Verify that width and height are not too large:     // - verify width and height don't overflow int.     // - width can later be multiplied by channels_ and sizeof(uint16), so     //   verify single dimension is not too large.     // - verify when width and height are multiplied together, there are a few     //   bits to spare as well.     const int width = static_cast<int>(decode.width);     const int height = static_cast<int>(decode.height);     const int64_t total_size =         static_cast<int64_t>(width) * static_cast<int64_t>(height);     if (width != static_cast<int64_t>(decode.width) || width <= 0 ||         width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||         height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {       png::CommonFreeDecode(&decode);       OP_REQUIRES(context, false,                   errors::InvalidArgument(""PNG size too large for int: "",                                           decode.width, "" by "", decode.height));     }      Tensor* output = nullptr;     Status status;     // By the existing API, we support decoding PNG with `DecodeGif` op.     // We need to make sure to return 4-D shapes when using `DecodeGif`.     if (op_type_ == ""DecodeGif"") {       status = context->allocate_output(           0, TensorShape({1, height, width, decode.channels}), &output);     } else {       status = context->allocate_output(           0, TensorShape({height, width, decode.channels}), &output);     }      if (op_type_ == ""DecodeBmp"") {       // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here       // because currently `decode_(jpeg|png|gif)` ops can decode any one of       // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode       // anything but bmp formats. This behavior needs to be revisited. For more       // details, please refer to the bug.       OP_REQUIRES(context, false,                   errors::InvalidArgument(                       ""Trying to decode PNG format using DecodeBmp op. Use ""                       ""`decode_png` or `decode_image` instead.""));     } else if (op_type_ == ""DecodeAndCropJpeg"") {       OP_REQUIRES(context, false,                   errors::InvalidArgument(                       ""DecodeAndCropJpeg operation can run on JPEG only, but ""                       ""detected PNG.""));     }      if (!status.ok()) png::CommonFreeDecode(&decode);     OP_REQUIRES_OK(context, status);      if (data_type_ == DataType::DT_UINT8) {       OP_REQUIRES(           context,           png::CommonFinishDecode(               reinterpret_cast<png_bytep>(output->flat<uint8>().data()),               decode.channels * width * sizeof(uint8), &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));     } else if (data_type_ == DataType::DT_UINT16) {       OP_REQUIRES(           context,           png::CommonFinishDecode(               reinterpret_cast<png_bytep>(output->flat<uint16>().data()),               decode.channels * width * sizeof(uint16), &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));     } else if (data_type_ == DataType::DT_FLOAT) {       // `png::CommonFinishDecode` does not support `float`. First allocate       // uint16 buffer for the image and decode in uint16 (lossless). Wrap the       // buffer in `unique_ptr` so that we don't forget to delete the buffer.       std::unique_ptr<uint16[]> buffer(           new uint16[height * width * decode.channels]);       OP_REQUIRES(           context,           png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),                                   decode.channels * width * sizeof(uint16),                                   &decode),           errors::InvalidArgument(""Invalid PNG data, size "", input.size()));        // Convert uint16 image data to desired data type.       // Use eigen threadpooling to speed up the copy operation.       const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();       TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,                                                   decode.channels);       float scale = 1. / std::numeric_limits<uint16>::max();       // Fill output tensor with desired dtype.       output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;     }   }"
"195074_CWE-415.c","CWE-415","GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size) { #ifndef GPAC_DISABLE_AV_PARSERS 	AV1State state; 	u8 reserved; 	GF_AV1Config *cfg;  	if (!size) size = (u32) gf_bs_available(bs); 	if (!size) return NULL;  	cfg = gf_odf_av1_cfg_new(); 	gf_av1_init_state(&state); 	state.config = cfg;  	cfg->marker = gf_bs_read_int(bs, 1); 	cfg->version = gf_bs_read_int(bs, 7); 	cfg->seq_profile = gf_bs_read_int(bs, 3); 	cfg->seq_level_idx_0 = gf_bs_read_int(bs, 5); 	cfg->seq_tier_0 = gf_bs_read_int(bs, 1); 	cfg->high_bitdepth = gf_bs_read_int(bs, 1); 	cfg->twelve_bit = gf_bs_read_int(bs, 1); 	cfg->monochrome = gf_bs_read_int(bs, 1); 	cfg->chroma_subsampling_x = gf_bs_read_int(bs, 1); 	cfg->chroma_subsampling_y = gf_bs_read_int(bs, 1); 	cfg->chroma_sample_position = gf_bs_read_int(bs, 2);  	reserved = gf_bs_read_int(bs, 3); 	if (reserved != 0 || cfg->marker != 1 || cfg->version != 1) { 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\n"", reserved, cfg->marker, cfg->version)); 		gf_odf_av1_cfg_del(cfg); 		return NULL; 	} 	cfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1); 	if (cfg->initial_presentation_delay_present) { 		cfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4); 	} else { 		/*reserved = */gf_bs_read_int(bs, 4); 		cfg->initial_presentation_delay_minus_one = 0; 	} 	size -= 4;  	while (size) { 		u64 pos, obu_size; 		ObuType obu_type; 		GF_AV1_OBUArrayEntry *a;  		pos = gf_bs_get_position(bs); 		obu_size = 0; 		if (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[AV1] could not parse AV1 OBU at position ""LLU"". Leaving parsing.\n"", pos)); 			break; 		} 		assert(obu_size == gf_bs_get_position(bs) - pos); 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] parsed AV1 OBU type=%u size=""LLU"" at position ""LLU"".\n"", obu_type, obu_size, pos));  		if (!av1_is_obu_header(obu_type)) { 			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] AV1 unexpected OBU type=%u size=""LLU"" found at position ""LLU"". Forwarding.\n"", pos)); 		} 		GF_SAFEALLOC(a, GF_AV1_OBUArrayEntry); 		if (!a) break; 		a->obu = gf_malloc((size_t)obu_size); 		if (!a->obu) { 			gf_free(a); 			break; 		} 		gf_bs_seek(bs, pos); 		gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size); 		a->obu_length = obu_size; 		a->obu_type = obu_type; 		gf_list_add(cfg->obu_array, a);  		if (size<obu_size) { 			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[AV1] AV1 config misses %d bytes to fit the entire OBU\n"", obu_size - size)); 			break; 		} 		size -= (u32) obu_size; 	} 	gf_av1_reset_state(& state, GF_TRUE); 	return cfg; #else 	return NULL; #endif }"
"195082_CWE-862.c","CWE-862","void recalc_intercepts(struct vcpu_svm *svm) { 	struct vmcb_control_area *c, *h, *g; 	unsigned int i;  	vmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);  	if (!is_guest_mode(&svm->vcpu)) 		return;  	c = &svm->vmcb->control; 	h = &svm->vmcb01.ptr->control; 	g = &svm->nested.ctl;  	for (i = 0; i < MAX_INTERCEPT; i++) 		c->intercepts[i] = h->intercepts[i];  	if (g->int_ctl & V_INTR_MASKING_MASK) { 		/* We only want the cr8 intercept bits of L1 */ 		vmcb_clr_intercept(c, INTERCEPT_CR8_READ); 		vmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);  		/* 		 * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not 		 * affect any interrupt we may want to inject; therefore, 		 * interrupt window vmexits are irrelevant to L0. 		 */ 		vmcb_clr_intercept(c, INTERCEPT_VINTR); 	}  	/* We don't want to see VMMCALLs from a nested guest */ 	vmcb_clr_intercept(c, INTERCEPT_VMMCALL);  	for (i = 0; i < MAX_INTERCEPT; i++) 		c->intercepts[i] |= g->intercepts[i];  	/* If SMI is not intercepted, ignore guest SMI intercept as well  */ 	if (!intercept_smi) 		vmcb_clr_intercept(c, INTERCEPT_SMI); }"
"195083_CWE-617.cc","CWE-617","bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {   CHECK_NOTNULL(a);   TensorBuffer* p = nullptr;   if (!TensorShape::IsValid(proto.tensor_shape())) return false;   if (proto.dtype() == DT_INVALID) return false;   TensorShape shape(proto.tensor_shape());   const int64_t N = shape.num_elements();   if (N > 0 && proto.dtype()) {     bool dtype_error = false;     if (!proto.tensor_content().empty()) {       const auto& content = proto.tensor_content();       CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),                          dtype_error = true, dtype_error = true);     } else {       CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),                          dtype_error = true, dtype_error = true);     }     if (dtype_error || p == nullptr) return false;   }   shape_ = shape;   set_dtype(proto.dtype());   UnrefIfNonNull(buf_);   buf_ = p;   // TODO(misard) add tracking of which kernels and steps are calling   // FromProto.   if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {     LogMemory::RecordTensorAllocation(""Unknown (from Proto)"",                                       LogMemory::UNKNOWN_STEP_ID, *this);   }   return true; }"
"195085_CWE-20.c","CWE-20","setup_seccomp (FlatpakBwrap   *bwrap,                const char     *arch,                gulong          allowed_personality,                FlatpakRunFlags run_flags,                GError        **error) {   gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;   gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;    __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;    /**** BEGIN NOTE ON CODE SHARING    *    * There are today a number of different Linux container    * implementations.  That will likely continue for long into the    * future.  But we can still try to share code, and it's important    * to do so because it affects what library and application writers    * can do, and we should support code portability between different    * container tools.    *    * This syscall blocklist is copied from linux-user-chroot, which was in turn    * clearly influenced by the Sandstorm.io blocklist.    *    * If you make any changes here, I suggest sending the changes along    * to other sandbox maintainers.  Using the libseccomp list is also    * an appropriate venue:    * https://groups.google.com/forum/#!forum/libseccomp    *    * A non-exhaustive list of links to container tooling that might    * want to share this blocklist:    *    *  https://github.com/sandstorm-io/sandstorm    *    in src/sandstorm/supervisor.c++    *  https://github.com/flatpak/flatpak.git    *    in common/flatpak-run.c    *  https://git.gnome.org/browse/linux-user-chroot    *    in src/setup-seccomp.c    *    **** END NOTE ON CODE SHARING    */   struct   {     int                  scall;     int                  errnum;     struct scmp_arg_cmp *arg;   } syscall_blocklist[] = {     /* Block dmesg */     {SCMP_SYS (syslog), EPERM},     /* Useless old syscall */     {SCMP_SYS (uselib), EPERM},     /* Don't allow disabling accounting */     {SCMP_SYS (acct), EPERM},     /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a        historic source of interesting information leaks. */     {SCMP_SYS (modify_ldt), EPERM},     /* Don't allow reading current quota use */     {SCMP_SYS (quotactl), EPERM},      /* Don't allow access to the kernel keyring */     {SCMP_SYS (add_key), EPERM},     {SCMP_SYS (keyctl), EPERM},     {SCMP_SYS (request_key), EPERM},      /* Scary VM/NUMA ops */     {SCMP_SYS (move_pages), EPERM},     {SCMP_SYS (mbind), EPERM},     {SCMP_SYS (get_mempolicy), EPERM},     {SCMP_SYS (set_mempolicy), EPERM},     {SCMP_SYS (migrate_pages), EPERM},      /* Don't allow subnamespace setups: */     {SCMP_SYS (unshare), EPERM},     {SCMP_SYS (mount), EPERM},     {SCMP_SYS (pivot_root), EPERM}, #if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)     /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack      * and flags arguments are reversed so the flags come second */     {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #else     /* Normally the flags come first */     {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #endif      /* Don't allow faking input to the controlling tty (CVE-2017-5226) */     {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},   };    struct   {     int                  scall;     int                  errnum;     struct scmp_arg_cmp *arg;   } syscall_nondevel_blocklist[] = {     /* Profiling operations; we expect these to be done by tools from outside      * the sandbox.  In particular perf has been the source of many CVEs.      */     {SCMP_SYS (perf_event_open), EPERM},     /* Don't allow you to switch to bsd emulation or whatnot */     {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},     {SCMP_SYS (ptrace), EPERM}   };   /* Blocklist all but unix, inet, inet6 and netlink */   struct   {     int             family;     FlatpakRunFlags flags_mask;   } socket_family_allowlist[] = {     /* NOTE: Keep in numerical order */     { AF_UNSPEC, 0 },     { AF_LOCAL, 0 },     { AF_INET, 0 },     { AF_INET6, 0 },     { AF_NETLINK, 0 },     { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },     { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },   };   int last_allowed_family;   int i, r;   g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };    seccomp = seccomp_init (SCMP_ACT_ALLOW);   if (!seccomp)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Initialize seccomp failed""));    if (arch != NULL)     {       uint32_t arch_id = 0;       const uint32_t *extra_arches = NULL;        if (strcmp (arch, ""i386"") == 0)         {           arch_id = SCMP_ARCH_X86;         }       else if (strcmp (arch, ""x86_64"") == 0)         {           arch_id = SCMP_ARCH_X86_64;           extra_arches = seccomp_x86_64_extra_arches;         }       else if (strcmp (arch, ""arm"") == 0)         {           arch_id = SCMP_ARCH_ARM;         } #ifdef SCMP_ARCH_AARCH64       else if (strcmp (arch, ""aarch64"") == 0)         {           arch_id = SCMP_ARCH_AARCH64;           extra_arches = seccomp_aarch64_extra_arches;         } #endif        /* We only really need to handle arches on multiarch systems.        * If only one arch is supported the default is fine */       if (arch_id != 0)         {           /* This *adds* the target arch, instead of replacing the              native one. This is not ideal, because we'd like to only              allow the target arch, but we can't really disallow the              native arch at this point, because then bubblewrap              couldn't continue running. */           r = seccomp_arch_add (seccomp, arch_id);           if (r < 0 && r != -EEXIST)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add architecture to seccomp filter""));            if (multiarch && extra_arches != NULL)             {               for (i = 0; extra_arches[i] != 0; i++)                 {                   r = seccomp_arch_add (seccomp, extra_arches[i]);                   if (r < 0 && r != -EEXIST)                     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add multiarch architecture to seccomp filter""));                 }             }         }     }    /* TODO: Should we filter the kernel keyring syscalls in some way?    * We do want them to be used by desktop apps, but they could also perhaps    * leak system stuff or secrets from other apps.    */    for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)     {       int scall = syscall_blocklist[i].scall;       int errnum = syscall_blocklist[i].errnum;        g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);        if (syscall_blocklist[i].arg)         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);       else         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);       if (r < 0 && r == -EFAULT /* unknown syscall */)         return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);     }    if (!devel)     {       for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)         {           int scall = syscall_nondevel_blocklist[i].scall;           int errnum = syscall_nondevel_blocklist[i].errnum;            g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);            if (syscall_nondevel_blocklist[i].arg)             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);           else             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);            if (r < 0 && r == -EFAULT /* unknown syscall */)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);         }     }    /* Socket filtering doesn't work on e.g. i386, so ignore failures here    * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing    * something else: https://github.com/seccomp/libseccomp/issues/8 */   last_allowed_family = -1;   for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)     {       int family = socket_family_allowlist[i].family;       int disallowed;        if (socket_family_allowlist[i].flags_mask != 0 &&           (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)         continue;        for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)         {           /* Blocklist the in-between valid families */           seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));         }       last_allowed_family = family;     }   /* Blocklist the rest */   seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));    if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, ""/tmp"", &seccomp_tmpf, error))     return FALSE;    if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to export bpf""));    lseek (seccomp_tmpf.fd, 0, SEEK_SET);    flatpak_bwrap_add_args_data_fd (bwrap,                                   ""--seccomp"", glnx_steal_fd (&seccomp_tmpf.fd), NULL);    return TRUE; }"
"195091_CWE-754.cc","CWE-754","llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,                                         ValueRange shapes, Location loc,                                         OpBuilder* builder) {   // First find the input shape with the largest rank.   SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;   size_t maxRank = 0;   for (const auto &shape : llvm::enumerate(shapes)) {     auto found_shape = analysis.GetValueInfo(shape.value());     if (!found_shape) return {};     shapes_found.push_back(*found_shape);     maxRank = std::max(maxRank, found_shape->size());   }    SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(       maxRank);   SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);   for (const auto &shape : llvm::enumerate(shapes_found)) {     for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {       // 1 dimensions don't contribute to the final result.       if (dim.value().isConstant(1)) continue;       // If it's not a 1 dimension it will be present in the result. Remember       // where it came from.       auto index = maxRank - dim.index() - 1;       if (!joined_dimensions[index]) {         joined_dimensions[index] = &dim.value();         shape_and_rank_for_dim[index] =             std::make_pair(shapes[shape.index()], shape.value().size());         continue;       }       // Bail if the dimensions are neither equal nor 1.       if (*joined_dimensions[index] != dim.value()) return {};     }   }   // If the output is the same as one of the inputs just return that.   if (llvm::is_splat(shape_and_rank_for_dim) &&       shape_and_rank_for_dim[0].first) {     return shape_and_rank_for_dim[0].first;   }   // Otherwise rematerialize the shape from the pieces we have.   SmallVector<Value> elements;   for (int i = 0; i != maxRank; ++i) {     // 1 dimensions are filtered above, recreate the constant.     if (!shape_and_rank_for_dim[i].first) {       auto one = builder->getIntegerAttr(           shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);       elements.push_back(builder->create<ConstantOp>(loc, one));       continue;     }     // Extract from one of the shapes, accounting for the reverse indexing     // performed by broadcast.     Value index = builder->create<ConstantIndexOp>(         loc, i - maxRank + shape_and_rank_for_dim[i].second);     elements.push_back(builder->create<tensor::ExtractOp>(         loc, shape_and_rank_for_dim[i].first, index));   }   return Value(builder->create<tensor::FromElementsOp>(loc, elements)); }"
"195092_CWE-843.cpp","CWE-843","Literal *hermes::evalUnaryOperator(     UnaryOperatorInst::OpKind kind,     IRBuilder &builder,     Literal *operand) {   switch (kind) {     case UnaryOperatorInst::OpKind::MinusKind:       // Negate constant integers.       switch (operand->getKind()) {         case ValueKind::LiteralNumberKind:           if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {             auto V = -literalNum->getValue();             return builder.getLiteralNumber(V);           }           break;         case ValueKind::LiteralUndefinedKind:           return builder.getLiteralNaN();         case ValueKind::LiteralBoolKind:           if (evalIsTrue(builder, operand)) {             return builder.getLiteralNumber(-1);           } else { // evalIsFalse(operand)             return builder.getLiteralNegativeZero();           }         case ValueKind::LiteralNullKind:           return builder.getLiteralNegativeZero();         default:           break;       }       break;     case UnaryOperatorInst::OpKind::TypeofKind:       switch (operand->getKind()) {         case ValueKind::GlobalObjectKind:         case ValueKind::LiteralNullKind:           return builder.getLiteralString(""object"");         case ValueKind::LiteralUndefinedKind:           return builder.getLiteralString(""undefined"");         case ValueKind::LiteralBoolKind:           return builder.getLiteralString(""boolean"");         case ValueKind::LiteralNumberKind:           return builder.getLiteralString(""number"");         case ValueKind::LiteralStringKind:           return builder.getLiteralString(""string"");         default:           llvm_unreachable(""Invalid literal kind."");       }       break;      case UnaryOperatorInst::OpKind::BangKind:       if (evalIsTrue(builder, operand)) {         return builder.getLiteralBool(false);       }       if (evalIsFalse(builder, operand)) {         return builder.getLiteralBool(true);       }       break;      case UnaryOperatorInst::OpKind::VoidKind:       return builder.getLiteralUndefined();      default:       break;   }    return nullptr; }"
"195095_CWE-295.cpp","CWE-295","int Socket::startSslClient(const std::string &certificate_path, String hostname) {     if (isssl) {         stopSsl();     }      ERR_clear_error(); #if OPENSSL_VERSION_NUMBER < 0x10100000L     ctx = SSL_CTX_new(SSLv23_client_method()); #else     ctx = SSL_CTX_new(TLS_client_method()); #endif      if (ctx == NULL) { #ifdef NETDEBUG         std::cout << thread_id << ""Error ssl context is null (check that openssl has been inited)"" << std::endl; #endif         log_ssl_errors(""Error ssl context is null for %s"", hostname.c_str());         return -1;     }      //set the timeout for the ssl session     if (SSL_CTX_set_timeout(ctx, 130l) < 1) {             SSL_CTX_free(ctx);             ctx = NULL;         return -1;     }      //load certs     ERR_clear_error();     if (certificate_path.length()) {         if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) { #ifdef NETDEBUG             std::cout << thread_id << ""couldnt load certificates"" << std::endl; #endif             log_ssl_errors(""couldnt load certificates from %s"", certificate_path.c_str());             //tidy up             SSL_CTX_free(ctx);             ctx = NULL;             return -2;         }     } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given     { #ifdef NETDEBUG         std::cout << thread_id << ""couldnt load certificates"" << std::endl; #endif             log_ssl_errors(""couldnt load default certificates for %s"", hostname.c_str());         //tidy up         SSL_CTX_free(ctx);         ctx = NULL;         return -2;     }      // add validation params     ERR_clear_error();     X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();     if (!x509_param) {         log_ssl_errors(""couldnt add validation params for %s"", hostname.c_str());         //X509_VERIFY_PARAM_free(x509_param);             SSL_CTX_free(ctx);             ctx = NULL;         return -2;     }      ERR_clear_error();     if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {         log_ssl_errors(""couldnt add validation params for %s"", hostname.c_str());         X509_VERIFY_PARAM_free(x509_param);             SSL_CTX_free(ctx);             ctx = NULL;         return -2;     }      ERR_clear_error();     if (!SSL_CTX_set1_param(ctx, x509_param)) {         log_ssl_errors(""couldnt add validation params for %s"", hostname.c_str());         X509_VERIFY_PARAM_free(x509_param);             SSL_CTX_free(ctx);             ctx = NULL;         return -2;     }      X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it      //hand socket over to ssl lib     ERR_clear_error();     ssl = SSL_new(ctx);     SSL_set_options(ssl, SSL_OP_ALL);     SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);     SSL_set_connect_state(ssl);      //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently     SSL_set_fd(ssl, this->getFD());     SSL_set_tlsext_host_name(ssl, hostname.c_str());      //make io non blocking as select wont tell us if we can do a read without blocking     //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently     //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently     ERR_clear_error();     int rc = SSL_connect(ssl);     if (rc < 0) {         log_ssl_errors(""ssl_connect failed to %s"", hostname.c_str()); #ifdef NETDEBUG         std::cout << thread_id << ""ssl_connect failed with error "" << SSL_get_error(ssl, rc) << std::endl; #endif         // tidy up         SSL_free(ssl);         ssl = NULL;         SSL_CTX_free(ctx);         ctx = NULL;         return -3;     }      //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup     isssl = true;     issslserver = false;     return 0; }"
"195216_CWE-617.cc","CWE-617","  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,                             const FunctionDef::ArgAttrs* arg_attrs,                             bool ints_on_device,                             int64_t resource_arg_unique_id) {     bool is_type_list;     DataTypeVector dtypes;     TF_RETURN_IF_ERROR(         ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));     CHECK_GE(dtypes.size(), size_t{1});     int arg_index = result_.nodes.size();     TF_RETURN_IF_ERROR(         AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));     // Creates dtypes.size() nodes in the graph.     for (size_t i = 0; i < dtypes.size(); ++i) {       TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), "":"", i),                                  {true, arg_index, 0, false, {dtypes[i]}}));       DCHECK_EQ(arg_index, result_.nodes.size());       string name = arg_def.name();       if (dtypes.size() > 1) {         strings::StrAppend(&name, ""_"", i);       }       NodeDef* gnode = AddNode(name);       if (ints_on_device && dtypes[i] == DataType::DT_INT32) {         gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);       } else {         gnode->set_op(FunctionLibraryDefinition::kArgOp);       }       DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];       AddAttr(""T"", dtype, gnode);       AddAttr(""index"", arg_index, gnode);       if (resource_arg_unique_id >= 0) {         AddAttr(""_resource_arg_unique_id"", resource_arg_unique_id, gnode);       }       if (arg_attrs) {         for (const auto& arg_attr : arg_attrs->attr()) {           AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());         }       }       result_.arg_types.push_back(dtypes[i]);       ++arg_index;     }     return Status::OK();   }"
"195218_CWE-125.c","CWE-125","gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) {   int idx;   int type = nint(tree->car);    switch (type) {   case NODE_GVAR:   case NODE_ARG:   case NODE_LVAR:   case NODE_IVAR:   case NODE_CVAR:   case NODE_CONST:   case NODE_NIL:   case NODE_MASGN:     if (rhs) {       codegen(s, rhs, VAL);       pop();       sp = cursp();     }     break;    case NODE_COLON2:   case NODE_CALL:   case NODE_SCALL:     /* keep evaluation order */     break;    case NODE_NVAR:     codegen_error(s, ""Can't assign to numbered parameter"");     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }    tree = tree->cdr;   switch (type) {   case NODE_GVAR:     gen_setxv(s, OP_SETGV, sp, nsym(tree), val);     break;   case NODE_ARG:   case NODE_LVAR:     idx = lv_idx(s, nsym(tree));     if (idx > 0) {       if (idx != sp) {         gen_move(s, idx, sp, val);       }       break;     }     else {                      /* upvar */       gen_setupvar(s, sp, nsym(tree));     }     break;   case NODE_IVAR:     gen_setxv(s, OP_SETIV, sp, nsym(tree), val);     break;   case NODE_CVAR:     gen_setxv(s, OP_SETCV, sp, nsym(tree), val);     break;   case NODE_CONST:     gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);     break;   case NODE_COLON2:     if (sp) {       gen_move(s, cursp(), sp, 0);     }     sp = cursp();     push();     codegen(s, tree->car, VAL);     if (rhs) {       codegen(s, rhs, VAL); pop();       gen_move(s, sp, cursp(), 0);     }     pop_n(2);     idx = new_sym(s, nsym(tree->cdr));     genop_2(s, OP_SETMCNST, sp, idx);     break;    case NODE_CALL:   case NODE_SCALL:     {       int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;       mrb_sym mid = nsym(tree->cdr->car);        top = cursp();       if (val || sp == cursp()) {         push();                   /* room for retval */       }       call = cursp();       if (!tree->car) {         noself = 1;         push();       }       else {         codegen(s, tree->car, VAL); /* receiver */       }       if (safe) {         int recv = cursp()-1;         gen_move(s, cursp(), recv, 1);         skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);       }       tree = tree->cdr->cdr->car;       if (tree) {         if (tree->car) {            /* positional arguments */           n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);           if (n < 0) {              /* variable length */             n = 15;             push();           }         }         if (tree->cdr->car) {       /* keyword arguments */           gen_hash(s, tree->cdr->car->cdr, VAL, 0);           if (n < 14) {             n++;             push();           }           else {             pop();             genop_2(s, OP_ARYPUSH, cursp(), 1);           }         }       }       if (rhs) {         codegen(s, rhs, VAL);         pop();       }       else {         gen_move(s, cursp(), sp, 0);       }       if (val) {         gen_move(s, top, cursp(), 1);       }       if (n < 14) {         n++;       }       else {         pop();         genop_2(s, OP_ARYPUSH, cursp(), 1);       }       s->sp = call;       if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {         genop_1(s, OP_SETIDX, cursp());       }       else {         genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);       }       if (safe) {         dispatch(s, skip);       }       s->sp = top;     }     break;    case NODE_MASGN:     gen_vmassignment(s, tree->car, sp, val);     break;    /* splat without assignment */   case NODE_NIL:     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }   if (val) push(); }"
"195220_CWE-362.c","CWE-362","int main(int argc, char **argv, char **envp) { 	int opt;  	while ((opt = getopt(argc, argv, ""b:h:k:p:q:w:z:xv"")) != -1) { 		switch (opt) { 		case 'b': 			tmate_settings->bind_addr = xstrdup(optarg); 			break; 		case 'h': 			tmate_settings->tmate_host = xstrdup(optarg); 			break; 		case 'k': 			tmate_settings->keys_dir = xstrdup(optarg); 			break; 		case 'p': 			tmate_settings->ssh_port = atoi(optarg); 			break; 		case 'q': 			tmate_settings->ssh_port_advertized = atoi(optarg); 			break; 		case 'w': 			tmate_settings->websocket_hostname = xstrdup(optarg); 			break; 		case 'z': 			tmate_settings->websocket_port = atoi(optarg); 			break; 		case 'x': 			tmate_settings->use_proxy_protocol = true; 			break; 		case 'v': 			tmate_settings->log_level++; 			break; 		default: 			usage(); 			return 1; 		} 	}  	init_logging(tmate_settings->log_level);  	setup_locale();  	if (!tmate_settings->tmate_host) 		tmate_settings->tmate_host = get_full_hostname();  	cmdline = *argv; 	cmdline_end = *envp;  	tmate_preload_trace_lib(); 	tmate_catch_sigsegv(); 	tmate_init_rand();  	if ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) || 	    (mkdir(TMATE_WORKDIR ""/sessions"", 0703) < 0 && errno != EEXIST) || 	    (mkdir(TMATE_WORKDIR ""/jail"", 0700)     < 0 && errno != EEXIST)) 		tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR);  	/* The websocket server needs to access the /session dir to rename sockets */ 	if ((chmod(TMATE_WORKDIR, 0701)             < 0) || 	    (chmod(TMATE_WORKDIR ""/sessions"", 0703) < 0) || 	    (chmod(TMATE_WORKDIR ""/jail"", 0700)     < 0)) 		tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR);  	tmate_ssh_server_main(tmate_session, 			      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port); 	return 0; }"
"195230_CWE-125.c","CWE-125","void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess, 				 const void *pkt, 				 pj_size_t size) {     const pjmedia_rtcp_xr_pkt	      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;     const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;     const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;     const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;     const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;     const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*)  						rtcp_xr->buf;     unsigned pkt_len, rb_len;      if (rtcp_xr->common.pt != RTCP_XR) 	return;      pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);      if ((pkt_len + 1) > (size / 4)) 	return;      /* Parse report rpt_types */     while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)     {	 	rb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);  	/* Just skip any block with length == 0 (no report content) */ 	if (rb_len) { 	    switch (rb_hdr->bt) { 		case BT_RR_TIME: 		    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr; 		    break; 		case BT_DLRR: 		    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr; 		    break; 		case BT_STATS: 		    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr; 		    break; 		case BT_VOIP_METRICS: 		    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr; 		    break; 		default: 		    break; 	    } 	} 	rb_hdr = (pjmedia_rtcp_xr_rb_header*) 		 ((pj_int32_t*)rb_hdr + rb_len + 1);     }      /* Receiving RR Time */     if (rb_rr_time) { 	/* Save LRR from NTP timestamp of the RR time block report */ 	sess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) |  		       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);  	/* Calculate RR arrival time for DLRR */ 	pj_get_timestamp(&sess->rx_lrr_time);  	TRACE_((sess->name, ""Rx RTCP SR: ntp_ts=%p"", sess->rx_lrr, 	       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/ 			     sess->rtcp_session->ts_freq.u64)));     }      /* Receiving DLRR */     if (rb_dlrr) { 	pj_uint32_t lrr, now, dlrr; 	pj_uint64_t eedelay; 	pjmedia_rtcp_ntp_rec ntp;  	/* LRR is the middle 32bit of NTP. It has 1/65536 second  	 * resolution  	 */ 	lrr = pj_ntohl(rb_dlrr->item.lrr);  	/* DLRR is delay since LRR, also in 1/65536 resolution */ 	dlrr = pj_ntohl(rb_dlrr->item.dlrr);  	/* Get current time, and convert to 1/65536 resolution */ 	pjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp); 	now = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);  	/* End-to-end delay is (now-lrr-dlrr) */ 	eedelay = now - lrr - dlrr;  	/* Convert end to end delay to usec (keeping the calculation in          * 64bit space):: 	 *   sess->ee_delay = (eedelay * 1000) / 65536; 	 */ 	if (eedelay < 4294) { 	    eedelay = (eedelay * 1000000) >> 16; 	} else { 	    eedelay = (eedelay * 1000) >> 16; 	    eedelay *= 1000; 	}  	TRACE_((sess->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), "" 			   ""now=%p, rtt=%p"", 		lrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536, 		now, (pj_uint32_t)eedelay)); 	 	/* Only save calculation if ""now"" is greater than lrr, or 	 * otherwise rtt will be invalid  	 */ 	if (now-dlrr >= lrr) { 	    unsigned rtt = (pj_uint32_t)eedelay; 	     	    /* Check that eedelay value really makes sense.  	     * We allow up to 30 seconds RTT! 	     */ 	    if (eedelay <= 30 * 1000 * 1000UL) { 		/* ""Normalize"" rtt value that is exceptionally high. 		 * For such values, ""normalize"" the rtt to be three times 		 * the average value. 		 */ 		if (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0) 		{ 		    unsigned orig_rtt = rtt; 		    rtt = (unsigned)sess->stat.rtt.mean*3; 		    PJ_LOG(5,(sess->name,  			      ""RTT value %d usec is normalized to %d usec"", 			      orig_rtt, rtt)); 		}     	 		TRACE_((sess->name, ""RTCP RTT is set to %d usec"", rtt)); 		pj_math_stat_update(&sess->stat.rtt, rtt); 	    } 	} else { 	    PJ_LOG(5, (sess->name, ""Internal RTCP NTP clock skew detected: "" 				   ""lrr=%p, now=%p, dlrr=%p (%d:%03dms), "" 				   ""diff=%d"", 				   lrr, now, dlrr, dlrr/65536, 				   (dlrr%65536)*1000/65536, 				   dlrr-(now-lrr))); 	}     }      /* Receiving Statistics Summary */     if (rb_stats) { 	pj_uint8_t flags = rb_stats->header.specific;  	pj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));  	/* Range of packets sequence reported in this blocks */ 	sess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq); 	sess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);  	/* Get flags of valid fields */ 	sess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0; 	sess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0; 	sess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0; 	sess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;  	/* Fetch the reports info */ 	if (sess->stat.tx.stat_sum.l) { 	    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost); 	}  	if (sess->stat.tx.stat_sum.d) { 	    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup); 	}  	if (sess->stat.tx.stat_sum.j) { 	    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min); 	    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max); 	    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean); 	    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter,  				    pj_ntohl(rb_stats->jitter_dev)); 	}  	if (sess->stat.tx.stat_sum.t) { 	    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min; 	    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max; 	    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean; 	    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh,  				    pj_ntohl(rb_stats->toh_dev)); 	}  	pj_gettimeofday(&sess->stat.tx.stat_sum.update);     }      /* Receiving VoIP Metrics */     if (rb_voip_mtc) { 	sess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate; 	sess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate; 	sess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den; 	sess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den; 	sess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur); 	sess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur); 	sess->stat.tx.voip_mtc.rnd_trip_delay =  					pj_ntohs(rb_voip_mtc->rnd_trip_delay); 	sess->stat.tx.voip_mtc.end_sys_delay =  					pj_ntohs(rb_voip_mtc->end_sys_delay); 	/* signal & noise level encoded in two's complement form */ 	sess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t) 				    ((rb_voip_mtc->signal_lvl > 127)? 				     ((int)rb_voip_mtc->signal_lvl - 256) :  				     rb_voip_mtc->signal_lvl); 	sess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t) 				    ((rb_voip_mtc->noise_lvl > 127)? 				     ((int)rb_voip_mtc->noise_lvl - 256) :  				     rb_voip_mtc->noise_lvl); 	sess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl; 	sess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin; 	sess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor; 	sess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor; 	sess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq; 	sess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq; 	sess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config; 	sess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom); 	sess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max); 	sess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);  	pj_gettimeofday(&sess->stat.tx.voip_mtc.update);     } }"
"195231_CWE-476.c","CWE-476","s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc) { 	u8 idr_flag; 	s32 slice, ret; 	u32 nal_hdr; 	AVCSliceInfo n_state;  	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);  	nal_hdr = gf_bs_read_u8(bs);  	slice = 0; 	memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo)); 	avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F; 	n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;  	idr_flag = 0;  	switch (n_state.nal_unit_type) { 	case GF_AVC_NALU_ACCESS_UNIT: 	case GF_AVC_NALU_END_OF_SEQ: 	case GF_AVC_NALU_END_OF_STREAM: 		ret = 1; 		break;  	case GF_AVC_NALU_SVC_SLICE: 		SVC_ReadNal_header_extension(bs, &n_state.NalHeader); 		// slice buffer - read the info and compare. 		/*ret = */svc_parse_slice(bs, avc, &n_state); 		if (avc->s_info.nal_ref_idc) { 			n_state.poc_lsb_prev = avc->s_info.poc_lsb; 			n_state.poc_msb_prev = avc->s_info.poc_msb; 		} 		avc_compute_poc(&n_state);  		if (avc->s_info.poc != n_state.poc) { 			memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo)); 			return 1; 		} 		memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo)); 		return 0;  	case GF_AVC_NALU_SVC_PREFIX_NALU: 		SVC_ReadNal_header_extension(bs, &n_state.NalHeader); 		return 0;  	case GF_AVC_NALU_IDR_SLICE: 	case GF_AVC_NALU_NON_IDR_SLICE: 	case GF_AVC_NALU_DP_A_SLICE: 	case GF_AVC_NALU_DP_B_SLICE: 	case GF_AVC_NALU_DP_C_SLICE: 		slice = 1; 		/* slice buffer - read the info and compare.*/ 		ret = avc_parse_slice(bs, avc, idr_flag, &n_state); 		if (ret < 0) return ret; 		ret = 0; 		if ( 			((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE)) 			&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE) 			) { 			break; 		} 		if (avc->s_info.frame_num != n_state.frame_num) { 			ret = 1; 			break; 		}  		if (avc->s_info.field_pic_flag != n_state.field_pic_flag) { 			ret = 1; 			break; 		} 		if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) && 			(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) { 			ret = 1; 			break; 		} 		assert(avc->s_info.sps);  		if (avc->s_info.sps->poc_type == n_state.sps->poc_type) { 			if (!avc->s_info.sps->poc_type) { 				if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) { 					ret = 1; 					break; 				} 				if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) { 					ret = 1; 					break; 				} 			} 			else if (avc->s_info.sps->poc_type == 1) { 				if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) { 					ret = 1; 					break; 				} 				if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) { 					ret = 1; 					break; 				} 			} 		}  		if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) { 			if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/ 				ret = 1; 				break; 			} 			else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/ 				ret = 1; 				break; 			} 		} 		break; 	case GF_AVC_NALU_SEQ_PARAM: 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr); 		if (avc->last_ps_idx < 0) return -1; 		return 0;  	case GF_AVC_NALU_PIC_PARAM: 		avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr); 		if (avc->last_ps_idx < 0) return -1; 		return 0; 	case GF_AVC_NALU_SVC_SUBSEQ_PARAM: 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr); 		if (avc->last_ps_idx < 0) return -1; 		return 0; 	case GF_AVC_NALU_SEQ_PARAM_EXT: 		avc->last_ps_idx = (s32) gf_bs_read_ue(bs); 		if (avc->last_ps_idx < 0) return -1; 		return 0;  	case GF_AVC_NALU_SEI: 	case GF_AVC_NALU_FILLER_DATA: 		return 0;  	default: 		if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1; 		//To detect change of AU when multiple sps and pps in stream 		else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE) 			ret = 1; 		else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE) 			ret = 1; 		else 			ret = 0; 		break; 	}  	/* save _prev values */ 	if (ret && avc->s_info.sps) { 		n_state.frame_num_offset_prev = avc->s_info.frame_num_offset; 		if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0)) 			n_state.frame_num_prev = avc->s_info.frame_num; 		if (avc->s_info.nal_ref_idc) { 			n_state.poc_lsb_prev = avc->s_info.poc_lsb; 			n_state.poc_msb_prev = avc->s_info.poc_msb; 		} 	} 	if (slice) 		avc_compute_poc(&n_state); 	memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo)); 	return ret; }"
"195233_CWE-787.cc","CWE-787","  Status SetUnknownShape(const NodeDef* node, int output_port) {     shape_inference::ShapeHandle shape =         GetUnknownOutputShape(node, output_port);     InferenceContext* ctx = GetContext(node);     if (ctx == nullptr) {       return errors::InvalidArgument(""Missing context"");     }     ctx->set_output(output_port, shape);     return Status::OK();   }"
"195234_CWE-617.cc","CWE-617","  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,                             const FunctionDef::ArgAttrs* arg_attrs,                             bool ints_on_device,                             int64_t resource_arg_unique_id) {     bool is_type_list;     DataTypeVector dtypes;     TF_RETURN_IF_ERROR(         ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));     if (dtypes.size() < size_t{1}) {       return errors::Internal(""Expected a list of at least one dtype"");     }     int arg_index = result_.nodes.size();     TF_RETURN_IF_ERROR(         AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));     // Creates dtypes.size() nodes in the graph.     for (size_t i = 0; i < dtypes.size(); ++i) {       TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), "":"", i),                                  {true, arg_index, 0, false, {dtypes[i]}}));       DCHECK_EQ(arg_index, result_.nodes.size());       string name = arg_def.name();       if (dtypes.size() > 1) {         strings::StrAppend(&name, ""_"", i);       }       NodeDef* gnode = AddNode(name);       if (ints_on_device && dtypes[i] == DataType::DT_INT32) {         gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);       } else {         gnode->set_op(FunctionLibraryDefinition::kArgOp);       }       DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];       AddAttr(""T"", dtype, gnode);       AddAttr(""index"", arg_index, gnode);       if (resource_arg_unique_id >= 0) {         AddAttr(""_resource_arg_unique_id"", resource_arg_unique_id, gnode);       }       if (arg_attrs) {         for (const auto& arg_attr : arg_attrs->attr()) {           AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());         }       }       result_.arg_types.push_back(dtypes[i]);       ++arg_index;     }     return Status::OK();   }"
"195237_CWE-190.c","CWE-190","static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define CropBox  ""CropBox"" #define DeviceCMYK  ""DeviceCMYK"" #define MediaBox  ""MediaBox"" #define RenderPCLText  ""  Rendering PCL...  ""    char     command[MagickPathExtent],     *density,     filename[MagickPathExtent],     geometry[MagickPathExtent],     *options,     input_filename[MagickPathExtent];    const DelegateInfo     *delegate_info;    Image     *image,     *next_image;    ImageInfo     *read_info;    MagickBooleanType     cmyk,     status;    PointInfo     delta;    RectangleInfo     bounding_box,     page;    char     *p;    ssize_t     c;    SegmentInfo     bounds;    size_t     height,     width;    ssize_t     count;    assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   /*     Open image file.   */   image=AcquireImage(image_info,exception);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);   if (status == MagickFalse)     {       ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",         image_info->filename);       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Set the page density.   */   delta.x=DefaultResolution;   delta.y=DefaultResolution;   if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))     {       GeometryInfo         geometry_info;        MagickStatusType         flags;        flags=ParseGeometry(PSDensityGeometry,&geometry_info);       if ((flags & RhoValue) != 0)         image->resolution.x=geometry_info.rho;       image->resolution.y=image->resolution.x;       if ((flags & SigmaValue) != 0)         image->resolution.y=geometry_info.sigma;     }   /*     Determine page geometry from the PCL media box.   */   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;   count=0;   (void) memset(&bounding_box,0,sizeof(bounding_box));   (void) memset(&bounds,0,sizeof(bounds));   (void) memset(&page,0,sizeof(page));   (void) memset(command,0,sizeof(command));   p=command;   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))   {     if (image_info->page != (char *) NULL)       continue;     /*       Note PCL elements.     */     *p++=(char) c;     if ((c != (int) '/') && (c != '\n') &&         ((size_t) (p-command) < (MagickPathExtent-1)))       continue;     *p='\0';     p=command;     /*       Is this a CMYK document?     */     if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)       cmyk=MagickTrue;     if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)       {         /*           Note region defined by crop box.         */         count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);         if (count != 4)           count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);       }     if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)       {         /*           Note region defined by media box.         */         count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);         if (count != 4)           count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);       }     if (count != 4)       continue;     /*       Set PCL render geometry.     */     width=(size_t) floor(bounds.x2-bounds.x1+0.5);     height=(size_t) floor(bounds.y2-bounds.y1+0.5);     if (width > page.width)       page.width=width;     if (height > page.height)       page.height=height;   }   (void) CloseBlob(image);   /*     Render PCL with the GhostPCL delegate.   */   if ((page.width == 0) || (page.height == 0))     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);   if (image_info->page != (char *) NULL)     (void) ParseAbsoluteGeometry(image_info->page,&page);   (void) FormatLocaleString(geometry,MagickPathExtent,""%.20gx%.20g"",(double)     page.width,(double) page.height);   if (image_info->monochrome != MagickFalse)     delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);   else      if (cmyk != MagickFalse)        delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);      else        delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);   if (delegate_info == (const DelegateInfo *) NULL)     {       image=DestroyImage(image);       return((Image *) NULL);     }   if ((page.width == 0) || (page.height == 0))     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);   if (image_info->page != (char *) NULL)     (void) ParseAbsoluteGeometry(image_info->page,&page);   density=AcquireString("""");   options=AcquireString("""");   (void) FormatLocaleString(density,MagickPathExtent,""%gx%g"",     image->resolution.x,image->resolution.y);   if (image_info->ping != MagickFalse)     (void) FormatLocaleString(density,MagickPathExtent,""2.0x2.0"");   page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);   page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);   (void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)     page.width,(double) page.height);   image=DestroyImage(image);   read_info=CloneImageInfo(image_info);   *read_info->magick='\0';   if (read_info->number_scenes != 0)     {       if (read_info->number_scenes != 1)         (void) FormatLocaleString(options,MagickPathExtent,""-dLastPage=%.20g"",           (double) (read_info->scene+read_info->number_scenes));       else         (void) FormatLocaleString(options,MagickPathExtent,           ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,           (double) (read_info->scene+read_info->number_scenes));       read_info->number_scenes=0;       if (read_info->scenes != (char *) NULL)         *read_info->scenes='\0';     }   (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);   (void) AcquireUniqueFilename(read_info->filename);   (void) FormatLocaleString(command,MagickPathExtent,     GetDelegateCommands(delegate_info),     read_info->antialias != MagickFalse ? 4 : 1,     read_info->antialias != MagickFalse ? 4 : 1,density,options,     read_info->filename,input_filename);   options=DestroyString(options);   density=DestroyString(density);   status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,     (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;   image=ReadImage(read_info,exception);   (void) RelinquishUniqueFileResource(read_info->filename);   (void) RelinquishUniqueFileResource(input_filename);   read_info=DestroyImageInfo(read_info);   if (image == (Image *) NULL)     ThrowReaderException(DelegateError,""PCLDelegateFailed"");   if (LocaleCompare(image->magick,""BMP"") == 0)     {       Image         *cmyk_image;        cmyk_image=ConsolidateCMYKImages(image,exception);       if (cmyk_image != (Image *) NULL)         {           image=DestroyImageList(image);           image=cmyk_image;         }     }   do   {     (void) CopyMagickString(image->filename,filename,MagickPathExtent);     image->page=page;     if (image_info->ping != MagickFalse)       {         image->magick_columns*=image->resolution.x/2.0;         image->magick_rows*=image->resolution.y/2.0;         image->columns*=image->resolution.x/2.0;         image->rows*=image->resolution.y/2.0;       }     next_image=SyncNextImageInList(image);     if (next_image != (Image *) NULL)       image=next_image;   } while (next_image != (Image *) NULL);   return(GetFirstImageInList(image)); }"
"195238_CWE-20.c","CWE-20","setup_seccomp (FlatpakBwrap   *bwrap,                const char     *arch,                gulong          allowed_personality,                FlatpakRunFlags run_flags,                GError        **error) {   gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;   gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;    __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;    /**** BEGIN NOTE ON CODE SHARING    *    * There are today a number of different Linux container    * implementations.  That will likely continue for long into the    * future.  But we can still try to share code, and it's important    * to do so because it affects what library and application writers    * can do, and we should support code portability between different    * container tools.    *    * This syscall blocklist is copied from linux-user-chroot, which was in turn    * clearly influenced by the Sandstorm.io blocklist.    *    * If you make any changes here, I suggest sending the changes along    * to other sandbox maintainers.  Using the libseccomp list is also    * an appropriate venue:    * https://groups.google.com/forum/#!forum/libseccomp    *    * A non-exhaustive list of links to container tooling that might    * want to share this blocklist:    *    *  https://github.com/sandstorm-io/sandstorm    *    in src/sandstorm/supervisor.c++    *  https://github.com/flatpak/flatpak.git    *    in common/flatpak-run.c    *  https://git.gnome.org/browse/linux-user-chroot    *    in src/setup-seccomp.c    *    **** END NOTE ON CODE SHARING    */   struct   {     int                  scall;     struct scmp_arg_cmp *arg;   } syscall_blocklist[] = {     /* Block dmesg */     {SCMP_SYS (syslog)},     /* Useless old syscall */     {SCMP_SYS (uselib)},     /* Don't allow disabling accounting */     {SCMP_SYS (acct)},     /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a        historic source of interesting information leaks. */     {SCMP_SYS (modify_ldt)},     /* Don't allow reading current quota use */     {SCMP_SYS (quotactl)},      /* Don't allow access to the kernel keyring */     {SCMP_SYS (add_key)},     {SCMP_SYS (keyctl)},     {SCMP_SYS (request_key)},      /* Scary VM/NUMA ops */     {SCMP_SYS (move_pages)},     {SCMP_SYS (mbind)},     {SCMP_SYS (get_mempolicy)},     {SCMP_SYS (set_mempolicy)},     {SCMP_SYS (migrate_pages)},      /* Don't allow subnamespace setups: */     {SCMP_SYS (unshare)},     {SCMP_SYS (mount)},     {SCMP_SYS (pivot_root)}, #if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)     /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack      * and flags arguments are reversed so the flags come second */     {SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #else     /* Normally the flags come first */     {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #endif      /* Don't allow faking input to the controlling tty (CVE-2017-5226) */     {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},   };    struct   {     int                  scall;     struct scmp_arg_cmp *arg;   } syscall_nondevel_blocklist[] = {     /* Profiling operations; we expect these to be done by tools from outside      * the sandbox.  In particular perf has been the source of many CVEs.      */     {SCMP_SYS (perf_event_open)},     /* Don't allow you to switch to bsd emulation or whatnot */     {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},     {SCMP_SYS (ptrace)}   };   /* Blocklist all but unix, inet, inet6 and netlink */   struct   {     int             family;     FlatpakRunFlags flags_mask;   } socket_family_allowlist[] = {     /* NOTE: Keep in numerical order */     { AF_UNSPEC, 0 },     { AF_LOCAL, 0 },     { AF_INET, 0 },     { AF_INET6, 0 },     { AF_NETLINK, 0 },     { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },     { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },   };   int last_allowed_family;   int i, r;   g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };    seccomp = seccomp_init (SCMP_ACT_ALLOW);   if (!seccomp)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Initialize seccomp failed""));    if (arch != NULL)     {       uint32_t arch_id = 0;       const uint32_t *extra_arches = NULL;        if (strcmp (arch, ""i386"") == 0)         {           arch_id = SCMP_ARCH_X86;         }       else if (strcmp (arch, ""x86_64"") == 0)         {           arch_id = SCMP_ARCH_X86_64;           extra_arches = seccomp_x86_64_extra_arches;         }       else if (strcmp (arch, ""arm"") == 0)         {           arch_id = SCMP_ARCH_ARM;         } #ifdef SCMP_ARCH_AARCH64       else if (strcmp (arch, ""aarch64"") == 0)         {           arch_id = SCMP_ARCH_AARCH64;           extra_arches = seccomp_aarch64_extra_arches;         } #endif        /* We only really need to handle arches on multiarch systems.        * If only one arch is supported the default is fine */       if (arch_id != 0)         {           /* This *adds* the target arch, instead of replacing the              native one. This is not ideal, because we'd like to only              allow the target arch, but we can't really disallow the              native arch at this point, because then bubblewrap              couldn't continue running. */           r = seccomp_arch_add (seccomp, arch_id);           if (r < 0 && r != -EEXIST)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add architecture to seccomp filter""));            if (multiarch && extra_arches != NULL)             {               for (i = 0; extra_arches[i] != 0; i++)                 {                   r = seccomp_arch_add (seccomp, extra_arches[i]);                   if (r < 0 && r != -EEXIST)                     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add multiarch architecture to seccomp filter""));                 }             }         }     }    /* TODO: Should we filter the kernel keyring syscalls in some way?    * We do want them to be used by desktop apps, but they could also perhaps    * leak system stuff or secrets from other apps.    */    for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)     {       int scall = syscall_blocklist[i].scall;       if (syscall_blocklist[i].arg)         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);       else         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);       if (r < 0 && r == -EFAULT /* unknown syscall */)         return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);     }    if (!devel)     {       for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)         {           int scall = syscall_nondevel_blocklist[i].scall;           if (syscall_nondevel_blocklist[i].arg)             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);           else             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);            if (r < 0 && r == -EFAULT /* unknown syscall */)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);         }     }    /* Socket filtering doesn't work on e.g. i386, so ignore failures here    * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing    * something else: https://github.com/seccomp/libseccomp/issues/8 */   last_allowed_family = -1;   for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)     {       int family = socket_family_allowlist[i].family;       int disallowed;        if (socket_family_allowlist[i].flags_mask != 0 &&           (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)         continue;        for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)         {           /* Blocklist the in-between valid families */           seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));         }       last_allowed_family = family;     }   /* Blocklist the rest */   seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));    if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, ""/tmp"", &seccomp_tmpf, error))     return FALSE;    if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to export bpf""));    lseek (seccomp_tmpf.fd, 0, SEEK_SET);    flatpak_bwrap_add_args_data_fd (bwrap,                                   ""--seccomp"", glnx_steal_fd (&seccomp_tmpf.fd), NULL);    return TRUE; }"
"195242_CWE-190.cc","CWE-190","  void Compute(OpKernelContext *ctx) override {     const Tensor *indices_t, *values_t, *shape_t, *dense_t;     OP_REQUIRES_OK(ctx, ctx->input(""sp_indices"", &indices_t));     OP_REQUIRES_OK(ctx, ctx->input(""sp_values"", &values_t));     OP_REQUIRES_OK(ctx, ctx->input(""sp_shape"", &shape_t));     OP_REQUIRES_OK(ctx, ctx->input(""dense"", &dense_t));      // Validations.     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),                 errors::InvalidArgument(                     ""Input sp_indices should be a matrix but received shape: "",                     indices_t->shape().DebugString()));     OP_REQUIRES(ctx,                 TensorShapeUtils::IsVector(values_t->shape()) &&                     TensorShapeUtils::IsVector(shape_t->shape()),                 errors::InvalidArgument(                     ""Inputs sp_values and sp_shape should be vectors ""                     ""but received shapes: "",                     values_t->shape().DebugString(), "" and "",                     shape_t->shape().DebugString()));     OP_REQUIRES(         ctx, values_t->dim_size(0) == indices_t->dim_size(0),         errors::InvalidArgument(             ""The first dimension of values and indices should match. ("",             values_t->dim_size(0), "" vs. "", indices_t->dim_size(0), "")""));      const auto indices_mat = indices_t->matrix<int64_t>();     const auto shape_vec = shape_t->vec<int64_t>();     const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));     const auto rhs_dims = BCast::FromShape(dense_t->shape());     BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.      // True iff (size(lhs) >= size(rhs)) and all dims in lhs is greater or equal     // to dims in rhs (from right to left).     auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {       if (lhs.size() < rhs.size()) return false;       for (size_t i = 0; i < rhs.size(); ++i) {         if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;       }       return true;     };     OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),                 errors::InvalidArgument(                     ""SparseDenseBinaryOpShared broadcasts dense to sparse ""                     ""only; got incompatible shapes: ["",                     absl::StrJoin(lhs_dims, "",""), ""] vs. ["",                     absl::StrJoin(rhs_dims, "",""), ""]""));      Tensor *output_values = nullptr;     Tensor dense_gathered;     const int64_t nnz = indices_t->dim_size(0);     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(0, TensorShape({nnz}), &output_values));     OP_REQUIRES_OK(         ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),                                 &dense_gathered));     bool op_is_div = false;     if (absl::StrContains(ctx->op_kernel().type_string_view(), ""Div"")) {       op_is_div = true;     }     // Pulls relevant entries from the dense side, with reshape and broadcasting     // *of the dense side* taken into account.  Use a TensorRef to avoid blowing     // up memory.     //     // We can directly use the sparse indices to look up dense side, because     // ""b.y_reshape()"" and ""b.y_bcast()"" are guaranteed to have rank ""ndims"".     auto dense_gathered_flat = dense_gathered.flat<T>();     const int ndims = lhs_dims.size();     switch (ndims) { #define CASE(NDIM)                                                             \   case NDIM: {                                                                 \     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \         dense_t->shaped<T, NDIM>(b.y_reshape())                                \             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \     bool indices_valid = true;                                                 \     for (int i = 0; i < nnz; ++i) {                                            \       for (int d = 0; d < NDIM; ++d) {                                         \         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \           indices_valid = false;                                               \         }                                                                      \       }                                                                        \       OP_REQUIRES(                                                             \           ctx, indices_valid,                                                  \           errors::InvalidArgument(""Provided indices are out-of-bounds w.r.t. "" \                                   ""dense side with broadcasted shape""));       \       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \       if (op_is_div) {                                                         \         OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \                     errors::InvalidArgument(                                   \                         ""SparseDenseCwiseDiv cannot divide by zero,""           \                         ""but input dense tensor contains zero ""));             \       }                                                                        \     }                                                                          \     break;                                                                     \   }        CASE(1);       CASE(2);       CASE(3);       CASE(4);       CASE(5);       default:         OP_REQUIRES(             ctx, false,             errors::InvalidArgument(""Only tensors with ranks between 1 and 5 ""                                     ""are currently supported.  Tensor rank: "",                                     ndims)); #undef CASE     }      output_values->flat<T>().device(ctx->eigen_device<Device>()) =         values_t->flat<T>().binaryExpr(dense_gathered_flat,                                        typename Functor::func());   }"
"195246_CWE-476.c","CWE-476","static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si) { 	s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;  	/*s->current_picture.reference= h->nal_ref_idc != 0;*/ 	gf_bs_read_ue_log(bs, ""first_mb_in_slice""); 	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); 	if (si->slice_type > 9) return -1;  	pps_id = gf_bs_read_ue_log(bs, ""pps_id""); 	if (pps_id > 255) return -1; 	si->pps = &avc->pps[pps_id]; 	if (!si->pps->slice_group_count) return -2; 	si->sps = &avc->sps[si->pps->sps_id]; 	if (!si->sps->log2_max_frame_num) return -2; 	avc->sps_active_idx = si->pps->sps_id; 	avc->pps_active_idx = pps_id;  	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");  	si->field_pic_flag = 0; 	si->bottom_field_flag = 0; 	if (!si->sps->frame_mbs_only_flag) { 		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); 		if (si->field_pic_flag) 			si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); 	}  	if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag) 		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");  	if (si->sps->poc_type == 0) { 		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); 		if (si->pps->pic_order_present && !si->field_pic_flag) { 			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb""); 		} 	} 	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { 		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); 		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) 			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); 	}  	if (si->pps->redundant_pic_cnt_present) { 		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); 	}  	if (si->slice_type % 5 == GF_AVC_TYPE_B) { 		gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag""); 	}  	num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1; 	num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;  	if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) { 		Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag""); 		if (num_ref_idx_active_override_flag) { 			num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1""); 			if (si->slice_type % 5 == GF_AVC_TYPE_B) { 				num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1""); 			} 		} 	}  	if (si->nal_unit_type == 20 || si->nal_unit_type == 21) { 		//ref_pic_list_mvc_modification(); /* specified in Annex H */ 		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n"")); 		assert(0); 		return -1; 	} 	else { 		ref_pic_list_modification(bs, si->slice_type); 	}  	if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP)) 		|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) { 		pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1); 	}  	if (si->nal_ref_idc != 0) { 		dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE)); 	}  	if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) { 		gf_bs_read_ue_log(bs, ""cabac_init_idc""); 	}  	/*slice_qp_delta = */gf_bs_read_se(bs); 	if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) { 		if (si->slice_type % 5 == GF_AVC_TYPE_SP) { 			gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag""); 		} 		gf_bs_read_se_log(bs, ""slice_qs_delta""); 	}  	if (si->pps->deblocking_filter_control_present_flag) { 		if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) { 			gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2""); 			gf_bs_read_se_log(bs, ""slice_beta_offset_div2""); 		} 	}  	if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) { 		gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle""); 	} 	return 0; }"
"195261_CWE-754.cc","CWE-754","Node* Graph::AddNode(NodeDef node_def, Status* status) {   const OpRegistrationData* op_reg_data;   status->Update(ops_.LookUp(node_def.op(), &op_reg_data));   if (!status->ok()) return nullptr;    DataTypeVector inputs;   DataTypeVector outputs;   status->Update(       InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));   if (!status->ok()) {     *status = AttachDef(*status, node_def);     return nullptr;   }    Node::NodeClass node_class = op_reg_data->is_function_op                                    ? Node::NC_FUNCTION_OP                                    : Node::GetNodeClassForOp(node_def.op());    if (op_reg_data->type_ctor != nullptr) {     VLOG(3) << ""AddNode: found type constructor for "" << node_def.name();     const auto ctor_type =         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();     if (ctor_typedef.type_id() != TFT_UNSET) {       *(node_def.mutable_experimental_type()) = ctor_typedef;     }   } else {     VLOG(3) << ""AddNode: no type constructor for "" << node_def.name();   }    Node* node = AllocateNode(std::make_shared<NodeProperties>(                                 &op_reg_data->op_def, std::move(node_def),                                 inputs, outputs, op_reg_data->fwd_type_fn),                             nullptr, node_class);   return node; }"
"195264_CWE-125.c","CWE-125","static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks) { DEFINE_COMPILER; jump_list *found = NULL; jump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks; sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX; struct sljit_jump *jump = NULL; PCRE2_SPTR ccbegin; int compares, invertcmp, numberofcmps; #if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16) BOOL utf = common->utf; #endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */  #ifdef SUPPORT_UNICODE sljit_u32 unicode_status = 0; int typereg = TMP1; const sljit_u32 *other_cases; sljit_uw typeoffset; #endif /* SUPPORT_UNICODE */  /* Scanning the necessary info. */ cc++; ccbegin = cc; compares = 0;  if (cc[-1] & XCL_MAP)   {   min = 0;   cc += 32 / sizeof(PCRE2_UCHAR);   }  while (*cc != XCL_END)   {   compares++;   if (*cc == XCL_SINGLE)     {     cc ++;     GETCHARINCTEST(c, cc);     if (c > max) max = c;     if (c < min) min = c; #ifdef SUPPORT_UNICODE     unicode_status |= XCLASS_SAVE_CHAR; #endif /* SUPPORT_UNICODE */     }   else if (*cc == XCL_RANGE)     {     cc ++;     GETCHARINCTEST(c, cc);     if (c < min) min = c;     GETCHARINCTEST(c, cc);     if (c > max) max = c; #ifdef SUPPORT_UNICODE     unicode_status |= XCLASS_SAVE_CHAR; #endif /* SUPPORT_UNICODE */     } #ifdef SUPPORT_UNICODE   else     {     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);     cc++;     if (*cc == PT_CLIST && *cc == XCL_PROP)       {       other_cases = PRIV(ucd_caseless_sets) + cc[1];       while (*other_cases != NOTACHAR)         {         if (*other_cases > max) max = *other_cases;         if (*other_cases < min) min = *other_cases;         other_cases++;         }       }     else       {       max = READ_CHAR_MAX;       min = 0;       }      switch(*cc)       {       case PT_ANY:       /* Any either accepts everything or ignored. */       if (cc[-1] == XCL_PROP)         {         compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);         if (list == backtracks)           add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));         return;         }       break;        case PT_LAMP:       case PT_GC:       case PT_PC:       case PT_ALNUM:       unicode_status |= XCLASS_HAS_TYPE;       break;        case PT_SCX:       unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;       if (cc[-1] == XCL_NOTPROP)         {         unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;         break;         }       compares++;       /* Fall through */         case PT_SC:       unicode_status |= XCLASS_HAS_SCRIPT;       break;        case PT_SPACE:       case PT_PXSPACE:       case PT_WORD:       case PT_PXGRAPH:       case PT_PXPRINT:       case PT_PXPUNCT:       unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;       break;        case PT_CLIST:       case PT_UCNC:       unicode_status |= XCLASS_SAVE_CHAR;       break;        case PT_BOOL:       unicode_status |= XCLASS_HAS_BOOL;       break;        case PT_BIDICL:       unicode_status |= XCLASS_HAS_BIDICL;       break;        default:       SLJIT_UNREACHABLE();       break;       }     cc += 2;     } #endif /* SUPPORT_UNICODE */   } SLJIT_ASSERT(compares > 0);  /* We are not necessary in utf mode even in 8 bit mode. */ cc = ccbegin; if ((cc[-1] & XCL_NOT) != 0)   read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR); else   { #ifdef SUPPORT_UNICODE   read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0); #else /* !SUPPORT_UNICODE */   read_char(common, min, max, NULL, 0); #endif /* SUPPORT_UNICODE */   }  if ((cc[-1] & XCL_HASPROP) == 0)   {   if ((cc[-1] & XCL_MAP) != 0)     {     jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);     if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))       {       OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);       OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);       OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);       OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);       OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);       add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));       }      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));     JUMPHERE(jump);      cc += 32 / sizeof(PCRE2_UCHAR);     }   else     {     OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);     add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));     }   } else if ((cc[-1] & XCL_MAP) != 0)   {   OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0); #ifdef SUPPORT_UNICODE   unicode_status |= XCLASS_CHAR_SAVED; #endif /* SUPPORT_UNICODE */   if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))     { #if PCRE2_CODE_UNIT_WIDTH == 8     jump = NULL;     if (common->utf) #endif /* PCRE2_CODE_UNIT_WIDTH == 8 */       jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);     OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);     OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);     add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));  #if PCRE2_CODE_UNIT_WIDTH == 8     if (common->utf) #endif /* PCRE2_CODE_UNIT_WIDTH == 8 */       JUMPHERE(jump);     }    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);   cc += 32 / sizeof(PCRE2_UCHAR);   }  #ifdef SUPPORT_UNICODE if (unicode_status & XCLASS_NEEDS_UCD)   {   if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)     OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);  #if PCRE2_CODE_UNIT_WIDTH == 32   if (!common->utf)     {     jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);     OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);     JUMPHERE(jump);     } #endif /* PCRE2_CODE_UNIT_WIDTH == 32 */    OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));   OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);   OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);   OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);   OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);   OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);    ccbegin = cc;    if (unicode_status & XCLASS_HAS_BIDICL)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_BIDICL)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;           jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);           add_jump(compiler, compares > 0 ? list : backtracks, jump);           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_BOOL)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_BOOL)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;            OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_SCRIPT)     {     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         switch (*cc)           {           case PT_SCX:           if (cc[-1] == XCL_NOTPROP)             break;           /* Fall through */             case PT_SC:           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;            add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);      if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)       {       if (unicode_status & XCLASS_HAS_TYPE)         {         if (unicode_status & XCLASS_SAVE_CHAR)           {           OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;           }         else           {           OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;           }         }       OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));       }      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_SCX)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);            jump = NULL;           if (cc[-1] == XCL_NOTPROP)             {             jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);             if (invertcmp)               {               add_jump(compiler, backtracks, jump);               jump = NULL;               }             invertcmp ^= 0x1;             }            OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));            if (jump != NULL)             JUMPHERE(jump);           }         cc += 2;         }       }      if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)       OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);     else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)       OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);     cc = ccbegin;     }    if (unicode_status & XCLASS_SAVE_CHAR)     OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);    if (unicode_status & XCLASS_HAS_TYPE)     {     if (unicode_status & XCLASS_SAVE_CHAR)       typereg = RETURN_ADDR;      OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));     }   } #endif /* SUPPORT_UNICODE */  /* Generating code. */ charoffset = 0; numberofcmps = 0; #ifdef SUPPORT_UNICODE typeoffset = 0; #endif /* SUPPORT_UNICODE */  while (*cc != XCL_END)   {   compares--;   invertcmp = (compares == 0 && list != backtracks);   jump = NULL;    if (*cc == XCL_SINGLE)     {     cc ++;     GETCHARINCTEST(c, cc);      if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))       {       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       numberofcmps++;       }     else if (numberofcmps > 0)       {       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       numberofcmps = 0;       }     else       {       jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       numberofcmps = 0;       }     }   else if (*cc == XCL_RANGE)     {     cc ++;     GETCHARINCTEST(c, cc);     SET_CHAR_OFFSET(c);     GETCHARINCTEST(c, cc);      if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))       {       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       numberofcmps++;       }     else if (numberofcmps > 0)       {       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       numberofcmps = 0;       }     else       {       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       numberofcmps = 0;       }     } #ifdef SUPPORT_UNICODE   else     {     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);     if (*cc == XCL_NOTPROP)       invertcmp ^= 0x1;     cc++;     switch(*cc)       {       case PT_ANY:       if (!invertcmp)         jump = JUMP(SLJIT_JUMP);       break;        case PT_LAMP:       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_GC:       c = PRIV(ucp_typerange)[(int)cc[1] * 2];       SET_TYPE_OFFSET(c);       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);       break;        case PT_PC:       jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);       break;        case PT_SC:       case PT_SCX:       case PT_BOOL:       case PT_BIDICL:       compares++;       /* Do nothing. */       break;        case PT_SPACE:       case PT_PXSPACE:       SET_CHAR_OFFSET(9);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        SET_TYPE_OFFSET(ucp_Zl);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_WORD:       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       /* Fall through. */        case PT_ALNUM:       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);       OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       SET_TYPE_OFFSET(ucp_Nd);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_CLIST:       other_cases = PRIV(ucd_caseless_sets) + cc[1];        /* At least three characters are required.          Otherwise this case would be handled by the normal code path. */       SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);       SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);        /* Optimizing character pairs, if their difference is power of 2. */       if (is_powerof2(other_cases[1] ^ other_cases[0]))         {         if (charoffset == 0)           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);         else           {           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);           }         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);         other_cases += 2;         }       else if (is_powerof2(other_cases[2] ^ other_cases[1]))         {         if (charoffset == 0)           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);         else           {           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);           }         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);          OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));         OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);          other_cases += 3;         }       else         {         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);         }        while (*other_cases != NOTACHAR)         {         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));         OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);         }       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_UCNC:       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        SET_CHAR_OFFSET(0xa0);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       SET_CHAR_OFFSET(0);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_PXGRAPH:       /* C and Z groups are the farthest two groups. */       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);        jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);        /* In case of ucp_Cf, we overwrite the result. */       SET_CHAR_OFFSET(0x2066);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        JUMPHERE(jump);       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);       break;        case PT_PXPRINT:       /* C and Z groups are the farthest two groups. */       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);        OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);        jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);        /* In case of ucp_Cf, we overwrite the result. */       SET_CHAR_OFFSET(0x2066);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        JUMPHERE(jump);       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);       break;        case PT_PXPUNCT:       SET_TYPE_OFFSET(ucp_Sc);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        SET_CHAR_OFFSET(0);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);        SET_TYPE_OFFSET(ucp_Pc);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        default:       SLJIT_UNREACHABLE();       break;       }     cc += 2;     } #endif /* SUPPORT_UNICODE */    if (jump != NULL)     add_jump(compiler, compares > 0 ? list : backtracks, jump);   }  if (found != NULL)   set_jumps(found, LABEL()); }"
"195274_CWE-476.cc","CWE-476","bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,                                       const GraphProperties& properties) {   // Push down multiplication on ConvND.   //                       *                  ConvND   //                     /   \                /    \   //                 ConvND  C2    -- >      X      *   //                  / \                          / \   //                 X  C1                       C1  C2   //   // where C1 and C2 are constants and X is non-constant.   //   // TODO(rmlarsen): Use PrepareConstantPushDown() to simplify this code.    if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;    NodeDef* mul_left_child = node_map_->GetNode(node->input(0));   NodeDef* mul_right_child = node_map_->GetNode(node->input(1));   // One child must be constant, and the second must be Conv op.   const bool left_child_is_constant = IsReallyConstant(*mul_left_child);   const bool right_child_is_constant = IsReallyConstant(*mul_right_child);   if (!left_child_is_constant && !right_child_is_constant) {     return false;   }   NodeDef* conv_node =       left_child_is_constant ? mul_right_child : mul_left_child;   if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {     return false;   }   if (node->device() != mul_left_child->device() ||       node->device() != mul_right_child->device()) {     return false;   }    // Make sure that it is safe to change the value of the convolution   // output.   if (conv_node->input_size() < 2 ||       NumNonControlOutputs(*conv_node, *node_map_) > 1 ||       nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {     return false;   }    // Identify the nodes to swap.   NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));   NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));   const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);   const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);   if (!conv_left_is_constant && !conv_right_is_constant) {     // At least one of the convolution inputs should be constant.     return false;   }   if (conv_left_is_constant && conv_right_is_constant) {     // Leverage regular constant folding to handle this.     return false;   }   const auto& mul_props = properties.GetOutputProperties(node->name());   const auto& conv_props = properties.GetOutputProperties(conv_node->name());   if (mul_props.empty() || conv_props.empty()) {     return false;   }   const auto& mul_shape = mul_props[0].shape();   const auto& conv_shape = conv_props[0].shape();   if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {     return false;   }    const auto& input_props = properties.GetInputProperties(conv_node->name());   if (input_props.size() < 2) {     return false;   }   const auto& filter_shape = input_props[1].shape();    NodeDef* const_node =       left_child_is_constant ? mul_left_child : mul_right_child;   const auto& const_props = properties.GetOutputProperties(const_node->name());   if (const_props.empty()) {     return false;   }   const auto& const_shape = const_props[0].shape();   if (!IsValidConstShapeForMulConvPushDown(           conv_node->attr().at(""data_format"").s(), filter_shape, const_shape)) {     return false;   }    string mul_new_name = AddPrefixToNodeName(""merged_input"", conv_node->name());   if (node_map_->NodeExists(mul_new_name)) {     return false;   }   // Make sure we don't introduce loops in the graph by removing control   // dependencies from the conv2d node to c2.   string conv_const_input =       conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);   if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,                               node_map_.get())) {     // Add a control dep from c1 to c2 to ensure c2 is in the right frame     MaybeAddControlInput(conv_const_input, const_node, optimized_graph,                          node_map_.get());   }    conv_node->set_name(node->name());   node->set_name(mul_new_name);   if (conv_left_is_constant) {     node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);     conv_node->set_input(0, mul_new_name);   } else {     node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);     conv_node->set_input(1, mul_new_name);   }   NodeDef* conv_const_node =       conv_left_is_constant ? conv_left_child : conv_right_child;   if (left_child_is_constant) {     node->set_input(1, conv_const_node->name());   } else {     node->set_input(0, conv_const_node->name());   }   node_map_->AddNode(mul_new_name, node);    return true; }"
"195289_CWE-787.cc","CWE-787","  void Compute(OpKernelContext* context) override {     const Tensor& indices = context->input(0);     const Tensor& values = context->input(1);     const Tensor& shape = context->input(2);     const Tensor& weights = context->input(3);     bool use_weights = weights.NumElements() > 0;      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),                 errors::InvalidArgument(                     ""Input indices must be a 2-dimensional tensor. Got: "",                     indices.shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),                 errors::InvalidArgument(""Input values must be a vector. Got: "",                                         values.shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),                 errors::InvalidArgument(""Input shape must be a vector. Got: "",                                         shape.shape().DebugString()));     OP_REQUIRES(context,                 values.shape().dim_size(0) == indices.shape().dim_size(0),                 errors::InvalidArgument(                     ""Number of values must match first dimension of indices."",                     ""Got "", values.shape().dim_size(0),                     "" values, indices shape: "", indices.shape().DebugString()));     OP_REQUIRES(         context, shape.shape().dim_size(0) == indices.shape().dim_size(1),         errors::InvalidArgument(             ""Number of dimensions must match second dimension of indices."",             ""Got "", shape.shape().dim_size(0),             "" dimensions, indices shape: "", indices.shape().DebugString()));     OP_REQUIRES(context, shape.NumElements() > 0,                 errors::InvalidArgument(                     ""The shape argument requires at least one element.""));      if (use_weights) {       OP_REQUIRES(           context, weights.shape() == values.shape(),           errors::InvalidArgument(               ""Weights and values must have the same shape. Weight shape: "",               weights.shape().DebugString(),               ""; values shape: "", values.shape().DebugString()));     }      bool is_1d = shape.NumElements() == 1;     auto shape_vector = shape.flat<int64_t>();     int num_batches = is_1d ? 1 : shape_vector(0);     int num_values = values.NumElements();      const auto indices_values = indices.matrix<int64_t>();     const auto values_values = values.flat<T>();     const auto weight_values = weights.flat<W>();      auto per_batch_counts = BatchedMap<W>(num_batches);      T max_value = 0;      for (int idx = 0; idx < num_values; ++idx) {       int batch = is_1d ? 0 : indices_values(idx, 0);       if (batch >= num_batches) {         OP_REQUIRES(context, batch < num_batches,                     errors::InvalidArgument(                         ""Indices value along the first dimension must be "",                         ""lower than the first index of the shape."", ""Got "",                         batch, "" as batch and "", num_batches,                         "" as the first dimension of the shape.""));       }       const auto& value = values_values(idx);       if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {         if (binary_output_) {           per_batch_counts[batch][value] = 1;         } else if (use_weights) {           per_batch_counts[batch][value] += weight_values(idx);         } else {           per_batch_counts[batch][value]++;         }         if (value > max_value) {           max_value = value;         }       }     }      int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,                                             is_1d, context));   }"
"195291_CWE-908.h","CWE-908","  void Compute(OpKernelContext* context) override {     const Tensor& rhs = context->input(1);      // We always return the input ref.     context->forward_ref_input_to_ref_output(0, 0);      // We can't always know how this value will be used downstream, so make     // conservative assumptions in specifying constraints on the memory     // allocation attributes, unless the Grappler graph analysis determined that     // it was safe not to.     AllocatorAttributes attr;     if (!relax_constraints_) {       attr.set_gpu_compatible(true);       attr.set_nic_compatible(true);     }      {       mutex_lock l(*context->input_ref_mutex(0));       const Tensor& old_lhs = context->mutable_input(0, /* lock_held */ true);       const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());       if (validate_shape_) {         OP_REQUIRES(context, same_shape,                     errors::InvalidArgument(                         ""Assign requires shapes of both tensors to match. ""                         ""lhs shape= "",                         old_lhs.shape().DebugString(),                         "" rhs shape= "", rhs.shape().DebugString()));       }        // In the code below we try to minimize the amount of memory allocation       // and copying by trying the following two shortcuts:       // 1. If the lhs is initialized and has the same number of elements as       //    the rhs we can avoid a memory allocation.       // 2. If we can reuse the rhs buffer we avoid both a memory allocation       //    and copying.        // 1. Try to copy into an existing buffer.       if (old_lhs.IsInitialized() &&           old_lhs.shape().num_elements() == rhs.shape().num_elements()) {         // The existing lhs tensor has already been initialized and the right         // hand side can fit in the underlying buffer.         Tensor reshaped_old_lhs;         if (same_shape) {           reshaped_old_lhs = old_lhs;         } else {           CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));           context->replace_ref_input(0, reshaped_old_lhs,                                      /* lock_held */ true);         }         if (use_exclusive_lock_) {           Copy(context, &reshaped_old_lhs, rhs);           return;         }       } else {         // 2. Try to reuse the rhs.         std::unique_ptr<Tensor> input_alias = context->forward_input(             1, OpKernelContext::Params::kNoReservation /*output_index*/,             rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);         if (input_alias != nullptr) {           // Update the ref to point to the new buffer.           context->replace_ref_input(0, *input_alias, /* lock_held */ true);           return;         }          // Otherwise, create a new tensor whose shape matches the         // right hand side, hand off to lhs and copy the rhs into it.         Tensor copy_tensor;         OP_REQUIRES_OK(context,                        context->allocate_temp(old_lhs.dtype(), rhs.shape(),                                               &copy_tensor, attr));         // We track memory of variables in variable ops instead of in this         // assign op.         context->clear_recorded_memory();         context->replace_ref_input(0, copy_tensor, /* lock_held */ true);         if (use_exclusive_lock_) {           Copy(context, &copy_tensor, rhs);           return;         }       }     }      // The tensor has already been initialized and the right hand side     // matches the left hand side's shape. We have been told to do the     // copy outside the lock.     Tensor old_unlocked_lhs = context->mutable_input(0, /* lock_held */ false);     Copy(context, &old_unlocked_lhs, rhs);   }"
"195293_CWE-476.c","CWE-476","gen_hash(codegen_scope *s, node *tree, int val, int limit) {   int slimit = GEN_VAL_STACK_MAX;   if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;   int len = 0;   mrb_bool update = FALSE;    while (tree) {     if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {       if (len > 0) {         pop_n(len*2);         if (!update) {           genop_2(s, OP_HASH, cursp(), len);         }         else {           pop();           genop_2(s, OP_HASHADD, cursp(), len);         }         push();       }       codegen(s, tree->car->cdr, val);       if (len > 0 || update) {         pop(); pop();         genop_1(s, OP_HASHCAT, cursp());         push();       }       update = TRUE;       len = 0;     }     else {       codegen(s, tree->car->car, val);       codegen(s, tree->car->cdr, val);       len++;     }     tree = tree->cdr;     if (val && cursp() >= slimit) {       pop_n(len*2);       if (!update) {         genop_2(s, OP_HASH, cursp(), len);       }       else {         pop();         genop_2(s, OP_HASHADD, cursp(), len);       }       push();       update = TRUE;       len = 0;     }   }   if (update) {     if (val && len > 0) {       pop_n(len*2+1);       genop_2(s, OP_HASHADD, cursp(), len);       push();     }     return -1;                  /* variable length */   }   return len; }"
"195294_CWE-843.cc","CWE-843","  void Compute(OpKernelContext* ctx) override {     StagingMap<Ordered>* map = nullptr;     OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));     core::ScopedUnref scope(map);     typename StagingMap<Ordered>::OptionalTuple tuple;      const Tensor* key_tensor;     const Tensor* indices_tensor;     OpInputList values_tensor;      OP_REQUIRES_OK(ctx, ctx->input(""key"", &key_tensor));     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices_tensor));     OP_REQUIRES_OK(ctx, ctx->input_list(""values"", &values_tensor));     OP_REQUIRES(ctx, key_tensor->NumElements() > 0,                 errors::InvalidArgument(""key must not be empty""));      // Create copy for insertion into Staging Area     Tensor key(*key_tensor);      // Create the tuple to store     for (std::size_t i = 0; i < values_tensor.size(); ++i) {       tuple.push_back(values_tensor[i]);     }      // Store the tuple in the map     OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));   }"
"195295_CWE-125.c","CWE-125","gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) {   int idx;   int type = nint(tree->car);    switch (type) {   case NODE_GVAR:   case NODE_ARG:   case NODE_LVAR:   case NODE_IVAR:   case NODE_CVAR:   case NODE_CONST:   case NODE_NIL:   case NODE_MASGN:     if (rhs) {       codegen(s, rhs, VAL);       pop();       sp = cursp();     }     break;    case NODE_COLON2:   case NODE_CALL:   case NODE_SCALL:     /* keep evaluation order */     break;    case NODE_NVAR:     codegen_error(s, ""Can't assign to numbered parameter"");     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }    tree = tree->cdr;   switch (type) {   case NODE_GVAR:     gen_setxv(s, OP_SETGV, sp, nsym(tree), val);     break;   case NODE_ARG:   case NODE_LVAR:     idx = lv_idx(s, nsym(tree));     if (idx > 0) {       if (idx != sp) {         gen_move(s, idx, sp, val);       }       break;     }     else {                      /* upvar */       gen_setupvar(s, sp, nsym(tree));     }     break;   case NODE_IVAR:     gen_setxv(s, OP_SETIV, sp, nsym(tree), val);     break;   case NODE_CVAR:     gen_setxv(s, OP_SETCV, sp, nsym(tree), val);     break;   case NODE_CONST:     gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);     break;   case NODE_COLON2:     if (sp) {       gen_move(s, cursp(), sp, 0);     }     sp = cursp();     push();     codegen(s, tree->car, VAL);     if (rhs) {       codegen(s, rhs, VAL); pop();       gen_move(s, sp, cursp(), 0);     }     pop_n(2);     idx = new_sym(s, nsym(tree->cdr));     genop_2(s, OP_SETMCNST, sp, idx);     break;    case NODE_CALL:   case NODE_SCALL:     {       int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;       mrb_sym mid = nsym(tree->cdr->car);        top = cursp();       if (val || sp == cursp()) {         push();                   /* room for retval */       }       call = cursp();       if (!tree->car) {         noself = 1;         push();       }       else {         codegen(s, tree->car, VAL); /* receiver */       }       if (safe) {         int recv = cursp()-1;         gen_move(s, cursp(), recv, 1);         skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);       }       tree = tree->cdr->cdr->car;       if (tree) {         if (tree->car) {            /* positional arguments */           n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);           if (n < 0) {              /* variable length */             n = 15;             push();           }         }         if (tree->cdr->car) {       /* keyword arguments */           if (n == 14) {             pop_n(n);             genop_2(s, OP_ARRAY, cursp(), n);             push();             n = 15;           }           gen_hash(s, tree->cdr->car->cdr, VAL, 0);           if (n < 14) {             n++;           }           else {             pop_n(2);             genop_2(s, OP_ARYPUSH, cursp(), 1);           }           push();         }       }       if (rhs) {         codegen(s, rhs, VAL);         pop();       }       else {         gen_move(s, cursp(), sp, 0);       }       if (val) {         gen_move(s, top, cursp(), 1);       }       if (n < 15) {         n++;         if (n == 15) {           pop_n(14);           genop_2(s, OP_ARRAY, cursp(), 15);         }       }       else {         pop();         genop_2(s, OP_ARYPUSH, cursp(), 1);       }       s->sp = call;       if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {         genop_1(s, OP_SETIDX, cursp());       }       else {         genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);       }       if (safe) {         dispatch(s, skip);       }       s->sp = top;     }     break;    case NODE_MASGN:     gen_massignment(s, tree->car, sp, val);     break;    /* splat without assignment */   case NODE_NIL:     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }   if (val) push(); }"
"195296_CWE-787.h","CWE-787","    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {         /* If we already have 64 triggered topics make sure to drain it here */         if (numTriggeredTopics == 64) {             drain();         }          /* Iterate over all segments in given topic */         for (; stop != std::string::npos; start = stop + 1) {             stop = topic.find('/', start);             std::string_view segment = topic.substr(start, stop - start);              /* It is very important to disallow wildcards when publishing.              * We will not catch EVERY misuse this lazy way, but enough to hinder              * explosive recursion.              * Terminating wildcards MAY still get triggered along the way, if for              * instace the error is found late while iterating the topic segments. */             if (segment.length() == 1) {                 if (segment[0] == '+' || segment[0] == '#') {                     return;                 }             }              /* Do we have a terminating wildcard child? */             if (iterator->terminatingWildcardChild) {                 iterator->terminatingWildcardChild->messages[messageId] = message;                  /* Add this topic to triggered */                 if (!iterator->terminatingWildcardChild->triggered) {                     triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;                     iterator->terminatingWildcardChild->triggered = true;                 }             }              /* Do we have a wildcard child? */             if (iterator->wildcardChild) {                 publish(iterator->wildcardChild, stop + 1, stop, topic, message);             }              std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);             if (it == iterator->children.end()) {                 /* Stop trying to match by exact string */                 return;             }              iterator = it->second;         }          /* If we went all the way we matched exactly */         iterator->messages[messageId] = message;          /* Add this topic to triggered */         if (!iterator->triggered) {             triggeredTopics[numTriggeredTopics++] = iterator;             iterator->triggered = true;         }     }"
"195302_CWE-125.c","CWE-125","R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) { 	RIOBank *bank = r_io_bank_get (io, bankid); 	RIOMap *map = r_io_map_get (io, mapid); 	r_return_val_if_fail (io && bank && map, false); 	RIOMapRef *mapref = _mapref_from_map (map); 	if (!mapref) { 		return false; 	} 	RIOSubMap *sm = r_io_submap_new (io, mapref); 	if (!sm) { 		free (mapref); 		return false; 	} 	RRBNode *entry = _find_entry_submap_node (bank, sm); 	if (!entry) { 		// no intersection with any submap, so just insert 		if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) { 			free (sm); 			free (mapref); 			return false; 		} 		r_list_append (bank->maprefs, mapref); 		return true; 	} 	bank->last_used = NULL; 	RIOSubMap *bd = (RIOSubMap *)entry->data; 	if (r_io_submap_to (bd) == r_io_submap_to (sm) && 		r_io_submap_from (bd) >= r_io_submap_from (sm)) { 		// _find_entry_submap_node guarantees, that there is no submap 		// prior to bd in the range of sm, so instead of deleting and inserting 		// we can just memcpy 		memcpy (bd, sm, sizeof (RIOSubMap)); 		free (sm); 		r_list_append (bank->maprefs, mapref); 		return true; 	} 	if (r_io_submap_from (bd) < r_io_submap_from (sm) && 		r_io_submap_to (sm) < r_io_submap_to (bd)) { 		// split bd into 2 maps => bd and bdsm 		RIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd); 		if (!bdsm) { 			free (sm); 			free (mapref); 			return false; 		} 		r_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1); 		r_io_submap_set_to (bd, r_io_submap_from (sm) - 1); 		// TODO: insert and check return value, before adjusting sm size 		if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) { 			free (sm); 			free (bdsm); 			free (mapref); 			return false; 		} 		if (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) { 			r_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL); 			free (sm); 			free (bdsm); 			free (mapref); 			return false; 		} 		r_list_append (bank->maprefs, mapref); 		return true; 	}  	// guaranteed intersection 	if (r_io_submap_from (bd) < r_io_submap_from (sm)) { 		r_io_submap_set_to (bd, r_io_submap_from (sm) - 1); 		entry = r_rbnode_next (entry); 	} 	while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) { 		//delete all submaps that are completly included in sm 		RRBNode *next = r_rbnode_next (entry); 		// this can be optimized, there is no need to do search here 		r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL); 		entry = next; 	} 	if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) { 		bd = (RIOSubMap *)entry->data; 		r_io_submap_set_from (bd, r_io_submap_to (sm) + 1); 	} 	if (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) { 		free (sm); 		free (mapref); 		return false; 	} 	r_list_append (bank->maprefs, mapref); 	return true; }"
"195308_CWE-20.c","CWE-20","setup_seccomp (FlatpakBwrap   *bwrap,                const char     *arch,                gulong          allowed_personality,                FlatpakRunFlags run_flags,                GError        **error) {   gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;   gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;    __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;    /**** BEGIN NOTE ON CODE SHARING    *    * There are today a number of different Linux container    * implementations.  That will likely continue for long into the    * future.  But we can still try to share code, and it's important    * to do so because it affects what library and application writers    * can do, and we should support code portability between different    * container tools.    *    * This syscall blocklist is copied from linux-user-chroot, which was in turn    * clearly influenced by the Sandstorm.io blocklist.    *    * If you make any changes here, I suggest sending the changes along    * to other sandbox maintainers.  Using the libseccomp list is also    * an appropriate venue:    * https://groups.google.com/forum/#!forum/libseccomp    *    * A non-exhaustive list of links to container tooling that might    * want to share this blocklist:    *    *  https://github.com/sandstorm-io/sandstorm    *    in src/sandstorm/supervisor.c++    *  https://github.com/flatpak/flatpak.git    *    in common/flatpak-run.c    *  https://git.gnome.org/browse/linux-user-chroot    *    in src/setup-seccomp.c    *    * Other useful resources:    * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c    * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json    *    **** END NOTE ON CODE SHARING    */   struct   {     int                  scall;     int                  errnum;     struct scmp_arg_cmp *arg;   } syscall_blocklist[] = {     /* Block dmesg */     {SCMP_SYS (syslog), EPERM},     /* Useless old syscall */     {SCMP_SYS (uselib), EPERM},     /* Don't allow disabling accounting */     {SCMP_SYS (acct), EPERM},     /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a        historic source of interesting information leaks. */     {SCMP_SYS (modify_ldt), EPERM},     /* Don't allow reading current quota use */     {SCMP_SYS (quotactl), EPERM},      /* Don't allow access to the kernel keyring */     {SCMP_SYS (add_key), EPERM},     {SCMP_SYS (keyctl), EPERM},     {SCMP_SYS (request_key), EPERM},      /* Scary VM/NUMA ops */     {SCMP_SYS (move_pages), EPERM},     {SCMP_SYS (mbind), EPERM},     {SCMP_SYS (get_mempolicy), EPERM},     {SCMP_SYS (set_mempolicy), EPERM},     {SCMP_SYS (migrate_pages), EPERM},      /* Don't allow subnamespace setups: */     {SCMP_SYS (unshare), EPERM},     {SCMP_SYS (setns), EPERM},     {SCMP_SYS (mount), EPERM},     {SCMP_SYS (umount), EPERM},     {SCMP_SYS (umount2), EPERM},     {SCMP_SYS (pivot_root), EPERM}, #if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)     /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack      * and flags arguments are reversed so the flags come second */     {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #else     /* Normally the flags come first */     {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)}, #endif      /* Don't allow faking input to the controlling tty (CVE-2017-5226) */     {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},      /* seccomp can't look into clone3()'s struct clone_args to check whether      * the flags are OK, so we have no choice but to block clone3().      * Return ENOSYS so user-space will fall back to clone().      * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */     {SCMP_SYS (clone3), ENOSYS},      /* New mount manipulation APIs can also change our VFS. There's no      * legitimate reason to do these in the sandbox, so block all of them      * rather than thinking about which ones might be dangerous.      * (GHSA-67h7-w3jq-vh4q) */     {SCMP_SYS (open_tree), ENOSYS},     {SCMP_SYS (move_mount), ENOSYS},     {SCMP_SYS (fsopen), ENOSYS},     {SCMP_SYS (fsconfig), ENOSYS},     {SCMP_SYS (fsmount), ENOSYS},     {SCMP_SYS (fspick), ENOSYS},     {SCMP_SYS (mount_setattr), ENOSYS},   };    struct   {     int                  scall;     int                  errnum;     struct scmp_arg_cmp *arg;   } syscall_nondevel_blocklist[] = {     /* Profiling operations; we expect these to be done by tools from outside      * the sandbox.  In particular perf has been the source of many CVEs.      */     {SCMP_SYS (perf_event_open), EPERM},     /* Don't allow you to switch to bsd emulation or whatnot */     {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},     {SCMP_SYS (ptrace), EPERM}   };   /* Blocklist all but unix, inet, inet6 and netlink */   struct   {     int             family;     FlatpakRunFlags flags_mask;   } socket_family_allowlist[] = {     /* NOTE: Keep in numerical order */     { AF_UNSPEC, 0 },     { AF_LOCAL, 0 },     { AF_INET, 0 },     { AF_INET6, 0 },     { AF_NETLINK, 0 },     { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },     { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },   };   int last_allowed_family;   int i, r;   g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };    seccomp = seccomp_init (SCMP_ACT_ALLOW);   if (!seccomp)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Initialize seccomp failed""));    if (arch != NULL)     {       uint32_t arch_id = 0;       const uint32_t *extra_arches = NULL;        if (strcmp (arch, ""i386"") == 0)         {           arch_id = SCMP_ARCH_X86;         }       else if (strcmp (arch, ""x86_64"") == 0)         {           arch_id = SCMP_ARCH_X86_64;           extra_arches = seccomp_x86_64_extra_arches;         }       else if (strcmp (arch, ""arm"") == 0)         {           arch_id = SCMP_ARCH_ARM;         } #ifdef SCMP_ARCH_AARCH64       else if (strcmp (arch, ""aarch64"") == 0)         {           arch_id = SCMP_ARCH_AARCH64;           extra_arches = seccomp_aarch64_extra_arches;         } #endif        /* We only really need to handle arches on multiarch systems.        * If only one arch is supported the default is fine */       if (arch_id != 0)         {           /* This *adds* the target arch, instead of replacing the              native one. This is not ideal, because we'd like to only              allow the target arch, but we can't really disallow the              native arch at this point, because then bubblewrap              couldn't continue running. */           r = seccomp_arch_add (seccomp, arch_id);           if (r < 0 && r != -EEXIST)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add architecture to seccomp filter""));            if (multiarch && extra_arches != NULL)             {               for (i = 0; extra_arches[i] != 0; i++)                 {                   r = seccomp_arch_add (seccomp, extra_arches[i]);                   if (r < 0 && r != -EEXIST)                     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add multiarch architecture to seccomp filter""));                 }             }         }     }    /* TODO: Should we filter the kernel keyring syscalls in some way?    * We do want them to be used by desktop apps, but they could also perhaps    * leak system stuff or secrets from other apps.    */    for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)     {       int scall = syscall_blocklist[i].scall;       int errnum = syscall_blocklist[i].errnum;        g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);        if (syscall_blocklist[i].arg)         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);       else         r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);       if (r < 0 && r == -EFAULT /* unknown syscall */)         return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);     }    if (!devel)     {       for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)         {           int scall = syscall_nondevel_blocklist[i].scall;           int errnum = syscall_nondevel_blocklist[i].errnum;            g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);            if (syscall_nondevel_blocklist[i].arg)             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);           else             r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);            if (r < 0 && r == -EFAULT /* unknown syscall */)             return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);         }     }    /* Socket filtering doesn't work on e.g. i386, so ignore failures here    * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing    * something else: https://github.com/seccomp/libseccomp/issues/8 */   last_allowed_family = -1;   for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)     {       int family = socket_family_allowlist[i].family;       int disallowed;        if (socket_family_allowlist[i].flags_mask != 0 &&           (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)         continue;        for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)         {           /* Blocklist the in-between valid families */           seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));         }       last_allowed_family = family;     }   /* Blocklist the rest */   seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));    if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, ""/tmp"", &seccomp_tmpf, error))     return FALSE;    if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)     return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to export bpf""));    lseek (seccomp_tmpf.fd, 0, SEEK_SET);    flatpak_bwrap_add_args_data_fd (bwrap,                                   ""--seccomp"", glnx_steal_fd (&seccomp_tmpf.fd), NULL);    return TRUE; }"
"195309_CWE-400.cc","CWE-400","gopherToHTML(GopherStateData * gopherState, char *inbuf, int len) {     char *pos = inbuf;     char *lpos = NULL;     char *tline = NULL;     LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);     LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);     char *name = NULL;     char *selector = NULL;     char *host = NULL;     char *port = NULL;     char *escaped_selector = NULL;     const char *icon_url = NULL;     char gtype;     StoreEntry *entry = NULL;      memset(tmpbuf, '\0', TEMP_BUF_SIZE);     memset(line, '\0', TEMP_BUF_SIZE);      entry = gopherState->entry;      if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {         char *html_url = html_quote(entry->url());         gopherHTMLHeader(entry, ""Gopher Index %s"", html_url);         storeAppendPrintf(entry,                           ""<p>This is a searchable Gopher index. Use the search\n""                           ""function of your browser to enter search terms.\n""                           ""<ISINDEX>\n"");         gopherHTMLFooter(entry);         /* now let start sending stuff to client */         entry->flush();         gopherState->HTML_header_added = 1;          return;     }      if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {         char *html_url = html_quote(entry->url());         gopherHTMLHeader(entry, ""CSO Search of %s"", html_url);         storeAppendPrintf(entry,                           ""<P>A CSO database usually contains a phonebook or\n""                           ""directory.  Use the search function of your browser to enter\n""                           ""search terms.</P><ISINDEX>\n"");         gopherHTMLFooter(entry);         /* now let start sending stuff to client */         entry->flush();         gopherState->HTML_header_added = 1;          return;     }      String outbuf;      if (!gopherState->HTML_header_added) {         if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)             gopherHTMLHeader(entry, ""CSO Search Result"", NULL);         else             gopherHTMLHeader(entry, ""Gopher Menu"", NULL);          outbuf.append (""<PRE>"");          gopherState->HTML_header_added = 1;          gopherState->HTML_pre = 1;     }      while (pos < inbuf + len) {         int llen;         int left = len - (pos - inbuf);         lpos = (char *)memchr(pos, '\n', left);         if (lpos) {             ++lpos;             /* Next line is after \n */             llen = lpos - pos;         } else {             llen = left;         }         if (gopherState->len + llen >= TEMP_BUF_SIZE) {             debugs(10, DBG_IMPORTANT, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << entry->url()  );             llen = TEMP_BUF_SIZE - gopherState->len - 1;             gopherState->overflowed = true; // may already be true         }         if (!lpos) {             /* there is no complete line in inbuf */             /* copy it to temp buffer */             /* note: llen is adjusted above */             memcpy(gopherState->buf + gopherState->len, pos, llen);             gopherState->len += llen;             break;         }         if (gopherState->len != 0) {             /* there is something left from last tx. */             memcpy(line, gopherState->buf, gopherState->len);             memcpy(line + gopherState->len, pos, llen);             llen += gopherState->len;             gopherState->len = 0;         } else {             memcpy(line, pos, llen);         }         line[llen + 1] = '\0';         /* move input to next line */         pos = lpos;          /* at this point. We should have one line in buffer to process */          if (*line == '.') {             /* skip it */             memset(line, '\0', TEMP_BUF_SIZE);             continue;         }          switch (gopherState->conversion) {          case GopherStateData::HTML_INDEX_RESULT:          case GopherStateData::HTML_DIR: {             tline = line;             gtype = *tline;             ++tline;             name = tline;             selector = strchr(tline, TAB);              if (selector) {                 *selector = '\0';                 ++selector;                 host = strchr(selector, TAB);                  if (host) {                     *host = '\0';                     ++host;                     port = strchr(host, TAB);                      if (port) {                         char *junk;                         port[0] = ':';                         junk = strchr(host, TAB);                          if (junk)                             *junk++ = 0;    /* Chop port */                         else {                             junk = strchr(host, '\r');                              if (junk)                                 *junk++ = 0;    /* Chop port */                             else {                                 junk = strchr(host, '\n');                                  if (junk)                                     *junk++ = 0;    /* Chop port */                             }                         }                          if ((port[1] == '0') && (!port[2]))                             port[0] = 0;    /* 0 means none */                     }                      /* escape a selector here */                     escaped_selector = xstrdup(rfc1738_escape_part(selector));                      switch (gtype) {                      case GOPHER_DIRECTORY:                         icon_url = mimeGetIconURL(""internal-menu"");                         break;                      case GOPHER_HTML:                      case GOPHER_FILE:                         icon_url = mimeGetIconURL(""internal-text"");                         break;                      case GOPHER_INDEX:                      case GOPHER_CSO:                         icon_url = mimeGetIconURL(""internal-index"");                         break;                      case GOPHER_IMAGE:                      case GOPHER_GIF:                      case GOPHER_PLUS_IMAGE:                         icon_url = mimeGetIconURL(""internal-image"");                         break;                      case GOPHER_SOUND:                      case GOPHER_PLUS_SOUND:                         icon_url = mimeGetIconURL(""internal-sound"");                         break;                      case GOPHER_PLUS_MOVIE:                         icon_url = mimeGetIconURL(""internal-movie"");                         break;                      case GOPHER_TELNET:                      case GOPHER_3270:                         icon_url = mimeGetIconURL(""internal-telnet"");                         break;                      case GOPHER_BIN:                      case GOPHER_MACBINHEX:                      case GOPHER_DOSBIN:                      case GOPHER_UUENCODED:                         icon_url = mimeGetIconURL(""internal-binary"");                         break;                      case GOPHER_INFO:                         icon_url = NULL;                         break;                      case GOPHER_WWW:                         icon_url = mimeGetIconURL(""internal-link"");                         break;                      default:                         icon_url = mimeGetIconURL(""internal-unknown"");                         break;                     }                      memset(tmpbuf, '\0', TEMP_BUF_SIZE);                      if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {                         if (strlen(escaped_selector) != 0)                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",                                      icon_url, escaped_selector, rfc1738_escape_part(host),                                      *port ? "":"" : """", port, html_quote(name));                         else                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",                                      icon_url, rfc1738_escape_part(host), *port ? "":"" : """",                                      port, html_quote(name));                      } else if (gtype == GOPHER_INFO) {                         snprintf(tmpbuf, TEMP_BUF_SIZE, ""\t%s\n"", html_quote(name));                     } else {                         if (strncmp(selector, ""GET /"", 5) == 0) {                             /* WWW link */                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",                                      icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));                         } else if (gtype == GOPHER_WWW) {                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""%s\"">%s</A>\n"",                                      icon_url, rfc1738_escape_unescaped(selector), html_quote(name));                         } else {                             /* Standard link */                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",                                      icon_url, host, gtype, escaped_selector, html_quote(name));                         }                     }                      safe_free(escaped_selector);                     outbuf.append(tmpbuf);                 } else {                     memset(line, '\0', TEMP_BUF_SIZE);                     continue;                 }             } else {                 memset(line, '\0', TEMP_BUF_SIZE);                 continue;             }              break;             }           /* HTML_DIR, HTML_INDEX_RESULT */          case GopherStateData::HTML_CSO_RESULT: {             if (line[0] == '-') {                 int code, recno;                 char *s_code, *s_recno, *result;                  s_code = strtok(line + 1, "":\n"");                 s_recno = strtok(NULL, "":\n"");                 result = strtok(NULL, ""\n"");                  if (!result)                     break;                  code = atoi(s_code);                  recno = atoi(s_recno);                  if (code != 200)                     break;                  if (gopherState->cso_recno != recno) {                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));                     gopherState->cso_recno = recno;                 } else {                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\n"", html_quote(result));                 }                  outbuf.append(tmpbuf);                 break;             } else {                 int code;                 char *s_code, *result;                  s_code = strtok(line, "":"");                 result = strtok(NULL, ""\n"");                  if (!result)                     break;                  code = atoi(s_code);                  switch (code) {                  case 200: {                     /* OK */                     /* Do nothing here */                     break;                 }                  case 102:   /* Number of matches */                  case 501:   /* No Match */                  case 502: { /* Too Many Matches */                     /* Print the message the server returns */                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));                     outbuf.append(tmpbuf);                     break;                 }                  }             }              break;             }           /* HTML_CSO_RESULT */         default:             break;      /* do nothing */          }           /* switch */      }               /* while loop */      if (outbuf.size() > 0) {         entry->append(outbuf.rawBuf(), outbuf.size());         /* now let start sending stuff to client */         entry->flush();     }      outbuf.clean();     return; }"
"195328_CWE-415.c","CWE-415","char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type) { 	u32 i, j, len; 	char *sOK; 	char szLineConv[1024]; 	unsigned short *sptr;  	memset(szLine, 0, sizeof(char)*lineSize); 	sOK = gf_fgets(szLine, lineSize, txt_in); 	if (!sOK) return NULL; 	if (unicode_type<=1) { 		j=0; 		len = (u32) strlen(szLine); 		for (i=0; i<len; i++) { 			if (!unicode_type && (szLine[i] & 0x80)) { 				/*non UTF8 (likely some win-CP)*/ 				if ((szLine[i+1] & 0xc0) != 0x80) { 					szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 ); 					j++; 					szLine[i] &= 0xbf; 				} 				/*UTF8 2 bytes char*/ 				else if ( (szLine[i] & 0xe0) == 0xc0) { 					szLineConv[j] = szLine[i]; 					i++; 					j++; 				} 				/*UTF8 3 bytes char*/ 				else if ( (szLine[i] & 0xf0) == 0xe0) { 					szLineConv[j] = szLine[i]; 					i++; 					j++; 					szLineConv[j] = szLine[i]; 					i++; 					j++; 				} 				/*UTF8 4 bytes char*/ 				else if ( (szLine[i] & 0xf8) == 0xf0) { 					szLineConv[j] = szLine[i]; 					i++; 					j++; 					szLineConv[j] = szLine[i]; 					i++; 					j++; 					szLineConv[j] = szLine[i]; 					i++; 					j++; 				} else { 					i+=1; 					continue; 				} 			} 			szLineConv[j] = szLine[i]; 			j++; 		} 		szLineConv[j] = 0; 		strcpy(szLine, szLineConv); 		return sOK; 	}  #ifdef GPAC_BIG_ENDIAN 	if (unicode_type==3) #else 	if (unicode_type==2) #endif 	{ 		i=0; 		while (1) { 			char c; 			if (!szLine[i] && !szLine[i+1]) break; 			c = szLine[i+1]; 			szLine[i+1] = szLine[i]; 			szLine[i] = c; 			i+=2; 		} 	} 	sptr = (u16 *)szLine; 	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr); 	szLineConv[i] = 0; 	strcpy(szLine, szLineConv); 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \0 after a \n*/ 	if (unicode_type==3) gf_fgetc(txt_in); 	return sOK; }"
"195331_CWE-843.cc","CWE-843","Status ConcatShapeHelper(InferenceContext* c, int start_value_index,                          int end_value_index, int dim_index) {   ShapeHandle unused;   TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));   const Tensor* concat_dim_t = c->input_tensor(dim_index);   if (concat_dim_t == nullptr) {     // Return an unknown shape with same rank as inputs, or an unknown rank     // if no input's rank is known.      // Find rank.     int32_t rank = InferenceContext::kUnknownRank;     for (int i = start_value_index; i < end_value_index; ++i) {       if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));       if (rank != InferenceContext::kUnknownRank) {         break;       }     }     if (rank == InferenceContext::kUnknownRank) {       c->set_output(0, c->UnknownShape());       return Status::OK();     } else if (rank == 0) {       return errors::InvalidArgument(           ""Can't concatenate scalars (use tf.stack instead)"");     } else {       for (int i = start_value_index; i < end_value_index; ++i) {         // Check that all the inputs are of the correct rank.         TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));       }     }     // Build result of <rank> different unknown dims.     std::vector<DimensionHandle> dims;     dims.reserve(rank);     for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());     c->set_output(0, c->MakeShape(dims));     return Status::OK();   }    // Merge all the non-concat dims, and sum the concat dim to make an output   // shape.   int64_t concat_dim;   if (concat_dim_t->dtype() == DT_INT32) {     concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));   } else {     concat_dim = concat_dim_t->flat<int64_t>()(0);   }    // Minimum required number of dimensions.   const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;    ShapeHandle output_before;   ShapeHandle output_after;    ShapeHandle input = c->input(end_value_index - 1);   TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));   TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));   DimensionHandle output_middle = c->Dim(input, concat_dim);   if (concat_dim == -1) {     output_after = c->Scalar();  // no dimensions.   } else {     TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));   }    for (int i = end_value_index - 2; i >= start_value_index; --i) {     ShapeHandle before;     ShapeHandle after;     input = c->input(i);     TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));     TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));     DimensionHandle middle = c->Dim(input, concat_dim);     if (concat_dim == -1) {       after = c->Scalar();     } else {       TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));     }      TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));     TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));     TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));   }    ShapeHandle s;   TF_RETURN_IF_ERROR(       c->Concatenate(output_before, c->Vector(output_middle), &s));   TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));   c->set_output(0, s);   return Status::OK(); }"
"195334_CWE-415.c","CWE-415","GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 item_count, extent_count, i, j; 	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;  	ISOM_DECREASE_SIZE(ptr, 2) 	ptr->offset_size = gf_bs_read_int(bs, 4); 	ptr->length_size = gf_bs_read_int(bs, 4); 	ptr->base_offset_size = gf_bs_read_int(bs, 4); 	if (ptr->version == 1 || ptr->version == 2) { 		ptr->index_size = gf_bs_read_int(bs, 4); 	} else { 		gf_bs_read_int(bs, 4); 	} 	if (ptr->version < 2) { 		ISOM_DECREASE_SIZE(ptr, 2) 		item_count = gf_bs_read_u16(bs); 	} else { 		ISOM_DECREASE_SIZE(ptr, 4) 		item_count = gf_bs_read_u32(bs); 	}  	for (i = 0; i < item_count; i++) { 		GF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry)); 		if (!location_entry) return GF_OUT_OF_MEM;  		gf_list_add(ptr->location_entries, location_entry); 		if (ptr->version < 2) { 			ISOM_DECREASE_SIZE(ptr, 2) 			location_entry->item_ID = gf_bs_read_u16(bs); 		} else { 			ISOM_DECREASE_SIZE(ptr, 4) 			location_entry->item_ID = gf_bs_read_u32(bs); 		} 		if (ptr->version == 1 || ptr->version == 2) { 			ISOM_DECREASE_SIZE(ptr, 2) 			location_entry->construction_method = gf_bs_read_u16(bs); 		} 		else { 			location_entry->construction_method = 0; 		} 		ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) ) 		location_entry->data_reference_index = gf_bs_read_u16(bs); 		location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size); #ifndef GPAC_DISABLE_ISOM_WRITE 		location_entry->original_base_offset = location_entry->base_offset; #endif  		ISOM_DECREASE_SIZE(ptr, 2) 		extent_count = gf_bs_read_u16(bs); 		location_entry->extent_entries = gf_list_new(); 		for (j = 0; j < extent_count; j++) { 			GF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry)); 			if (!extent_entry) return GF_OUT_OF_MEM; 			 			gf_list_add(location_entry->extent_entries, extent_entry); 			if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) { 				ISOM_DECREASE_SIZE(ptr, ptr->index_size) 				extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size); 			} 			else { 				extent_entry->extent_index = 0; 			} 			ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )  			extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size); 			extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size); #ifndef GPAC_DISABLE_ISOM_WRITE 			extent_entry->original_extent_offset = extent_entry->extent_offset; #endif 		} 	} 	return GF_OK; }"
"195338_CWE-476.c","CWE-476","static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id) { 	GF_List *list = NULL, *alt_list = NULL; 	GF_NALUFFParam *sl; 	u32 i, count; 	u32 crc = gf_crc_32(data, size);  	if (ctx->codecid==GF_CODECID_HEVC) { 		switch (ps_type) { 		case GF_HEVC_NALU_VID_PARAM: 			if (!ctx->vps) ctx->vps = gf_list_new(); 			list = ctx->vps; 			break; 		case GF_HEVC_NALU_SEQ_PARAM: 			list = ctx->sps; 			break; 		case GF_HEVC_NALU_PIC_PARAM: 			list = ctx->pps; 			break; 		default: 			assert(0); 			return; 		} 	} else if (ctx->codecid==GF_CODECID_VVC) { 		switch (ps_type) { 		case GF_VVC_NALU_VID_PARAM: 			if (!ctx->vps) ctx->vps = gf_list_new(); 			list = ctx->vps; 			break; 		case GF_VVC_NALU_SEQ_PARAM: 			list = ctx->sps; 			break; 		case GF_VVC_NALU_PIC_PARAM: 			list = ctx->pps; 			break; 		case GF_VVC_NALU_DEC_PARAM: 			if (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new(); 			list = ctx->vvc_dci; 			break; 		case GF_VVC_NALU_APS_PREFIX: 			if (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new(); 			list = ctx->vvc_aps_pre; 			break; 		default: 			assert(0); 			return; 		} 	} else { 		switch (ps_type) { 		case GF_AVC_NALU_SVC_SUBSEQ_PARAM: 		case GF_AVC_NALU_SEQ_PARAM: 			list = ctx->sps; 			break; 		case GF_AVC_NALU_PIC_PARAM: 			list = ctx->pps; 			alt_list = ctx->pps_svc; 			break; 		case GF_AVC_NALU_SEQ_PARAM_EXT: 			if (!ctx->sps_ext) ctx->sps_ext = gf_list_new(); 			list = ctx->sps_ext; 			break; 		default: 			assert(0); 			return; 		} 	} 	sl = NULL; 	count = gf_list_count(list); 	for (i=0; i<count; i++) { 		sl = gf_list_get(list, i); 		if (sl->id != ps_id) { 			sl = NULL; 			continue; 		} 		//same ID, same CRC, we don't change our state 		if (sl->crc == crc) return; 		break; 	} 	//handle alt PPS list for SVC 	if (!sl && alt_list) { 		count = gf_list_count(alt_list); 		for (i=0; i<count; i++) { 			sl = gf_list_get(alt_list, i); 			if (sl->id != ps_id) { 				sl = NULL; 				continue; 			} 			//same ID, same CRC, we don't change our state 			if (sl->crc == crc) return; 			break; 		} 	}  	if (sl) { 		//otherwise we keep this new param set 		sl->data = gf_realloc(sl->data, size); 		memcpy(sl->data, data, size); 		sl->size = size; 		sl->crc = crc; 		ctx->ps_modified = GF_TRUE; 		return; 	} 	//TODO we might want to purge the list after a while !!  	GF_SAFEALLOC(sl, GF_NALUFFParam); 	if (!sl) return; 	sl->data = gf_malloc(sizeof(char) * size); 	if (!sl->data) { 		gf_free(sl); 		return; 	} 	memcpy(sl->data, data, size); 	sl->size = size; 	sl->id = ps_id; 	sl->crc = crc;  	ctx->ps_modified = GF_TRUE; 	gf_list_add(list, sl); }"
"195340_CWE-190.cc","CWE-190","  void Compute(OpKernelContext *ctx) override {     const Tensor *indices_t, *values_t, *shape_t, *dense_t;     OP_REQUIRES_OK(ctx, ctx->input(""sp_indices"", &indices_t));     OP_REQUIRES_OK(ctx, ctx->input(""sp_values"", &values_t));     OP_REQUIRES_OK(ctx, ctx->input(""sp_shape"", &shape_t));     OP_REQUIRES_OK(ctx, ctx->input(""dense"", &dense_t));      // Validations.     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),                 errors::InvalidArgument(                     ""Input sp_indices should be a matrix but received shape: "",                     indices_t->shape().DebugString()));     OP_REQUIRES(ctx,                 TensorShapeUtils::IsVector(values_t->shape()) &&                     TensorShapeUtils::IsVector(shape_t->shape()),                 errors::InvalidArgument(                     ""Inputs sp_values and sp_shape should be vectors ""                     ""but received shapes: "",                     values_t->shape().DebugString(), "" and "",                     shape_t->shape().DebugString()));     OP_REQUIRES(         ctx, TensorShapeUtils::IsVector(shape_t->shape()),         errors::InvalidArgument(""Input sp_shape must be a vector. Got: "",                                 shape_t->shape().DebugString()));     OP_REQUIRES(         ctx, values_t->dim_size(0) == indices_t->dim_size(0),         errors::InvalidArgument(             ""The first dimension of values and indices should match. ("",             values_t->dim_size(0), "" vs. "", indices_t->dim_size(0), "")""));     OP_REQUIRES(         ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),         errors::InvalidArgument(             ""Number of dimensions must match second dimension of indices. "",             ""Got "", shape_t->shape().dim_size(0),             "" dimensions, indices shape: "", indices_t->shape().DebugString()));     OP_REQUIRES(ctx, shape_t->NumElements() > 0,                 errors::InvalidArgument(                     ""The shape argument requires at least one element.""));      const auto indices_mat = indices_t->matrix<int64_t>();     const auto shape_vec = shape_t->vec<int64_t>();     const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));     const auto rhs_dims = BCast::FromShape(dense_t->shape());     BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.      // True iff (size(lhs) >= size(rhs)) and all dims in lhs is greater or equal     // to dims in rhs (from right to left).     auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {       if (lhs.size() < rhs.size()) return false;       for (size_t i = 0; i < rhs.size(); ++i) {         if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;       }       return true;     };     OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),                 errors::InvalidArgument(                     ""SparseDenseBinaryOpShared broadcasts dense to sparse ""                     ""only; got incompatible shapes: ["",                     absl::StrJoin(lhs_dims, "",""), ""] vs. ["",                     absl::StrJoin(rhs_dims, "",""), ""]""));      Tensor *output_values = nullptr;     Tensor dense_gathered;     const int64_t nnz = indices_t->dim_size(0);     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(0, TensorShape({nnz}), &output_values));     OP_REQUIRES_OK(         ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),                                 &dense_gathered));     bool op_is_div = false;     if (absl::StrContains(ctx->op_kernel().type_string_view(), ""Div"")) {       op_is_div = true;     }     // Pulls relevant entries from the dense side, with reshape and broadcasting     // *of the dense side* taken into account.  Use a TensorRef to avoid blowing     // up memory.     //     // We can directly use the sparse indices to look up dense side, because     // ""b.y_reshape()"" and ""b.y_bcast()"" are guaranteed to have rank ""ndims"".     auto dense_gathered_flat = dense_gathered.flat<T>();     const int ndims = lhs_dims.size();     switch (ndims) { #define CASE(NDIM)                                                             \   case NDIM: {                                                                 \     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \         dense_t->shaped<T, NDIM>(b.y_reshape())                                \             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \     bool indices_valid = true;                                                 \     for (int i = 0; i < nnz; ++i) {                                            \       for (int d = 0; d < NDIM; ++d) {                                         \         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \           indices_valid = false;                                               \         }                                                                      \       }                                                                        \       OP_REQUIRES(                                                             \           ctx, indices_valid,                                                  \           errors::InvalidArgument(""Provided indices are out-of-bounds w.r.t. "" \                                   ""dense side with broadcasted shape""));       \       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \       if (op_is_div) {                                                         \         OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \                     errors::InvalidArgument(                                   \                         ""SparseDenseCwiseDiv cannot divide by zero,""           \                         ""but input dense tensor contains zero ""));             \       }                                                                        \     }                                                                          \     break;                                                                     \   }        CASE(1);       CASE(2);       CASE(3);       CASE(4);       CASE(5);       default:         OP_REQUIRES(             ctx, false,             errors::InvalidArgument(""Only tensors with ranks between 1 and 5 ""                                     ""are currently supported.  Tensor rank: "",                                     ndims)); #undef CASE     }      output_values->flat<T>().device(ctx->eigen_device<Device>()) =         values_t->flat<T>().binaryExpr(dense_gathered_flat,                                        typename Functor::func());   }"
"195341_CWE-190.cc","CWE-190","int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,                                                   bool* found_unknown_shapes) {   int64_t total_output_size = 0;   // Use float as default for calculations.   for (const auto& output : op_info.outputs()) {     DataType dt = output.dtype();     const auto& original_output_shape = output.shape();     int64_t output_size = DataTypeSize(BaseType(dt));     int num_dims = std::max(1, original_output_shape.dim_size());     auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,                                              found_unknown_shapes);     for (const auto& dim : output_shape.dim()) {       output_size *= dim.size();     }     total_output_size += output_size;     VLOG(1) << ""Output Size: "" << output_size             << "" Total Output Size:"" << total_output_size;   }   return total_output_size; }"
"195343_CWE-125.cc","CWE-125","  void Compute(OpKernelContext* context) override {     // Here's the basic idea:     // Batch and depth dimension are independent from row and col dimension. And     // because FractionalAvgPool currently only support pooling along row and     // col, we can basically think of this 4D tensor backpropagation as     // operation of a series of 2D planes.     //     // For each element of a 'slice' (2D plane) of output_backprop, we need to     // figure out its contributors when doing FractionalAvgPool operation. This     // can be done based on row_pooling_sequence, col_pooling_seq and     // overlapping.     // Once we figure out the original contributors, we just need to evenly     // divide the value of this element among these contributors.     //     // Internally, we divide the out_backprop tensor and store it in a temporary     // tensor of double type. And cast it to the corresponding type.     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>         ConstEigenMatrixMap;     typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>         EigenDoubleMatrixMap;      // Grab the inputs.     const Tensor& orig_input_tensor_shape = context->input(0);     OP_REQUIRES(context,                 orig_input_tensor_shape.dims() == 1 &&                     orig_input_tensor_shape.NumElements() == 4,                 errors::InvalidArgument(""original input tensor shape must be""                                         ""1-dimensional and 4 elements""));     const Tensor& out_backprop = context->input(1);     const Tensor& row_seq_tensor = context->input(2);     const Tensor& col_seq_tensor = context->input(3);      const int64_t out_batch = out_backprop.dim_size(0);     const int64_t out_rows = out_backprop.dim_size(1);     const int64_t out_cols = out_backprop.dim_size(2);     const int64_t out_depth = out_backprop.dim_size(3);      OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,                 errors::InvalidArgument(""Given out_backprop shape "",                                         out_backprop.shape().DebugString(),                                         "", row_seq_tensor must have at least "",                                         out_rows + 1, "" elements, but got "",                                         row_seq_tensor.NumElements()));     OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,                 errors::InvalidArgument(""Given out_backprop shape "",                                         out_backprop.shape().DebugString(),                                         "", col_seq_tensor must have at least "",                                         out_cols + 1, "" elements, but got "",                                         col_seq_tensor.NumElements()));      auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();     auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();      const int64_t in_batch = orig_input_tensor_shape_flat(0);     const int64_t in_rows = orig_input_tensor_shape_flat(1);     const int64_t in_cols = orig_input_tensor_shape_flat(2);     const int64_t in_depth = orig_input_tensor_shape_flat(3);     OP_REQUIRES(         context, in_batch != 0,         errors::InvalidArgument(""Batch dimension of input must not be 0""));     OP_REQUIRES(         context, in_rows != 0,         errors::InvalidArgument(""Rows dimension of input must not be 0""));     OP_REQUIRES(         context, in_cols != 0,         errors::InvalidArgument(""Columns dimension of input must not be 0""));     OP_REQUIRES(         context, in_depth != 0,         errors::InvalidArgument(""Depth dimension of input must not be 0""));      constexpr int tensor_in_and_out_dims = 4;     // Transform orig_input_tensor_shape into TensorShape     TensorShape in_shape;     for (auto i = 0; i < tensor_in_and_out_dims; ++i) {       in_shape.AddDim(orig_input_tensor_shape_flat(i));     }      // Create intermediate in_backprop.     Tensor in_backprop_tensor_temp;     OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(                                 {0}, DataTypeToEnum<double>::v(), in_shape,                                 &in_backprop_tensor_temp));     in_backprop_tensor_temp.flat<double>().setZero();     // Transform 4D tensor to 2D matrix.     EigenDoubleMatrixMap in_backprop_tensor_temp_mat(         in_backprop_tensor_temp.flat<double>().data(), in_depth,         in_cols * in_rows * in_batch);     ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),                                          out_depth,                                          out_cols * out_rows * out_batch);     // Loop through each element of out_backprop and evenly distribute the     // element to the corresponding pooling cell.     const int64_t in_max_row_index = in_rows - 1;     const int64_t in_max_col_index = in_cols - 1;     for (int64_t b = 0; b < out_batch; ++b) {       for (int64_t r = 0; r < out_rows; ++r) {         const int64_t in_row_start = row_seq_tensor_flat(r);         int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)                                           : row_seq_tensor_flat(r + 1) - 1;         in_row_end = std::min(in_row_end, in_max_row_index);         for (int64_t c = 0; c < out_cols; ++c) {           const int64_t in_col_start = col_seq_tensor_flat(c);           int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)                                             : col_seq_tensor_flat(c + 1) - 1;           in_col_end = std::min(in_col_end, in_max_col_index);            const int64_t num_elements_in_pooling_cell =               (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);           const int64_t out_index = (b * out_rows + r) * out_cols + c;           // Now we can evenly distribute out_backprop(b, h, w, *) to           // in_backprop(b, hs:he, ws:we, *).           for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {             for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {               const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;               // Walk through each channel (depth).               for (int64_t d = 0; d < out_depth; ++d) {                 const double out_backprop_element = static_cast<double>(                     out_backprop_mat.coeffRef(d, out_index));                 double& in_backprop_ref =                     in_backprop_tensor_temp_mat.coeffRef(d, in_index);                 in_backprop_ref +=                     out_backprop_element / num_elements_in_pooling_cell;               }             }           }         }       }     }      // Depending on the type, cast double to type T.     Tensor* in_backprop_tensor = nullptr;     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(                                 {0}, 0, in_shape, &in_backprop_tensor));     auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();     auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();     for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {       in_backprop_tensor_flat(i) =           static_cast<T>(in_backprop_tensor_temp_flat(i));     }   }"
"195385_CWE-276.c","CWE-276","flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,                                   GFile              *file,                                   GBytes             *extra_gpg_data,                                   FlatpakDecomposed **out_ref,                                   char              **out_checksum,                                   char              **out_metadata,                                   gboolean           *out_created_remote,                                   GCancellable       *cancellable,                                   GError            **error) {   g_autoptr(FlatpakDecomposed) ref = NULL;   gboolean created_remote = FALSE;   g_autoptr(GBytes) deploy_data = NULL;   g_autoptr(GVariant) metadata = NULL;   g_autofree char *origin = NULL;   g_autofree char *fp_metadata = NULL;   g_autofree char *basename = NULL;   g_autoptr(GBytes) included_gpg_data = NULL;   GBytes *gpg_data = NULL;   g_autofree char *to_checksum = NULL;   g_autofree char *remote = NULL;   g_autofree char *collection_id = NULL;    if (!flatpak_dir_ensure_repo (self, cancellable, error))     return NULL;    metadata = flatpak_bundle_load (file, &to_checksum,                                   &ref,                                   &origin,                                   NULL, &fp_metadata, NULL,                                   &included_gpg_data,                                   &collection_id,                                   error);   if (metadata == NULL)     return NULL;    gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;    deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);   if (deploy_data != NULL)     {       remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));        /* We need to import any gpg keys because otherwise the pull will fail */       if (gpg_data != NULL)         {           g_autoptr(GKeyFile) new_config = NULL;            new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));            if (!flatpak_dir_modify_remote (self, remote, new_config,                                           gpg_data, cancellable, error))             return NULL;         }     }   else     {       g_autofree char *id = flatpak_decomposed_dup_id (ref);       /* Add a remote for later updates */       basename = g_file_get_basename (file);       remote = flatpak_dir_create_origin_remote (self,                                                  origin,                                                  id,                                                  basename,                                                  flatpak_decomposed_get_ref (ref),                                                  gpg_data,                                                  collection_id,                                                  &created_remote,                                                  cancellable,                                                  error);       if (remote == NULL)         return NULL;     }    if (out_created_remote)     *out_created_remote = created_remote;    if (out_ref)     *out_ref = g_steal_pointer (&ref);    if (out_checksum)     *out_checksum = g_steal_pointer (&to_checksum);    if (out_metadata)     *out_metadata = g_steal_pointer (&fp_metadata);     return g_steal_pointer (&remote); }"
"195388_CWE-522.c","CWE-522","PQconnectPoll(PGconn *conn) { 	bool		reset_connection_state_machine = false; 	bool		need_new_connection = false; 	PGresult   *res; 	char		sebuf[PG_STRERROR_R_BUFLEN]; 	int			optval;  	if (conn == NULL) 		return PGRES_POLLING_FAILED;  	/* Get the new data */ 	switch (conn->status) 	{ 			/* 			 * We really shouldn't have been polled in these two cases, but we 			 * can handle it. 			 */ 		case CONNECTION_BAD: 			return PGRES_POLLING_FAILED; 		case CONNECTION_OK: 			return PGRES_POLLING_OK;  			/* These are reading states */ 		case CONNECTION_AWAITING_RESPONSE: 		case CONNECTION_AUTH_OK: 		case CONNECTION_CHECK_WRITABLE: 		case CONNECTION_CONSUME: 		case CONNECTION_CHECK_STANDBY: 			{ 				/* Load waiting data */ 				int			n = pqReadData(conn);  				if (n < 0) 					goto error_return; 				if (n == 0) 					return PGRES_POLLING_READING;  				break; 			}  			/* These are writing states, so we just proceed. */ 		case CONNECTION_STARTED: 		case CONNECTION_MADE: 			break;  			/* Special cases: proceed without waiting. */ 		case CONNECTION_SSL_STARTUP: 		case CONNECTION_NEEDED: 		case CONNECTION_GSS_STARTUP: 		case CONNECTION_CHECK_TARGET: 			break;  		default: 			appendPQExpBufferStr(&conn->errorMessage, 								 libpq_gettext(""invalid connection state, probably indicative of memory corruption\n"")); 			goto error_return; 	}   keep_going:						/* We will come back to here until there is 								 * nothing left to do. */  	/* Time to advance to next address, or next host if no more addresses? */ 	if (conn->try_next_addr) 	{ 		if (conn->addr_cur && conn->addr_cur->ai_next) 		{ 			conn->addr_cur = conn->addr_cur->ai_next; 			reset_connection_state_machine = true; 		} 		else 			conn->try_next_host = true; 		conn->try_next_addr = false; 	}  	/* Time to advance to next connhost[] entry? */ 	if (conn->try_next_host) 	{ 		pg_conn_host *ch; 		struct addrinfo hint; 		int			thisport; 		int			ret; 		char		portstr[MAXPGPATH];  		if (conn->whichhost + 1 < conn->nconnhost) 			conn->whichhost++; 		else 		{ 			/* 			 * Oops, no more hosts. 			 * 			 * If we are trying to connect in ""prefer-standby"" mode, then drop 			 * the standby requirement and start over. 			 * 			 * Otherwise, an appropriate error message is already set up, so 			 * we just need to set the right status. 			 */ 			if (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY && 				conn->nconnhost > 0) 			{ 				conn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2; 				conn->whichhost = 0; 			} 			else 				goto error_return; 		}  		/* Drop any address info for previous host */ 		release_conn_addrinfo(conn);  		/* 		 * Look up info for the new host.  On failure, log the problem in 		 * conn->errorMessage, then loop around to try the next host.  (Note 		 * we don't clear try_next_host until we've succeeded.) 		 */ 		ch = &conn->connhost[conn->whichhost];  		/* Initialize hint structure */ 		MemSet(&hint, 0, sizeof(hint)); 		hint.ai_socktype = SOCK_STREAM; 		conn->addrlist_family = hint.ai_family = AF_UNSPEC;  		/* Figure out the port number we're going to use. */ 		if (ch->port == NULL || ch->port[0] == '\0') 			thisport = DEF_PGPORT; 		else 		{ 			if (!parse_int_param(ch->port, &thisport, conn, ""port"")) 				goto error_return;  			if (thisport < 1 || thisport > 65535) 			{ 				appendPQExpBuffer(&conn->errorMessage, 								  libpq_gettext(""invalid port number: \""%s\""\n""), 								  ch->port); 				goto keep_going; 			} 		} 		snprintf(portstr, sizeof(portstr), ""%d"", thisport);  		/* Use pg_getaddrinfo_all() to resolve the address */ 		switch (ch->type) 		{ 			case CHT_HOST_NAME: 				ret = pg_getaddrinfo_all(ch->host, portstr, &hint, 										 &conn->addrlist); 				if (ret || !conn->addrlist) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not translate host name \""%s\"" to address: %s\n""), 									  ch->host, gai_strerror(ret)); 					goto keep_going; 				} 				break;  			case CHT_HOST_ADDRESS: 				hint.ai_flags = AI_NUMERICHOST; 				ret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint, 										 &conn->addrlist); 				if (ret || !conn->addrlist) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not parse network address \""%s\"": %s\n""), 									  ch->hostaddr, gai_strerror(ret)); 					goto keep_going; 				} 				break;  			case CHT_UNIX_SOCKET: #ifdef HAVE_UNIX_SOCKETS 				conn->addrlist_family = hint.ai_family = AF_UNIX; 				UNIXSOCK_PATH(portstr, thisport, ch->host); 				if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""Unix-domain socket path \""%s\"" is too long (maximum %d bytes)\n""), 									  portstr, 									  (int) (UNIXSOCK_PATH_BUFLEN - 1)); 					goto keep_going; 				}  				/* 				 * NULL hostname tells pg_getaddrinfo_all to parse the service 				 * name as a Unix-domain socket path. 				 */ 				ret = pg_getaddrinfo_all(NULL, portstr, &hint, 										 &conn->addrlist); 				if (ret || !conn->addrlist) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not translate Unix-domain socket path \""%s\"" to address: %s\n""), 									  portstr, gai_strerror(ret)); 					goto keep_going; 				} #else 				Assert(false); #endif 				break; 		}  		/* OK, scan this addrlist for a working server address */ 		conn->addr_cur = conn->addrlist; 		reset_connection_state_machine = true; 		conn->try_next_host = false; 	}  	/* Reset connection state machine? */ 	if (reset_connection_state_machine) 	{ 		/* 		 * (Re) initialize our connection control variables for a set of 		 * connection attempts to a single server address.  These variables 		 * must persist across individual connection attempts, but we must 		 * reset them when we start to consider a new server. 		 */ 		conn->pversion = PG_PROTOCOL(3, 0); 		conn->send_appname = true; #ifdef USE_SSL 		/* initialize these values based on SSL mode */ 		conn->allow_ssl_try = (conn->sslmode[0] != 'd');	/* ""disable"" */ 		conn->wait_ssl_try = (conn->sslmode[0] == 'a'); /* ""allow"" */ #endif #ifdef ENABLE_GSS 		conn->try_gss = (conn->gssencmode[0] != 'd');	/* ""disable"" */ #endif  		reset_connection_state_machine = false; 		need_new_connection = true; 	}  	/* Force a new connection (perhaps to the same server as before)? */ 	if (need_new_connection) 	{ 		/* Drop any existing connection */ 		pqDropConnection(conn, true);  		/* Reset all state obtained from old server */ 		pqDropServerData(conn);  		/* Drop any PGresult we might have, too */ 		conn->asyncStatus = PGASYNC_IDLE; 		conn->xactStatus = PQTRANS_IDLE; 		conn->pipelineStatus = PQ_PIPELINE_OFF; 		pqClearAsyncResult(conn);  		/* Reset conn->status to put the state machine in the right state */ 		conn->status = CONNECTION_NEEDED;  		need_new_connection = false; 	}  	/* Now try to advance the state machine for this connection */ 	switch (conn->status) 	{ 		case CONNECTION_NEEDED: 			{ 				/* 				 * Try to initiate a connection to one of the addresses 				 * returned by pg_getaddrinfo_all().  conn->addr_cur is the 				 * next one to try. 				 * 				 * The extra level of braces here is historical.  It's not 				 * worth reindenting this whole switch case to remove 'em. 				 */ 				{ 					struct addrinfo *addr_cur = conn->addr_cur; 					char		host_addr[NI_MAXHOST];  					/* 					 * Advance to next possible host, if we've tried all of 					 * the addresses for the current host. 					 */ 					if (addr_cur == NULL) 					{ 						conn->try_next_host = true; 						goto keep_going; 					}  					/* Remember current address for possible use later */ 					memcpy(&conn->raddr.addr, addr_cur->ai_addr, 						   addr_cur->ai_addrlen); 					conn->raddr.salen = addr_cur->ai_addrlen;  					/* 					 * Set connip, too.  Note we purposely ignore strdup 					 * failure; not a big problem if it fails. 					 */ 					if (conn->connip != NULL) 					{ 						free(conn->connip); 						conn->connip = NULL; 					} 					getHostaddr(conn, host_addr, NI_MAXHOST); 					if (host_addr[0]) 						conn->connip = strdup(host_addr);  					/* Try to create the socket */ 					conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0); 					if (conn->sock == PGINVALID_SOCKET) 					{ 						int			errorno = SOCK_ERRNO;  						/* 						 * Silently ignore socket() failure if we have more 						 * addresses to try; this reduces useless chatter in 						 * cases where the address list includes both IPv4 and 						 * IPv6 but kernel only accepts one family. 						 */ 						if (addr_cur->ai_next != NULL || 							conn->whichhost + 1 < conn->nconnhost) 						{ 							conn->try_next_addr = true; 							goto keep_going; 						} 						emitHostIdentityInfo(conn, host_addr); 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""could not create socket: %s\n""), 										  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf))); 						goto error_return; 					}  					/* 					 * Once we've identified a target address, all errors 					 * except the preceding socket()-failure case should be 					 * prefixed with host-identity information.  (If the 					 * connection succeeds, the contents of conn->errorMessage 					 * won't matter, so this is harmless.) 					 */ 					emitHostIdentityInfo(conn, host_addr);  					/* 					 * Select socket options: no delay of outgoing data for 					 * TCP sockets, nonblock mode, close-on-exec.  Try the 					 * next address if any of this fails. 					 */ 					if (!IS_AF_UNIX(addr_cur->ai_family)) 					{ 						if (!connectNoDelay(conn)) 						{ 							/* error message already created */ 							conn->try_next_addr = true; 							goto keep_going; 						} 					} 					if (!pg_set_noblock(conn->sock)) 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""could not set socket to nonblocking mode: %s\n""), 										  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 						conn->try_next_addr = true; 						goto keep_going; 					}  #ifdef F_SETFD 					if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1) 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""could not set socket to close-on-exec mode: %s\n""), 										  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 						conn->try_next_addr = true; 						goto keep_going; 					} #endif							/* F_SETFD */  					if (!IS_AF_UNIX(addr_cur->ai_family)) 					{ #ifndef WIN32 						int			on = 1; #endif 						int			usekeepalives = useKeepalives(conn); 						int			err = 0;  						if (usekeepalives < 0) 						{ 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""keepalives parameter must be an integer\n"")); 							err = 1; 						} 						else if (usekeepalives == 0) 						{ 							/* Do nothing */ 						} #ifndef WIN32 						else if (setsockopt(conn->sock, 											SOL_SOCKET, SO_KEEPALIVE, 											(char *) &on, sizeof(on)) < 0) 						{ 							appendPQExpBuffer(&conn->errorMessage, 											  libpq_gettext(""%s(%s) failed: %s\n""), 											  ""setsockopt"", 											  ""SO_KEEPALIVE"", 											  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 							err = 1; 						} 						else if (!setKeepalivesIdle(conn) 								 || !setKeepalivesInterval(conn) 								 || !setKeepalivesCount(conn)) 							err = 1; #else							/* WIN32 */ #ifdef SIO_KEEPALIVE_VALS 						else if (!setKeepalivesWin32(conn)) 							err = 1; #endif							/* SIO_KEEPALIVE_VALS */ #endif							/* WIN32 */ 						else if (!setTCPUserTimeout(conn)) 							err = 1;  						if (err) 						{ 							conn->try_next_addr = true; 							goto keep_going; 						} 					}  					/*---------- 					 * We have three methods of blocking SIGPIPE during 					 * send() calls to this socket: 					 * 					 *	- setsockopt(sock, SO_NOSIGPIPE) 					 *	- send(sock, ..., MSG_NOSIGNAL) 					 *	- setting the signal mask to SIG_IGN during send() 					 * 					 * The third method requires three syscalls per send, 					 * so we prefer either of the first two, but they are 					 * less portable.  The state is tracked in the following 					 * members of PGconn: 					 * 					 * conn->sigpipe_so		- we have set up SO_NOSIGPIPE 					 * conn->sigpipe_flag	- we're specifying MSG_NOSIGNAL 					 * 					 * If we can use SO_NOSIGPIPE, then set sigpipe_so here 					 * and we're done.  Otherwise, set sigpipe_flag so that 					 * we will try MSG_NOSIGNAL on sends.  If we get an error 					 * with MSG_NOSIGNAL, we'll clear that flag and revert to 					 * signal masking. 					 *---------- 					 */ 					conn->sigpipe_so = false; #ifdef MSG_NOSIGNAL 					conn->sigpipe_flag = true; #else 					conn->sigpipe_flag = false; #endif							/* MSG_NOSIGNAL */  #ifdef SO_NOSIGPIPE 					optval = 1; 					if (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE, 								   (char *) &optval, sizeof(optval)) == 0) 					{ 						conn->sigpipe_so = true; 						conn->sigpipe_flag = false; 					} #endif							/* SO_NOSIGPIPE */  					/* 					 * Start/make connection.  This should not block, since we 					 * are in nonblock mode.  If it does, well, too bad. 					 */ 					if (connect(conn->sock, addr_cur->ai_addr, 								addr_cur->ai_addrlen) < 0) 					{ 						if (SOCK_ERRNO == EINPROGRESS || #ifdef WIN32 							SOCK_ERRNO == EWOULDBLOCK || #endif 							SOCK_ERRNO == EINTR) 						{ 							/* 							 * This is fine - we're in non-blocking mode, and 							 * the connection is in progress.  Tell caller to 							 * wait for write-ready on socket. 							 */ 							conn->status = CONNECTION_STARTED; 							return PGRES_POLLING_WRITING; 						} 						/* otherwise, trouble */ 					} 					else 					{ 						/* 						 * Hm, we're connected already --- seems the ""nonblock 						 * connection"" wasn't.  Advance the state machine and 						 * go do the next stuff. 						 */ 						conn->status = CONNECTION_STARTED; 						goto keep_going; 					}  					/* 					 * This connection failed.  Add the error report to 					 * conn->errorMessage, then try the next address if any. 					 */ 					connectFailureMessage(conn, SOCK_ERRNO); 					conn->try_next_addr = true; 					goto keep_going; 				} 			}  		case CONNECTION_STARTED: 			{ 				ACCEPT_TYPE_ARG3 optlen = sizeof(optval);  				/* 				 * Write ready, since we've made it here, so the connection 				 * has been made ... or has failed. 				 */  				/* 				 * Now check (using getsockopt) that there is not an error 				 * state waiting for us on the socket. 				 */  				if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR, 							   (char *) &optval, &optlen) == -1) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not get socket error status: %s\n""), 									  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 					goto error_return; 				} 				else if (optval != 0) 				{ 					/* 					 * When using a nonblocking connect, we will typically see 					 * connect failures at this point, so provide a friendly 					 * error message. 					 */ 					connectFailureMessage(conn, optval);  					/* 					 * Try the next address if any, just as in the case where 					 * connect() returned failure immediately. 					 */ 					conn->try_next_addr = true; 					goto keep_going; 				}  				/* Fill in the client address */ 				conn->laddr.salen = sizeof(conn->laddr.addr); 				if (getsockname(conn->sock, 								(struct sockaddr *) &conn->laddr.addr, 								&conn->laddr.salen) < 0) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not get client address from socket: %s\n""), 									  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 					goto error_return; 				}  				/* 				 * Make sure we can write before advancing to next step. 				 */ 				conn->status = CONNECTION_MADE; 				return PGRES_POLLING_WRITING; 			}  		case CONNECTION_MADE: 			{ 				char	   *startpacket; 				int			packetlen;  				/* 				 * Implement requirepeer check, if requested and it's a 				 * Unix-domain socket. 				 */ 				if (conn->requirepeer && conn->requirepeer[0] && 					IS_AF_UNIX(conn->raddr.addr.ss_family)) 				{ #ifndef WIN32 					char		pwdbuf[BUFSIZ]; 					struct passwd pass_buf; 					struct passwd *pass; 					int			passerr; #endif 					uid_t		uid; 					gid_t		gid;  					errno = 0; 					if (getpeereid(conn->sock, &uid, &gid) != 0) 					{ 						/* 						 * Provide special error message if getpeereid is a 						 * stub 						 */ 						if (errno == ENOSYS) 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""requirepeer parameter is not supported on this platform\n"")); 						else 							appendPQExpBuffer(&conn->errorMessage, 											  libpq_gettext(""could not get peer credentials: %s\n""), 											  strerror_r(errno, sebuf, sizeof(sebuf))); 						goto error_return; 					}  #ifndef WIN32 					passerr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass); 					if (pass == NULL) 					{ 						if (passerr != 0) 							appendPQExpBuffer(&conn->errorMessage, 											  libpq_gettext(""could not look up local user ID %d: %s\n""), 											  (int) uid, 											  strerror_r(passerr, sebuf, sizeof(sebuf))); 						else 							appendPQExpBuffer(&conn->errorMessage, 											  libpq_gettext(""local user with ID %d does not exist\n""), 											  (int) uid); 						goto error_return; 					}  					if (strcmp(pass->pw_name, conn->requirepeer) != 0) 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""requirepeer specifies \""%s\"", but actual peer user name is \""%s\""\n""), 										  conn->requirepeer, pass->pw_name); 						goto error_return; 					} #else							/* WIN32 */ 					/* should have failed with ENOSYS above */ 					Assert(false); #endif							/* WIN32 */ 				}  				if (IS_AF_UNIX(conn->raddr.addr.ss_family)) 				{ 					/* Don't request SSL or GSSAPI over Unix sockets */ #ifdef USE_SSL 					conn->allow_ssl_try = false; #endif #ifdef ENABLE_GSS 					conn->try_gss = false; #endif 				}  #ifdef ENABLE_GSS  				/* 				 * If GSSAPI encryption is enabled, then call 				 * pg_GSS_have_cred_cache() which will return true if we can 				 * acquire credentials (and give us a handle to use in 				 * conn->gcred), and then send a packet to the server asking 				 * for GSSAPI Encryption (and skip past SSL negotiation and 				 * regular startup below). 				 */ 				if (conn->try_gss && !conn->gctx) 					conn->try_gss = pg_GSS_have_cred_cache(&conn->gcred); 				if (conn->try_gss && !conn->gctx) 				{ 					ProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);  					if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK) 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""could not send GSSAPI negotiation packet: %s\n""), 										  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 						goto error_return; 					}  					/* Ok, wait for response */ 					conn->status = CONNECTION_GSS_STARTUP; 					return PGRES_POLLING_READING; 				} 				else if (!conn->gctx && conn->gssencmode[0] == 'r') 				{ 					appendPQExpBufferStr(&conn->errorMessage, 										 libpq_gettext(""GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\n"")); 					goto error_return; 				} #endif  #ifdef USE_SSL  				/* 				 * Enable the libcrypto callbacks before checking if SSL needs 				 * to be done.  This is done before sending the startup packet 				 * as depending on the type of authentication done, like MD5 				 * or SCRAM that use cryptohashes, the callbacks would be 				 * required even without a SSL connection 				 */ 				if (pqsecure_initialize(conn, false, true) < 0) 					goto error_return;  				/* 				 * If SSL is enabled and we haven't already got encryption of 				 * some sort running, request SSL instead of sending the 				 * startup message. 				 */ 				if (conn->allow_ssl_try && !conn->wait_ssl_try && 					!conn->ssl_in_use #ifdef ENABLE_GSS 					&& !conn->gssenc #endif 					) 				{ 					ProtocolVersion pv;  					/* 					 * Send the SSL request packet. 					 * 					 * Theoretically, this could block, but it really 					 * shouldn't since we only got here if the socket is 					 * write-ready. 					 */ 					pv = pg_hton32(NEGOTIATE_SSL_CODE); 					if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK) 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""could not send SSL negotiation packet: %s\n""), 										  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 						goto error_return; 					} 					/* Ok, wait for response */ 					conn->status = CONNECTION_SSL_STARTUP; 					return PGRES_POLLING_READING; 				} #endif							/* USE_SSL */  				/* 				 * Build the startup packet. 				 */ 				startpacket = pqBuildStartupPacket3(conn, &packetlen, 													EnvironmentOptions); 				if (!startpacket) 				{ 					appendPQExpBufferStr(&conn->errorMessage, 										 libpq_gettext(""out of memory\n"")); 					goto error_return; 				}  				/* 				 * Send the startup packet. 				 * 				 * Theoretically, this could block, but it really shouldn't 				 * since we only got here if the socket is write-ready. 				 */ 				if (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""could not send startup packet: %s\n""), 									  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 					free(startpacket); 					goto error_return; 				}  				free(startpacket);  				conn->status = CONNECTION_AWAITING_RESPONSE; 				return PGRES_POLLING_READING; 			}  			/* 			 * Handle SSL negotiation: wait for postmaster messages and 			 * respond as necessary. 			 */ 		case CONNECTION_SSL_STARTUP: 			{ #ifdef USE_SSL 				PostgresPollingStatusType pollres;  				/* 				 * On first time through, get the postmaster's response to our 				 * SSL negotiation packet. 				 */ 				if (!conn->ssl_in_use) 				{ 					/* 					 * We use pqReadData here since it has the logic to 					 * distinguish no-data-yet from connection closure. Since 					 * conn->ssl isn't set, a plain recv() will occur. 					 */ 					char		SSLok; 					int			rdresult;  					rdresult = pqReadData(conn); 					if (rdresult < 0) 					{ 						/* errorMessage is already filled in */ 						goto error_return; 					} 					if (rdresult == 0) 					{ 						/* caller failed to wait for data */ 						return PGRES_POLLING_READING; 					} 					if (pqGetc(&SSLok, conn) < 0) 					{ 						/* should not happen really */ 						return PGRES_POLLING_READING; 					} 					if (SSLok == 'S') 					{ 						/* mark byte consumed */ 						conn->inStart = conn->inCursor;  						/* 						 * Set up global SSL state if required.  The crypto 						 * state has already been set if libpq took care of 						 * doing that, so there is no need to make that happen 						 * again. 						 */ 						if (pqsecure_initialize(conn, true, false) != 0) 							goto error_return; 					} 					else if (SSLok == 'N') 					{ 						/* mark byte consumed */ 						conn->inStart = conn->inCursor; 						/* OK to do without SSL? */ 						if (conn->sslmode[0] == 'r' ||	/* ""require"" */ 							conn->sslmode[0] == 'v')	/* ""verify-ca"" or 														 * ""verify-full"" */ 						{ 							/* Require SSL, but server does not want it */ 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""server does not support SSL, but SSL was required\n"")); 							goto error_return; 						} 						/* Otherwise, proceed with normal startup */ 						conn->allow_ssl_try = false; 						/* We can proceed using this connection */ 						conn->status = CONNECTION_MADE; 						return PGRES_POLLING_WRITING; 					} 					else if (SSLok == 'E') 					{ 						/* 						 * Server failure of some sort, such as failure to 						 * fork a backend process.  We need to process and 						 * report the error message, which might be formatted 						 * according to either protocol 2 or protocol 3. 						 * Rather than duplicate the code for that, we flip 						 * into AWAITING_RESPONSE state and let the code there 						 * deal with it.  Note we have *not* consumed the ""E"" 						 * byte here. 						 */ 						conn->status = CONNECTION_AWAITING_RESPONSE; 						goto keep_going; 					} 					else 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""received invalid response to SSL negotiation: %c\n""), 										  SSLok); 						goto error_return; 					} 				}  				/* 				 * Begin or continue the SSL negotiation process. 				 */ 				pollres = pqsecure_open_client(conn); 				if (pollres == PGRES_POLLING_OK) 				{ 					/* SSL handshake done, ready to send startup packet */ 					conn->status = CONNECTION_MADE; 					return PGRES_POLLING_WRITING; 				} 				if (pollres == PGRES_POLLING_FAILED) 				{ 					/* 					 * Failed ... if sslmode is ""prefer"" then do a non-SSL 					 * retry 					 */ 					if (conn->sslmode[0] == 'p' /* ""prefer"" */ 						&& conn->allow_ssl_try	/* redundant? */ 						&& !conn->wait_ssl_try) /* redundant? */ 					{ 						/* only retry once */ 						conn->allow_ssl_try = false; 						need_new_connection = true; 						goto keep_going; 					} 					/* Else it's a hard failure */ 					goto error_return; 				} 				/* Else, return POLLING_READING or POLLING_WRITING status */ 				return pollres; #else							/* !USE_SSL */ 				/* can't get here */ 				goto error_return; #endif							/* USE_SSL */ 			}  		case CONNECTION_GSS_STARTUP: 			{ #ifdef ENABLE_GSS 				PostgresPollingStatusType pollres;  				/* 				 * If we haven't yet, get the postmaster's response to our 				 * negotiation packet 				 */ 				if (conn->try_gss && !conn->gctx) 				{ 					char		gss_ok; 					int			rdresult = pqReadData(conn);  					if (rdresult < 0) 						/* pqReadData fills in error message */ 						goto error_return; 					else if (rdresult == 0) 						/* caller failed to wait for data */ 						return PGRES_POLLING_READING; 					if (pqGetc(&gss_ok, conn) < 0) 						/* shouldn't happen... */ 						return PGRES_POLLING_READING;  					if (gss_ok == 'E') 					{ 						/* 						 * Server failure of some sort.  Assume it's a 						 * protocol version support failure, and let's see if 						 * we can't recover (if it's not, we'll get a better 						 * error message on retry).  Server gets fussy if we 						 * don't hang up the socket, though. 						 */ 						conn->try_gss = false; 						need_new_connection = true; 						goto keep_going; 					}  					/* mark byte consumed */ 					conn->inStart = conn->inCursor;  					if (gss_ok == 'N') 					{ 						/* Server doesn't want GSSAPI; fall back if we can */ 						if (conn->gssencmode[0] == 'r') 						{ 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""server doesn't support GSSAPI encryption, but it was required\n"")); 							goto error_return; 						}  						conn->try_gss = false; 						/* We can proceed using this connection */ 						conn->status = CONNECTION_MADE; 						return PGRES_POLLING_WRITING; 					} 					else if (gss_ok != 'G') 					{ 						appendPQExpBuffer(&conn->errorMessage, 										  libpq_gettext(""received invalid response to GSSAPI negotiation: %c\n""), 										  gss_ok); 						goto error_return; 					} 				}  				/* Begin or continue GSSAPI negotiation */ 				pollres = pqsecure_open_gss(conn); 				if (pollres == PGRES_POLLING_OK) 				{ 					/* All set for startup packet */ 					conn->status = CONNECTION_MADE; 					return PGRES_POLLING_WRITING; 				} 				else if (pollres == PGRES_POLLING_FAILED && 						 conn->gssencmode[0] == 'p') 				{ 					/* 					 * We failed, but we can retry on ""prefer"".  Have to drop 					 * the current connection to do so, though. 					 */ 					conn->try_gss = false; 					need_new_connection = true; 					goto keep_going; 				} 				return pollres; #else							/* !ENABLE_GSS */ 				/* unreachable */ 				goto error_return; #endif							/* ENABLE_GSS */ 			}  			/* 			 * Handle authentication exchange: wait for postmaster messages 			 * and respond as necessary. 			 */ 		case CONNECTION_AWAITING_RESPONSE: 			{ 				char		beresp; 				int			msgLength; 				int			avail; 				AuthRequest areq; 				int			res;  				/* 				 * Scan the message from current point (note that if we find 				 * the message is incomplete, we will return without advancing 				 * inStart, and resume here next time). 				 */ 				conn->inCursor = conn->inStart;  				/* Read type byte */ 				if (pqGetc(&beresp, conn)) 				{ 					/* We'll come back when there is more data */ 					return PGRES_POLLING_READING; 				}  				/* 				 * Validate message type: we expect only an authentication 				 * request or an error here.  Anything else probably means 				 * it's not Postgres on the other end at all. 				 */ 				if (!(beresp == 'R' || beresp == 'E')) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""expected authentication request from server, but received %c\n""), 									  beresp); 					goto error_return; 				}  				/* Read message length word */ 				if (pqGetInt(&msgLength, 4, conn)) 				{ 					/* We'll come back when there is more data */ 					return PGRES_POLLING_READING; 				}  				/* 				 * Try to validate message length before using it. 				 * Authentication requests can't be very large, although GSS 				 * auth requests may not be that small.  Errors can be a 				 * little larger, but not huge.  If we see a large apparent 				 * length in an error, it means we're really talking to a 				 * pre-3.0-protocol server; cope.  (Before version 14, the 				 * server also used the old protocol for errors that happened 				 * before processing the startup packet.) 				 */ 				if (beresp == 'R' && (msgLength < 8 || msgLength > 2000)) 				{ 					appendPQExpBuffer(&conn->errorMessage, 									  libpq_gettext(""expected authentication request from server, but received %c\n""), 									  beresp); 					goto error_return; 				}  				if (beresp == 'E' && (msgLength < 8 || msgLength > 30000)) 				{ 					/* Handle error from a pre-3.0 server */ 					conn->inCursor = conn->inStart + 1; /* reread data */ 					if (pqGets_append(&conn->errorMessage, conn)) 					{ 						/* We'll come back when there is more data */ 						return PGRES_POLLING_READING; 					} 					/* OK, we read the message; mark data consumed */ 					conn->inStart = conn->inCursor;  					/* 					 * Before 7.2, the postmaster didn't always end its 					 * messages with a newline, so add one if needed to 					 * conform to libpq conventions. 					 */ 					if (conn->errorMessage.len == 0 || 						conn->errorMessage.data[conn->errorMessage.len - 1] != '\n') 					{ 						appendPQExpBufferChar(&conn->errorMessage, '\n'); 					}  					goto error_return; 				}  				/* 				 * Can't process if message body isn't all here yet. 				 */ 				msgLength -= 4; 				avail = conn->inEnd - conn->inCursor; 				if (avail < msgLength) 				{ 					/* 					 * Before returning, try to enlarge the input buffer if 					 * needed to hold the whole message; see notes in 					 * pqParseInput3. 					 */ 					if (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength, 											 conn)) 						goto error_return; 					/* We'll come back when there is more data */ 					return PGRES_POLLING_READING; 				}  				/* Handle errors. */ 				if (beresp == 'E') 				{ 					if (pqGetErrorNotice3(conn, true)) 					{ 						/* We'll come back when there is more data */ 						return PGRES_POLLING_READING; 					} 					/* OK, we read the message; mark data consumed */ 					conn->inStart = conn->inCursor;  					/* 					 * If error is ""cannot connect now"", try the next host if 					 * any (but we don't want to consider additional addresses 					 * for this host, nor is there much point in changing SSL 					 * or GSS mode).  This is helpful when dealing with 					 * standby servers that might not be in hot-standby state. 					 */ 					if (strcmp(conn->last_sqlstate, 							   ERRCODE_CANNOT_CONNECT_NOW) == 0) 					{ 						conn->try_next_host = true; 						goto keep_going; 					}  					/* Check to see if we should mention pgpassfile */ 					pgpassfileWarning(conn);  #ifdef ENABLE_GSS  					/* 					 * If gssencmode is ""prefer"" and we're using GSSAPI, retry 					 * without it. 					 */ 					if (conn->gssenc && conn->gssencmode[0] == 'p') 					{ 						/* only retry once */ 						conn->try_gss = false; 						need_new_connection = true; 						goto keep_going; 					} #endif  #ifdef USE_SSL  					/* 					 * if sslmode is ""allow"" and we haven't tried an SSL 					 * connection already, then retry with an SSL connection 					 */ 					if (conn->sslmode[0] == 'a' /* ""allow"" */ 						&& !conn->ssl_in_use 						&& conn->allow_ssl_try 						&& conn->wait_ssl_try) 					{ 						/* only retry once */ 						conn->wait_ssl_try = false; 						need_new_connection = true; 						goto keep_going; 					}  					/* 					 * if sslmode is ""prefer"" and we're in an SSL connection, 					 * then do a non-SSL retry 					 */ 					if (conn->sslmode[0] == 'p' /* ""prefer"" */ 						&& conn->ssl_in_use 						&& conn->allow_ssl_try	/* redundant? */ 						&& !conn->wait_ssl_try) /* redundant? */ 					{ 						/* only retry once */ 						conn->allow_ssl_try = false; 						need_new_connection = true; 						goto keep_going; 					} #endif  					goto error_return; 				}  				/* It is an authentication request. */ 				conn->auth_req_received = true;  				/* Get the type of request. */ 				if (pqGetInt((int *) &areq, 4, conn)) 				{ 					/* We'll come back when there are more data */ 					return PGRES_POLLING_READING; 				} 				msgLength -= 4;  				/* 				 * Process the rest of the authentication request message, and 				 * respond to it if necessary. 				 * 				 * Note that conn->pghost must be non-NULL if we are going to 				 * avoid the Kerberos code doing a hostname look-up. 				 */ 				res = pg_fe_sendauth(areq, msgLength, conn);  				/* OK, we have processed the message; mark data consumed */ 				conn->inStart = conn->inCursor;  				if (res != STATUS_OK) 					goto error_return;  				/* 				 * Just make sure that any data sent by pg_fe_sendauth is 				 * flushed out.  Although this theoretically could block, it 				 * really shouldn't since we don't send large auth responses. 				 */ 				if (pqFlush(conn)) 					goto error_return;  				if (areq == AUTH_REQ_OK) 				{ 					/* We are done with authentication exchange */ 					conn->status = CONNECTION_AUTH_OK;  					/* 					 * Set asyncStatus so that PQgetResult will think that 					 * what comes back next is the result of a query.  See 					 * below. 					 */ 					conn->asyncStatus = PGASYNC_BUSY; 				}  				/* Look to see if we have more data yet. */ 				goto keep_going; 			}  		case CONNECTION_AUTH_OK: 			{ 				/* 				 * Now we expect to hear from the backend. A ReadyForQuery 				 * message indicates that startup is successful, but we might 				 * also get an Error message indicating failure. (Notice 				 * messages indicating nonfatal warnings are also allowed by 				 * the protocol, as are ParameterStatus and BackendKeyData 				 * messages.) Easiest way to handle this is to let 				 * PQgetResult() read the messages. We just have to fake it 				 * out about the state of the connection, by setting 				 * asyncStatus = PGASYNC_BUSY (done above). 				 */  				if (PQisBusy(conn)) 					return PGRES_POLLING_READING;  				res = PQgetResult(conn);  				/* 				 * NULL return indicating we have gone to IDLE state is 				 * expected 				 */ 				if (res) 				{ 					if (res->resultStatus != PGRES_FATAL_ERROR) 						appendPQExpBufferStr(&conn->errorMessage, 											 libpq_gettext(""unexpected message from server during startup\n"")); 					else if (conn->send_appname && 							 (conn->appname || conn->fbappname)) 					{ 						/* 						 * If we tried to send application_name, check to see 						 * if the error is about that --- pre-9.0 servers will 						 * reject it at this stage of the process.  If so, 						 * close the connection and retry without sending 						 * application_name.  We could possibly get a false 						 * SQLSTATE match here and retry uselessly, but there 						 * seems no great harm in that; we'll just get the 						 * same error again if it's unrelated. 						 */ 						const char *sqlstate;  						sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE); 						if (sqlstate && 							strcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0) 						{ 							PQclear(res); 							conn->send_appname = false; 							need_new_connection = true; 							goto keep_going; 						} 					}  					/* 					 * if the resultStatus is FATAL, then conn->errorMessage 					 * already has a copy of the error; needn't copy it back. 					 * But add a newline if it's not there already, since 					 * postmaster error messages may not have one. 					 */ 					if (conn->errorMessage.len <= 0 || 						conn->errorMessage.data[conn->errorMessage.len - 1] != '\n') 						appendPQExpBufferChar(&conn->errorMessage, '\n'); 					PQclear(res); 					goto error_return; 				}  				/* Almost there now ... */ 				conn->status = CONNECTION_CHECK_TARGET; 				goto keep_going; 			}  		case CONNECTION_CHECK_TARGET: 			{ 				/* 				 * If a read-write, read-only, primary, or standby connection 				 * is required, see if we have one. 				 */ 				if (conn->target_server_type == SERVER_TYPE_READ_WRITE || 					conn->target_server_type == SERVER_TYPE_READ_ONLY) 				{ 					bool		read_only_server;  					/* 					 * If the server didn't report 					 * ""default_transaction_read_only"" or ""in_hot_standby"" at 					 * startup, we must determine its state by sending the 					 * query ""SHOW transaction_read_only"".  This GUC exists in 					 * all server versions that support 3.0 protocol. 					 */ 					if (conn->default_transaction_read_only == PG_BOOL_UNKNOWN || 						conn->in_hot_standby == PG_BOOL_UNKNOWN) 					{ 						/* 						 * We use PQsendQueryContinue so that 						 * conn->errorMessage does not get cleared.  We need 						 * to preserve any error messages related to previous 						 * hosts we have tried and failed to connect to. 						 */ 						conn->status = CONNECTION_OK; 						if (!PQsendQueryContinue(conn, 												 ""SHOW transaction_read_only"")) 							goto error_return; 						/* We'll return to this state when we have the answer */ 						conn->status = CONNECTION_CHECK_WRITABLE; 						return PGRES_POLLING_READING; 					}  					/* OK, we can make the test */ 					read_only_server = 						(conn->default_transaction_read_only == PG_BOOL_YES || 						 conn->in_hot_standby == PG_BOOL_YES);  					if ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ? 						read_only_server : !read_only_server) 					{ 						/* Wrong server state, reject and try the next host */ 						if (conn->target_server_type == SERVER_TYPE_READ_WRITE) 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""session is read-only\n"")); 						else 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""session is not read-only\n""));  						/* Close connection politely. */ 						conn->status = CONNECTION_OK; 						sendTerminateConn(conn);  						/* 						 * Try next host if any, but we don't want to consider 						 * additional addresses for this host. 						 */ 						conn->try_next_host = true; 						goto keep_going; 					} 				} 				else if (conn->target_server_type == SERVER_TYPE_PRIMARY || 						 conn->target_server_type == SERVER_TYPE_STANDBY || 						 conn->target_server_type == SERVER_TYPE_PREFER_STANDBY) 				{ 					/* 					 * If the server didn't report ""in_hot_standby"" at 					 * startup, we must determine its state by sending the 					 * query ""SELECT pg_catalog.pg_is_in_recovery()"".  Servers 					 * before 9.0 don't have that function, but by the same 					 * token they don't have any standby mode, so we may just 					 * assume the result. 					 */ 					if (conn->sversion < 90000) 						conn->in_hot_standby = PG_BOOL_NO;  					if (conn->in_hot_standby == PG_BOOL_UNKNOWN) 					{ 						/* 						 * We use PQsendQueryContinue so that 						 * conn->errorMessage does not get cleared.  We need 						 * to preserve any error messages related to previous 						 * hosts we have tried and failed to connect to. 						 */ 						conn->status = CONNECTION_OK; 						if (!PQsendQueryContinue(conn, 												 ""SELECT pg_catalog.pg_is_in_recovery()"")) 							goto error_return; 						/* We'll return to this state when we have the answer */ 						conn->status = CONNECTION_CHECK_STANDBY; 						return PGRES_POLLING_READING; 					}  					/* OK, we can make the test */ 					if ((conn->target_server_type == SERVER_TYPE_PRIMARY) ? 						(conn->in_hot_standby == PG_BOOL_YES) : 						(conn->in_hot_standby == PG_BOOL_NO)) 					{ 						/* Wrong server state, reject and try the next host */ 						if (conn->target_server_type == SERVER_TYPE_PRIMARY) 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""server is in hot standby mode\n"")); 						else 							appendPQExpBufferStr(&conn->errorMessage, 												 libpq_gettext(""server is not in hot standby mode\n""));  						/* Close connection politely. */ 						conn->status = CONNECTION_OK; 						sendTerminateConn(conn);  						/* 						 * Try next host if any, but we don't want to consider 						 * additional addresses for this host. 						 */ 						conn->try_next_host = true; 						goto keep_going; 					} 				}  				/* We can release the address list now. */ 				release_conn_addrinfo(conn);  				/* 				 * Contents of conn->errorMessage are no longer interesting 				 * (and it seems some clients expect it to be empty after a 				 * successful connection). 				 */ 				resetPQExpBuffer(&conn->errorMessage);  				/* We are open for business! */ 				conn->status = CONNECTION_OK; 				return PGRES_POLLING_OK; 			}  		case CONNECTION_CONSUME: 			{ 				/* 				 * This state just makes sure the connection is idle after 				 * we've obtained the result of a SHOW or SELECT query.  Once 				 * we're clear, return to CONNECTION_CHECK_TARGET state to 				 * decide what to do next.  We must transiently set status = 				 * CONNECTION_OK in order to use the result-consuming 				 * subroutines. 				 */ 				conn->status = CONNECTION_OK; 				if (!PQconsumeInput(conn)) 					goto error_return;  				if (PQisBusy(conn)) 				{ 					conn->status = CONNECTION_CONSUME; 					return PGRES_POLLING_READING; 				}  				/* Call PQgetResult() again until we get a NULL result */ 				res = PQgetResult(conn); 				if (res != NULL) 				{ 					PQclear(res); 					conn->status = CONNECTION_CONSUME; 					return PGRES_POLLING_READING; 				}  				conn->status = CONNECTION_CHECK_TARGET; 				goto keep_going; 			}  		case CONNECTION_CHECK_WRITABLE: 			{ 				/* 				 * Waiting for result of ""SHOW transaction_read_only"".  We 				 * must transiently set status = CONNECTION_OK in order to use 				 * the result-consuming subroutines. 				 */ 				conn->status = CONNECTION_OK; 				if (!PQconsumeInput(conn)) 					goto error_return;  				if (PQisBusy(conn)) 				{ 					conn->status = CONNECTION_CHECK_WRITABLE; 					return PGRES_POLLING_READING; 				}  				res = PQgetResult(conn); 				if (res && PQresultStatus(res) == PGRES_TUPLES_OK && 					PQntuples(res) == 1) 				{ 					char	   *val = PQgetvalue(res, 0, 0);  					/* 					 * ""transaction_read_only = on"" proves that at least one 					 * of default_transaction_read_only and in_hot_standby is 					 * on, but we don't actually know which.  We don't care 					 * though for the purpose of identifying a read-only 					 * session, so satisfy the CONNECTION_CHECK_TARGET code by 					 * claiming they are both on.  On the other hand, if it's 					 * a read-write session, they are certainly both off. 					 */ 					if (strncmp(val, ""on"", 2) == 0) 					{ 						conn->default_transaction_read_only = PG_BOOL_YES; 						conn->in_hot_standby = PG_BOOL_YES; 					} 					else 					{ 						conn->default_transaction_read_only = PG_BOOL_NO; 						conn->in_hot_standby = PG_BOOL_NO; 					} 					PQclear(res);  					/* Finish reading messages before continuing */ 					conn->status = CONNECTION_CONSUME; 					goto keep_going; 				}  				/* Something went wrong with ""SHOW transaction_read_only"". */ 				if (res) 					PQclear(res);  				/* Append error report to conn->errorMessage. */ 				appendPQExpBuffer(&conn->errorMessage, 								  libpq_gettext(""\""%s\"" failed\n""), 								  ""SHOW transaction_read_only"");  				/* Close connection politely. */ 				conn->status = CONNECTION_OK; 				sendTerminateConn(conn);  				/* Try next host. */ 				conn->try_next_host = true; 				goto keep_going; 			}  		case CONNECTION_CHECK_STANDBY: 			{ 				/* 				 * Waiting for result of ""SELECT pg_is_in_recovery()"".  We 				 * must transiently set status = CONNECTION_OK in order to use 				 * the result-consuming subroutines. 				 */ 				conn->status = CONNECTION_OK; 				if (!PQconsumeInput(conn)) 					goto error_return;  				if (PQisBusy(conn)) 				{ 					conn->status = CONNECTION_CHECK_STANDBY; 					return PGRES_POLLING_READING; 				}  				res = PQgetResult(conn); 				if (res && PQresultStatus(res) == PGRES_TUPLES_OK && 					PQntuples(res) == 1) 				{ 					char	   *val = PQgetvalue(res, 0, 0);  					if (strncmp(val, ""t"", 1) == 0) 						conn->in_hot_standby = PG_BOOL_YES; 					else 						conn->in_hot_standby = PG_BOOL_NO; 					PQclear(res);  					/* Finish reading messages before continuing */ 					conn->status = CONNECTION_CONSUME; 					goto keep_going; 				}  				/* Something went wrong with ""SELECT pg_is_in_recovery()"". */ 				if (res) 					PQclear(res);  				/* Append error report to conn->errorMessage. */ 				appendPQExpBuffer(&conn->errorMessage, 								  libpq_gettext(""\""%s\"" failed\n""), 								  ""SELECT pg_is_in_recovery()"");  				/* Close connection politely. */ 				conn->status = CONNECTION_OK; 				sendTerminateConn(conn);  				/* Try next host. */ 				conn->try_next_host = true; 				goto keep_going; 			}  		default: 			appendPQExpBuffer(&conn->errorMessage, 							  libpq_gettext(""invalid connection state %d, "" 											""probably indicative of memory corruption\n""), 							  conn->status); 			goto error_return; 	}  	/* Unreachable */  error_return:  	/* 	 * We used to close the socket at this point, but that makes it awkward 	 * for those above us if they wish to remove this socket from their own 	 * records (an fd_set for example).  We'll just have this socket closed 	 * when PQfinish is called (which is compulsory even after an error, since 	 * the connection structure must be freed). 	 */ 	conn->status = CONNECTION_BAD; 	return PGRES_POLLING_FAILED; }"
"195389_CWE-617.cc","CWE-617","bool RepeatedAttrDefEqual(     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {   std::unordered_map<string, const OpDef::AttrDef*> a1_set;   for (const OpDef::AttrDef& def : a1) {     DCHECK(a1_set.find(def.name()) == a1_set.end())         << ""AttrDef names must be unique, but '"" << def.name()         << ""' appears more than once"";     a1_set[def.name()] = &def;   }   for (const OpDef::AttrDef& def : a2) {     auto iter = a1_set.find(def.name());     if (iter == a1_set.end()) return false;     if (!AttrDefEqual(*iter->second, def)) return false;     a1_set.erase(iter);   }   if (!a1_set.empty()) return false;   return true; }"
"195391_CWE-190.cc","CWE-190","  void Compute(tensorflow::OpKernelContext* context) override {     for (int ngram_width : ngram_widths_) {       OP_REQUIRES(           context, ngram_width > 0,           errors::InvalidArgument(""ngram_widths must contain positive values""));     }      const tensorflow::Tensor* data;     OP_REQUIRES_OK(context, context->input(""data"", &data));     const auto& input_data = data->flat<tstring>().data();      const tensorflow::Tensor* splits;     OP_REQUIRES_OK(context, context->input(""data_splits"", &splits));     const auto& splits_vec = splits->flat<SPLITS_TYPE>();      // Validate that the splits are valid indices into data, only if there are     // splits specified.     const int input_data_size = data->flat<tstring>().size();     const int splits_vec_size = splits_vec.size();     if (splits_vec_size > 0) {       int prev_split = splits_vec(0);       OP_REQUIRES(context, prev_split == 0,                   errors::InvalidArgument(""First split value must be 0, got "",                                           prev_split));       for (int i = 1; i < splits_vec_size; ++i) {         bool valid_splits = splits_vec(i) >= prev_split;         valid_splits = valid_splits && (splits_vec(i) <= input_data_size);         OP_REQUIRES(context, valid_splits,                     errors::InvalidArgument(                         ""Invalid split value "", splits_vec(i), "", must be in ["",                         prev_split, "", "", input_data_size, ""]""));         prev_split = splits_vec(i);       }       OP_REQUIRES(context, prev_split == input_data_size,                   errors::InvalidArgument(                       ""Last split value must be data size. Expected "",                       input_data_size, "", got "", prev_split));     }      int num_batch_items = splits_vec.size() - 1;     tensorflow::Tensor* ngrams_splits;     OP_REQUIRES_OK(         context, context->allocate_output(1, splits->shape(), &ngrams_splits));     auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();      // If there is no data or size, return an empty RT.     if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {       tensorflow::Tensor* empty;       OP_REQUIRES_OK(context,                      context->allocate_output(0, data->shape(), &empty));       for (int i = 0; i <= num_batch_items; ++i) {         ngrams_splits_data[i] = 0;       }       return;     }      ngrams_splits_data[0] = 0;     for (int i = 1; i <= num_batch_items; ++i) {       int length = splits_vec(i) - splits_vec(i - 1);       int num_ngrams = 0;       for (int ngram_width : ngram_widths_)         num_ngrams += get_num_ngrams(length, ngram_width);       if (preserve_short_ && length > 0 && num_ngrams == 0) {         num_ngrams = 1;       }       ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;     }      tensorflow::Tensor* ngrams;     OP_REQUIRES_OK(         context,         context->allocate_output(             0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));     auto ngrams_data = ngrams->flat<tstring>().data();      for (int i = 0; i < num_batch_items; ++i) {       auto data_start = &input_data[splits_vec(i)];       int output_start_idx = ngrams_splits_data[i];       for (int ngram_width : ngram_widths_) {         auto output_start = &ngrams_data[output_start_idx];         int length = splits_vec(i + 1) - splits_vec(i);         int num_ngrams = get_num_ngrams(length, ngram_width);         CreateNgrams(data_start, output_start, num_ngrams, ngram_width);         output_start_idx += num_ngrams;       }       // If we're preserving short sequences, check to see if no sequence was       // generated by comparing the current output start idx to the original       // one (ngram_splits_data). If no ngrams were generated, then they will       // be equal (since we increment output_start_idx by num_ngrams every       // time we create a set of ngrams.)       if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {         int data_length = splits_vec(i + 1) - splits_vec(i);         // One legitimate reason to not have any ngrams when preserve_short_         // is true is if the sequence itself is empty. In that case, move on.         if (data_length == 0) {           continue;         }         // We don't have to worry about dynamic padding sizes here: if padding         // was dynamic, every sequence would have had sufficient padding to         // generate at least one ngram.         int ngram_width = data_length + 2 * pad_width_;         auto output_start = &ngrams_data[output_start_idx];         int num_ngrams = 1;         CreateNgrams(data_start, output_start, num_ngrams, ngram_width);       }     }   }"
"195398_CWE-134.c","CWE-134","static int vidioc_querycap(struct file *file, void *priv, 			   struct v4l2_capability *cap) { 	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file); 	int labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ? 			       sizeof(cap->card) : 				     sizeof(dev->card_label); 	int device_nr = 		((struct v4l2loopback_private *)video_get_drvdata(dev->vdev)) 			->device_nr; 	__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;  	strlcpy(cap->driver, ""v4l2 loopback"", sizeof(cap->driver)); 	snprintf(cap->card, labellen, dev->card_label); 	snprintf(cap->bus_info, sizeof(cap->bus_info), 		 ""platform:v4l2loopback-%03d"", device_nr);  #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0) 	/* since 3.1.0, the v4l2-core system is supposed to set the version */ 	cap->version = V4L2LOOPBACK_VERSION_CODE; #endif  #ifdef V4L2_CAP_VIDEO_M2M 	capabilities |= V4L2_CAP_VIDEO_M2M; #endif /* V4L2_CAP_VIDEO_M2M */  	if (dev->announce_all_caps) { 		capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT; 	} else { 		if (dev->ready_for_capture) { 			capabilities |= V4L2_CAP_VIDEO_CAPTURE; 		} 		if (dev->ready_for_output) { 			capabilities |= V4L2_CAP_VIDEO_OUTPUT; 		} 	}  #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0) 	dev->vdev->device_caps = #endif /* >=linux-4.7.0 */ 		cap->device_caps = cap->capabilities = capabilities;  #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0) 	cap->capabilities |= V4L2_CAP_DEVICE_CAPS; #endif  	memset(cap->reserved, 0, sizeof(cap->reserved)); 	return 0; }"
"195399_CWE-476.cc","CWE-476","bool IsIdentityConsumingSwitch(const MutableGraphView& graph,                                const NodeDef& node) {   if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&       node.input_size() > 0) {     TensorId tensor_id = ParseTensorName(node.input(0));     if (IsTensorIdControlling(tensor_id)) {       return false;     }      NodeDef* input_node = graph.GetNode(tensor_id.node());     return IsSwitch(*input_node);   }   return false; }"
"195402_CWE-190.c","CWE-190","int TfLiteIntArrayGetSizeInBytes(int size) {   static TfLiteIntArray dummy;    int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; #if defined(_MSC_VER)   // Context for why this is needed is in http://b/189926408#comment21   computed_size -= sizeof(dummy.data[0]); #endif   return computed_size; }"
"195403_CWE-190.c","CWE-190","TfLiteIntArray* TfLiteIntArrayCreate(int size) {   int alloc_size = TfLiteIntArrayGetSizeInBytes(size);   if (alloc_size <= 0) return NULL;   TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);   if (!ret) return ret;   ret->size = size;   return ret; }"
"195404_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* context) override {     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>         ConstEigenMatrixMap;     typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>         EigenMatrixMap;      constexpr int tensor_in_and_out_dims = 4;      const Tensor& tensor_in = context->input(0);     OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,                 errors::InvalidArgument(""tensor_in must be 4-dimensional""));      std::vector<int> input_size(tensor_in_and_out_dims);     std::vector<int> output_size(tensor_in_and_out_dims);     for (int i = 0; i < tensor_in_and_out_dims; ++i) {       input_size[i] = tensor_in.dim_size(i);     }     // Output size.     for (int i = 0; i < tensor_in_and_out_dims; ++i) {       // This must match the same logic in the shape function in       // core/ops/nn_ops.cc.       output_size[i] =           static_cast<int>(std::floor(input_size[i] / pooling_ratio_[i]));       DCHECK_GT(output_size[i], 0);     }      // Generate pooling sequence.     std::vector<int64_t> height_cum_seq;     std::vector<int64_t> width_cum_seq;     GuardedPhiloxRandom generator;     generator.Init(seed_, seed2_);     height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],                                              &generator, pseudo_random_);     width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],                                             &generator, pseudo_random_);      // Prepare output.     Tensor* output_tensor = nullptr;     OP_REQUIRES_OK(context, context->allocate_output(                                 0,                                 TensorShape({output_size[0], output_size[1],                                              output_size[2], output_size[3]}),                                 &output_tensor));     Tensor* output_height_seq_tensor = nullptr;     OP_REQUIRES_OK(         context,         context->allocate_output(             1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),             &output_height_seq_tensor));     Tensor* output_width_seq_tensor = nullptr;     OP_REQUIRES_OK(         context,         context->allocate_output(             2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),             &output_width_seq_tensor));      ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(), input_size[3],                                input_size[2] * input_size[1] * input_size[0]);      EigenMatrixMap out_mat(output_tensor->flat<T>().data(), output_size[3],                            output_size[2] * output_size[1] * output_size[0]);      // Initializes the output tensor with MIN<T>.     output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());      auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();     auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();      // Set output tensors.     for (int i = 0; i < height_cum_seq.size(); ++i) {       output_height_seq_flat(i) = height_cum_seq[i];     }      for (int i = 0; i < width_cum_seq.size(); ++i) {       output_width_seq_flat(i) = width_cum_seq[i];     }      // For both input and output,     // 0: batch     // 1: height / row     // 2: width / col     // 3: depth / channel     const int64_t height_max = input_size[1] - 1;     const int64_t width_max = input_size[2] - 1;     for (int64_t b = 0; b < input_size[0]; ++b) {       // height sequence.       for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {         // height start and end.         const int64_t height_start = height_cum_seq[hs];         int64_t height_end =             overlapping_ ? height_cum_seq[hs + 1] : height_cum_seq[hs + 1] - 1;         height_end = std::min(height_end, height_max);          // width sequence.         for (int64_t ws = 0; ws < width_cum_seq.size() - 1; ++ws) {           const int64_t out_offset =               (b * output_size[1] + hs) * output_size[2] + ws;           // width start and end.           const int64_t width_start = width_cum_seq[ws];           int64_t width_end =               overlapping_ ? width_cum_seq[ws + 1] : width_cum_seq[ws + 1] - 1;           width_end = std::min(width_end, width_max);           for (int64_t h = height_start; h <= height_end; ++h) {             for (int64_t w = width_start; w <= width_end; ++w) {               const int64_t in_offset =                   (b * input_size[1] + h) * input_size[2] + w;               out_mat.col(out_offset) =                   out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));             }           }         }       }     }   }"
"195405_CWE-190.c","CWE-190","static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define CropBox  ""CropBox"" #define DeviceCMYK  ""DeviceCMYK"" #define MediaBox  ""MediaBox"" #define RenderPCLText  ""  Rendering PCL...  ""    char     command[MaxTextExtent],     *density,     filename[MaxTextExtent],     geometry[MaxTextExtent],     *options,     input_filename[MaxTextExtent];    const DelegateInfo     *delegate_info;    Image     *image,     *next_image;    ImageInfo     *read_info;    int     c;    MagickBooleanType     cmyk,     status;    PointInfo     delta;    RectangleInfo     bounding_box,     page;    char     *p;    SegmentInfo     bounds;    size_t     height,     width;    ssize_t     count;    assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   /*     Open image file.   */   image=AcquireImage(image_info);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);   if (status == MagickFalse)     {       ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",         image_info->filename);       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Set the page density.   */   delta.x=DefaultResolution;   delta.y=DefaultResolution;   if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))     {       GeometryInfo         geometry_info;        MagickStatusType         flags;        flags=ParseGeometry(PSDensityGeometry,&geometry_info);       if ((flags & RhoValue) != 0)         image->x_resolution=geometry_info.rho;       image->y_resolution=image->x_resolution;       if ((flags & SigmaValue) != 0)         image->y_resolution=geometry_info.sigma;     }   /*     Determine page geometry from the PCL media box.   */   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;   count=0;   (void) memset(&bounding_box,0,sizeof(bounding_box));   (void) memset(&bounds,0,sizeof(bounds));   (void) memset(&page,0,sizeof(page));   (void) memset(command,0,sizeof(command));   p=command;   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))   {     if (image_info->page != (char *) NULL)       continue;     /*       Note PCL elements.     */     *p++=(char) c;     if ((c != (int) '/') && (c != '\n') &&         ((size_t) (p-command) < (MaxTextExtent-1)))       continue;     *p='\0';     p=command;     /*       Is this a CMYK document?     */     if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)       cmyk=MagickTrue;     if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)       {         /*           Note region defined by crop box.         */         count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);         if (count != 4)           count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);       }     if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)       {         /*           Note region defined by media box.         */         count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",           &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);         if (count != 4)           count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",             &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);       }     if (count != 4)       continue;     /*       Set PCL render geometry.     */     width=(size_t) floor(bounds.x2-bounds.x1+0.5);     height=(size_t) floor(bounds.y2-bounds.y1+0.5);     if (width > page.width)       page.width=width;     if (height > page.height)       page.height=height;   }   (void) CloseBlob(image);   /*     Render PCL with the GhostPCL delegate.   */   if ((page.width == 0) || (page.height == 0))     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);   if (image_info->page != (char *) NULL)     (void) ParseAbsoluteGeometry(image_info->page,&page);   (void) FormatLocaleString(geometry,MaxTextExtent,""%.20gx%.20g"",(double)     page.width,(double) page.height);   if (image_info->monochrome != MagickFalse)     delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);   else      if (cmyk != MagickFalse)        delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);      else        delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);   if (delegate_info == (const DelegateInfo *) NULL)     {       image=DestroyImage(image);       return((Image *) NULL);     }   if ((page.width == 0) || (page.height == 0))     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);   if (image_info->page != (char *) NULL)     (void) ParseAbsoluteGeometry(image_info->page,&page);   density=AcquireString("""");   options=AcquireString("""");   (void) FormatLocaleString(density,MaxTextExtent,""%gx%g"",     image->x_resolution,image->y_resolution);   if (image_info->ping != MagickFalse)     (void) FormatLocaleString(density,MagickPathExtent,""2.0x2.0"");   page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+     0.5);   page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+     0.5);   (void) FormatLocaleString(options,MaxTextExtent,""-g%.20gx%.20g "",(double)      page.width,(double) page.height);   image=DestroyImage(image);   read_info=CloneImageInfo(image_info);   *read_info->magick='\0';   if (read_info->number_scenes != 0)     {       if (read_info->number_scenes != 1)         (void) FormatLocaleString(options,MaxTextExtent,""-dLastPage=%.20g"",           (double) (read_info->scene+read_info->number_scenes));       else         (void) FormatLocaleString(options,MaxTextExtent,           ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,           (double) (read_info->scene+read_info->number_scenes));       read_info->number_scenes=0;       if (read_info->scenes != (char *) NULL)         *read_info->scenes='\0';     }   (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);   (void) AcquireUniqueFilename(read_info->filename);   (void) FormatLocaleString(command,MaxTextExtent,     GetDelegateCommands(delegate_info),     read_info->antialias != MagickFalse ? 4 : 1,     read_info->antialias != MagickFalse ? 4 : 1,density,options,     read_info->filename,input_filename);   options=DestroyString(options);   density=DestroyString(density);   status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,     (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;   image=ReadImage(read_info,exception);   (void) RelinquishUniqueFileResource(read_info->filename);   (void) RelinquishUniqueFileResource(input_filename);   read_info=DestroyImageInfo(read_info);   if (image == (Image *) NULL)     ThrowReaderException(DelegateError,""PCLDelegateFailed"");   if (LocaleCompare(image->magick,""BMP"") == 0)     {       Image         *cmyk_image;        cmyk_image=ConsolidateCMYKImages(image,&image->exception);       if (cmyk_image != (Image *) NULL)         {           image=DestroyImageList(image);           image=cmyk_image;         }     }   do   {     (void) CopyMagickString(image->filename,filename,MaxTextExtent);     image->page=page;     if (image_info->ping != MagickFalse)       {         image->magick_columns*=image->x_resolution/2.0;         image->magick_rows*=image->y_resolution/2.0;         image->columns*=image->x_resolution/2.0;         image->rows*=image->y_resolution/2.0;       }     next_image=SyncNextImageInList(image);     if (next_image != (Image *) NULL)       image=next_image;   } while (next_image != (Image *) NULL);   return(GetFirstImageInList(image)); }"
"195409_CWE-476.c","CWE-476"," void gitn_box_del(GF_Box *s) { 	u32 i; 	GroupIdToNameBox *ptr = (GroupIdToNameBox *)s; 	if (ptr == NULL) return; 	for (i=0; i<ptr->nb_entries; i++) { 		if (ptr->entries[i].name) gf_free(ptr->entries[i].name); 	} 	if (ptr->entries) gf_free(ptr->entries); 	gf_free(ptr);"
"195410_CWE-476.cc","CWE-476","  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {     // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in     // the step container, and return it as the output.     const Tensor* indices;     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices));     const Tensor* values;     OP_REQUIRES_OK(ctx, ctx->input(""values"", &values));     const Tensor* dense_shape;     OP_REQUIRES_OK(ctx, ctx->input(""dense_shape"", &dense_shape));      OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),                 errors::InvalidArgument(                     ""Input indices should be a matrix but received shape "",                     indices->shape().DebugString()));      const auto num_indices = indices->NumElements();     const auto num_values = values->NumElements();     if (num_indices == 0 || num_values == 0) {       OP_REQUIRES(ctx, num_indices == num_values,                   errors::InvalidArgument(                       ""If indices or values are empty, the other one must also ""                       ""be. Got indices of shape "",                       indices->shape().DebugString(), "" and values of shape "",                       values->shape().DebugString()));     }     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),                 errors::InvalidArgument(                     ""Input values should be a vector but received shape "",                     indices->shape().DebugString()));     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),                 errors::InvalidArgument(                     ""Input shape should be a vector but received shape "",                     dense_shape->shape().DebugString()));      // We currently ensure that `sparse_tensor` is ordered in the     // batch dimension.     // TODO(mrry): Investigate ways to avoid this unconditional check     // if we can be sure that the sparse tensor was produced in an     // appropriate order (e.g. by `tf.parse_example()` or a Dataset     // that batches elements into rows of a SparseTensor).     int64_t previous_batch_index = -1;     for (int64_t i = 0; i < indices->dim_size(0); ++i) {       int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);       OP_REQUIRES(           ctx, next_batch_index >= previous_batch_index,           errors::Unimplemented(""The SparseTensor must be ordered in the batch ""                                 ""dimension; handling arbitrarily ordered input ""                                 ""is not currently supported.""));       previous_batch_index = next_batch_index;     }     gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);     sparse::SparseTensor tensor;     OP_REQUIRES_OK(         ctx, sparse::SparseTensor::Create(                  *indices, *values, TensorShape(dense_shape->vec<int64_t>()),                  std_order, &tensor));     *output = new Dataset<T>(ctx, std::move(tensor));   }"
"195471_CWE-476.c","CWE-476","IRC_PROTOCOL_CALLBACK(352) {     char *pos_attr, *pos_hopcount, *pos_realname, *str_host;     int arg_start, length;     struct t_irc_channel *ptr_channel;     struct t_irc_nick *ptr_nick;      IRC_PROTOCOL_MIN_ARGS(5);      /* silently ignore malformed 352 message (missing infos) */     if (argc < 8)         return WEECHAT_RC_OK;      pos_attr = NULL;     pos_hopcount = NULL;     pos_realname = NULL;      if (argc > 8)     {         arg_start = (strcmp (argv[8], ""*"") == 0) ? 9 : 8;         if (argv[arg_start][0] == ':')         {             pos_attr = NULL;             pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;             pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;         }         else         {             pos_attr = argv[arg_start];             pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;             pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;         }     }      ptr_channel = irc_channel_search (server, argv[3]);     ptr_nick = (ptr_channel) ?         irc_nick_search (server, ptr_channel, argv[7]) : NULL;      /* update host in nick */     if (ptr_nick)     {         length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;         str_host = malloc (length);         if (str_host)         {             snprintf (str_host, length, ""%s@%s"", argv[4], argv[5]);             irc_nick_set_host (ptr_nick, str_host);             free (str_host);         }     }      /* update away flag in nick */     if (ptr_channel && ptr_nick && pos_attr)     {         irc_nick_set_away (server, ptr_channel, ptr_nick,                            (pos_attr[0] == 'G') ? 1 : 0);     }      /* update realname in nick */     if (ptr_channel && ptr_nick && pos_realname)     {         if (ptr_nick->realname)             free (ptr_nick->realname);         if (pos_realname &&             weechat_hashtable_has_key (server->cap_list, ""extended-join""))         {             ptr_nick->realname = strdup (pos_realname);         }         else         {             ptr_nick->realname = NULL;         }     }      /* display output of who (manual who from user) */     if (!ptr_channel || (ptr_channel->checking_whox <= 0))     {         weechat_printf_date_tags (             irc_msgbuffer_get_target_buffer (                 server, NULL, command, ""who"", NULL),             date,             irc_protocol_tags (command, ""irc_numeric"", NULL, NULL),             ""%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)"",             weechat_prefix (""network""),             IRC_COLOR_CHAT_DELIMITERS,             IRC_COLOR_CHAT_CHANNEL,             argv[3],             IRC_COLOR_CHAT_DELIMITERS,             irc_nick_color_for_msg (server, 1, NULL, argv[7]),             argv[7],             IRC_COLOR_CHAT_DELIMITERS,             IRC_COLOR_CHAT_HOST,             argv[4],             argv[5],             IRC_COLOR_CHAT_DELIMITERS,             IRC_COLOR_RESET,             (pos_attr) ? pos_attr : """",             (pos_attr) ? "" "" : """",             (pos_hopcount) ? pos_hopcount : """",             (pos_hopcount) ? "" "" : """",             (pos_realname) ? pos_realname : """");     }      return WEECHAT_RC_OK; }"
"195549_CWE-125.cpp","CWE-125","bool JSON_parser(Variant &z, const char *p, int length, bool const assoc,                  int depth, int64_t options) {   // No GC safepoints during JSON parsing, please. Code is not re-entrant.   NoHandleSurpriseScope no_surprise(SafepointFlags);    json_parser *json = s_json_parser.get(); /* the parser state */   // Clear and reuse the thread-local string buffers. They are only freed if   // they exceed kMaxPersistentStringBufferCapacity at exit or if the thread   // is explicitly flushed (e.g., due to being idle).   json->initSb(length);   SCOPE_EXIT {     constexpr int kMaxPersistentStringBufferCapacity = 256 * 1024;     if (json->sb_cap > kMaxPersistentStringBufferCapacity) json->flushSb();   };   // SimpleParser only handles the most common set of options. Also, only use it   // if its array nesting depth check is *more* restrictive than what the user   // asks for, to ensure that the precise semantics of the general case is   // applied for all nesting overflows.   if (assoc &&       options == (options & (k_JSON_FB_LOOSE |                              k_JSON_FB_DARRAYS |                              k_JSON_FB_DARRAYS_AND_VARRAYS |                              k_JSON_FB_HACK_ARRAYS |                              k_JSON_FB_THRIFT_SIMPLE_JSON |                              k_JSON_FB_LEGACY_HACK_ARRAYS)) &&       depth >= SimpleParser::kMaxArrayDepth &&       length <= RuntimeOption::EvalSimpleJsonMaxLength &&       SimpleParser::TryParse(p, length, json->tl_buffer.tv, z,                              get_container_type_from_options(options),                              options & k_JSON_FB_THRIFT_SIMPLE_JSON)) {     return true;   }    int b;  /* the next character */   int c;  /* the next character class */   int s;  /* the next state */   int state = 0;    /*<fb>*/   bool const loose = options & k_JSON_FB_LOOSE;   JSONContainerType const container_type =     get_container_type_from_options(options);   int qchr = 0;   int8_t const *byte_class;   int8_t const (*next_state_table)[32];   if (loose) {     byte_class = loose_ascii_class;     next_state_table = loose_state_transition_table;   } else {     byte_class = ascii_class;     next_state_table = state_transition_table;   }   /*</fb>*/    UncheckedBuffer *buf = &json->sb_buf;   UncheckedBuffer *key = &json->sb_key;    DataType type = kInvalidDataType;   unsigned short escaped_bytes = 0;    auto reset_type = [&] { type = kInvalidDataType; };    json->depth = depth;   // Since the stack is maintainined on a per request basis, for performance   // reasons, it only makes sense to expand if necessary and cycles are wasted   // contracting. Calls with a depth other than default should be rare.   if (depth > json->stack.size()) {     json->stack.resize(depth);   }   SCOPE_EXIT {     if (json->stack.empty()) return;     for (int i = 0; i <= json->mark; i++) {       json->stack[i].key.reset();       json->stack[i].val.unset();     }     json->mark = -1;   };    json->mark = json->top = -1;   push(json, Mode::DONE);    UTF8To16Decoder decoder(p, length, loose);   for (;;) {     b = decoder.decode();     // Fast-case most common transition: append a simple string character.     if (state == 3 && type == KindOfString) {       while (b != '\""' &&  b != '\\' && b != '\'' && b <= 127 && b >= ' ') {         buf->append((char)b);         b = decoder.decode();       }     }     if (b == UTF8_END) break; // UTF-8 decoding finishes successfully.     if (b == UTF8_ERROR) {       s_json_parser->error_code = JSON_ERROR_UTF8;       return false;     }     assertx(b >= 0);      if ((b & 127) == b) {       /*<fb>*/       c = byte_class[b];       /*</fb>*/       if (c <= S_ERR) {         s_json_parser->error_code = JSON_ERROR_CTRL_CHAR;         return false;       }     } else {       c = S_ETC;     }     /*       Get the next state from the transition table.     */      /*<fb>*/     s = next_state_table[state][c];      if (s == -4) {       if (b != qchr) {         s = 3;       } else {         qchr = 0;       }     }     /*</fb>*/      if (s < 0) {       /*         Perform one of the predefined actions.       */       switch (s) {         /*           empty }         */       case -9:         /*<fb>*/         if (json->top == 1) z = json->stack[json->top].val;         else {         /*</fb>*/           attach_zval(json, json->stack[json->top].key, assoc, container_type);         /*<fb>*/         }         /*</fb>*/         if (!pop(json, Mode::KEY)) {           return false;         }         state = 9;         break;         /*           {         */       case -8:         if (!push(json, Mode::KEY)) {           s_json_parser->error_code = JSON_ERROR_DEPTH;           return false;         }          state = 1;         if (json->top > 0) {           Variant &top = json->stack[json->top].val;           /*<fb>*/           if (container_type == JSONContainerType::COLLECTIONS) {             // stable_maps is meaningless             top = req::make<c_Map>();           } else {           /*</fb>*/             if (!assoc) {               top = SystemLib::AllocStdClassObject();             /* <fb> */             } else if (container_type == JSONContainerType::HACK_ARRAYS) {               top = Array::CreateDict();             } else if (container_type == JSONContainerType::DARRAYS ||                        container_type == JSONContainerType::DARRAYS_AND_VARRAYS)             {               top = Array::CreateDArray();             /* </fb> */             } else if (               container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {               auto arr = staticEmptyDictArray()->copy();               arr->setLegacyArray(true);               top = arr;             } else {               top = Array::CreateDArray();             }           /*<fb>*/           }           /*</fb>*/           json->stack[json->top].key = copy_and_clear(*key);           reset_type();         }         break;         /*           }         */       case -7:         /*** BEGIN Facebook: json_utf8_loose ***/         /*           If this is a trailing comma in an object definition,           we're in Mode::KEY. In that case, throw that off the           stack and restore Mode::OBJECT so that we pretend the           trailing comma just didn't happen.         */         if (loose) {           if (pop(json, Mode::KEY)) {             push(json, Mode::OBJECT);           }         }         /*** END Facebook: json_utf8_loose ***/          if (type != kInvalidDataType &&             json->stack[json->top].mode == Mode::OBJECT) {           Variant mval;           json_create_zval(mval, *buf, type, options);           Variant &top = json->stack[json->top].val;           object_set(json, top, copy_and_clear(*key),                      mval, assoc, container_type);           buf->clear();           reset_type();         }          /*<fb>*/         if (json->top == 1) z = json->stack[json->top].val;         else {         /*</fb>*/           attach_zval(json, json->stack[json->top].key,             assoc, container_type);         /*<fb>*/         }         /*</fb>*/         if (!pop(json, Mode::OBJECT)) {           s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;           return false;         }         state = 9;         break;         /*           [         */       case -6:         if (!push(json, Mode::ARRAY)) {           s_json_parser->error_code = JSON_ERROR_DEPTH;           return false;         }         state = 2;          if (json->top > 0) {           Variant &top = json->stack[json->top].val;           /*<fb>*/           if (container_type == JSONContainerType::COLLECTIONS) {             top = req::make<c_Vector>();           } else if (container_type == JSONContainerType::HACK_ARRAYS) {             top = Array::CreateVec();           } else if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {             top = Array::CreateVArray();           } else if (container_type == JSONContainerType::DARRAYS) {             top = Array::CreateDArray();           } else if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {             auto arr = staticEmptyVecArray()->copy();             arr->setLegacyArray(true);             top = arr;           } else {             top = Array::CreateDArray();           }           /*</fb>*/           json->stack[json->top].key = copy_and_clear(*key);           reset_type();         }         break;         /*           ]         */       case -5:         {           if (type != kInvalidDataType &&                json->stack[json->top].mode == Mode::ARRAY) {             Variant mval;             json_create_zval(mval, *buf, type, options);             auto& top = json->stack[json->top].val;             if (container_type == JSONContainerType::COLLECTIONS) {               collections::append(top.getObjectData(), mval.asTypedValue());             } else {               top.asArrRef().append(mval);             }             buf->clear();             reset_type();           }            /*<fb>*/           if (json->top == 1) z = json->stack[json->top].val;           else {           /*</fb>*/             attach_zval(json, json->stack[json->top].key, assoc,               container_type);           /*<fb>*/           }           /*</fb>*/           if (!pop(json, Mode::ARRAY)) {             s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;             return false;           }           state = 9;         }         break;         /*           ""         */       case -4:         switch (json->stack[json->top].mode) {         case Mode::KEY:           state = 27;           std::swap(buf, key);           reset_type();           break;         case Mode::ARRAY:         case Mode::OBJECT:           state = 9;           break;         case Mode::DONE:           if (type == KindOfString) {             z = copy_and_clear(*buf);             state = 9;             break;           }           /* fall through if not KindOfString */         default:           s_json_parser->error_code = JSON_ERROR_SYNTAX;           return false;         }         break;         /*           ,         */       case -3:         {           Variant mval;           if (type != kInvalidDataType &&               (json->stack[json->top].mode == Mode::OBJECT ||                json->stack[json->top].mode == Mode::ARRAY)) {             json_create_zval(mval, *buf, type, options);           }            switch (json->stack[json->top].mode) {           case Mode::OBJECT:             if (pop(json, Mode::OBJECT) &&                 push(json, Mode::KEY)) {               if (type != kInvalidDataType) {                 Variant &top = json->stack[json->top].val;                 object_set(                   json,                   top,                   copy_and_clear(*key),                   mval,                   assoc,                   container_type                 );               }               state = 29;             }             break;           case Mode::ARRAY:             if (type != kInvalidDataType) {               auto& top = json->stack[json->top].val;               if (container_type == JSONContainerType::COLLECTIONS) {                 collections::append(top.getObjectData(), mval.asTypedValue());               } else {                 top.asArrRef().append(mval);               }             }             state = 28;             break;           default:             s_json_parser->error_code = JSON_ERROR_SYNTAX;             return false;           }           buf->clear();           reset_type();           check_non_safepoint_surprise();         }         break;          /*<fb>*/         /*           : (after unquoted string)         */       case -10:         if (json->stack[json->top].mode == Mode::KEY) {           state = 27;           std::swap(buf, key);           reset_type();           s = -2;         } else {           s = 3;           break;         }         /*</fb>*/          /*           :         */       case -2:         if (pop(json, Mode::KEY) && push(json, Mode::OBJECT)) {           state = 28;           break;         }         /*           syntax error         */       case -1:         s_json_parser->error_code = JSON_ERROR_SYNTAX;         return false;       }     } else {       /*         Change the state and iterate.       */       bool is_tsimplejson = options & k_JSON_FB_THRIFT_SIMPLE_JSON;       if (type == KindOfString) {         if (/*<fb>*/(/*</fb>*/s == 3/*<fb>*/ || s == 30)/*</fb>*/ &&             state != 8) {           if (state != 4) {             utf16_to_utf8(*buf, b);           } else {             switch (b) {             case 'b': buf->append('\b'); break;             case 't': buf->append('\t'); break;             case 'n': buf->append('\n'); break;             case 'f': buf->append('\f'); break;             case 'r': buf->append('\r'); break;             default:               utf16_to_utf8(*buf, b);               break;             }           }         } else if (s == 6) {           if (UNLIKELY(is_tsimplejson)) {             if (UNLIKELY(b != '0'))  {               s_json_parser->error_code = JSON_ERROR_SYNTAX;               return false;             }             escaped_bytes = 0;           } else {             escaped_bytes = dehexchar(b) << 12;           }         } else if (s == 7) {           if (UNLIKELY(is_tsimplejson)) {             if (UNLIKELY(b != '0'))  {               s_json_parser->error_code = JSON_ERROR_SYNTAX;               return false;             }           } else {             escaped_bytes += dehexchar(b) << 8;           }         } else if (s == 8) {           escaped_bytes += dehexchar(b) << 4;         } else if (s == 3 && state == 8) {           escaped_bytes += dehexchar(b);           if (UNLIKELY(is_tsimplejson)) {             buf->append((char)escaped_bytes);           } else {             utf16_to_utf8(*buf, escaped_bytes);           }         }       } else if ((type == kInvalidDataType || type == KindOfNull) &&                  (c == S_DIG || c == S_ZER)) {         type = KindOfInt64;         buf->append((char)b);       } else if (type == KindOfInt64 && s == 24) {         type = KindOfDouble;         buf->append((char)b);       } else if ((type == kInvalidDataType || type == KindOfNull ||                   type == KindOfInt64) &&                  c == S_DOT) {         type = KindOfDouble;         buf->append((char)b);       } else if (type != KindOfString && c == S_QUO) {         type = KindOfString;         /*<fb>*/qchr = b;/*</fb>*/       } else if ((type == kInvalidDataType || type == KindOfNull ||                   type == KindOfInt64 || type == KindOfDouble) &&                  ((state == 12 && s == 9) ||                   (state == 16 && s == 9))) {         type = KindOfBoolean;       } else if (type == kInvalidDataType && state == 19 && s == 9) {         type = KindOfNull;       } else if (type != KindOfString && c > S_WSP) {         utf16_to_utf8(*buf, b);       }        state = s;     }   }    if (state == 9 && pop(json, Mode::DONE)) {     s_json_parser->error_code = JSON_ERROR_NONE;     return true;   }    s_json_parser->error_code = JSON_ERROR_SYNTAX;   return false; }"
"195565_CWE-119.cpp","CWE-119","String string_number_format(double d, int dec,                             const String& dec_point,                             const String& thousand_sep) {   char *tmpbuf = nullptr, *resbuf;   char *s, *t;  /* source, target */   char *dp;   int integral;   int tmplen, reslen=0;   int count=0;   int is_negative=0;    if (d < 0) {     is_negative = 1;     d = -d;   }    if (dec < 0) dec = 0;   d = php_math_round(d, dec);    // departure from PHP: we got rid of dependencies on spprintf() here.   String tmpstr(63, ReserveString);   tmpbuf = tmpstr.mutableData();   tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);   if (tmplen < 0) return empty_string();   if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {     tmpstr.setSize(tmplen);     return tmpstr;   }   if (tmplen >= 64) {     // Uncommon, asked for more than 64 chars worth of precision     tmpstr = String(tmplen, ReserveString);     tmpbuf = tmpstr.mutableData();     tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d);     if (tmplen < 0) return empty_string();     if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {       tmpstr.setSize(tmplen);       return tmpstr;     }   }    /* find decimal point, if expected */   if (dec) {     dp = strpbrk(tmpbuf, "".,"");   } else {     dp = nullptr;   }    /* calculate the length of the return buffer */   if (dp) {     integral = dp - tmpbuf;   } else {     /* no decimal point was found */     integral = tmplen;   }    /* allow for thousand separators */   if (!thousand_sep.empty()) {     if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) {       /* overflow */       raise_error(""String overflow"");     }      integral += ((integral-1) / 3) * thousand_sep.size();   }    reslen = integral;    if (dec) {     reslen += dec;      if (!dec_point.empty()) {       if (reslen + dec_point.size() < dec_point.size()) {         /* overflow */         raise_error(""String overflow"");       }       reslen += dec_point.size();     }   }    /* add a byte for minus sign */   if (is_negative) {     reslen++;   }   String resstr(reslen, ReserveString);   resbuf = resstr.mutableData();    s = tmpbuf+tmplen-1;   t = resbuf+reslen-1;    /* copy the decimal places.    * Take care, as the sprintf implementation may return less places than    * we requested due to internal buffer limitations */   if (dec) {     int declen = dp ? s - dp : 0;     int topad = dec > declen ? dec - declen : 0;      /* pad with '0's */     while (topad--) {       *t-- = '0';     }      if (dp) {       s -= declen + 1; /* +1 to skip the point */       t -= declen;        /* now copy the chars after the point */       memcpy(t + 1, dp + 1, declen);     }      /* add decimal point */     if (!dec_point.empty()) {       memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size());       t -= dec_point.size();     }   }    /* copy the numbers before the decimal point, adding thousand    * separator every three digits */   while(s >= tmpbuf) {     *t-- = *s--;     if (thousand_sep && (++count%3)==0 && s>=tmpbuf) {       memcpy(t + (1 - thousand_sep.size()),              thousand_sep.data(),              thousand_sep.size());       t -= thousand_sep.size();     }   }    /* and a minus sign, if needed */   if (is_negative) {     *t-- = '-';   }    resstr.setSize(reslen);   return resstr; }"
"195626_CWE-787.c","CWE-787","static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) {     VirtQueueElement elem;     VirtQueue *vq;      vq = vser->c_ivq;     if (!virtio_queue_ready(vq)) {         return 0;     }     if (!virtqueue_pop(vq, &elem)) {         return 0;     }      memcpy(elem.in_sg[0].iov_base, buf, len);      virtqueue_push(vq, &elem, len);     virtio_notify(VIRTIO_DEVICE(vser), vq);     return len; }"
"195629_CWE-476.cc","CWE-476","Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,                          TensorHandle* tensor_handle, Device** result) {   Device* cpu_device = ctx.HostCPU();   string device_name;   if (tensor_handle->Type() != TensorHandle::LOCAL) {     Device* device = tensor_handle->device();     device_name = device != nullptr ? device->name() : cpu_device->name();     *result = (device == nullptr ? cpu_device : device);   } else if (tensor_handle->dtype == DT_RESOURCE) {     // Use the resource's actual device because it is the device that will     // influence partitioning the multi-device function.     const Tensor* tensor;     // TODO(fishx): Avoid blocking here.     TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));     const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);     device_name = handle.device();      Device* input_device;     TF_RETURN_IF_ERROR(         ctx.FindDeviceFromName(device_name.c_str(), &input_device));     *result = input_device;   } else {     Device* device = tensor_handle->device();     const bool is_tpu = device != nullptr && device->device_type() == ""TPU"";     // int32 return values can be placed on TPUs.     const bool use_host_memory =         is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)                : MTypeFromDType(tensor_handle->dtype);     if (use_host_memory) {       *result = cpu_device;     } else {       // Eager ops executing as functions should have their preferred inputs set       // to the op's device. This allows us to avoid expensive D2H copies if a       // mirror of the tensor already exists on the op's device.       if (!op.is_function() && device != nullptr && device != cpu_device) {         device = absl::get<Device*>(op.Device());       }       *result = (device == nullptr ? cpu_device : device);     }   }   return Status::OK(); }"
"195665_CWE-703.c","CWE-703","njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,     njs_index_t unused) {     int64_t      i, n, start, length, items, delta, delete;     njs_int_t    ret;     njs_value_t  *this, value, del_object;     njs_array_t  *array, *deleted;      this = njs_argument(args, 0);      ret = njs_value_to_object(vm, this);     if (njs_slow_path(ret != NJS_OK)) {         return ret;     }      ret = njs_object_length(vm, this, &length);     if (njs_slow_path(ret == NJS_ERROR)) {         return ret;     }      ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);     if (njs_slow_path(ret != NJS_OK)) {         return ret;     }      start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);      items = 0;     delete = 0;      if (nargs == 2) {         delete = length - start;      } else if (nargs > 2) {         items = nargs - 3;          ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);         if (njs_slow_path(ret != NJS_OK)) {             return ret;         }          delete = njs_min(njs_max(delete, 0), length - start);     }      delta = items - delete;      if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {         njs_type_error(vm, ""Invalid length"");         return NJS_ERROR;     }      /* TODO: ArraySpeciesCreate(). */      deleted = njs_array_alloc(vm, 0, delete, 0);     if (njs_slow_path(deleted == NULL)) {         return NJS_ERROR;     }      if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {         array = njs_array(this);         for (i = 0, n = start; i < delete; i++, n++) {             deleted->start[i] = array->start[n];         }      } else {         njs_set_array(&del_object, deleted);          for (i = 0, n = start; i < delete; i++, n++) {             ret = njs_value_property_i64(vm, this, n, &value);             if (njs_slow_path(ret == NJS_ERROR)) {                 return NJS_ERROR;             }              if (ret == NJS_OK) {                 /* TODO:  CreateDataPropertyOrThrow(). */                 ret = njs_value_property_i64_set(vm, &del_object, i, &value);                 if (njs_slow_path(ret == NJS_ERROR)) {                     return ret;                 }             }         }          ret = njs_object_length_set(vm, &del_object, delete);         if (njs_slow_path(ret != NJS_OK)) {             return NJS_ERROR;         }     }      if (njs_fast_path(njs_is_fast_array(this))) {         array = njs_array(this);          if (delta != 0) {             /*              * Relocate the rest of items.              * Index of the first item is in ""n"".              */             if (delta > 0) {                 ret = njs_array_expand(vm, array, 0, delta);                 if (njs_slow_path(ret != NJS_OK)) {                     return ret;                 }             }              ret = njs_array_copy_within(vm, this, start + items, start + delete,                                         array->length - (start + delete), 0);             if (njs_slow_path(ret != NJS_OK)) {                 return ret;             }              array->length += delta;         }          /* Copy new items. */          if (items > 0) {             memcpy(&array->start[start], &args[3],                    items * sizeof(njs_value_t));         }      } else {         if (delta != 0) {            ret = njs_array_copy_within(vm, this, start + items, start + delete,                                        length - (start + delete), delta < 0);             if (njs_slow_path(ret != NJS_OK)) {                 return ret;             }              for (i = length - 1; i >= length + delta; i--) {                 ret = njs_value_property_i64_delete(vm, this, i, NULL);                 if (njs_slow_path(ret == NJS_ERROR)) {                     return NJS_ERROR;                 }             }        }          /* Copy new items. */          for (i = 3, n = start; items-- > 0; i++, n++) {             ret = njs_value_property_i64_set(vm, this, n, &args[i]);             if (njs_slow_path(ret == NJS_ERROR)) {                 return NJS_ERROR;             }         }          ret = njs_object_length_set(vm, this, length + delta);         if (njs_slow_path(ret != NJS_OK)) {             return NJS_ERROR;         }     }      njs_set_array(&vm->retval, deleted);      return NJS_OK; }"
"195668_CWE-415.c","CWE-415","gen_values(codegen_scope *s, node *t, int val, int limit) {   int n = 0;   int first = 1;   int slimit = GEN_VAL_STACK_MAX;    if (limit == 0) limit = GEN_LIT_ARY_MAX;   if (cursp() >= slimit) slimit = INT16_MAX;    if (!val) {     while (t) {       codegen(s, t->car, NOVAL);       n++;       t = t->cdr;     }     return n;   }    while (t) {     int is_splat = nint(t->car->car) == NODE_SPLAT;      if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */       pop_n(n);       if (first) {         if (n == 0) {           genop_1(s, OP_LOADNIL, cursp());         }         else {           genop_2(s, OP_ARRAY, cursp(), n);         }         push();         first = 0;         limit = GEN_LIT_ARY_MAX;       }       else if (n > 0) {         pop();         genop_2(s, OP_ARYPUSH, cursp(), n);         push();       }       n = 0;     }     codegen(s, t->car, val);     if (is_splat) {       pop(); pop();       genop_1(s, OP_ARYCAT, cursp());       push();     }     else {       n++;     }     t = t->cdr;   }   if (!first) {     pop();     if (n > 0) {       pop_n(n);       genop_2(s, OP_ARYPUSH, cursp(), n);     }     return -1;                  /* variable length */   }   return n; }"
"195670_CWE-703.c","CWE-703","static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner) {     pj_xml_node *node;     pj_str_t end_name;      PJ_CHECK_STACK();      if (*scanner->curptr != '<') 	on_syntax_error(scanner);      /* Handle Processing Instructino (PI) construct (i.e. ""<?"") */     if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') { 	pj_scan_advance_n(scanner, 2, PJ_FALSE); 	for (;;) { 	    pj_str_t dummy; 	    pj_scan_get_until_ch(scanner, '?', &dummy); 	    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') { 		pj_scan_advance_n(scanner, 2, PJ_TRUE); 		break; 	    } else { 		pj_scan_advance_n(scanner, 1, PJ_FALSE); 	    } 	} 	return xml_parse_node(pool, scanner);     }      /* Handle comments construct (i.e. ""<!"") */     if (pj_scan_strcmp(scanner, ""<!"", 2) == 0) { 	pj_scan_advance_n(scanner, 2, PJ_FALSE); 	for (;;) { 	    pj_str_t dummy; 	    pj_scan_get_until_ch(scanner, '>', &dummy); 	    if (pj_scan_strcmp(scanner, "">"", 1) == 0) { 		pj_scan_advance_n(scanner, 1, PJ_TRUE); 		break; 	    } else { 		pj_scan_advance_n(scanner, 1, PJ_FALSE); 	    } 	} 	return xml_parse_node(pool, scanner);     }      /* Alloc node. */     node = alloc_node(pool);      /* Get '<' */     pj_scan_get_char(scanner);      /* Get node name. */     pj_scan_get_until_chr( scanner, "" />\t\r\n"", &node->name);      /* Get attributes. */     while (*scanner->curptr != '>' && *scanner->curptr != '/') { 	pj_xml_attr *attr = alloc_attr(pool); 	 	pj_scan_get_until_chr( scanner, ""=> \t\r\n"", &attr->name); 	if (*scanner->curptr == '=') { 	    pj_scan_get_char( scanner );             pj_scan_get_quotes(scanner, ""\""'"", ""\""'"", 2, &attr->value); 	    /* remove quote characters */ 	    ++attr->value.ptr; 	    attr->value.slen -= 2; 	} 	 	pj_list_push_back( &node->attr_head, attr );     }      if (*scanner->curptr == '/') { 	pj_scan_get_char(scanner); 	if (pj_scan_get_char(scanner) != '>') 	    on_syntax_error(scanner); 	return node;     }      /* Enclosing bracket. */     if (pj_scan_get_char(scanner) != '>') 	on_syntax_error(scanner);      /* Sub nodes. */     while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/' 				   && *(scanner->curptr+1) != '!')     { 	pj_xml_node *sub_node = xml_parse_node(pool, scanner); 	pj_list_push_back( &node->node_head, sub_node );     }      /* Content. */     if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') { 	pj_scan_get_until_ch(scanner, '<', &node->content);     }      /* CDATA content. */     if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' && 	pj_scan_strcmp(scanner, ""<![CDATA["", 9) == 0)     { 	pj_scan_advance_n(scanner, 9, PJ_FALSE); 	pj_scan_get_until_ch(scanner, ']', &node->content); 	while (pj_scan_strcmp(scanner, ""]]>"", 3)) { 	    pj_str_t dummy; 	    pj_scan_get_until_ch(scanner, ']', &dummy); 	} 	node->content.slen = scanner->curptr - node->content.ptr; 	pj_scan_advance_n(scanner, 3, PJ_TRUE);     }      /* Enclosing node. */     if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/') 	on_syntax_error(scanner);      pj_scan_get_until_chr(scanner, "" \t>"", &end_name);      /* Compare name. */     if (pj_stricmp(&node->name, &end_name) != 0) 	on_syntax_error(scanner);      /* Enclosing '>' */     if (pj_scan_get_char(scanner) != '>') 	on_syntax_error(scanner);      return node; }"
"195691_CWE-703.c","CWE-703","mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc) {   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */   const mrb_irep *irep = proc->body.irep;   const mrb_pool_value *pool = irep->pool;   const mrb_sym *syms = irep->syms;   mrb_code insn;   int ai = mrb_gc_arena_save(mrb);   struct mrb_jmpbuf *prev_jmp = mrb->jmp;   struct mrb_jmpbuf c_jmp;   uint32_t a;   uint16_t b;   uint16_t c;   mrb_sym mid;   const struct mrb_irep_catch_handler *ch;  #ifdef DIRECT_THREADED   static const void * const optable[] = { #define OPCODE(x,_) &&L_OP_ ## x, #include ""mruby/ops.h"" #undef OPCODE   }; #endif    mrb_bool exc_catched = FALSE; RETRY_TRY_BLOCK:    MRB_TRY(&c_jmp) {    if (exc_catched) {     exc_catched = FALSE;     mrb_gc_arena_restore(mrb, ai);     if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)       goto L_BREAK;     goto L_RAISE;   }   mrb->jmp = &c_jmp;   mrb_vm_ci_proc_set(mrb->c->ci, proc);  #define regs (mrb->c->ci->stack)   INIT_DISPATCH {     CASE(OP_NOP, Z) {       /* do nothing */       NEXT;     }      CASE(OP_MOVE, BB) {       regs[a] = regs[b];       NEXT;     }      CASE(OP_LOADL, BB) {       switch (pool[b].tt) {   /* number */       case IREP_TT_INT32:         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);         break;       case IREP_TT_INT64: #if defined(MRB_INT64)         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);         break; #else #if defined(MRB_64BIT)         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);           break;         } #endif         goto L_INT_OVERFLOW; #endif       case IREP_TT_BIGINT: #ifdef MRB_USE_BIGINT         {           const char *s = pool[b].u.str;           regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);         }         break; #else         goto L_INT_OVERFLOW; #endif #ifndef MRB_NO_FLOAT       case IREP_TT_FLOAT:         regs[a] = mrb_float_value(mrb, pool[b].u.f);         break; #endif       default:         /* should not happen (tt:string) */         regs[a] = mrb_nil_value();         break;       }       NEXT;     }      CASE(OP_LOADI, BB) {       SET_FIXNUM_VALUE(regs[a], b);       NEXT;     }      CASE(OP_LOADINEG, BB) {       SET_FIXNUM_VALUE(regs[a], -b);       NEXT;     }      CASE(OP_LOADI__1,B) goto L_LOADI;     CASE(OP_LOADI_0,B) goto L_LOADI;     CASE(OP_LOADI_1,B) goto L_LOADI;     CASE(OP_LOADI_2,B) goto L_LOADI;     CASE(OP_LOADI_3,B) goto L_LOADI;     CASE(OP_LOADI_4,B) goto L_LOADI;     CASE(OP_LOADI_5,B) goto L_LOADI;     CASE(OP_LOADI_6,B) goto L_LOADI;     CASE(OP_LOADI_7, B) {     L_LOADI:       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);       NEXT;     }      CASE(OP_LOADI16, BS) {       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);       NEXT;     }      CASE(OP_LOADI32, BSS) {       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));       NEXT;     }      CASE(OP_LOADSYM, BB) {       SET_SYM_VALUE(regs[a], syms[b]);       NEXT;     }      CASE(OP_LOADNIL, B) {       SET_NIL_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADSELF, B) {       regs[a] = regs[0];       NEXT;     }      CASE(OP_LOADT, B) {       SET_TRUE_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADF, B) {       SET_FALSE_VALUE(regs[a]);       NEXT;     }      CASE(OP_GETGV, BB) {       mrb_value val = mrb_gv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETGV, BB) {       mrb_gv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETSV, BB) {       mrb_value val = mrb_vm_special_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETSV, BB) {       mrb_vm_special_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIV, BB) {       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);       NEXT;     }      CASE(OP_SETIV, BB) {       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETCV, BB) {       mrb_value val;       val = mrb_vm_cv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETCV, BB) {       mrb_vm_cv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIDX, B) {       mrb_value va = regs[a], vb = regs[a+1];       switch (mrb_type(va)) {       case MRB_TT_ARRAY:         if (!mrb_integer_p(vb)) goto getidx_fallback;         regs[a] = mrb_ary_entry(va, mrb_integer(vb));         break;       case MRB_TT_HASH:         va = mrb_hash_get(mrb, va, vb);         regs[a] = va;         break;       case MRB_TT_STRING:         switch (mrb_type(vb)) {         case MRB_TT_INTEGER:         case MRB_TT_STRING:         case MRB_TT_RANGE:           va = mrb_str_aref(mrb, va, vb, mrb_undef_value());           regs[a] = va;           break;         default:           goto getidx_fallback;         }         break;       default:       getidx_fallback:         mid = MRB_OPSYM(aref);         goto L_SEND_SYM;       }       NEXT;     }      CASE(OP_SETIDX, B) {       c = 2;       mid = MRB_OPSYM(aset);       SET_NIL_VALUE(regs[a+3]);       goto L_SENDB_SYM;     }      CASE(OP_GETCONST, BB) {       mrb_value v = mrb_vm_const_get(mrb, syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETCONST, BB) {       mrb_vm_const_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETMCNST, BB) {       mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETMCNST, BB) {       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETUPVAR, BBB) {       mrb_value *regs_a = regs + a;       struct REnv *e = uvenv(mrb, c);        if (e && b < MRB_ENV_LEN(e)) {         *regs_a = e->stack[b];       }       else {         *regs_a = mrb_nil_value();       }       NEXT;     }      CASE(OP_SETUPVAR, BBB) {       struct REnv *e = uvenv(mrb, c);        if (e) {         mrb_value *regs_a = regs + a;          if (b < MRB_ENV_LEN(e)) {           e->stack[b] = *regs_a;           mrb_write_barrier(mrb, (struct RBasic*)e);         }       }       NEXT;     }      CASE(OP_JMP, S) {       pc += (int16_t)a;       JUMP;     }     CASE(OP_JMPIF, BS) {       if (mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNOT, BS) {       if (!mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNIL, BS) {       if (mrb_nil_p(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }      CASE(OP_JMPUW, S) {       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {         struct RBreak *brk = (struct RBreak*)mrb->exc;         mrb_value target = mrb_break_value_get(brk);         mrb_assert(mrb_integer_p(target));         a = (uint32_t)mrb_integer(target);         mrb_assert(a >= 0 && a < irep->ilen);       }       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);         if (ch) {           /* avoiding a jump from a catch handler into the same handler */           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));           }         }       }       CHECKPOINT_END(RBREAK_TAG_JUMP);        mrb->exc = NULL; /* clear break object */       pc = irep->iseq + a;       JUMP;     }      CASE(OP_EXCEPT, B) {       mrb_value exc;        if (mrb->exc == NULL) {         exc = mrb_nil_value();       }       else {         switch (mrb->exc->tt) {         case MRB_TT_BREAK:         case MRB_TT_EXCEPTION:           exc = mrb_obj_value(mrb->exc);           break;         default:           mrb_assert(!""bad mrb_type"");           exc = mrb_nil_value();           break;         }         mrb->exc = NULL;       }       regs[a] = exc;       NEXT;     }     CASE(OP_RESCUE, BB) {       mrb_value exc = regs[a];  /* exc on stack */       mrb_value e = regs[b];       struct RClass *ec;        switch (mrb_type(e)) {       case MRB_TT_CLASS:       case MRB_TT_MODULE:         break;       default:         {           mrb_value exc;            exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                     ""class or module required for rescue clause"");           mrb_exc_set(mrb, exc);           goto L_RAISE;         }       }       ec = mrb_class_ptr(e);       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));       NEXT;     }      CASE(OP_RAISEIF, B) {       mrb_value exc = regs[a];       if (mrb_break_p(exc)) {         mrb->exc = mrb_obj_ptr(exc);         goto L_BREAK;       }       mrb_exc_set(mrb, exc);       if (mrb->exc) {         goto L_RAISE;       }       NEXT;     }      CASE(OP_SSEND, BBB) {       regs[a] = regs[0];       insn = OP_SEND;     }     goto L_SENDB;      CASE(OP_SSENDB, BBB) {       regs[a] = regs[0];     }     goto L_SENDB;      CASE(OP_SEND, BBB)     goto L_SENDB;      L_SEND_SYM:     c = 1;     /* push nil after arguments */     SET_NIL_VALUE(regs[a+2]);     goto L_SENDB_SYM;      CASE(OP_SENDB, BBB)     L_SENDB:     mid = syms[b];     L_SENDB_SYM:     {       mrb_callinfo *ci = mrb->c->ci;       mrb_method_t m;       struct RClass *cls;       mrb_value recv, blk;        ARGUMENT_NORMALIZE(a, &c, insn);        recv = regs[a];       cls = mrb_class(mrb, recv);       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, c);        if (MRB_METHOD_CFUNC_P(m)) {         if (MRB_METHOD_PROC_P(m)) {           struct RProc *p = MRB_METHOD_PROC(m);            mrb_vm_ci_proc_set(ci, p);           recv = p->body.func(mrb, recv);         }         else {           if (MRB_METHOD_NOARG_P(m)) {             check_method_noarg(mrb, ci);           }           recv = MRB_METHOD_FUNC(m)(mrb, recv);         }         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }         if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return recv;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         ci->stack[0] = recv;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }     }     JUMP;      CASE(OP_CALL, Z) {       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv = ci->stack[0];       struct RProc *m = mrb_proc_ptr(recv);        /* replace callinfo */       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);       mrb_vm_ci_proc_set(ci, m);       if (MRB_PROC_ENV_P(m)) {         ci->mid = MRB_PROC_ENV(m)->mid;       }        /* prepare stack */       if (MRB_PROC_CFUNC_P(m)) {         recv = MRB_PROC_CFUNC(m)(mrb, recv);         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;         ci[1].stack[0] = recv;         irep = mrb->c->ci->proc->body.irep;       }       else {         /* setup environment for calling method */         proc = m;         irep = m->body.irep;         if (!irep) {           mrb->c->ci->stack[0] = mrb_nil_value();           a = 0;           c = OP_R_NORMAL;           goto L_OP_RETURN_BODY;         }         mrb_int nargs = mrb_ci_bidx(ci)+1;         if (nargs < irep->nregs) {           mrb_stack_extend(mrb, irep->nregs);           stack_clear(regs+nargs, irep->nregs-nargs);         }         if (MRB_PROC_ENV_P(m)) {           regs[0] = MRB_PROC_ENV(m)->stack[0];         }         pc = irep->iseq;       }       pool = irep->pool;       syms = irep->syms;       JUMP;     }      CASE(OP_SUPER, BB) {       mrb_method_t m;       struct RClass *cls;       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv, blk;       const struct RProc *p = ci->proc;       mrb_sym mid = ci->mid;       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);        if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */         mid = p->e.env->mid;    /* restore old mid */       }        if (mid == 0 || !target_class) {         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {         target_class = mrb_vm_ci_target_class(ci);       }       else if (target_class->tt == MRB_TT_MODULE) {         target_class = mrb_vm_ci_target_class(ci);         if (!target_class || target_class->tt != MRB_TT_ICLASS) {           goto super_typeerror;         }       }       recv = regs[0];       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {       super_typeerror: ;         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                             ""self has wrong type to call super in this context"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }        ARGUMENT_NORMALIZE(a, &b, OP_SUPER);        cls = target_class->super;       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, b);        /* prepare stack */       ci->stack[0] = recv;        if (MRB_METHOD_CFUNC_P(m)) {         mrb_value v;          if (MRB_METHOD_PROC_P(m)) {           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));         }         v = MRB_METHOD_CFUNC(m)(mrb, recv);         mrb_gc_arena_restore(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         mrb_assert(!mrb_break_p(v));         if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return v;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         mrb->c->ci->stack[0] = v;         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }       JUMP;     }      CASE(OP_ARGARY, BS) {       mrb_int m1 = (b>>11)&0x3f;       mrb_int r  = (b>>10)&0x1;       mrb_int m2 = (b>>5)&0x1f;       mrb_int kd = (b>>4)&0x1;       mrb_int lv = (b>>0)&0xf;       mrb_value *stack;        if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {         mrb_value exc;        L_NOSUPER:         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e) goto L_NOSUPER;         if (MRB_ENV_LEN(e) <= m1+r+m2+1)           goto L_NOSUPER;         stack = e->stack + 1;       }       if (r == 0) {         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);       }       else {         mrb_value *pp = NULL;         struct RArray *rest;         mrb_int len = 0;          if (mrb_array_p(stack[m1])) {           struct RArray *ary = mrb_ary_ptr(stack[m1]);            pp = ARY_PTR(ary);           len = ARY_LEN(ary);         }         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);         rest = mrb_ary_ptr(regs[a]);         if (m1 > 0) {           stack_copy(ARY_PTR(rest), stack, m1);         }         if (len > 0) {           stack_copy(ARY_PTR(rest)+m1, pp, len);         }         if (m2 > 0) {           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);         }         ARY_SET_LEN(rest, m1+len+m2);       }       if (kd) {         regs[a+1] = stack[m1+r+m2];         regs[a+2] = stack[m1+r+m2+1];       }       else {         regs[a+1] = stack[m1+r+m2];       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ENTER, W) {       mrb_int m1 = MRB_ASPEC_REQ(a);       mrb_int o  = MRB_ASPEC_OPT(a);       mrb_int r  = MRB_ASPEC_REST(a);       mrb_int m2 = MRB_ASPEC_POST(a);       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;       /* unused       int b  = MRB_ASPEC_BLOCK(a);       */       mrb_int const len = m1 + o + r + m2;        mrb_callinfo *ci = mrb->c->ci;       mrb_int argc = ci->n;       mrb_value *argv = regs+1;       mrb_value * const argv0 = argv;       mrb_int const kw_pos = len + kd;    /* where kwhash should be */       mrb_int const blk_pos = kw_pos + 1; /* where block should be */       mrb_value blk = regs[mrb_ci_bidx(ci)];       mrb_value kdict = mrb_nil_value();        /* keyword arguments */       if (ci->nk > 0) {         mrb_int kidx = mrb_ci_kidx(ci);         kdict = regs[kidx];         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {           kdict = mrb_nil_value();           ci->nk = 0;         }       }       if (!kd && !mrb_nil_p(kdict)) {         if (argc < 14) {           ci->n++;           argc++;    /* include kdict in normal arguments */         }         else if (argc == 14) {           /* pack arguments and kdict */           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);           argc = ci->n = 15;         }         else {/* argc == 15 */           /* push kdict to packed arguments */           mrb_ary_push(mrb, regs[1], regs[2]);         }         ci->nk = 0;       }       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {         kdict = mrb_hash_dup(mrb, kdict);       }        /* arguments is passed with Array */       if (argc == 15) {         struct RArray *ary = mrb_ary_ptr(regs[1]);         argv = ARY_PTR(ary);         argc = (int)ARY_LEN(ary);         mrb_gc_protect(mrb, regs[1]);       }        /* strict argument check */       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {         if (argc < m1 + m2 || (r == 0 && argc > len)) {           argnum_error(mrb, m1+m2);           goto L_RAISE;         }       }       /* extract first argument array to arguments */       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {         mrb_gc_protect(mrb, argv[0]);         argc = (int)RARRAY_LEN(argv[0]);         argv = RARRAY_PTR(argv[0]);       }        /* rest arguments */       mrb_value rest = mrb_nil_value();       if (argc < len) {         mrb_int mlen = m2;         if (argc < m1+m2) {           mlen = m1 < argc ? argc - m1 : 0;         }          /* copy mandatory and optional arguments */         if (argv0 != argv && argv) {           value_move(&regs[1], argv, argc-mlen); /* m1 + o */         }         if (argc < m1) {           stack_clear(&regs[argc+1], m1-argc);         }         /* copy post mandatory arguments */         if (mlen) {           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);         }         if (mlen < m2) {           stack_clear(&regs[len-m2+mlen+1], m2-mlen);         }         /* initialize rest arguments with empty Array */         if (r) {           rest = mrb_ary_new_capa(mrb, 0);           regs[m1+o+1] = rest;         }         /* skip initializer of passed arguments */         if (o > 0 && argc > m1+m2)           pc += (argc - m1 - m2)*3;       }       else {         mrb_int rnum = 0;         if (argv0 != argv) {           value_move(&regs[1], argv, m1+o);         }         if (r) {           rnum = argc-m1-o-m2;           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);           regs[m1+o+1] = rest;         }         if (m2 > 0 && argc-m2 > m1) {           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);         }         pc += o*3;       }        /* need to be update blk first to protect blk from GC */       regs[blk_pos] = blk;              /* move block */       if (kd) {         if (mrb_nil_p(kdict))           kdict = mrb_hash_new_capa(mrb, 0);         regs[kw_pos] = kdict;           /* set kwhash */       }        /* format arguments for generated code */       mrb->c->ci->n = (uint8_t)len;        /* clear local (but non-argument) variables */       if (irep->nlocals-blk_pos-1 > 0) {         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);       }       JUMP;     }      CASE(OP_KARG, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict, v;        if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {         mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       v = mrb_hash_get(mrb, kdict, k);       regs[a] = v;       mrb_hash_delete_key(mrb, kdict, k);       NEXT;     }      CASE(OP_KEY_P, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;       mrb_bool key_p = FALSE;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {         key_p = mrb_hash_key_p(mrb, kdict, k);       }       regs[a] = mrb_bool_value(key_p);       NEXT;     }      CASE(OP_KEYEND, Z) {       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {         mrb_value keys = mrb_hash_keys(mrb, kdict);         mrb_value key1 = RARRAY_PTR(keys)[0];         mrb_value str = mrb_format(mrb, ""unknown keyword: %v"", key1);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       NEXT;     }      CASE(OP_BREAK, B) {       c = OP_R_BREAK;       goto L_RETURN;     }     CASE(OP_RETURN_BLK, B) {       c = OP_R_RETURN;       goto L_RETURN;     }     CASE(OP_RETURN, B)     c = OP_R_NORMAL;     L_RETURN:     {       mrb_callinfo *ci;        ci = mrb->c->ci;       if (ci->mid) {         mrb_value blk = regs[mrb_ci_bidx(ci)];          if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);            if (!MRB_PROC_STRICT_P(p) &&               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }       }        if (mrb->exc) {       L_RAISE:         ci = mrb->c->ci;         if (ci == mrb->c->cibase) {           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);           if (ch == NULL) goto L_FTOP;           goto L_CATCH;         }         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {           ci = cipop(mrb);           if (ci[1].cci == CINFO_SKIP && prev_jmp) {             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           pc = ci[0].pc;           if (ci == mrb->c->cibase) {             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);             if (ch == NULL) {             L_FTOP:             /* fiber top */               if (mrb->c == mrb->root_c) {                 mrb->c->ci->stack = mrb->c->stbase;                 goto L_STOP;               }               else {                 struct mrb_context *c = mrb->c;                  c->status = MRB_FIBER_TERMINATED;                 mrb->c = c->prev;                 c->prev = NULL;                 goto L_RAISE;               }             }             break;           }         }       L_CATCH:         if (ch == NULL) goto L_STOP;         if (FALSE) {         L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */           ci = mrb->c->ci;         }         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, irep->nregs);         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);       }       else {         mrb_int acc;         mrb_value v;          ci = mrb->c->ci;         v = regs[a];         mrb_gc_protect(mrb, v);         switch (c) {         case OP_R_RETURN:           /* Fall through to OP_R_NORMAL otherwise */           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {             const struct RProc *dst;             mrb_callinfo *cibase;             cibase = mrb->c->cibase;             dst = top_proc(mrb, proc);              if (MRB_PROC_ENV_P(dst)) {               struct REnv *e = MRB_PROC_ENV(dst);                if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }             }             /* check jump destination */             while (cibase <= ci && ci->proc != dst) {               if (ci->cci > CINFO_NONE) { /* jump cross C boundary */                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }               ci--;             }             if (ci <= cibase) { /* no jump destination */               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);               goto L_RAISE;             }             ci = mrb->c->ci;             while (cibase <= ci && ci->proc != dst) {               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {                 cibase = mrb->c->cibase;                 dst = top_proc(mrb, proc);               }               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);               }               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);               ci = cipop(mrb);               pc = ci->pc;             }             proc = ci->proc;             mrb->exc = NULL; /* clear break object */             break;           }           /* fallthrough */         case OP_R_NORMAL:         NORMAL_RETURN:           if (ci == mrb->c->cibase) {             struct mrb_context *c;             c = mrb->c;              if (!c->prev) { /* toplevel return */               regs[irep->nlocals] = v;               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);             }             if (!c->vmexec && c->prev->ci == c->prev->cibase) {               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, ""double resume"");               mrb_exc_set(mrb, exc);               goto L_RAISE;             }             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {               c = mrb->c;             }             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);             /* automatic yield at the end */             c->status = MRB_FIBER_TERMINATED;             mrb->c = c->prev;             mrb->c->status = MRB_FIBER_RUNNING;             c->prev = NULL;             if (c->vmexec) {               mrb_gc_arena_restore(mrb, ai);               c->vmexec = FALSE;               mrb->jmp = prev_jmp;               return v;             }             ci = mrb->c->ci;           }           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_RETURN);           mrb->exc = NULL; /* clear break object */           break;         case OP_R_BREAK:           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;           if (MRB_PROC_ORPHAN_P(proc)) {             mrb_value exc;            L_BREAK_ERROR:             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,                                       ""break from proc-closure"");             mrb_exc_set(mrb, exc);             goto L_RAISE;           }           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {             goto L_BREAK_ERROR;           }           else {             struct REnv *e = MRB_PROC_ENV(proc);              if (e->cxt != mrb->c) {               goto L_BREAK_ERROR;             }           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK);           /* break from fiber block */           if (ci == mrb->c->cibase && ci->pc) {             struct mrb_context *c = mrb->c;              mrb->c = c->prev;             c->prev = NULL;             ci = mrb->c->ci;           }           if (ci->cci > CINFO_NONE) {             ci = cipop(mrb);             mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);             mrb_gc_arena_restore(mrb, ai);             mrb->c->vmexec = FALSE;             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           if (FALSE) {             struct RBreak *brk;            L_BREAK:             brk = (struct RBreak*)mrb->exc;             proc = mrb_break_proc_get(brk);             v = mrb_break_value_get(brk);             ci = mrb->c->ci;              switch (mrb_break_tag_get(brk)) { #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS) #undef DISPATCH_CHECKPOINTS               default:                 mrb_assert(!""wrong break tag"");             }           }           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {             if (ci[-1].cci == CINFO_SKIP) {               goto L_BREAK_ERROR;             }             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {               /* do nothing */             }             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);             ci = cipop(mrb);             pc = ci->pc;           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);           if (ci == mrb->c->cibase) {             goto L_BREAK_ERROR;           }           mrb->exc = NULL; /* clear break object */           break;         default:           /* cannot happen */           break;         }         mrb_assert(ci == mrb->c->ci);         mrb_assert(mrb->exc == NULL);          if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {           mrb_gc_arena_restore(mrb, ai);           mrb->c->vmexec = FALSE;           mrb->jmp = prev_jmp;           return v;         }         acc = ci->cci;         ci = cipop(mrb);         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {           mrb_gc_arena_restore(mrb, ai);           mrb->jmp = prev_jmp;           return v;         }         pc = ci->pc;         DEBUG(fprintf(stderr, ""from :%s\n"", mrb_sym_name(mrb, ci->mid)));         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;          ci[1].stack[0] = v;         mrb_gc_arena_restore(mrb, ai);       }       JUMP;     }      CASE(OP_BLKPUSH, BS) {       int m1 = (b>>11)&0x3f;       int r  = (b>>10)&0x1;       int m2 = (b>>5)&0x1f;       int kd = (b>>4)&0x1;       int lv = (b>>0)&0xf;       mrb_value *stack;        if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||             MRB_ENV_LEN(e) <= m1+r+m2+1) {           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);           goto L_RAISE;         }         stack = e->stack + 1;       }       if (mrb_nil_p(stack[m1+r+m2+kd])) {         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);         goto L_RAISE;       }       regs[a] = stack[m1+r+m2+kd];       NEXT;     }  #if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)   L_INT_OVERFLOW:     {       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, ""integer overflow"");       mrb_exc_set(mrb, exc);     }     goto L_RAISE; #endif  #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff)) #define OP_MATH(op_name)                                                    \   /* need to check if op is overridden */                                   \   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \     OP_MATH_CASE_INTEGER(op_name);                                          \     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \     OP_MATH_CASE_STRING_##op_name();                                        \     default:                                                                \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATH_CASE_INTEGER(op_name)                                       \   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \       if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \         OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \       }                                                                     \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0 #else #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \     {                                                                           \       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \     }                                                                           \     break #endif #ifdef MRB_USE_BIGINT #define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y) #else #define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW #endif #define OP_MATH_CASE_STRING_add()                                           \   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \     mrb_gc_arena_restore(mrb, ai);                                          \     break #define OP_MATH_CASE_STRING_sub() (void)0 #define OP_MATH_CASE_STRING_mul() (void)0 #define OP_MATH_OP_add + #define OP_MATH_OP_sub - #define OP_MATH_OP_mul * #define OP_MATH_TT_integer MRB_TT_INTEGER #define OP_MATH_TT_float   MRB_TT_FLOAT      CASE(OP_ADD, B) {       OP_MATH(add);     }      CASE(OP_SUB, B) {       OP_MATH(sub);     }      CASE(OP_MUL, B) {       OP_MATH(mul);     }      CASE(OP_DIV, B) { #ifndef MRB_NO_FLOAT       mrb_float x, y, f; #endif        /* need to check if op is overridden */       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):         {           mrb_int x = mrb_integer(regs[a]);           mrb_int y = mrb_integer(regs[a+1]);           mrb_int div = mrb_div_int(mrb, x, y);           SET_INT_VALUE(mrb, regs[a], div);         }         NEXT; #ifndef MRB_NO_FLOAT       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):         x = (mrb_float)mrb_integer(regs[a]);         y = mrb_float(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):         x = mrb_float(regs[a]);         y = (mrb_float)mrb_integer(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):         x = mrb_float(regs[a]);         y = mrb_float(regs[a+1]);         break; #endif       default:         mid = MRB_OPSYM(div);         goto L_SEND_SYM;       }  #ifndef MRB_NO_FLOAT       f = mrb_div_float(x, y);       SET_FLOAT_VALUE(mrb, regs[a], f); #endif       NEXT;     }  #define OP_MATHI(op_name)                                                   \   /* need to check if op is overridden */                                   \   switch (mrb_type(regs[a])) {                                              \     OP_MATHI_CASE_INTEGER(op_name);                                         \     OP_MATHI_CASE_FLOAT(op_name);                                           \     default:                                                                \       SET_INT_VALUE(mrb,regs[a+1], b);                                      \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATHI_CASE_INTEGER(op_name)                                      \   case MRB_TT_INTEGER:                                                      \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \       if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \         OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \       }                                                                     \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATHI_CASE_FLOAT(op_name) (void)0 #else #define OP_MATHI_CASE_FLOAT(op_name)                                        \   case MRB_TT_FLOAT:                                                        \     {                                                                       \       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \     }                                                                       \     break #endif      CASE(OP_ADDI, BB) {       OP_MATHI(add);     }      CASE(OP_SUBI, BB) {       OP_MATHI(sub);     }  #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))  #ifdef MRB_NO_FLOAT #define OP_CMP(op,sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #else #define OP_CMP(op, sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_float,mrb_float);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #endif      CASE(OP_EQ, B) {       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {         SET_TRUE_VALUE(regs[a]);       }       else {         OP_CMP(==,eq);       }       NEXT;     }      CASE(OP_LT, B) {       OP_CMP(<,lt);       NEXT;     }      CASE(OP_LE, B) {       OP_CMP(<=,le);       NEXT;     }      CASE(OP_GT, B) {       OP_CMP(>,gt);       NEXT;     }      CASE(OP_GE, B) {       OP_CMP(>=,ge);       NEXT;     }      CASE(OP_ARRAY, BB) {       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_ARRAY2, BBB) {       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYCAT, B) {       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);       if (mrb_nil_p(regs[a])) {         regs[a] = splat;       }       else {         mrb_assert(mrb_array_p(regs[a]));         mrb_ary_concat(mrb, regs[a], splat);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYPUSH, BB) {       mrb_assert(mrb_array_p(regs[a]));       for (mrb_int i=0; i<b; i++) {         mrb_ary_push(mrb, regs[a], regs[a+i+1]);       }       NEXT;     }      CASE(OP_ARYDUP, B) {       mrb_value ary = regs[a];       if (mrb_array_p(ary)) {         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));       }       else {         ary = mrb_ary_new_from_values(mrb, 1, &ary);       }       regs[a] = ary;       NEXT;     }      CASE(OP_AREF, BBB) {       mrb_value v = regs[b];        if (!mrb_array_p(v)) {         if (c == 0) {           regs[a] = v;         }         else {           SET_NIL_VALUE(regs[a]);         }       }       else {         v = mrb_ary_ref(mrb, v, c);         regs[a] = v;       }       NEXT;     }      CASE(OP_ASET, BBB) {       mrb_assert(mrb_array_p(regs[a]));       mrb_ary_set(mrb, regs[b], c, regs[a]);       NEXT;     }      CASE(OP_APOST, BBB) {       mrb_value v = regs[a];       int pre  = b;       int post = c;       struct RArray *ary;       int len, idx;        if (!mrb_array_p(v)) {         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);       }       ary = mrb_ary_ptr(v);       len = (int)ARY_LEN(ary);       if (len > pre + post) {         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);         regs[a++] = v;         while (post--) {           regs[a++] = ARY_PTR(ary)[len-post-1];         }       }       else {         v = mrb_ary_new_capa(mrb, 0);         regs[a++] = v;         for (idx=0; idx+pre<len; idx++) {           regs[a+idx] = ARY_PTR(ary)[pre+idx];         }         while (idx < post) {           SET_NIL_VALUE(regs[a+idx]);           idx++;         }       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_INTERN, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_sym sym = mrb_intern_str(mrb, regs[a]);       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_SYMBOL, BB) {       size_t len;       mrb_sym sym;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         sym = mrb_intern_static(mrb, pool[b].u.str, len);       }       else {         sym  = mrb_intern(mrb, pool[b].u.str, len);       }       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_STRING, BB) {       mrb_int len;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);       }       else {         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_STRCAT, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_str_concat(mrb, regs[a], regs[a+1]);       NEXT;     }      CASE(OP_HASH, BB) {       mrb_value hash = mrb_hash_new_capa(mrb, b);       int i;       int lim = a+b*2;        for (i=a; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       regs[a] = hash;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_HASHADD, BB) {       mrb_value hash;       int i;       int lim = a+b*2+1;        hash = regs[a];       mrb_ensure_hash_type(mrb, hash);       for (i=a+1; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_HASHCAT, B) {       mrb_value hash = regs[a];        mrb_assert(mrb_hash_p(hash));       mrb_hash_merge(mrb, hash, regs[a+1]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_LAMBDA, BB)     c = OP_L_LAMBDA;     L_MAKE_LAMBDA:     {       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        if (c & OP_L_CAPTURE) {         p = mrb_closure_new(mrb, nirep);       }       else {         p = mrb_proc_new(mrb, nirep);         p->flags |= MRB_PROC_SCOPE;       }       if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;       regs[a] = mrb_obj_value(p);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_BLOCK, BB) {       c = OP_L_BLOCK;       goto L_MAKE_LAMBDA;     }     CASE(OP_METHOD, BB) {       c = OP_L_METHOD;       goto L_MAKE_LAMBDA;     }      CASE(OP_RANGE_INC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_RANGE_EXC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_OCLASS, B) {       regs[a] = mrb_obj_value(mrb->object_class);       NEXT;     }      CASE(OP_CLASS, BB) {       struct RClass *c = 0, *baseclass;       mrb_value base, super;       mrb_sym id = syms[b];        base = regs[a];       super = regs[a+1];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       c = mrb_vm_define_class(mrb, base, super, id);       regs[a] = mrb_obj_value(c);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_MODULE, BB) {       struct RClass *cls = 0, *baseclass;       mrb_value base;       mrb_sym id = syms[b];        base = regs[a];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       cls = mrb_vm_define_module(mrb, base, id);       regs[a] = mrb_obj_value(cls);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_EXEC, BB)     {       mrb_value recv = regs[a];       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        /* prepare closure */       p = mrb_proc_new(mrb, nirep);       p->c = NULL;       mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);       MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));       p->flags |= MRB_PROC_SCOPE;        /* prepare call stack */       cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);        irep = p->body.irep;       pool = irep->pool;       syms = irep->syms;       mrb_stack_extend(mrb, irep->nregs);       stack_clear(regs+1, irep->nregs-1);       pc = irep->iseq;       JUMP;     }      CASE(OP_DEF, BB) {       struct RClass *target = mrb_class_ptr(regs[a]);       struct RProc *p = mrb_proc_ptr(regs[a+1]);       mrb_method_t m;       mrb_sym mid = syms[b];        MRB_METHOD_FROM_PROC(m, p);       mrb_define_method_raw(mrb, target, mid, m);       mrb_method_added(mrb, target, mid);       mrb_gc_arena_restore(mrb, ai);       regs[a] = mrb_symbol_value(mid);       NEXT;     }      CASE(OP_SCLASS, B) {       regs[a] = mrb_singleton_class(mrb, regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_TCLASS, B) {       struct RClass *target = check_target_class(mrb);       if (!target) goto L_RAISE;       regs[a] = mrb_obj_value(target);       NEXT;     }      CASE(OP_ALIAS, BB) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_alias_method(mrb, target, syms[a], syms[b]);       mrb_method_added(mrb, target, syms[a]);       NEXT;     }     CASE(OP_UNDEF, B) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_undef_method_id(mrb, target, syms[a]);       NEXT;     }      CASE(OP_DEBUG, Z) {       FETCH_BBB(); #ifdef MRB_USE_DEBUG_HOOK       mrb->debug_op_hook(mrb, irep, pc, regs); #else #ifndef MRB_NO_STDIO       printf(""OP_DEBUG %d %d %d\n"", a, b, c); #else       abort(); #endif #endif       NEXT;     }      CASE(OP_ERR, B) {       size_t len = pool[a].tt >> 2;       mrb_value exc;        mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);       exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);       mrb_exc_set(mrb, exc);       goto L_RAISE;     }      CASE(OP_EXT1, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT2, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT3, Z) {       uint8_t insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }      CASE(OP_STOP, Z) {       /*        stop VM */       CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {         /* do nothing */       }       CHECKPOINT_MAIN(RBREAK_TAG_STOP) {         UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());       }       CHECKPOINT_END(RBREAK_TAG_STOP);     L_STOP:       mrb->jmp = prev_jmp;       if (mrb->exc) {         mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);         return mrb_obj_value(mrb->exc);       }       return regs[irep->nlocals];     }   }   END_DISPATCH; #undef regs   }   MRB_CATCH(&c_jmp) {     mrb_callinfo *ci = mrb->c->ci;     while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {       ci = cipop(mrb);     }     exc_catched = TRUE;     pc = ci->pc;     goto RETRY_TRY_BLOCK;   }   MRB_END_EXC(&c_jmp); }"
"195692_CWE-200.c","CWE-200","    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,                                         const UBaseType_t uxItemSize,                                         const uint8_t ucQueueType )      {          Queue_t * pxNewQueue;          size_t xQueueSizeInBytes;          uint8_t * pucQueueStorage;            configASSERT( uxQueueLength > ( UBaseType_t ) 0 );            /* Allocate enough space to hold the maximum number of items that           * can be in the queue at any time.  It is valid for uxItemSize to be           * zero in the case the queue is used as a semaphore. */          xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */            /* Check for multiplication overflow. */          configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );            /* Allocate the queue and storage area.  Justification for MISRA           * deviation as follows:  pvPortMalloc() always ensures returned memory           * blocks are aligned per the requirements of the MCU stack.  In this case           * pvPortMalloc() must return a pointer that is guaranteed to meet the           * alignment requirements of the Queue_t structure - which in this case           * is an int8_t *.  Therefore, whenever the stack alignment requirements           * are greater than or equal to the pointer to char requirements the cast           * is safe.  In other cases alignment requirements are not strict (one or           * two bytes). */          pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */            if( pxNewQueue != NULL )          {              /* Jump past the queue structure to find the location of the queue               * storage area. */              pucQueueStorage = ( uint8_t * ) pxNewQueue;              pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */                #if ( configSUPPORT_STATIC_ALLOCATION == 1 )                  {                      /* Queues can be created either statically or dynamically, so                       * note this task was created dynamically in case it is later                       * deleted. */                      pxNewQueue->ucStaticallyAllocated = pdFALSE;                  }              #endif /* configSUPPORT_STATIC_ALLOCATION */                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );          }          else          {              traceQUEUE_CREATE_FAILED( ucQueueType );              mtCOVERAGE_TEST_MARKER();          }            return pxNewQueue;      } "
"195720_CWE-703.cpp","CWE-703","void updateHandshakeState(QuicServerConnectionState& conn) {   // Zero RTT read cipher is available after chlo is processed with the   // condition that early data attempt is accepted.   auto handshakeLayer = conn.serverHandshakeLayer;   auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();   auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();   // One RTT write cipher is available at Fizz layer after chlo is processed.   // However, the cipher is only exported to QUIC if early data attempt is   // accepted. Otherwise, the cipher will be available after cfin is   // processed.   auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();   // One RTT read cipher is available after cfin is processed.   auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();    auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();   auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();    if (zeroRttReadCipher) {     if (conn.qLogger) {       conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);     }     QUIC_TRACE(fst_trace, conn, ""derived 0-rtt read cipher"");     conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));   }   if (zeroRttHeaderCipher) {     conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));   }   if (oneRttWriteHeaderCipher) {     conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);   }   if (oneRttReadHeaderCipher) {     conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));   }    if (oneRttWriteCipher) {     if (conn.qLogger) {       conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);     }     QUIC_TRACE(fst_trace, conn, ""derived 1-rtt write cipher"");     CHECK(!conn.oneRttWriteCipher.get());     conn.oneRttWriteCipher = std::move(oneRttWriteCipher);      updatePacingOnKeyEstablished(conn);      // We negotiate the transport parameters whenever we have the 1-RTT write     // keys available.     auto clientParams = handshakeLayer->getClientTransportParams();     if (!clientParams) {       throw QuicTransportException(           ""No client transport params"",           TransportErrorCode::TRANSPORT_PARAMETER_ERROR);     }     processClientInitialParams(conn, std::move(*clientParams));   }   if (oneRttReadCipher) {     if (conn.qLogger) {       conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);     }     QUIC_TRACE(fst_trace, conn, ""derived 1-rtt read cipher"");     // Clear limit because CFIN is received at this point     conn.writableBytesLimit = folly::none;     conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));   }   auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();   auto handshakeReadHeaderCipher =       handshakeLayer->getHandshakeReadHeaderCipher();   if (handshakeReadCipher) {     CHECK(handshakeReadHeaderCipher);     conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));     conn.readCodec->setHandshakeHeaderCipher(         std::move(handshakeReadHeaderCipher));   }   if (handshakeLayer->isHandshakeDone()) {     CHECK(conn.oneRttWriteCipher);     if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {       sendSimpleFrame(conn, HandshakeDoneFrame());       conn.sentHandshakeDone = true;     }   } }"
"195740_CWE-703.cpp","CWE-703","bool SampleInterleavedLSScan::ParseMCU(void) { #if ACCUSOFT_CODE   int lines             = m_ulRemaining[0]; // total number of MCU lines processed.   UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();   struct Line *line[4];   UBYTE cx;    //   // If a DNL marker is present, the number of remaining lines is zero. Fix it.   if (m_pFrame->HeightOf() == 0) {     assert(lines == 0);     lines = 8;   }   //   // A ""MCU"" in respect to the code organization is eight lines.   if (lines > 8) {     lines = 8;   }   if (m_pFrame->HeightOf() > 0)     m_ulRemaining[0] -= lines;   assert(lines > 0);   assert(m_ucCount < 4);    //   // Fill the line pointers.   for(cx = 0;cx < m_ucCount;cx++) {     line[cx] = CurrentLine(cx);   }    // Loop over lines and columns   do {     LONG length = m_ulWidth[0];     LONG *lp[4];      // Get the line pointers and initialize the internal backup lines.     for(cx = 0;cx < m_ucCount;cx++) {       lp[cx] = line[cx]->m_pData;       StartLine(cx);     }      if (BeginReadMCU(m_Stream.ByteStreamOf())) {        // No error handling strategy. No RST in scans. Bummer!       do {         LONG a[4],b[4],c[4],d[4]; // neighbouring values.         LONG d1[4],d2[4],d3[4];   // local gradients.         bool isrun = true;                for(cx = 0;cx < m_ucCount;cx++) {           GetContext(cx,a[cx],b[cx],c[cx],d[cx]);            d1[cx]  = d[cx] - b[cx];    // compute local gradients           d2[cx]  = b[cx] - c[cx];           d3[cx]  = c[cx] - a[cx];            //           // Run mode only if the run condition is met for all components           if (isrun && !isRunMode(d1[cx],d2[cx],d3[cx]))             isrun = false;         }                  if (isrun) {           LONG run = DecodeRun(length,m_lRunIndex[0]);           //           // Now fill the data.           while(run) {             // Update so that the next process gets the correct value.             // There is one sample per component.             for(cx = 0;cx < m_ucCount;cx++) {               UpdateContext(cx,a[cx]);               // And insert the value into the target line as well.               *lp[cx]++ = a[cx] << preshift;             }             run--,length--;             // As long as there are pixels on the line.           }           //           // More data on the line? I.e. the run did not cover the full m_lJ samples?           // Now decode the run interruption sample. The rtype is here always zero.           if (length) {             bool negative; // the sign variable             LONG errval;   // the prediction error             LONG merr;     // the mapped error (symbol)             LONG rx;       // the reconstructed value             UBYTE k;       // golomb parameter             //             // Decode the interrupting pixels.             for(cx = 0;cx < m_ucCount;cx++) {               // Get the neighbourhood.               GetContext(cx,a[cx],b[cx],c[cx],d[cx]);               // The prediction mode is always false, but the sign information               // is required.               negative = a[cx] > b[cx];               // Get the golomb parameter for run interruption coding.               k       = GolombParameter(false);               // Golomb-decode the error symbol. It is always using the common               // run index.               merr    = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);               // Inverse the error mapping procedure.               errval  = InverseErrorMapping(merr,ErrorMappingOffset(false,merr != 0,k));               // Compute the reconstructed value.               rx      = Reconstruct(negative,b[cx],errval);               // Update so that the next process gets the correct value.               UpdateContext(cx,rx);               // Fill in the value into the line               *lp[cx]++ = rx << preshift;               // Update the variables of the run mode.               UpdateState(false,errval);             }             // Update the run index now. This is not part of             // EncodeRun because the non-reduced run-index is             // required for the golomb coder length limit.              if (m_lRunIndex[0] > 0)               m_lRunIndex[0]--;           } else break; // end of line.         } else {           UWORD ctxt;           bool  negative; // the sign variable.           LONG  px;       // the predicted variable.           LONG  rx;       // the reconstructed value.           LONG  errval;   // the error value.           LONG  merr;     // the mapped error value.           UBYTE k;        // the Golomb parameter.           //           for(cx = 0;cx < m_ucCount;cx++) {             // Quantize the gradients.             d1[cx]  = QuantizedGradient(d1[cx]);             d2[cx]  = QuantizedGradient(d2[cx]);             d3[cx]  = QuantizedGradient(d3[cx]);             // Compute the context.             ctxt    = Context(negative,d1[cx],d2[cx],d3[cx]);              // Compute the predicted value.             px      = Predict(a[cx],b[cx],c[cx]);             // Correct the prediction.             px      = CorrectPrediction(ctxt,negative,px);             // Compute the golomb parameter k from the context.             k       = GolombParameter(ctxt);             // Decode the error symbol.             merr    = GolombDecode(k,m_lLimit);             // Inverse the error symbol into an error value.             errval  = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));             // Update the variables.             UpdateState(ctxt,errval);             // Compute the reconstructed value.             rx      = Reconstruct(negative,px,errval);             // Update so that the next process gets the correct value.             UpdateContext(cx,rx);             // And insert the value into the target line as well.             *lp[cx]++ = rx << preshift;           }         }       } while(--length);     } // No error handling here.     //     // Advance the line pointers.     for(cx = 0;cx < m_ucCount;cx++) {       EndLine(cx);       line[cx] = line[cx]->m_pNext;     }     //   } while(--lines);   //   // If this is the last line, gobble up all the   // bits from bitstuffing the last byte may have left.   // As SkipStuffing is idempotent, we can also do that   // all the time.   m_Stream.SkipStuffing(); #endif     return false; }"
"195741_CWE-703.cpp","CWE-703","bool SingleComponentLSScan::ParseMCU(void) {  #if ACCUSOFT_CODE   int lines             = m_ulRemaining[0]; // total number of MCU lines processed.   UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();   struct Line *line     = CurrentLine(0);      //   // If a DNL marker is present, the number of remaining lines is zero. Fix it.   if (m_pFrame->HeightOf() == 0) {     assert(lines == 0);     lines = 8;   }    assert(m_ucCount == 1);    //   // A ""MCU"" in respect to the code organization is eight lines.   if (lines > 8) {     lines = 8;   }   if (m_pFrame->HeightOf() > 0)     m_ulRemaining[0] -= lines;      assert(lines > 0);    // Loop over lines and columns   do {     LONG length = m_ulWidth[0];     LONG *lp    = line->m_pData;  #ifdef DEBUG_LS     int xpos    = 0;     static int linenumber = 0;     printf(""\n%4d : "",++linenumber); #endif           StartLine(0);     if (BeginReadMCU(m_Stream.ByteStreamOf())) { // No error handling strategy. No RST in scans. Bummer!       do {         LONG a,b,c,d;   // neighbouring values.         LONG d1,d2,d3;  // local gradients.                GetContext(0,a,b,c,d);         d1  = d - b;    // compute local gradients         d2  = b - c;         d3  = c - a;                  if (isRunMode(d1,d2,d3)) {           LONG run = DecodeRun(length,m_lRunIndex[0]);           //           // Now fill the data.           while(run) {             // Update so that the next process gets the correct value.             UpdateContext(0,a);             // And insert the value into the target line as well.             *lp++ = a << preshift; #ifdef DEBUG_LS             printf(""%4d:<%2x> "",xpos++,a); #endif             run--,length--;             // As long as there are pixels on the line.           }           //           // More data on the line? I.e. the run did not cover the full m_lJ samples?           // Now decode the run interruption sample.           if (length) {             bool negative; // the sign variable             bool rtype;    // run interruption type             LONG errval;   // the prediction error             LONG merr;     // the mapped error (symbol)             LONG rx;       // the reconstructed value             UBYTE k;       // golomb parameter             // Get the neighbourhood.             GetContext(0,a,b,c,d);             // Get the prediction mode.             rtype  = InterruptedPredictionMode(negative,a,b);             // Get the golomb parameter for run interruption coding.             k      = GolombParameter(rtype);             // Golomb-decode the error symbol.             merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);             // Inverse the error mapping procedure.             errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));             // Compute the reconstructed value.             rx     = Reconstruct(negative,rtype?a:b,errval);             // Update so that the next process gets the correct value.             UpdateContext(0,rx);             // Fill in the value into the line             *lp    = rx << preshift; #ifdef DEBUG_LS             printf(""%4d:<%2x> "",xpos++,*lp); #endif             // Update the variables of the run mode.             UpdateState(rtype,errval);             // Update the run index now. This is not part of             // EncodeRun because the non-reduced run-index is             // required for the golomb coder length limit.              if (m_lRunIndex[0] > 0)               m_lRunIndex[0]--;           } else break; // end of line.         } else {           UWORD ctxt;           bool  negative; // the sign variable.           LONG  px;       // the predicted variable.           LONG  rx;       // the reconstructed value.           LONG  errval;   // the error value.           LONG  merr;     // the mapped error value.           UBYTE k;        // the Golomb parameter.           // Quantize the gradients.           d1     = QuantizedGradient(d1);           d2     = QuantizedGradient(d2);           d3     = QuantizedGradient(d3);           // Compute the context.           ctxt   = Context(negative,d1,d2,d3);            // Compute the predicted value.           px     = Predict(a,b,c);           // Correct the prediction.           px     = CorrectPrediction(ctxt,negative,px);           // Compute the golomb parameter k from the context.           k      = GolombParameter(ctxt);           // Decode the error symbol.           merr   = GolombDecode(k,m_lLimit);           // Inverse the error symbol into an error value.           errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));           // Update the variables.           UpdateState(ctxt,errval);           // Compute the reconstructed value.           rx     = Reconstruct(negative,px,errval);           // Update so that the next process gets the correct value.           UpdateContext(0,rx);           // And insert the value into the target line as well.           *lp    = rx << preshift; #ifdef DEBUG_LS           printf(""%4d:<%2x> "",xpos++,*lp); #endif         }       } while(++lp,--length);     } // No error handling here.     EndLine(0);     line = line->m_pNext;   } while(--lines);    //   // If this is the last line, gobble up all the   // bits from bitstuffing the last byte may have left.   // As SkipStuffing is idempotent, we can also do that   // all the time.   m_Stream.SkipStuffing(); #endif     return false; }"
"195742_CWE-476.cpp","CWE-476","static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode) { 	GF_Box *a; 	u64 totSize, mdat_end=0; 	GF_Err e = GF_OK;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 	if (mov->single_moof_mode && mov->single_moof_state == 2) { 		return e; 	}  	/*restart from where we stopped last*/ 	totSize = mov->current_top_box_start; 	if (mov->bytes_removed) { 		assert(totSize >= mov->bytes_removed); 		totSize -= mov->bytes_removed; 	} 	gf_bs_seek(mov->movieFileMap->bs, totSize); #endif   	/*while we have some data, parse our boxes*/ 	while (gf_bs_available(mov->movieFileMap->bs)) { 		*bytesMissing = 0; #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed; 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Parsing a top-level box at position %d\n"", mov->current_top_box_start)); #endif  		e = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);  		if (e >= 0) {  		} else if (e == GF_ISOM_INCOMPLETE_FILE) { 			/*our mdat is uncomplete, only valid for READ ONLY files...*/ 			if (mov->openMode != GF_ISOM_OPEN_READ) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			if ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete file while reading for dump - aborting parsing\n"")); 				break; 			} 			return e; 		} else { 			return e; 		}  		switch (a->type) { 		/*MOOV box*/ 		case GF_ISOM_BOX_TYPE_MOOV: 			if (mov->moov) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate MOOV detected!\n"")); 				gf_isom_box_del(a); 				return GF_ISOM_INVALID_FILE; 			} 			mov->moov = (GF_MovieBox *)a; 			mov->original_moov_offset = mov->current_top_box_start; 			/*set our pointer to the movie*/ 			mov->moov->mov = mov; #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (mov->moov->mvex) mov->moov->mvex->mov = mov;  #ifdef GF_ENABLE_CTRN 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				gf_isom_setup_traf_inheritance(mov); 			} #endif  #endif 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e;  			totSize += a->size;              if (!mov->moov->mvhd) {                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MovieHeaderBox\n""));                 return GF_ISOM_INVALID_FILE;             }              if (mov->meta) { 				gf_isom_meta_restore_items_ref(mov, mov->meta); 			}  			//dump senc info in dump mode 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				u32 k; 				for (k=0; k<gf_list_count(mov->moov->trackList); k++) { 					GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);  					if (trak->sample_encryption) { 						e = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption); 						if (e) return e; 					} 				} 			} else { 				u32 k; 				for (k=0; k<gf_list_count(mov->moov->trackList); k++) { 					GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k); 					if (trak->Media->information->sampleTable->sampleGroups) { 						convert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups); 					} 				} 			}              if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {                 gf_isom_push_mdat_end(mov, mdat_end);                 mdat_end=0;             } 			break;  		/*META box*/ 		case GF_ISOM_BOX_TYPE_META: 			if (mov->meta) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate META detected!\n"")); 				gf_isom_box_del(a); 				return GF_ISOM_INVALID_FILE; 			} 			mov->meta = (GF_MetaBox *)a; 			mov->original_meta_offset = mov->current_top_box_start; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) { 				return e; 			} 			totSize += a->size; 			gf_isom_meta_restore_items_ref(mov, mov->meta); 			break;  		/*we only keep the MDAT in READ for dump purposes*/ 		case GF_ISOM_BOX_TYPE_MDAT: 			if (!mov->first_data_toplevel_offset) { 				mov->first_data_toplevel_offset = mov->current_top_box_start; 				mov->first_data_toplevel_size = a->size; 			} 			totSize += a->size;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 			if (mov->emsgs) { 				gf_isom_box_array_del(mov->emsgs); 				mov->emsgs = NULL; 			} #endif  			if (mov->openMode == GF_ISOM_OPEN_READ) { 				if (!mov->mdat) { 					mov->mdat = (GF_MediaDataBox *) a; 					e = gf_list_add(mov->TopBoxes, mov->mdat); 					if (e) { 						return e; 					} 				} #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 				else if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a); #endif 				else gf_isom_box_del(a); //in other modes we don't care   				if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {                     mdat_end = gf_bs_get_position(mov->movieFileMap->bs);                     if (mov->moov) {                         gf_isom_push_mdat_end(mov, mdat_end);                         mdat_end=0;                     } 				} 			} 			/*if we don't have any MDAT yet, create one (edit-write mode) 			We only work with one mdat, but we're puting it at the place 			of the first mdat found when opening a file for editing*/ 			else if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) { 				gf_isom_box_del(a); 				mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT); 				if (!mov->mdat) return GF_OUT_OF_MEM; 				e = gf_list_add(mov->TopBoxes, mov->mdat); 				if (e) { 					return e; 				} 			} else { 				gf_isom_box_del(a); 			} 			break; 		case GF_ISOM_BOX_TYPE_FTYP: 			/*ONE AND ONLY ONE FTYP*/ 			if (mov->brand) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'ftyp' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			mov->brand = (GF_FileTypeBox *)a; 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break;  		case GF_ISOM_BOX_TYPE_OTYP: 			/*ONE AND ONLY ONE FTYP*/ 			if (mov->otyp) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'otyp' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			}  			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				mov->otyp = (GF_Box *)a; 				totSize += a->size; 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} else { 				GF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP); 				if (brand) { 					s32 pos; 					gf_list_del_item(a->child_boxes, brand); 					pos = gf_list_del_item(mov->TopBoxes, mov->brand); 					gf_isom_box_del((GF_Box *) mov->brand); 					mov->brand = brand; 					if (pos<0) pos=0; 					gf_list_insert(mov->TopBoxes, brand, pos); 				} 				gf_isom_box_del(a); 			} 			break;  		case GF_ISOM_BOX_TYPE_PDIN: 			/*ONE AND ONLY ONE PDIN*/ 			if (mov->pdin) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'pdin'' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			mov->pdin = (GF_ProgressiveDownloadBox *) a; 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break;   #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		case GF_ISOM_BOX_TYPE_STYP: 		{ 			u32 brand = ((GF_FileTypeBox *)a)->majorBrand; 			switch (brand) { 			case GF_ISOM_BRAND_SISX: 			case GF_ISOM_BRAND_RISX: 			case GF_ISOM_BRAND_SSSS: 				mov->is_index_segment = GF_TRUE; 				break; 			default: 				break; 			} 		} 		/*fall-through*/  		case GF_ISOM_BOX_TYPE_SIDX: 		case GF_ISOM_BOX_TYPE_SSIX: 			if (mov->moov && !mov->first_data_toplevel_offset) { 				mov->first_data_toplevel_offset = mov->current_top_box_start; 				mov->first_data_toplevel_size = a->size; 			} 			totSize += a->size; 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS) 			) { 				if (a->type==GF_ISOM_BOX_TYPE_SIDX) { 					if (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx); 					mov->root_sidx = (GF_SegmentIndexBox *) a; 					mov->sidx_start_offset = mov->current_top_box_start; 					mov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);  				} 				else if (a->type==GF_ISOM_BOX_TYPE_STYP) { 					mov->styp_start_offset = mov->current_top_box_start;  					if (mov->seg_styp) gf_isom_box_del(mov->seg_styp); 					mov->seg_styp = a; 				} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) { 					if (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix); 					mov->seg_ssix = a; 				} else { 					gf_isom_box_del(a); 				} 				gf_isom_push_mdat_end(mov, mov->current_top_box_start); 			} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) { 				if (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx); 				mov->main_sidx = (GF_SegmentIndexBox *) a; 				mov->main_sidx_end_pos = mov->current_top_box_start + a->size; 			} else { 				gf_isom_box_del(a); 			} 			break;  		case GF_ISOM_BOX_TYPE_MOOF: 			//no support for inplace rewrite for fragmented files 			gf_isom_disable_inplace_rewrite(mov); 			if (!mov->moov) { 				GF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\n"")); 			} 			if (mov->single_moof_mode) { 				mov->single_moof_state++; 				if (mov->single_moof_state > 1) { 					gf_isom_box_del(a); 					return GF_OK; 				} 			} 			((GF_MovieFragmentBox *)a)->mov = mov;  			totSize += a->size; 			mov->moof = (GF_MovieFragmentBox *) a;  			/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/ 			FixTrackID(mov); 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				FixSDTPInTRAF(mov->moof); 			} else { 				u32 k; 				for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 					GF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k); 					if (traf->sampleGroups) { 						convert_compact_sample_groups(traf->child_boxes, traf->sampleGroups); 					} 				} 			}  			/*read & debug: store at root level*/ 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				u32 k; 				gf_list_add(mov->TopBoxes, a); 				/*also update pointers to trex for debug*/ 				if (mov->moov) { 					for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 						GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k); 						if (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) { 							GF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID); 							u32 j=0; 							while ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) { 								if (traf->trex->trackID == traf->tfhd->trackID) { 									if (!traf->trex->track) traf->trex->track = trak; 									break; 								} 								traf->trex = NULL; 							} 						} 						//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly 						if (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) { 							GF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID); 							if (trak) { 								trak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index; 								e = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption); 								if (e) return e; 								trak->current_traf_stsd_idx = 0; 							} 						} 					} 				} else { 					for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 						GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k); 						if (traf->sample_encryption) { 							e = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption); 							if (e) return e; 						} 					}  				} 			} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) { 				mov->NextMoofNumber = mov->moof->mfhd->sequence_number+1; 				mov->moof = NULL; 				gf_isom_box_del(a); 			} else { 				/*merge all info*/ 				e = MergeFragment((GF_MovieFragmentBox *)a, mov); 				gf_isom_box_del(a); 				if (e) return e; 			}  			//done with moov 			if (mov->root_sidx) { 				gf_isom_box_del((GF_Box *) mov->root_sidx); 				mov->root_sidx = NULL; 			} 			if (mov->root_ssix) { 				gf_isom_box_del(mov->seg_ssix); 				mov->root_ssix = NULL; 			} 			if (mov->seg_styp) { 				gf_isom_box_del(mov->seg_styp); 				mov->seg_styp = NULL; 			} 			mov->sidx_start_offset = 0; 			mov->sidx_end_offset = 0; 			mov->styp_start_offset = 0; 			break; #endif 		case GF_ISOM_BOX_TYPE_UNKNOWN: 		{ 			GF_UnknownBox *box = (GF_UnknownBox*)a; 			if (box->original_4cc == GF_ISOM_BOX_TYPE_JP) { 				u8 *c = (u8 *) box->data; 				if ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A)) 					mov->is_jp2 = 1; 				gf_isom_box_del(a); 			} else { 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} 		} 		break;  		case GF_ISOM_BOX_TYPE_PRFT: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				//keep the last one read 				if (mov->last_producer_ref_time) 					gf_isom_box_del(a); 				else 					mov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a; 				break; 			} #endif 		//fallthrough 		case GF_ISOM_BOX_TYPE_EMSG: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				if (!mov->emsgs) mov->emsgs = gf_list_new(); 				gf_list_add(mov->emsgs, a); 				break; 			} #endif 		case GF_ISOM_BOX_TYPE_MFRA: 		case GF_ISOM_BOX_TYPE_MFRO: 			//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				totSize += a->size; 				gf_isom_box_del(a); 				break; 			} 		default: 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break; 		}  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		/*remember where we left, in case we append an entire number of movie fragments*/ 		mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed; #endif 	}  	/*we need at least moov or meta*/ 	if (!mov->moov && !mov->meta #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 	        && !mov->moof && !mov->is_index_segment #endif 	   ) { 		return GF_ISOM_INCOMPLETE_FILE; 	} 	/*we MUST have movie header*/ 	if (!gf_opts_get_bool(""core"", ""no-check"")) { 		if (mov->moov && !mov->moov->mvhd) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MVHD in MOOV!\n"")); 			return GF_ISOM_INVALID_FILE; 		}  		/*we MUST have meta handler*/ 		if (mov->meta && !mov->meta->handler) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing handler in META!\n"")); 			return GF_ISOM_INVALID_FILE; 		} 	}  #ifndef GPAC_DISABLE_ISOM_WRITE  	if (mov->moov) { 		/*set the default interleaving time*/ 		mov->interleavingTime = mov->moov->mvhd->timeScale;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		/*in edit mode with successfully loaded fragments, delete all fragment signaling since 		file is no longer fragmented*/ 		if ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) { 			gf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex); 			mov->moov->mvex = NULL; 		} #endif  	}  	//create a default mdat if none was found 	if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) { 		mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT); 		if (!mov->mdat) return GF_OUT_OF_MEM; 		e = gf_list_add(mov->TopBoxes, mov->mdat); 		if (e) return e; 	} #endif /*GPAC_DISABLE_ISOM_WRITE*/  	return GF_OK; }"
"195752_CWE-476.cc","CWE-476","  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {     // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in     // the step container, and return it as the output.     const Tensor* indices;     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices));     const Tensor* values;     OP_REQUIRES_OK(ctx, ctx->input(""values"", &values));     const Tensor* dense_shape;     OP_REQUIRES_OK(ctx, ctx->input(""dense_shape"", &dense_shape));      OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),                 errors::InvalidArgument(                     ""Input indices should be a matrix but received shape "",                     indices->shape().DebugString()));     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),                 errors::InvalidArgument(                     ""Input values should be a vector but received shape "",                     indices->shape().DebugString()));     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),                 errors::InvalidArgument(                     ""Input shape should be a vector but received shape "",                     dense_shape->shape().DebugString()));      // We currently ensure that `sparse_tensor` is ordered in the     // batch dimension.     // TODO(mrry): Investigate ways to avoid this unconditional check     // if we can be sure that the sparse tensor was produced in an     // appropriate order (e.g. by `tf.parse_example()` or a Dataset     // that batches elements into rows of a SparseTensor).     int64_t previous_batch_index = -1;     for (int64_t i = 0; i < indices->dim_size(0); ++i) {       int64_t next_batch_index = indices->matrix<int64>()(i, 0);       OP_REQUIRES(           ctx, next_batch_index >= previous_batch_index,           errors::Unimplemented(""The SparseTensor must be ordered in the batch ""                                 ""dimension; handling arbitrarily ordered input ""                                 ""is not currently supported.""));       previous_batch_index = next_batch_index;     }     gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);     sparse::SparseTensor tensor;     OP_REQUIRES_OK(         ctx, sparse::SparseTensor::Create(                  *indices, *values, TensorShape(dense_shape->vec<int64>()),                  std_order, &tensor));     *output = new Dataset<T>(ctx, std::move(tensor));   }"
"195768_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* context) override {     // Only create one, if one does not exist already. Report status for all     // other exceptions. If one already exists, it unrefs the new one.     // An epsilon value of zero could cause performance issues and is therefore,     // disallowed.     const Tensor* epsilon_t;     OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));     float epsilon = epsilon_t->scalar<float>()();     OP_REQUIRES(         context, epsilon > 0,         errors::InvalidArgument(""An epsilon value of zero is not allowed.""));      const Tensor* num_streams_t;     OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));     int64_t num_streams = num_streams_t->scalar<int64>()();      auto result =         new QuantileStreamResource(epsilon, max_elements_, num_streams);     auto status = CreateResource(context, HandleFromInput(context, 0), result);     if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {       OP_REQUIRES(context, false, status);     }   }"
"195800_CWE-369.c","CWE-369","void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi, 	i64 pos) { 	i64 pixmap_version; 	i64 pack_size; 	i64 plane_bytes; 	i64 n;  	de_dbg(c, ""additional PixMap header fields, at %d"", (int)pos); 	de_dbg_indent(c, 1);  	pixmap_version = dbuf_getu16be(f, pos+0); 	de_dbg(c, ""pixmap version: %d"", (int)pixmap_version);  	bi->packing_type = dbuf_getu16be(f, pos+2); 	de_dbg(c, ""packing type: %d"", (int)bi->packing_type);  	pack_size = dbuf_getu32be(f, pos+4); 	de_dbg(c, ""pixel data length: %d"", (int)pack_size);  	bi->hdpi = pict_read_fixed(f, pos+8); 	bi->vdpi = pict_read_fixed(f, pos+12); 	de_dbg(c, ""dpi: %.2f""DE_CHAR_TIMES""%.2f"", bi->hdpi, bi->vdpi);  	bi->pixeltype = dbuf_getu16be(f, pos+16); 	bi->pixelsize = dbuf_getu16be(f, pos+18); 	bi->cmpcount = dbuf_getu16be(f, pos+20); 	bi->cmpsize = dbuf_getu16be(f, pos+22); 	de_dbg(c, ""pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d"", 		(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);  	bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize; 	if(bi->pdwidth < bi->npwidth) { 		bi->pdwidth = bi->npwidth; 	}  	plane_bytes = dbuf_getu32be(f, pos+24); 	de_dbg(c, ""plane bytes: %d"", (int)plane_bytes);  	bi->pmTable = (u32)dbuf_getu32be(f, pos+28); 	de_dbg(c, ""pmTable: 0x%08x"", (unsigned int)bi->pmTable);  	n = dbuf_getu32be(f, pos+32); 	de_dbg(c, ""pmReserved: 0x%08x"", (unsigned int)n);  	de_dbg_indent(c, -1); }"
"195801_CWE-476.c","CWE-476"," */ static void php_wddx_pop_element(void *user_data, const XML_Char *name) { 	st_entry 			*ent1, *ent2; 	wddx_stack 			*stack = (wddx_stack *)user_data; 	HashTable 			*target_hash; 	zend_class_entry 	*pce; 	zval				obj;  /* OBJECTS_FIXME */ 	if (stack->top == 0) { 		return; 	}  	if (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) || 		!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) || 	  	!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) || 		!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) || 		!strcmp((char *)name, EL_DATETIME)) { 		wddx_stack_top(stack, (void**)&ent1);  		if (Z_TYPE(ent1->data) == IS_UNDEF) { 			if (stack->top > 1) { 				stack->top--; 			} else { 				stack->done = 1; 			} 			efree(ent1); 			return; 		}  		if (!strcmp((char *)name, EL_BINARY)) { 			zend_string *new_str = php_base64_decode( 				(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data)); 			zval_ptr_dtor(&ent1->data); 			ZVAL_STR(&ent1->data, new_str); 		}  		/* Call __wakeup() method on the object. */ 		if (Z_TYPE(ent1->data) == IS_OBJECT) { 			zval fname, retval;  			ZVAL_STRING(&fname, ""__wakeup"");  			call_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);  			zval_ptr_dtor(&fname); 			zval_ptr_dtor(&retval); 		}  		if (stack->top > 1) { 			stack->top--; 			wddx_stack_top(stack, (void**)&ent2);  			/* if non-existent field */ 			if (ent2->type == ST_FIELD && Z_ISUNDEF(ent2->data)) { 				zval_ptr_dtor(&ent1->data); 				efree(ent1); 				return; 			}  			if (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) { 				target_hash = HASH_OF(&ent2->data);  				if (ent1->varname) { 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) && 						Z_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) && 						ent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) { 						zend_bool incomplete_class = 0;  						zend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data)); 						zend_string_forget_hash_val(Z_STR(ent1->data)); 						if ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) { 							incomplete_class = 1; 							pce = PHP_IC_ENTRY; 						}  						/* Initialize target object */ 						object_init_ex(&obj, pce);  						/* Merge current hashtable with object's default properties */ 						zend_hash_merge(Z_OBJPROP(obj), 										Z_ARRVAL(ent2->data), 										zval_add_ref, 0);  						if (incomplete_class) { 							php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data)); 						}  						/* Clean up old array entry */ 						zval_ptr_dtor(&ent2->data);  						/* Set stack entry to point to the newly created object */ 						ZVAL_COPY_VALUE(&ent2->data, &obj);  						/* Clean up class name var entry */ 						zval_ptr_dtor(&ent1->data); 					} else if (Z_TYPE(ent2->data) == IS_OBJECT) { 						zend_class_entry *old_scope = EG(scope);  						EG(scope) = Z_OBJCE(ent2->data); 						add_property_zval(&ent2->data, ent1->varname, &ent1->data); 						if Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data); 						EG(scope) = old_scope; 					} else { 						zend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data); 					} 					efree(ent1->varname); 				} else	{ 					zend_hash_next_index_insert(target_hash, &ent1->data); 				} 			} 			efree(ent1); 		} else { 			stack->done = 1; 		} 	} else if (!strcmp((char *)name, EL_VAR) && stack->varname) { 		efree(stack->varname); 		stack->varname = NULL; 	} else if (!strcmp((char *)name, EL_FIELD)) { 		st_entry *ent; 		wddx_stack_top(stack, (void **)&ent); 		efree(ent); 		stack->top--; 	}"
"195908_CWE-703.c","CWE-703","int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path, 		    u64 devid) { 	struct btrfs_device *device; 	struct btrfs_fs_devices *cur_devices; 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices; 	u64 num_devices; 	int ret = 0;  	mutex_lock(&uuid_mutex);  	num_devices = btrfs_num_devices(fs_info);  	ret = btrfs_check_raid_min_devices(fs_info, num_devices - 1); 	if (ret) 		goto out;  	device = btrfs_find_device_by_devspec(fs_info, devid, device_path);  	if (IS_ERR(device)) { 		if (PTR_ERR(device) == -ENOENT && 		    strcmp(device_path, ""missing"") == 0) 			ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND; 		else 			ret = PTR_ERR(device); 		goto out; 	}  	if (btrfs_pinned_by_swapfile(fs_info, device)) { 		btrfs_warn_in_rcu(fs_info, 		  ""cannot remove device %s (devid %llu) due to active swapfile"", 				  rcu_str_deref(device->name), device->devid); 		ret = -ETXTBSY; 		goto out; 	}  	if (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) { 		ret = BTRFS_ERROR_DEV_TGT_REPLACE; 		goto out; 	}  	if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) && 	    fs_info->fs_devices->rw_devices == 1) { 		ret = BTRFS_ERROR_DEV_ONLY_WRITABLE; 		goto out; 	}  	if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) { 		mutex_lock(&fs_info->chunk_mutex); 		list_del_init(&device->dev_alloc_list); 		device->fs_devices->rw_devices--; 		mutex_unlock(&fs_info->chunk_mutex); 	}  	mutex_unlock(&uuid_mutex); 	ret = btrfs_shrink_device(device, 0); 	if (!ret) 		btrfs_reada_remove_dev(device); 	mutex_lock(&uuid_mutex); 	if (ret) 		goto error_undo;  	/* 	 * TODO: the superblock still includes this device in its num_devices 	 * counter although write_all_supers() is not locked out. This 	 * could give a filesystem state which requires a degraded mount. 	 */ 	ret = btrfs_rm_dev_item(device); 	if (ret) 		goto error_undo;  	clear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state); 	btrfs_scrub_cancel_dev(device);  	/* 	 * the device list mutex makes sure that we don't change 	 * the device list while someone else is writing out all 	 * the device supers. Whoever is writing all supers, should 	 * lock the device list mutex before getting the number of 	 * devices in the super block (super_copy). Conversely, 	 * whoever updates the number of devices in the super block 	 * (super_copy) should hold the device list mutex. 	 */  	/* 	 * In normal cases the cur_devices == fs_devices. But in case 	 * of deleting a seed device, the cur_devices should point to 	 * its own fs_devices listed under the fs_devices->seed. 	 */ 	cur_devices = device->fs_devices; 	mutex_lock(&fs_devices->device_list_mutex); 	list_del_rcu(&device->dev_list);  	cur_devices->num_devices--; 	cur_devices->total_devices--; 	/* Update total_devices of the parent fs_devices if it's seed */ 	if (cur_devices != fs_devices) 		fs_devices->total_devices--;  	if (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) 		cur_devices->missing_devices--;  	btrfs_assign_next_active_device(device, NULL);  	if (device->bdev) { 		cur_devices->open_devices--; 		/* remove sysfs entry */ 		btrfs_sysfs_remove_device(device); 	}  	num_devices = btrfs_super_num_devices(fs_info->super_copy) - 1; 	btrfs_set_super_num_devices(fs_info->super_copy, num_devices); 	mutex_unlock(&fs_devices->device_list_mutex);  	/* 	 * at this point, the device is zero sized and detached from 	 * the devices list.  All that's left is to zero out the old 	 * supers and free the device. 	 */ 	if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) 		btrfs_scratch_superblocks(fs_info, device->bdev, 					  device->name->str);  	btrfs_close_bdev(device); 	synchronize_rcu(); 	btrfs_free_device(device);  	if (cur_devices->open_devices == 0) { 		list_del_init(&cur_devices->seed_list); 		close_fs_devices(cur_devices); 		free_fs_devices(cur_devices); 	}  out: 	mutex_unlock(&uuid_mutex); 	return ret;  error_undo: 	btrfs_reada_undo_remove_dev(device); 	if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) { 		mutex_lock(&fs_info->chunk_mutex); 		list_add(&device->dev_alloc_list, 			 &fs_devices->alloc_list); 		device->fs_devices->rw_devices++; 		mutex_unlock(&fs_info->chunk_mutex); 	} 	goto out; }"
"195909_CWE-125.c","CWE-125","static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,      ExceptionInfo *exception) {   char     page_geometry[MagickPathExtent];    Image     *image;    MagickBooleanType     logging;    volatile int     first_mng_object,     object_id,     term_chunk_found,     skip_to_iend;    volatile ssize_t     image_count=0;    MagickBooleanType     status;    MagickOffsetType     offset;    MngBox     default_fb,     fb,     previous_fb;  #if defined(MNG_INSERT_LAYERS)   PixelInfo     mng_background_color; #endif    register unsigned char     *p;    register ssize_t     i;    size_t     count;    ssize_t     loop_level;    volatile short     skipping_loop;  #if defined(MNG_INSERT_LAYERS)   unsigned int     mandatory_back=0; #endif    volatile unsigned int #ifdef MNG_OBJECT_BUFFERS     mng_background_object=0, #endif     mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */    size_t     default_frame_timeout,     frame_timeout, #if defined(MNG_INSERT_LAYERS)     image_height,     image_width, #endif     length;    /* These delays are all measured in image ticks_per_second,    * not in MNG ticks_per_second    */   volatile size_t     default_frame_delay,     final_delay,     final_image_delay,     frame_delay, #if defined(MNG_INSERT_LAYERS)     insert_layers, #endif     mng_iterations=1,     simplicity=0,     subframe_height=0,     subframe_width=0;    previous_fb.top=0;   previous_fb.bottom=0;   previous_fb.left=0;   previous_fb.right=0;   default_fb.top=0;   default_fb.bottom=0;   default_fb.left=0;   default_fb.right=0;    logging=LogMagickEvent(CoderEvent,GetMagickModule(),     ""  Enter ReadOneMNGImage()"");    image=mng_info->image;    if (LocaleCompare(image_info->magick,""MNG"") == 0)     {       char         magic_number[MagickPathExtent];        /* Verify MNG signature.  */       count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);       if (memcmp(magic_number,""\212MNG\r\n\032\n"",8) != 0)         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");        /* Initialize some nonzero members of the MngInfo structure.  */       for (i=0; i < MNG_MAX_OBJECTS; i++)       {         mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;         mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;       }       mng_info->exists[0]=MagickTrue;     }    skipping_loop=(-1);   first_mng_object=MagickTrue;   mng_type=0; #if defined(MNG_INSERT_LAYERS)   insert_layers=MagickFalse; /* should be False during convert or mogrify */ #endif   default_frame_delay=0;   default_frame_timeout=0;   frame_delay=0;   final_delay=1;   mng_info->ticks_per_second=1UL*image->ticks_per_second;   object_id=0;   skip_to_iend=MagickFalse;   term_chunk_found=MagickFalse;   mng_info->framing_mode=1; #if defined(MNG_INSERT_LAYERS)   mandatory_back=MagickFalse; #endif #if defined(MNG_INSERT_LAYERS)   mng_background_color=image->background_color; #endif   default_fb=mng_info->frame;   previous_fb=mng_info->frame;   do   {     char       type[MagickPathExtent];      if (LocaleCompare(image_info->magick,""MNG"") == 0)       {         unsigned char           *chunk;          /*           Read a new chunk.         */         type[0]='\0';         (void) ConcatenateMagickString(type,""errr"",MagickPathExtent);         length=ReadBlobMSBLong(image);         count=(size_t) ReadBlob(image,4,(unsigned char *) type);          if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),            ""  Reading MNG chunk type %c%c%c%c, length: %.20g"",            type[0],type[1],type[2],type[3],(double) length);          if (length > PNG_UINT_31_MAX)           {             status=MagickFalse;             break;           }          if (count == 0)           ThrowReaderException(CorruptImageError,""CorruptImage"");          p=NULL;         chunk=(unsigned char *) NULL;          if (length != 0)           {             if (length > GetBlobSize(image))               ThrowReaderException(CorruptImageError,                 ""InsufficientImageDataInFile"");             chunk=(unsigned char *) AcquireQuantumMemory(length+              MagickPathExtent,sizeof(*chunk));              if (chunk == (unsigned char *) NULL)               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");              for (i=0; i < (ssize_t) length; i++)             {               int                 c;                c=ReadBlobByte(image);               if (c == EOF)                 break;               chunk[i]=(unsigned char) c;             }              p=chunk;           }          (void) ReadBlobMSBLong(image);  /* read crc word */  #if !defined(JNG_SUPPORTED)         if (memcmp(type,mng_JHDR,4) == 0)           {             skip_to_iend=MagickTrue;              if (mng_info->jhdr_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""JNGCompressNotSupported"",""`%s'"",image->filename);              mng_info->jhdr_warning++;           } #endif         if (memcmp(type,mng_DHDR,4) == 0)           {             skip_to_iend=MagickTrue;              if (mng_info->dhdr_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""DeltaPNGNotSupported"",""`%s'"",image->filename);              mng_info->dhdr_warning++;           }         if (memcmp(type,mng_MEND,4) == 0)           break;          if (skip_to_iend)           {             if (memcmp(type,mng_IEND,4) == 0)               skip_to_iend=MagickFalse;              if (length != 0)               chunk=(unsigned char *) RelinquishMagickMemory(chunk);              if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""  Skip to IEND."");              continue;           }          if (memcmp(type,mng_MHDR,4) == 0)           {             if (length != 28)               {                 chunk=(unsigned char *) RelinquishMagickMemory(chunk);                 ThrowReaderException(CorruptImageError,""CorruptImage"");               }              mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |                 (p[2] << 8) | p[3]);              mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |                 (p[6] << 8) | p[7]);              if (logging != MagickFalse)               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  MNG width: %.20g"",(double) mng_info->mng_width);                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  MNG height: %.20g"",(double) mng_info->mng_height);               }              p+=8;             mng_info->ticks_per_second=(size_t) mng_get_long(p);              if (mng_info->ticks_per_second == 0)               default_frame_delay=0;              else               default_frame_delay=1UL*image->ticks_per_second/                 mng_info->ticks_per_second;              frame_delay=default_frame_delay;             simplicity=0;              p+=16;             simplicity=(size_t) mng_get_long(p);              mng_type=1;    /* Full MNG */              if ((simplicity != 0) && ((simplicity | 11) == 11))               mng_type=2; /* LC */              if ((simplicity != 0) && ((simplicity | 9) == 9))               mng_type=3; /* VLC */  #if defined(MNG_INSERT_LAYERS)             if (mng_type != 3)               insert_layers=MagickTrue; #endif             if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)               {                 /* Allocate next image structure.  */                 AcquireNextImage(image_info,image,exception);                  if (GetNextImageInList(image) == (Image *) NULL)                   return((Image *) NULL);                  image=SyncNextImageInList(image);                 mng_info->image=image;               }              if ((mng_info->mng_width > 65535L) ||                 (mng_info->mng_height > 65535L))               {                 chunk=(unsigned char *) RelinquishMagickMemory(chunk);                 ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit"");               }              (void) FormatLocaleString(page_geometry,MagickPathExtent,               ""%.20gx%.20g+0+0"",(double) mng_info->mng_width,(double)               mng_info->mng_height);              mng_info->frame.left=0;             mng_info->frame.right=(ssize_t) mng_info->mng_width;             mng_info->frame.top=0;             mng_info->frame.bottom=(ssize_t) mng_info->mng_height;             mng_info->clip=default_fb=previous_fb=mng_info->frame;              for (i=0; i < MNG_MAX_OBJECTS; i++)               mng_info->object_clip[i]=mng_info->frame;              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_TERM,4) == 0)           {             int               repeat=0;              if (length != 0)               repeat=p[0];              if (repeat == 3)               {                 final_delay=(png_uint_32) mng_get_long(&p[2]);                 mng_iterations=(png_uint_32) mng_get_long(&p[6]);                  if (mng_iterations == PNG_UINT_31_MAX)                   mng_iterations=0;                  image->iterations=mng_iterations;                 term_chunk_found=MagickTrue;               }              if (logging != MagickFalse)               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""    repeat=%d,  final_delay=%.20g,  iterations=%.20g"",                   repeat,(double) final_delay, (double) image->iterations);               }              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }         if (memcmp(type,mng_DEFI,4) == 0)           {             if (mng_type == 3)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""DEFI chunk found in MNG-VLC datastream"",""`%s'"",                 image->filename);              if (length < 2)               {                 if (chunk)                   chunk=(unsigned char *) RelinquishMagickMemory(chunk);                 ThrowReaderException(CorruptImageError,""CorruptImage"");               }              object_id=(p[0] << 8) | p[1];              if (mng_type == 2 && object_id != 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""Nonzero object_id in MNG-LC datastream"",""`%s'"",                 image->filename);              if (object_id > MNG_MAX_OBJECTS)               {                 /*                   Instead of using a warning we should allocate a larger                   MngInfo structure and continue.                 */                 (void) ThrowMagickException(exception,GetMagickModule(),                   CoderError,""object id too large"",""`%s'"",image->filename);                 object_id=MNG_MAX_OBJECTS;               }              if (mng_info->exists[object_id])               if (mng_info->frozen[object_id])                 {                   chunk=(unsigned char *) RelinquishMagickMemory(chunk);                   (void) ThrowMagickException(exception,                     GetMagickModule(),CoderError,                     ""DEFI cannot redefine a frozen MNG object"",""`%s'"",                     image->filename);                   continue;                 }              mng_info->exists[object_id]=MagickTrue;              if (length > 2)               mng_info->invisible[object_id]=p[2];              /*               Extract object offset info.             */             if (length > 11)               {                 mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |                     (p[5] << 16) | (p[6] << 8) | p[7]);                  mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |                     (p[9] << 16) | (p[10] << 8) | p[11]);                  if (logging != MagickFalse)                   {                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),                       ""  x_off[%d]: %.20g,  y_off[%d]: %.20g"",                       object_id,(double) mng_info->x_off[object_id],                       object_id,(double) mng_info->y_off[object_id]);                   }               }              /*               Extract object clipping info.             */             if (length > 27)               mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,                 &p[12]);              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }         if (memcmp(type,mng_bKGD,4) == 0)           {             mng_info->have_global_bkgd=MagickFalse;              if (length > 5)               {                 mng_info->mng_global_bkgd.red=                   ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));                  mng_info->mng_global_bkgd.green=                   ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));                  mng_info->mng_global_bkgd.blue=                   ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));                  mng_info->have_global_bkgd=MagickTrue;               }              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }         if (memcmp(type,mng_BACK,4) == 0)           { #if defined(MNG_INSERT_LAYERS)             if (length > 6)               mandatory_back=p[6];              else               mandatory_back=0;              if (mandatory_back && length > 5)               {                 mng_background_color.red=                     ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));                  mng_background_color.green=                     ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));                  mng_background_color.blue=                     ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));                  mng_background_color.alpha=OpaqueAlpha;               }  #ifdef MNG_OBJECT_BUFFERS             if (length > 8)               mng_background_object=(p[7] << 8) | p[8]; #endif #endif             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_PLTE,4) == 0)           {             /* Read global PLTE.  */              if (length && (length < 769))               {                 if (mng_info->global_plte == (png_colorp) NULL)                   mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,                     sizeof(*mng_info->global_plte));                  for (i=0; i < (ssize_t) (length/3); i++)                 {                   mng_info->global_plte[i].red=p[3*i];                   mng_info->global_plte[i].green=p[3*i+1];                   mng_info->global_plte[i].blue=p[3*i+2];                 }                  mng_info->global_plte_length=(unsigned int) (length/3);               } #ifdef MNG_LOOSE             for ( ; i < 256; i++)             {               mng_info->global_plte[i].red=i;               mng_info->global_plte[i].green=i;               mng_info->global_plte[i].blue=i;             }              if (length != 0)               mng_info->global_plte_length=256; #endif             else               mng_info->global_plte_length=0;              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_tRNS,4) == 0)           {             /* read global tRNS */              if (length > 0 && length < 257)               for (i=0; i < (ssize_t) length; i++)                 mng_info->global_trns[i]=p[i];  #ifdef MNG_LOOSE             for ( ; i < 256; i++)               mng_info->global_trns[i]=255; #endif             mng_info->global_trns_length=(unsigned int) length;             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }         if (memcmp(type,mng_gAMA,4) == 0)           {             if (length == 4)               {                 ssize_t                   igamma;                  igamma=mng_get_long(p);                 mng_info->global_gamma=((float) igamma)*0.00001;                 mng_info->have_global_gama=MagickTrue;               }              else               mng_info->have_global_gama=MagickFalse;              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_cHRM,4) == 0)           {             /* Read global cHRM */              if (length == 32)               {                 mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);                 mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);                 mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);                 mng_info->global_chrm.red_primary.y=0.00001*                   mng_get_long(&p[12]);                 mng_info->global_chrm.green_primary.x=0.00001*                   mng_get_long(&p[16]);                 mng_info->global_chrm.green_primary.y=0.00001*                   mng_get_long(&p[20]);                 mng_info->global_chrm.blue_primary.x=0.00001*                   mng_get_long(&p[24]);                 mng_info->global_chrm.blue_primary.y=0.00001*                   mng_get_long(&p[28]);                 mng_info->have_global_chrm=MagickTrue;               }             else               mng_info->have_global_chrm=MagickFalse;              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_sRGB,4) == 0)           {             /*               Read global sRGB.             */             if (length != 0)               {                 mng_info->global_srgb_intent=                   Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);                 mng_info->have_global_srgb=MagickTrue;               }             else               mng_info->have_global_srgb=MagickFalse;              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_iCCP,4) == 0)           {             /* To do: */              /*               Read global iCCP.             */             if (length != 0)               chunk=(unsigned char *) RelinquishMagickMemory(chunk);              continue;           }          if (memcmp(type,mng_FRAM,4) == 0)           {             if (mng_type == 3)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""FRAM chunk found in MNG-VLC datastream"",""`%s'"",                 image->filename);              if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))               image->delay=frame_delay;              frame_delay=default_frame_delay;             frame_timeout=default_frame_timeout;             fb=default_fb;              if (length != 0)               if (p[0])                 mng_info->framing_mode=p[0];              if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""    Framing_mode=%d"",mng_info->framing_mode);              if (length > 6)               {                 /* Note the delay and frame clipping boundaries.  */                  p++; /* framing mode */                  while (*p && ((p-chunk) < (ssize_t) length))                   p++;  /* frame name */                  p++;  /* frame name terminator */                  if ((p-chunk) < (ssize_t) (length-4))                   {                     int                       change_delay,                       change_timeout,                       change_clipping;                      change_delay=(*p++);                     change_timeout=(*p++);                     change_clipping=(*p++);                     p++; /* change_sync */                      if (change_delay)                       {                         frame_delay=1UL*image->ticks_per_second*                           mng_get_long(p);                          if (mng_info->ticks_per_second != 0)                           frame_delay/=mng_info->ticks_per_second;                          else                           frame_delay=PNG_UINT_31_MAX;                          if (change_delay == 2)                           default_frame_delay=frame_delay;                          p+=4;                          if (logging != MagickFalse)                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),                             ""    Framing_delay=%.20g"",(double) frame_delay);                       }                      if (change_timeout)                       {                         frame_timeout=1UL*image->ticks_per_second*                           mng_get_long(p);                          if (mng_info->ticks_per_second != 0)                           frame_timeout/=mng_info->ticks_per_second;                          else                           frame_timeout=PNG_UINT_31_MAX;                          if (change_timeout == 2)                           default_frame_timeout=frame_timeout;                          p+=4;                          if (logging != MagickFalse)                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),                             ""    Framing_timeout=%.20g"",(double) frame_timeout);                       }                      if (change_clipping)                       {                         fb=mng_read_box(previous_fb,(char) p[0],&p[1]);                         p+=17;                         previous_fb=fb;                          if (logging != MagickFalse)                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),                             ""    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g"",                             (double) fb.left,(double) fb.right,(double) fb.top,                             (double) fb.bottom);                          if (change_clipping == 2)                           default_fb=fb;                       }                   }               }             mng_info->clip=fb;             mng_info->clip=mng_minimum_box(fb,mng_info->frame);              subframe_width=(size_t) (mng_info->clip.right                -mng_info->clip.left);              subframe_height=(size_t) (mng_info->clip.bottom                -mng_info->clip.top);             /*               Insert a background layer behind the frame if framing_mode is 4.             */ #if defined(MNG_INSERT_LAYERS)             if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""   subframe_width=%.20g, subframe_height=%.20g"",(double)                 subframe_width,(double) subframe_height);              if (insert_layers && (mng_info->framing_mode == 4) &&                 (subframe_width) && (subframe_height))               {                 /* Allocate next image structure.  */                 if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)                   {                     AcquireNextImage(image_info,image,exception);                      if (GetNextImageInList(image) == (Image *) NULL)                       return(DestroyImageList(image));                      image=SyncNextImageInList(image);                   }                  mng_info->image=image;                  if (term_chunk_found)                   {                     image->start_loop=MagickTrue;                     image->iterations=mng_iterations;                     term_chunk_found=MagickFalse;                   }                  else                     image->start_loop=MagickFalse;                  image->columns=subframe_width;                 image->rows=subframe_height;                 image->page.width=subframe_width;                 image->page.height=subframe_height;                 image->page.x=mng_info->clip.left;                 image->page.y=mng_info->clip.top;                 image->background_color=mng_background_color;                 image->alpha_trait=UndefinedPixelTrait;                 image->delay=0;                 (void) SetImageBackgroundColor(image,exception);                  if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g"",                     (double) mng_info->clip.left,                     (double) mng_info->clip.right,                     (double) mng_info->clip.top,                     (double) mng_info->clip.bottom);               } #endif             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_CLIP,4) == 0)           {             unsigned int               first_object,               last_object;              /*               Read CLIP.             */             if (length > 3)               {                 first_object=(p[0] << 8) | p[1];                 last_object=(p[2] << 8) | p[3];                 p+=4;                  for (i=(int) first_object; i <= (int) last_object; i++)                 {                   if (mng_info->exists[i] && !mng_info->frozen[i])                     {                       MngBox                         box;                        box=mng_info->object_clip[i];                       if ((p-chunk) < (ssize_t) (length-17))                         mng_info->object_clip[i]=                            mng_read_box(box,(char) p[0],&p[1]);                     }                 }                }             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_SAVE,4) == 0)           {             for (i=1; i < MNG_MAX_OBJECTS; i++)               if (mng_info->exists[i])                 {                  mng_info->frozen[i]=MagickTrue; #ifdef MNG_OBJECT_BUFFERS                  if (mng_info->ob[i] != (MngBuffer *) NULL)                     mng_info->ob[i]->frozen=MagickTrue; #endif                 }              if (length != 0)               chunk=(unsigned char *) RelinquishMagickMemory(chunk);              continue;           }          if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))           {             /* Read DISC or SEEK.  */              if ((length == 0) || !memcmp(type,mng_SEEK,4))               {                 for (i=1; i < MNG_MAX_OBJECTS; i++)                   MngInfoDiscardObject(mng_info,i);               }              else               {                 register ssize_t                   j;                  for (j=1; j < (ssize_t) length; j+=2)                 {                   i=p[j-1] << 8 | p[j];                   MngInfoDiscardObject(mng_info,i);                 }               }              if (length != 0)               chunk=(unsigned char *) RelinquishMagickMemory(chunk);              continue;           }          if (memcmp(type,mng_MOVE,4) == 0)           {             size_t               first_object,               last_object;              /* read MOVE */              if (length > 3)             {               first_object=(p[0] << 8) | p[1];               last_object=(p[2] << 8) | p[3];               p+=4;                for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)               {                 if ((i < 0) || (i >= MNG_MAX_OBJECTS))                   continue;                  if (mng_info->exists[i] && !mng_info->frozen[i] &&                     (p-chunk) < (ssize_t) (length-8))                   {                     MngPair                       new_pair;                      MngPair                       old_pair;                      old_pair.a=mng_info->x_off[i];                     old_pair.b=mng_info->y_off[i];                     new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);                     mng_info->x_off[i]=new_pair.a;                     mng_info->y_off[i]=new_pair.b;                   }               }             }              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_LOOP,4) == 0)           {             ssize_t loop_iters=1;             if (length > 4)               {                 loop_level=chunk[0];                 mng_info->loop_active[loop_level]=1;  /* mark loop active */                  /* Record starting point.  */                 loop_iters=mng_get_long(&chunk[1]);                  if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""  LOOP level %.20g has %.20g iterations "",                     (double) loop_level, (double) loop_iters);                  if (loop_iters == 0)                   skipping_loop=loop_level;                  else                   {                     mng_info->loop_jump[loop_level]=TellBlob(image);                     mng_info->loop_count[loop_level]=loop_iters;                   }                  mng_info->loop_iteration[loop_level]=0;               }             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_ENDL,4) == 0)           {             if (length > 0)               {                 loop_level=chunk[0];                  if (skipping_loop > 0)                   {                     if (skipping_loop == loop_level)                       {                         /*                           Found end of zero-iteration loop.                         */                         skipping_loop=(-1);                         mng_info->loop_active[loop_level]=0;                       }                   }                  else                   {                     if (mng_info->loop_active[loop_level] == 1)                       {                         mng_info->loop_count[loop_level]--;                         mng_info->loop_iteration[loop_level]++;                          if (logging != MagickFalse)                           (void) LogMagickEvent(CoderEvent,GetMagickModule(),                           ""  ENDL: LOOP level %.20g has %.20g remaining iters"",                             (double) loop_level,(double)                             mng_info->loop_count[loop_level]);                          if (mng_info->loop_count[loop_level] != 0)                           {                             offset=                               SeekBlob(image,mng_info->loop_jump[loop_level],                               SEEK_SET);                              if (offset < 0)                               {                                 chunk=(unsigned char *) RelinquishMagickMemory(                                   chunk);                                 ThrowReaderException(CorruptImageError,                                   ""ImproperImageHeader"");                               }                           }                          else                           {                             short                               last_level;                              /*                               Finished loop.                             */                             mng_info->loop_active[loop_level]=0;                             last_level=(-1);                             for (i=0; i < loop_level; i++)                               if (mng_info->loop_active[i] == 1)                                 last_level=(short) i;                             loop_level=last_level;                           }                       }                   }               }              chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_CLON,4) == 0)           {             if (mng_info->clon_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""CLON is not implemented yet"",""`%s'"",                 image->filename);              mng_info->clon_warning++;           }          if (memcmp(type,mng_MAGN,4) == 0)           {             png_uint_16               magn_first,               magn_last,               magn_mb,               magn_ml,               magn_mr,               magn_mt,               magn_mx,               magn_my,               magn_methx,               magn_methy;              if (length > 1)               magn_first=(p[0] << 8) | p[1];              else               magn_first=0;              if (length > 3)               magn_last=(p[2] << 8) | p[3];              else               magn_last=magn_first; #ifndef MNG_OBJECT_BUFFERS             if (magn_first || magn_last)               if (mng_info->magn_warning == 0)                 {                   (void) ThrowMagickException(exception,                      GetMagickModule(),CoderError,                      ""MAGN is not implemented yet for nonzero objects"",                      ""`%s'"",image->filename);                     mng_info->magn_warning++;                 } #endif             if (length > 4)               magn_methx=p[4];              else               magn_methx=0;              if (length > 6)               magn_mx=(p[5] << 8) | p[6];              else               magn_mx=1;              if (magn_mx == 0)               magn_mx=1;              if (length > 8)               magn_my=(p[7] << 8) | p[8];              else               magn_my=magn_mx;              if (magn_my == 0)               magn_my=1;              if (length > 10)               magn_ml=(p[9] << 8) | p[10];              else               magn_ml=magn_mx;              if (magn_ml == 0)               magn_ml=1;              if (length > 12)               magn_mr=(p[11] << 8) | p[12];              else               magn_mr=magn_mx;              if (magn_mr == 0)               magn_mr=1;              if (length > 14)               magn_mt=(p[13] << 8) | p[14];              else               magn_mt=magn_my;              if (magn_mt == 0)               magn_mt=1;              if (length > 16)               magn_mb=(p[15] << 8) | p[16];              else               magn_mb=magn_my;              if (magn_mb == 0)               magn_mb=1;              if (length > 17)               magn_methy=p[17];              else               magn_methy=magn_methx;               if (magn_methx > 5 || magn_methy > 5)               if (mng_info->magn_warning == 0)                 {                   (void) ThrowMagickException(exception,                      GetMagickModule(),CoderError,                      ""Unknown MAGN method in MNG datastream"",""`%s'"",                      image->filename);                     mng_info->magn_warning++;                 } #ifdef MNG_OBJECT_BUFFERS           /* Magnify existing objects in the range magn_first to magn_last */ #endif             if (magn_first == 0 || magn_last == 0)               {                 /* Save the magnification factors for object 0 */                 mng_info->magn_mb=magn_mb;                 mng_info->magn_ml=magn_ml;                 mng_info->magn_mr=magn_mr;                 mng_info->magn_mt=magn_mt;                 mng_info->magn_mx=magn_mx;                 mng_info->magn_my=magn_my;                 mng_info->magn_methx=magn_methx;                 mng_info->magn_methy=magn_methy;               }           }          if (memcmp(type,mng_PAST,4) == 0)           {             if (mng_info->past_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""PAST is not implemented yet"",""`%s'"",                 image->filename);              mng_info->past_warning++;           }          if (memcmp(type,mng_SHOW,4) == 0)           {             if (mng_info->show_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""SHOW is not implemented yet"",""`%s'"",                 image->filename);              mng_info->show_warning++;           }          if (memcmp(type,mng_sBIT,4) == 0)           {             if (length < 4)               mng_info->have_global_sbit=MagickFalse;              else               {                 mng_info->global_sbit.gray=p[0];                 mng_info->global_sbit.red=p[0];                 mng_info->global_sbit.green=p[1];                 mng_info->global_sbit.blue=p[2];                 mng_info->global_sbit.alpha=p[3];                 mng_info->have_global_sbit=MagickTrue;              }           }         if (memcmp(type,mng_pHYs,4) == 0)           {             if (length > 8)               {                 mng_info->global_x_pixels_per_unit=                     (size_t) mng_get_long(p);                 mng_info->global_y_pixels_per_unit=                     (size_t) mng_get_long(&p[4]);                 mng_info->global_phys_unit_type=p[8];                 mng_info->have_global_phys=MagickTrue;               }              else               mng_info->have_global_phys=MagickFalse;           }         if (memcmp(type,mng_pHYg,4) == 0)           {             if (mng_info->phyg_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""pHYg is not implemented."",""`%s'"",image->filename);              mng_info->phyg_warning++;           }         if (memcmp(type,mng_BASI,4) == 0)           {             skip_to_iend=MagickTrue;              if (mng_info->basi_warning == 0)               (void) ThrowMagickException(exception,GetMagickModule(),                 CoderError,""BASI is not implemented yet"",""`%s'"",                 image->filename);              mng_info->basi_warning++; #ifdef MNG_BASI_SUPPORTED             basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |                (p[2] << 8) | p[3]);             basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |                (p[6] << 8) | p[7]);             basi_color_type=p[8];             basi_compression_method=p[9];             basi_filter_type=p[10];             basi_interlace_method=p[11];             if (length > 11)               basi_red=(p[12] << 8) & p[13];              else               basi_red=0;              if (length > 13)               basi_green=(p[14] << 8) & p[15];              else               basi_green=0;              if (length > 15)               basi_blue=(p[16] << 8) & p[17];              else               basi_blue=0;              if (length > 17)               basi_alpha=(p[18] << 8) & p[19];              else               {                 if (basi_sample_depth == 16)                   basi_alpha=65535L;                 else                   basi_alpha=255;               }              if (length > 19)               basi_viewable=p[20];              else               basi_viewable=0;  #endif             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           }          if (memcmp(type,mng_IHDR,4) #if defined(JNG_SUPPORTED)             && memcmp(type,mng_JHDR,4) #endif             )           {             /* Not an IHDR or JHDR chunk */             if (length != 0)               chunk=(unsigned char *) RelinquishMagickMemory(chunk);              continue;           } /* Process IHDR */         if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Processing %c%c%c%c chunk"",type[0],type[1],type[2],type[3]);          mng_info->exists[object_id]=MagickTrue;         mng_info->viewable[object_id]=MagickTrue;          if (mng_info->invisible[object_id])           {             if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""  Skipping invisible object"");              skip_to_iend=MagickTrue;             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             continue;           } #if defined(MNG_INSERT_LAYERS)         if (length < 8)           {             chunk=(unsigned char *) RelinquishMagickMemory(chunk);             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");           }          image_width=(size_t) mng_get_long(p);         image_height=(size_t) mng_get_long(&p[4]); #endif         chunk=(unsigned char *) RelinquishMagickMemory(chunk);          /*           Insert a transparent background layer behind the entire animation           if it is not full screen.         */ #if defined(MNG_INSERT_LAYERS)         if (insert_layers && mng_type && first_mng_object)           {             if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||                 (image_width < mng_info->mng_width) ||                 (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||                 (image_height < mng_info->mng_height) ||                 (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))               {                 if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)                   {                     /*                       Allocate next image structure.                     */                     AcquireNextImage(image_info,image,exception);                      if (GetNextImageInList(image) == (Image *) NULL)                       return(DestroyImageList(image));                      image=SyncNextImageInList(image);                   }                 mng_info->image=image;                  if (term_chunk_found)                   {                     image->start_loop=MagickTrue;                     image->iterations=mng_iterations;                     term_chunk_found=MagickFalse;                   }                  else                     image->start_loop=MagickFalse;                  /* Make a background rectangle.  */                  image->delay=0;                 image->columns=mng_info->mng_width;                 image->rows=mng_info->mng_height;                 image->page.width=mng_info->mng_width;                 image->page.height=mng_info->mng_height;                 image->page.x=0;                 image->page.y=0;                 image->background_color=mng_background_color;                 (void) SetImageBackgroundColor(image,exception);                 if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""  Inserted transparent background layer, W=%.20g, H=%.20g"",                     (double) mng_info->mng_width,(double) mng_info->mng_height);               }           }         /*           Insert a background layer behind the upcoming image if           framing_mode is 3, and we haven't already inserted one.         */         if (insert_layers && (mng_info->framing_mode == 3) &&                 (subframe_width) && (subframe_height) && (simplicity == 0 ||                 (simplicity & 0x08)))           {             if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)             {               /*                 Allocate next image structure.               */               AcquireNextImage(image_info,image,exception);                if (GetNextImageInList(image) == (Image *) NULL)                 return(DestroyImageList(image));                image=SyncNextImageInList(image);             }              mng_info->image=image;              if (term_chunk_found)               {                 image->start_loop=MagickTrue;                 image->iterations=mng_iterations;                 term_chunk_found=MagickFalse;               }              else                 image->start_loop=MagickFalse;              image->delay=0;             image->columns=subframe_width;             image->rows=subframe_height;             image->page.width=subframe_width;             image->page.height=subframe_height;             image->page.x=mng_info->clip.left;             image->page.y=mng_info->clip.top;             image->background_color=mng_background_color;             image->alpha_trait=UndefinedPixelTrait;             (void) SetImageBackgroundColor(image,exception);              if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g"",                 (double) mng_info->clip.left,(double) mng_info->clip.right,                 (double) mng_info->clip.top,(double) mng_info->clip.bottom);           } #endif /* MNG_INSERT_LAYERS */         first_mng_object=MagickFalse;          if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)           {             /*               Allocate next image structure.             */             AcquireNextImage(image_info,image,exception);              if (GetNextImageInList(image) == (Image *) NULL)               return(DestroyImageList(image));              image=SyncNextImageInList(image);           }         mng_info->image=image;         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),           GetBlobSize(image));          if (status == MagickFalse)           break;          if (term_chunk_found)           {             image->start_loop=MagickTrue;             term_chunk_found=MagickFalse;           }          else             image->start_loop=MagickFalse;          if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)           {             image->delay=frame_delay;             frame_delay=default_frame_delay;           }          else           image->delay=0;          image->page.width=mng_info->mng_width;         image->page.height=mng_info->mng_height;         image->page.x=mng_info->x_off[object_id];         image->page.y=mng_info->y_off[object_id];         image->iterations=mng_iterations;          /*           Seek back to the beginning of the IHDR or JHDR chunk's length field.         */          if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Seeking back to beginning of %c%c%c%c chunk"",type[0],type[1],             type[2],type[3]);          offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);          if (offset < 0)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }      mng_info->image=image;     mng_info->mng_type=mng_type;     mng_info->object_id=object_id;      if (memcmp(type,mng_IHDR,4) == 0)       image=ReadOnePNGImage(mng_info,image_info,exception);  #if defined(JNG_SUPPORTED)     else       image=ReadOneJNGImage(mng_info,image_info,exception); #endif      if (image == (Image *) NULL)       {         if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""exit ReadJNGImage() with error"");          return((Image *) NULL);       }      if (image->columns == 0 || image->rows == 0)       {         (void) CloseBlob(image);         return(DestroyImageList(image));       }      mng_info->image=image;      if (mng_type)       {         MngBox           crop_box;          if (mng_info->magn_methx || mng_info->magn_methy)           {             png_uint_32                magnified_height,                magnified_width;              if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""  Processing MNG MAGN chunk"");              if (mng_info->magn_methx == 1)               {                 magnified_width=mng_info->magn_ml;                  if (image->columns > 1)                    magnified_width += mng_info->magn_mr;                  if (image->columns > 2)                    magnified_width += (png_uint_32)                       ((image->columns-2)*(mng_info->magn_mx));               }              else               {                 magnified_width=(png_uint_32) image->columns;                  if (image->columns > 1)                    magnified_width += mng_info->magn_ml-1;                  if (image->columns > 2)                    magnified_width += mng_info->magn_mr-1;                  if (image->columns > 3)                    magnified_width += (png_uint_32)                       ((image->columns-3)*(mng_info->magn_mx-1));               }              if (mng_info->magn_methy == 1)               {                 magnified_height=mng_info->magn_mt;                  if (image->rows > 1)                    magnified_height += mng_info->magn_mb;                  if (image->rows > 2)                    magnified_height += (png_uint_32)                       ((image->rows-2)*(mng_info->magn_my));               }              else               {                 magnified_height=(png_uint_32) image->rows;                  if (image->rows > 1)                    magnified_height += mng_info->magn_mt-1;                  if (image->rows > 2)                    magnified_height += mng_info->magn_mb-1;                  if (image->rows > 3)                    magnified_height += (png_uint_32)                       ((image->rows-3)*(mng_info->magn_my-1));               }              if (magnified_height > image->rows ||                 magnified_width > image->columns)               {                 Image                   *large_image;                  int                   yy;                  Quantum                   *next,                   *prev;                  png_uint_16                   magn_methx,                   magn_methy;                  ssize_t                   m,                   y;                  register Quantum                   *n,                   *q;                  register ssize_t                   x;                  /* Allocate next image structure.  */                  if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""    Allocate magnified image"");                  AcquireNextImage(image_info,image,exception);                  if (GetNextImageInList(image) == (Image *) NULL)                   return(DestroyImageList(image));                  large_image=SyncNextImageInList(image);                  large_image->columns=magnified_width;                 large_image->rows=magnified_height;                  magn_methx=mng_info->magn_methx;                 magn_methy=mng_info->magn_methy;  #if (MAGICKCORE_QUANTUM_DEPTH > 16) #define QM unsigned short                 if (magn_methx != 1 || magn_methy != 1)                   {                   /*                      Scale pixels to unsigned shorts to prevent                      overflow of intermediate values of interpolations                   */                      for (y=0; y < (ssize_t) image->rows; y++)                      {                        q=GetAuthenticPixels(image,0,y,image->columns,1,                           exception);                         for (x=(ssize_t) image->columns-1; x >= 0; x--)                        {                           SetPixelRed(image,ScaleQuantumToShort(                             GetPixelRed(image,q)),q);                           SetPixelGreen(image,ScaleQuantumToShort(                             GetPixelGreen(image,q)),q);                           SetPixelBlue(image,ScaleQuantumToShort(                             GetPixelBlue(image,q)),q);                           SetPixelAlpha(image,ScaleQuantumToShort(                             GetPixelAlpha(image,q)),q);                           q+=GetPixelChannels(image);                        }                         if (SyncAuthenticPixels(image,exception) == MagickFalse)                          break;                      }                   } #else #define QM Quantum #endif                  if (image->alpha_trait != UndefinedPixelTrait)                    (void) SetImageBackgroundColor(large_image,exception);                  else                   {                     large_image->background_color.alpha=OpaqueAlpha;                     (void) SetImageBackgroundColor(large_image,exception);                      if (magn_methx == 4)                       magn_methx=2;                      if (magn_methx == 5)                       magn_methx=3;                      if (magn_methy == 4)                       magn_methy=2;                      if (magn_methy == 5)                       magn_methy=3;                   }                  /* magnify the rows into the right side of the large image */                  if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""    Magnify the rows to %.20g"",                     (double) large_image->rows);                 m=(ssize_t) mng_info->magn_mt;                 yy=0;                 length=(size_t) GetPixelChannels(image)*image->columns;                 next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));                 prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));                  if ((prev == (Quantum *) NULL) ||                     (next == (Quantum *) NULL))                   {                      image=DestroyImageList(image);                      ThrowReaderException(ResourceLimitError,                        ""MemoryAllocationFailed"");                   }                  n=GetAuthenticPixels(image,0,0,image->columns,1,exception);                 (void) CopyMagickMemory(next,n,length);                  for (y=0; y < (ssize_t) image->rows; y++)                 {                   if (y == 0)                     m=(ssize_t) mng_info->magn_mt;                    else if (magn_methy > 1 && y == (ssize_t) image->rows-2)                     m=(ssize_t) mng_info->magn_mb;                    else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)                     m=(ssize_t) mng_info->magn_mb;                    else if (magn_methy > 1 && y == (ssize_t) image->rows-1)                     m=1;                    else                     m=(ssize_t) mng_info->magn_my;                    n=prev;                   prev=next;                   next=n;                    if (y < (ssize_t) image->rows-1)                     {                       n=GetAuthenticPixels(image,0,y+1,image->columns,1,                           exception);                       (void) CopyMagickMemory(next,n,length);                     }                    for (i=0; i < m; i++, yy++)                   {                     register Quantum                       *pixels;                      assert(yy < (ssize_t) large_image->rows);                     pixels=prev;                     n=next;                     q=GetAuthenticPixels(large_image,0,yy,large_image->columns,                       1,exception);                     q+=(large_image->columns-image->columns)*                       GetPixelChannels(large_image);                      for (x=(ssize_t) image->columns-1; x >= 0; x--)                     {                       /* To do: get color as function of indexes[x] */                       /*                       if (image->storage_class == PseudoClass)                         {                         }                       */                        if (magn_methy <= 1)                         {                           /* replicate previous */                           SetPixelRed(large_image,GetPixelRed(image,pixels),q);                           SetPixelGreen(large_image,GetPixelGreen(image,                              pixels),q);                           SetPixelBlue(large_image,GetPixelBlue(image,                              pixels),q);                           SetPixelAlpha(large_image,GetPixelAlpha(image,                              pixels),q);                         }                        else if (magn_methy == 2 || magn_methy == 4)                         {                           if (i == 0)                             {                               SetPixelRed(large_image,GetPixelRed(image,                                  pixels),q);                               SetPixelGreen(large_image,GetPixelGreen(image,                                  pixels),q);                               SetPixelBlue(large_image,GetPixelBlue(image,                                  pixels),q);                               SetPixelAlpha(large_image,GetPixelAlpha(image,                                  pixels),q);                             }                            else                             {                               /* Interpolate */                               SetPixelRed(large_image,((QM) (((ssize_t)                                  (2*i*(GetPixelRed(image,n)                                  -GetPixelRed(image,pixels)+m))/                                  ((ssize_t) (m*2))                                  +GetPixelRed(image,pixels)))),q);                               SetPixelGreen(large_image,((QM) (((ssize_t)                                  (2*i*(GetPixelGreen(image,n)                                  -GetPixelGreen(image,pixels)+m))/                                  ((ssize_t) (m*2))                                  +GetPixelGreen(image,pixels)))),q);                               SetPixelBlue(large_image,((QM) (((ssize_t)                                  (2*i*(GetPixelBlue(image,n)                                  -GetPixelBlue(image,pixels)+m))/                                  ((ssize_t) (m*2))                                  +GetPixelBlue(image,pixels)))),q);                                if (image->alpha_trait != UndefinedPixelTrait)                                  SetPixelAlpha(large_image, ((QM) (((ssize_t)                                     (2*i*(GetPixelAlpha(image,n)                                     -GetPixelAlpha(image,pixels)+m))                                     /((ssize_t) (m*2))+                                    GetPixelAlpha(image,pixels)))),q);                             }                            if (magn_methy == 4)                             {                               /* Replicate nearest */                               if (i <= ((m+1) << 1))                                  SetPixelAlpha(large_image,GetPixelAlpha(image,                                     pixels),q);                               else                                  SetPixelAlpha(large_image,GetPixelAlpha(image,                                     n),q);                             }                         }                        else /* if (magn_methy == 3 || magn_methy == 5) */                         {                           /* Replicate nearest */                           if (i <= ((m+1) << 1))                           {                              SetPixelRed(large_image,GetPixelRed(image,                                     pixels),q);                              SetPixelGreen(large_image,GetPixelGreen(image,                                     pixels),q);                              SetPixelBlue(large_image,GetPixelBlue(image,                                     pixels),q);                              SetPixelAlpha(large_image,GetPixelAlpha(image,                                     pixels),q);                           }                            else                           {                              SetPixelRed(large_image,GetPixelRed(image,n),q);                              SetPixelGreen(large_image,GetPixelGreen(image,n),                                     q);                              SetPixelBlue(large_image,GetPixelBlue(image,n),                                     q);                              SetPixelAlpha(large_image,GetPixelAlpha(image,n),                                     q);                           }                            if (magn_methy == 5)                             {                               SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*                                  (GetPixelAlpha(image,n)                                  -GetPixelAlpha(image,pixels))                                  +m))/((ssize_t) (m*2))                                  +GetPixelAlpha(image,pixels)),q);                             }                         }                       n+=GetPixelChannels(image);                       q+=GetPixelChannels(large_image);                       pixels+=GetPixelChannels(image);                     } /* x */                      if (SyncAuthenticPixels(large_image,exception) == 0)                       break;                    } /* i */                 } /* y */                  prev=(Quantum *) RelinquishMagickMemory(prev);                 next=(Quantum *) RelinquishMagickMemory(next);                  length=image->columns;                  if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""    Delete original image"");                  DeleteImageFromList(&image);                  image=large_image;                  mng_info->image=image;                  /* magnify the columns */                 if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""    Magnify the columns to %.20g"",                     (double) image->columns);                  for (y=0; y < (ssize_t) image->rows; y++)                 {                   register Quantum                     *pixels;                    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);                   pixels=q+(image->columns-length)*GetPixelChannels(image);                   n=pixels+GetPixelChannels(image);                    for (x=(ssize_t) (image->columns-length);                     x < (ssize_t) image->columns; x++)                   {                     /* To do: Rewrite using Get/Set***PixelChannel() */                      if (x == (ssize_t) (image->columns-length))                       m=(ssize_t) mng_info->magn_ml;                      else if (magn_methx > 1 && x == (ssize_t) image->columns-2)                       m=(ssize_t) mng_info->magn_mr;                      else if (magn_methx <= 1 &&                         x == (ssize_t) image->columns-1)                       m=(ssize_t) mng_info->magn_mr;                      else if (magn_methx > 1 && x == (ssize_t) image->columns-1)                       m=1;                      else                       m=(ssize_t) mng_info->magn_mx;                      for (i=0; i < m; i++)                     {                       if (magn_methx <= 1)                         {                           /* replicate previous */                           SetPixelRed(image,GetPixelRed(image,pixels),q);                           SetPixelGreen(image,GetPixelGreen(image,pixels),q);                           SetPixelBlue(image,GetPixelBlue(image,pixels),q);                           SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);                         }                        else if (magn_methx == 2 || magn_methx == 4)                         {                           if (i == 0)                           {                             SetPixelRed(image,GetPixelRed(image,pixels),q);                             SetPixelGreen(image,GetPixelGreen(image,pixels),q);                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);                             SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);                           }                            /* To do: Rewrite using Get/Set***PixelChannel() */                           else                             {                               /* Interpolate */                               SetPixelRed(image,(QM) ((2*i*(                                  GetPixelRed(image,n)                                  -GetPixelRed(image,pixels))+m)                                  /((ssize_t) (m*2))+                                  GetPixelRed(image,pixels)),q);                                SetPixelGreen(image,(QM) ((2*i*(                                  GetPixelGreen(image,n)                                  -GetPixelGreen(image,pixels))+m)                                  /((ssize_t) (m*2))+                                  GetPixelGreen(image,pixels)),q);                                SetPixelBlue(image,(QM) ((2*i*(                                  GetPixelBlue(image,n)                                  -GetPixelBlue(image,pixels))+m)                                  /((ssize_t) (m*2))+                                  GetPixelBlue(image,pixels)),q);                               if (image->alpha_trait != UndefinedPixelTrait)                                  SetPixelAlpha(image,(QM) ((2*i*(                                    GetPixelAlpha(image,n)                                    -GetPixelAlpha(image,pixels))+m)                                    /((ssize_t) (m*2))+                                    GetPixelAlpha(image,pixels)),q);                             }                            if (magn_methx == 4)                             {                               /* Replicate nearest */                               if (i <= ((m+1) << 1))                               {                                  SetPixelAlpha(image,                                    GetPixelAlpha(image,pixels)+0,q);                               }                               else                               {                                  SetPixelAlpha(image,                                    GetPixelAlpha(image,n)+0,q);                               }                             }                         }                        else /* if (magn_methx == 3 || magn_methx == 5) */                         {                           /* Replicate nearest */                           if (i <= ((m+1) << 1))                           {                              SetPixelRed(image,GetPixelRed(image,pixels),q);                              SetPixelGreen(image,GetPixelGreen(image,                                  pixels),q);                              SetPixelBlue(image,GetPixelBlue(image,pixels),q);                              SetPixelAlpha(image,GetPixelAlpha(image,                                  pixels),q);                           }                            else                           {                              SetPixelRed(image,GetPixelRed(image,n),q);                              SetPixelGreen(image,GetPixelGreen(image,n),q);                              SetPixelBlue(image,GetPixelBlue(image,n),q);                              SetPixelAlpha(image,GetPixelAlpha(image,n),q);                           }                            if (magn_methx == 5)                             {                               /* Interpolate */                               SetPixelAlpha(image,                                  (QM) ((2*i*( GetPixelAlpha(image,n)                                  -GetPixelAlpha(image,pixels))+m)/                                  ((ssize_t) (m*2))                                  +GetPixelAlpha(image,pixels)),q);                             }                         }                       q+=GetPixelChannels(image);                     }                     n+=GetPixelChannels(image);                   }                    if (SyncAuthenticPixels(image,exception) == MagickFalse)                     break;                 } #if (MAGICKCORE_QUANTUM_DEPTH > 16)               if (magn_methx != 1 || magn_methy != 1)                 {                 /*                    Rescale pixels to Quantum                 */                    for (y=0; y < (ssize_t) image->rows; y++)                    {                      q=GetAuthenticPixels(image,0,y,image->columns,1,                        exception);                       for (x=(ssize_t) image->columns-1; x >= 0; x--)                      {                         SetPixelRed(image,ScaleShortToQuantum(                           GetPixelRed(image,q)),q);                         SetPixelGreen(image,ScaleShortToQuantum(                           GetPixelGreen(image,q)),q);                         SetPixelBlue(image,ScaleShortToQuantum(                           GetPixelBlue(image,q)),q);                         SetPixelAlpha(image,ScaleShortToQuantum(                           GetPixelAlpha(image,q)),q);                         q+=GetPixelChannels(image);                      }                       if (SyncAuthenticPixels(image,exception) == MagickFalse)                        break;                    }                 } #endif                 if (logging != MagickFalse)                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),                     ""  Finished MAGN processing"");               }           }          /*           Crop_box is with respect to the upper left corner of the MNG.         */         crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];         crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];         crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];         crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];         crop_box=mng_minimum_box(crop_box,mng_info->clip);         crop_box=mng_minimum_box(crop_box,mng_info->frame);         crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);         if ((crop_box.left != (mng_info->image_box.left             +mng_info->x_off[object_id])) ||             (crop_box.right != (mng_info->image_box.right             +mng_info->x_off[object_id])) ||             (crop_box.top != (mng_info->image_box.top             +mng_info->y_off[object_id])) ||             (crop_box.bottom != (mng_info->image_box.bottom             +mng_info->y_off[object_id])))           {             if (logging != MagickFalse)               (void) LogMagickEvent(CoderEvent,GetMagickModule(),                 ""  Crop the PNG image"");              if ((crop_box.left < crop_box.right) &&                 (crop_box.top < crop_box.bottom))               {                 Image                   *im;                  RectangleInfo                   crop_info;                  /*                   Crop_info is with respect to the upper left corner of                   the image.                 */                 crop_info.x=(crop_box.left-mng_info->x_off[object_id]);                 crop_info.y=(crop_box.top-mng_info->y_off[object_id]);                 crop_info.width=(size_t) (crop_box.right-crop_box.left);                 crop_info.height=(size_t) (crop_box.bottom-crop_box.top);                 image->page.width=image->columns;                 image->page.height=image->rows;                 image->page.x=0;                 image->page.y=0;                 im=CropImage(image,&crop_info,exception);                  if (im != (Image *) NULL)                   {                     image->columns=im->columns;                     image->rows=im->rows;                     im=DestroyImage(im);                     image->page.width=image->columns;                     image->page.height=image->rows;                     image->page.x=crop_box.left;                     image->page.y=crop_box.top;                   }               }              else               {                 /*                   No pixels in crop area.  The MNG spec still requires                   a layer, though, so make a single transparent pixel in                   the top left corner.                 */                 image->columns=1;                 image->rows=1;                 image->colors=2;                 (void) SetImageBackgroundColor(image,exception);                 image->page.width=1;                 image->page.height=1;                 image->page.x=0;                 image->page.y=0;               }           } #ifndef PNG_READ_EMPTY_PLTE_SUPPORTED         image=mng_info->image; #endif       }  #if (MAGICKCORE_QUANTUM_DEPTH > 16)       /* PNG does not handle depths greater than 16 so reduce it even        * if lossy.        */       if (image->depth > 16)          image->depth=16; #endif  #if (MAGICKCORE_QUANTUM_DEPTH > 8)       if (image->depth > 8)         {           /* To do: fill low byte properly */           image->depth=16;         }        if (LosslessReduceDepthOK(image,exception) != MagickFalse)          image->depth = 8; #endif        if (image_info->number_scenes != 0)         {           if (mng_info->scenes_found >              (ssize_t) (image_info->first_scene+image_info->number_scenes))             break;         }        if (logging != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""  Finished reading image datastream."");    } while (LocaleCompare(image_info->magick,""MNG"") == 0);    (void) CloseBlob(image);    if (logging != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),       ""  Finished reading all image datastreams."");  #if defined(MNG_INSERT_LAYERS)   if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&        (mng_info->mng_height))     {       /*         Insert a background layer if nothing else was found.       */       if (logging != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""  No images found.  Inserting a background layer."");        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)         {           /*             Allocate next image structure.           */           AcquireNextImage(image_info,image,exception);           if (GetNextImageInList(image) == (Image *) NULL)             {               if (logging != MagickFalse)                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Allocation failed, returning NULL."");                return(DestroyImageList(image));;             }           image=SyncNextImageInList(image);         }       image->columns=mng_info->mng_width;       image->rows=mng_info->mng_height;       image->page.width=mng_info->mng_width;       image->page.height=mng_info->mng_height;       image->page.x=0;       image->page.y=0;       image->background_color=mng_background_color;       image->alpha_trait=UndefinedPixelTrait;        if (image_info->ping == MagickFalse)         (void) SetImageBackgroundColor(image,exception);        mng_info->image_found++;     } #endif   image->iterations=mng_iterations;    if (mng_iterations == 1)     image->start_loop=MagickTrue;    while (GetPreviousImageInList(image) != (Image *) NULL)   {     image_count++;     if (image_count > 10*mng_info->image_found)       {         if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  No beginning"");          (void) ThrowMagickException(exception,GetMagickModule(),           CoderError,""Linked list is corrupted, beginning of list not found"",           ""`%s'"",image_info->filename);          return(DestroyImageList(image));       }      image=GetPreviousImageInList(image);      if (GetNextImageInList(image) == (Image *) NULL)       {         if (logging != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Corrupt list"");          (void) ThrowMagickException(exception,GetMagickModule(),           CoderError,""Linked list is corrupted; next_image is NULL"",""`%s'"",           image_info->filename);       }   }    if (mng_info->ticks_per_second && mng_info->image_found > 1 &&              GetNextImageInList(image) ==      (Image *) NULL)     {       if (logging != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  First image null"");        (void) ThrowMagickException(exception,GetMagickModule(),         CoderError,""image->next for first image is NULL but shouldn't be."",         ""`%s'"",image_info->filename);     }    if (mng_info->image_found == 0)     {       if (logging != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""  No visible images found."");        (void) ThrowMagickException(exception,GetMagickModule(),         CoderError,""No visible images in file"",""`%s'"",image_info->filename);        return(DestroyImageList(image));     }    if (mng_info->ticks_per_second)     final_delay=1UL*MagickMax(image->ticks_per_second,1L)*             final_delay/mng_info->ticks_per_second;    else     image->start_loop=MagickTrue;    /* Find final nonzero image delay */   final_image_delay=0;    while (GetNextImageInList(image) != (Image *) NULL)     {       if (image->delay)         final_image_delay=image->delay;        image=GetNextImageInList(image);     }    if (final_delay < final_image_delay)     final_delay=final_image_delay;    image->delay=final_delay;    if (logging != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  image->delay=%.20g, final_delay=%.20g"",(double) image->delay,         (double) final_delay);    if (logging != MagickFalse)     {       int         scene;        scene=0;       image=GetFirstImageInList(image);        (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Before coalesce:"");        (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""    scene 0 delay=%.20g"",(double) image->delay);        while (GetNextImageInList(image) != (Image *) NULL)       {         image=GetNextImageInList(image);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""    scene %.20g delay=%.20g"",(double) scene++,           (double) image->delay);       }     }    image=GetFirstImageInList(image); #ifdef MNG_COALESCE_LAYERS   if (insert_layers)     {       Image         *next_image,         *next;        size_t         scene;        if (logging != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""  Coalesce Images"");        scene=image->scene;       next_image=CoalesceImages(image,exception);        if (next_image == (Image *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");        image=DestroyImageList(image);       image=next_image;        for (next=image; next != (Image *) NULL; next=next_image)       {          next->page.width=mng_info->mng_width;          next->page.height=mng_info->mng_height;          next->page.x=0;          next->page.y=0;          next->scene=scene++;          next_image=GetNextImageInList(next);           if (next_image == (Image *) NULL)            break;           if (next->delay == 0)            {              scene--;              next_image->previous=GetPreviousImageInList(next);              if (GetPreviousImageInList(next) == (Image *) NULL)                image=next_image;              else                next->previous->next=next_image;              next=DestroyImage(next);            }       }     } #endif    while (GetNextImageInList(image) != (Image *) NULL)       image=GetNextImageInList(image);    image->dispose=BackgroundDispose;    if (logging != MagickFalse)     {       int         scene;        scene=0;       image=GetFirstImageInList(image);        (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  After coalesce:"");        (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""    scene 0 delay=%.20g dispose=%.20g"",(double) image->delay,         (double) image->dispose);        while (GetNextImageInList(image) != (Image *) NULL)       {         image=GetNextImageInList(image);          (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""    scene %.20g delay=%.20g dispose=%.20g"",(double) scene++,           (double) image->delay,(double) image->dispose);       }    }    if (logging != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),       ""  exit ReadOneMNGImage();"");    return(image); }"
"195954_CWE-787.c","CWE-787","static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool, 			       const pj_uint8_t *pkt, const pj_uint8_t *start, 			       const pj_uint8_t *max, int *parsed_len) {     const pj_uint8_t *p = start;     int name_len, name_part_len;     pj_status_t status;      /* Get the length of the name */     status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);     if (status != PJ_SUCCESS) 	return status;      /* Allocate memory for the name */     q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);     q->name.slen = 0;      /* Get the name */     status = get_name(0, pkt, start, max, &q->name);     if (status != PJ_SUCCESS) 	return status;      p = (start + name_part_len);      /* Get the type */     pj_memcpy(&q->type, p, 2);     q->type = pj_ntohs(q->type);     p += 2;      /* Get the class */     pj_memcpy(&q->dnsclass, p, 2);     q->dnsclass = pj_ntohs(q->dnsclass);     p += 2;      *parsed_len = (int)(p - start);      return PJ_SUCCESS; }"
"195965_CWE-787.cc","CWE-787","  void Compute(OpKernelContext* ctx) override {     const Tensor* hypothesis_indices;     const Tensor* hypothesis_values;     const Tensor* hypothesis_shape;     const Tensor* truth_indices;     const Tensor* truth_values;     const Tensor* truth_shape;     OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_indices"", &hypothesis_indices));     OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_values"", &hypothesis_values));     OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_shape"", &hypothesis_shape));     OP_REQUIRES_OK(ctx, ctx->input(""truth_indices"", &truth_indices));     OP_REQUIRES_OK(ctx, ctx->input(""truth_values"", &truth_values));     OP_REQUIRES_OK(ctx, ctx->input(""truth_shape"", &truth_shape));      OP_REQUIRES_OK(         ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values,                             *hypothesis_shape, *truth_indices, *truth_values,                             *truth_shape));      TensorShape hypothesis_st_shape;     OP_REQUIRES_OK(ctx,                    TensorShapeUtils::MakeShape(                        hypothesis_shape->vec<int64_t>().data(),                        hypothesis_shape->NumElements(), &hypothesis_st_shape));     TensorShape truth_st_shape;     OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(                             truth_shape->vec<int64_t>().data(),                             truth_shape->NumElements(), &truth_st_shape));      // Assume indices are sorted in row-major order.     std::vector<int64_t> sorted_order(truth_st_shape.dims());     std::iota(sorted_order.begin(), sorted_order.end(), 0);      sparse::SparseTensor hypothesis;     OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(                             *hypothesis_indices, *hypothesis_values,                             hypothesis_st_shape, sorted_order, &hypothesis));      sparse::SparseTensor truth;     OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(                             *truth_indices, *truth_values, truth_st_shape,                             sorted_order, &truth));      // Group dims 0, 1, ..., RANK - 1.  The very last dim is assumed     // to store the variable length sequences.     std::vector<int64_t> group_dims(truth_st_shape.dims() - 1);     std::iota(group_dims.begin(), group_dims.end(), 0);      TensorShape output_shape;     for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) {       output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),                                    truth_st_shape.dim_size(d)));     }     const auto output_elements = output_shape.num_elements();     OP_REQUIRES(         ctx, output_elements > 0,         errors::InvalidArgument(""Got output shape "", output_shape.DebugString(),                                 "" which has 0 elements""));      Tensor* output = nullptr;     OP_REQUIRES_OK(ctx, ctx->allocate_output(""output"", output_shape, &output));     auto output_t = output->flat<float>();     output_t.setZero();      std::vector<int64_t> output_strides(output_shape.dims());     output_strides[output_shape.dims() - 1] = 1;     for (int d = output_shape.dims() - 2; d >= 0; --d) {       output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1);     }      auto hypothesis_grouper = hypothesis.group(group_dims);     auto truth_grouper = truth.group(group_dims);      auto hypothesis_iter = hypothesis_grouper.begin();     auto truth_iter = truth_grouper.begin();      auto cmp = std::equal_to<T>();      while (hypothesis_iter != hypothesis_grouper.end() &&            truth_iter != truth_grouper.end()) {       sparse::Group truth_i = *truth_iter;       sparse::Group hypothesis_j = *hypothesis_iter;       std::vector<int64_t> g_truth = truth_i.group();       std::vector<int64_t> g_hypothesis = hypothesis_j.group();       auto truth_seq = truth_i.values<T>();       auto hypothesis_seq = hypothesis_j.values<T>();        if (g_truth == g_hypothesis) {         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),                                       output_strides.begin(), int64_t{0});         OP_REQUIRES(             ctx, loc < output_elements,             errors::Internal(""Got an inner product "", loc,                              "" which would require in writing to outside of ""                              ""the buffer for the output tensor (max elements "",                              output_elements, "")""));         output_t(loc) =             gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);         if (normalize_) output_t(loc) /= truth_seq.size();          ++hypothesis_iter;         ++truth_iter;       } else if (g_truth > g_hypothesis) {  // zero-length truth         auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),                                       output_strides.begin(), int64_t{0});         OP_REQUIRES(             ctx, loc < output_elements,             errors::Internal(""Got an inner product "", loc,                              "" which would require in writing to outside of ""                              ""the buffer for the output tensor (max elements "",                              output_elements, "")""));         output_t(loc) = hypothesis_seq.size();         if (normalize_ && output_t(loc) != 0.0f) {           output_t(loc) = std::numeric_limits<float>::infinity();         }         ++hypothesis_iter;       } else {  // zero-length hypothesis         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),                                       output_strides.begin(), int64_t{0});         OP_REQUIRES(             ctx, loc < output_elements,             errors::Internal(""Got an inner product "", loc,                              "" which would require in writing to outside of ""                              ""the buffer for the output tensor (max elements "",                              output_elements, "")""));         output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();         ++truth_iter;       }     }     while (hypothesis_iter != hypothesis_grouper.end()) {  // zero-length truths       sparse::Group hypothesis_j = *hypothesis_iter;       std::vector<int64_t> g_hypothesis = hypothesis_j.group();       auto hypothesis_seq = hypothesis_j.values<T>();       auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),                                     output_strides.begin(), int64_t{0});       OP_REQUIRES(           ctx, loc < output_elements,           errors::Internal(""Got an inner product "", loc,                            "" which would require in writing to outside of the ""                            ""buffer for the output tensor (max elements "",                            output_elements, "")""));       output_t(loc) = hypothesis_seq.size();       if (normalize_ && output_t(loc) != 0.0f) {         output_t(loc) = std::numeric_limits<float>::infinity();       }       ++hypothesis_iter;     }     while (truth_iter != truth_grouper.end()) {  // missing hypotheses       sparse::Group truth_i = *truth_iter;       std::vector<int64_t> g_truth = truth_i.group();       auto truth_seq = truth_i.values<T>();       auto loc = std::inner_product(g_truth.begin(), g_truth.end(),                                     output_strides.begin(), int64_t{0});       OP_REQUIRES(           ctx, loc < output_elements,           errors::Internal(""Got an inner product "", loc,                            "" which would require in writing to outside of the ""                            ""buffer for the output tensor (max elements "",                            output_elements, "")""));       output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();       ++truth_iter;     }   }"
"195984_CWE-703.c","CWE-703","GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 i; 	char str[1024]; 	GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;  	i=0; 	str[0]=0; 	while (1) { 		str[i] = gf_bs_read_u8(bs); 		if (!str[i]) break; 		i++; 	} 	ISOM_DECREASE_SIZE(p, i);  	p->content_script_types = gf_strdup(str); 	return GF_OK; }"
"196231_CWE-369.cc","CWE-369","void TensorSliceReader::LoadShard(int shard) const {   CHECK_LT(shard, sss_.size());   if (sss_[shard] || !status_.ok()) {     return;  // Already loaded, or invalid.   }   string value;   SavedTensorSlices sts;   const string fname = fnames_[shard];   VLOG(1) << ""Reading meta data from file "" << fname << ""..."";   Table* table;   Status s = open_function_(fname, &table);   if (!s.ok()) {     status_ = errors::DataLoss(""Unable to open table file "", fname, "": "",                                s.ToString());     return;   }   sss_[shard].reset(table);   if (!(table->Get(kSavedTensorSlicesKey, &value) &&         ParseProtoUnlimited(&sts, value))) {     status_ = errors::Internal(         ""Failed to find the saved tensor slices at the beginning of the ""         ""checkpoint file: "",         fname);     return;   }   status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,                           TF_CHECKPOINT_VERSION_MIN_PRODUCER, ""Checkpoint"",                           ""checkpoint"");   if (!status_.ok()) return;   for (const SavedSliceMeta& ssm : sts.meta().tensor()) {     TensorShape ssm_shape(ssm.shape());     for (const TensorSliceProto& tsp : ssm.slice()) {       TensorSlice ss_slice(tsp);       status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,                                     ss_slice, &tensors_);       if (!status_.ok()) return;     }   } }"
"196276_CWE-269.c","CWE-269","lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,              unsigned dyn_table_size, unsigned max_risked_streams, int server) {     enum lsqpack_enc_opts enc_opts;      assert(qeh->qeh_flags & QEH_INITIALIZED);      if (qeh->qeh_flags & QEH_HAVE_SETTINGS)     {         LSQ_WARN(""settings already set"");         return -1;     }      enc_opts = LSQPACK_ENC_OPT_STAGE_2              | (server ? LSQPACK_ENC_OPT_SERVER : 0);     qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);     if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,                 max_table_size, dyn_table_size, max_risked_streams, enc_opts,                 qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))     {         LSQ_INFO(""could not initialize QPACK encoder"");         return -1;     }     LSQ_DEBUG(""%zu-byte post-init TSU"", qeh->qeh_tsu_sz);     qeh->qeh_flags |= QEH_HAVE_SETTINGS;     qeh->qeh_max_prefix_size =                         lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);     LSQ_DEBUG(""have settings: max table size=%u; dyn table size=%u; max risked ""         ""streams=%u"", max_table_size, dyn_table_size, max_risked_streams);     if (qeh->qeh_enc_sm_out)         qeh_begin_out(qeh);     return 0; }"
"196316_CWE-200.c","CWE-200","int digest_generic_verify(struct digest *d, const unsigned char *md) { 	int ret; 	int len = digest_length(d); 	unsigned char *tmp;  	tmp = xmalloc(len);  	ret = digest_final(d, tmp); 	if (ret) 		goto end;  	ret = memcmp(md, tmp, len); 	ret = ret ? -EINVAL : 0; end: 	free(tmp); 	return ret; }"
"196328_CWE-416.c","CWE-416","find_pattern_in_path(     char_u	*ptr,		// pointer to search pattern     int		dir UNUSED,	// direction of expansion     int		len,		// length of search pattern     int		whole,		// match whole words only     int		skip_comments,	// don't match inside comments     int		type,		// Type of search; are we looking for a type? 				// a macro?     long	count,     int		action,		// What to do when we find it     linenr_T	start_lnum,	// first line to start searching     linenr_T	end_lnum)	// last line for searching {     SearchedFile *files;		// Stack of included files     SearchedFile *bigger;		// When we need more space     int		max_path_depth = 50;     long	match_count = 1;      char_u	*pat;     char_u	*new_fname;     char_u	*curr_fname = curbuf->b_fname;     char_u	*prev_fname = NULL;     linenr_T	lnum;     int		depth;     int		depth_displayed;	// For type==CHECK_PATH     int		old_files;     int		already_searched;     char_u	*file_line;     char_u	*line;     char_u	*p;     char_u	save_char;     int		define_matched;     regmatch_T	regmatch;     regmatch_T	incl_regmatch;     regmatch_T	def_regmatch;     int		matched = FALSE;     int		did_show = FALSE;     int		found = FALSE;     int		i;     char_u	*already = NULL;     char_u	*startp = NULL;     char_u	*inc_opt = NULL; #if defined(FEAT_QUICKFIX)     win_T	*curwin_save = NULL; #endif      regmatch.regprog = NULL;     incl_regmatch.regprog = NULL;     def_regmatch.regprog = NULL;      file_line = alloc(LSIZE);     if (file_line == NULL) 	return;      if (type != CHECK_PATH && type != FIND_DEFINE 	    // when CONT_SOL is set compare ""ptr"" with the beginning of the 	    // line is faster than quote_meta/regcomp/regexec ""ptr"" -- Acevedo 	    && !compl_status_sol())     { 	pat = alloc(len + 5); 	if (pat == NULL) 	    goto fpip_end; 	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr); 	// ignore case according to p_ic, p_scs and pat 	regmatch.rm_ic = ignorecase(pat); 	regmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0); 	vim_free(pat); 	if (regmatch.regprog == NULL) 	    goto fpip_end;     }     inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;     if (*inc_opt != NUL)     { 	incl_regmatch.regprog = vim_regcomp(inc_opt, 						 magic_isset() ? RE_MAGIC : 0); 	if (incl_regmatch.regprog == NULL) 	    goto fpip_end; 	incl_regmatch.rm_ic = FALSE;	// don't ignore case in incl. pat.     }     if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))     { 	def_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL 			   ? p_def : curbuf->b_p_def, 						 magic_isset() ? RE_MAGIC : 0); 	if (def_regmatch.regprog == NULL) 	    goto fpip_end; 	def_regmatch.rm_ic = FALSE;	// don't ignore case in define pat.     }     files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);     if (files == NULL) 	goto fpip_end;     old_files = max_path_depth;     depth = depth_displayed = -1;      lnum = start_lnum;     if (end_lnum > curbuf->b_ml.ml_line_count) 	end_lnum = curbuf->b_ml.ml_line_count;     if (lnum > end_lnum)		// do at least one line 	lnum = end_lnum;     line = ml_get(lnum);      for (;;)     { 	if (incl_regmatch.regprog != NULL 		&& vim_regexec(&incl_regmatch, line, (colnr_T)0)) 	{ 	    char_u *p_fname = (curr_fname == curbuf->b_fname) 					      ? curbuf->b_ffname : curr_fname;  	    if (inc_opt != NULL && strstr((char *)inc_opt, ""\\zs"") != NULL) 		// Use text from '\zs' to '\ze' (or end) of 'include'. 		new_fname = find_file_name_in_path(incl_regmatch.startp[0], 		       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]), 				 FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname); 	    else 		// Use text after match with 'include'. 		new_fname = file_name_in_line(incl_regmatch.endp[0], 0, 			     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL); 	    already_searched = FALSE; 	    if (new_fname != NULL) 	    { 		// Check whether we have already searched in this file 		for (i = 0;; i++) 		{ 		    if (i == depth + 1) 			i = old_files; 		    if (i == max_path_depth) 			break; 		    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE) 								    & FPC_SAME) 		    { 			if (type != CHECK_PATH 				&& action == ACTION_SHOW_ALL 				&& files[i].matched) 			{ 			    msg_putchar('\n');	    // cursor below last one 			    if (!got_int)	    // don't display if 'q' 						    // typed at ""--more--"" 						    // message 			    { 				msg_home_replace_hl(new_fname); 				msg_puts(_("" (includes previously listed match)"")); 				prev_fname = NULL; 			    } 			} 			VIM_CLEAR(new_fname); 			already_searched = TRUE; 			break; 		    } 		} 	    }  	    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL 				 || (new_fname == NULL && !already_searched))) 	    { 		if (did_show) 		    msg_putchar('\n');	    // cursor below last one 		else 		{ 		    gotocmdline(TRUE);	    // cursor at status line 		    msg_puts_title(_(""--- Included files "")); 		    if (action != ACTION_SHOW_ALL) 			msg_puts_title(_(""not found "")); 		    msg_puts_title(_(""in path ---\n"")); 		} 		did_show = TRUE; 		while (depth_displayed < depth && !got_int) 		{ 		    ++depth_displayed; 		    for (i = 0; i < depth_displayed; i++) 			msg_puts(""  ""); 		    msg_home_replace(files[depth_displayed].name); 		    msg_puts("" -->\n""); 		} 		if (!got_int)		    // don't display if 'q' typed 					    // for ""--more--"" message 		{ 		    for (i = 0; i <= depth_displayed; i++) 			msg_puts(""  ""); 		    if (new_fname != NULL) 		    { 			// using ""new_fname"" is more reliable, e.g., when 			// 'includeexpr' is set. 			msg_outtrans_attr(new_fname, HL_ATTR(HLF_D)); 		    } 		    else 		    { 			/* 			 * Isolate the file name. 			 * Include the surrounding """" or <> if present. 			 */ 			if (inc_opt != NULL 				   && strstr((char *)inc_opt, ""\\zs"") != NULL) 			{ 			    // pattern contains \zs, use the match 			    p = incl_regmatch.startp[0]; 			    i = (int)(incl_regmatch.endp[0] 						   - incl_regmatch.startp[0]); 			} 			else 			{ 			    // find the file name after the end of the match 			    for (p = incl_regmatch.endp[0]; 						  *p && !vim_isfilec(*p); p++) 				; 			    for (i = 0; vim_isfilec(p[i]); i++) 				; 			}  			if (i == 0) 			{ 			    // Nothing found, use the rest of the line. 			    p = incl_regmatch.endp[0]; 			    i = (int)STRLEN(p); 			} 			// Avoid checking before the start of the line, can 			// happen if \zs appears in the regexp. 			else if (p > line) 			{ 			    if (p[-1] == '""' || p[-1] == '<') 			    { 				--p; 				++i; 			    } 			    if (p[i] == '""' || p[i] == '>') 				++i; 			} 			save_char = p[i]; 			p[i] = NUL; 			msg_outtrans_attr(p, HL_ATTR(HLF_D)); 			p[i] = save_char; 		    }  		    if (new_fname == NULL && action == ACTION_SHOW_ALL) 		    { 			if (already_searched) 			    msg_puts(_(""  (Already listed)"")); 			else 			    msg_puts(_(""  NOT FOUND"")); 		    } 		} 		out_flush();	    // output each line directly 	    }  	    if (new_fname != NULL) 	    { 		// Push the new file onto the file stack 		if (depth + 1 == old_files) 		{ 		    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2); 		    if (bigger != NULL) 		    { 			for (i = 0; i <= depth; i++) 			    bigger[i] = files[i]; 			for (i = depth + 1; i < old_files + max_path_depth; i++) 			{ 			    bigger[i].fp = NULL; 			    bigger[i].name = NULL; 			    bigger[i].lnum = 0; 			    bigger[i].matched = FALSE; 			} 			for (i = old_files; i < max_path_depth; i++) 			    bigger[i + max_path_depth] = files[i]; 			old_files += max_path_depth; 			max_path_depth *= 2; 			vim_free(files); 			files = bigger; 		    } 		} 		if ((files[depth + 1].fp = mch_fopen((char *)new_fname, ""r"")) 								    == NULL) 		    vim_free(new_fname); 		else 		{ 		    if (++depth == old_files) 		    { 			/* 			 * lalloc() for 'bigger' must have failed above.  We 			 * will forget one of our already visited files now. 			 */ 			vim_free(files[old_files].name); 			++old_files; 		    } 		    files[depth].name = curr_fname = new_fname; 		    files[depth].lnum = 0; 		    files[depth].matched = FALSE; 		    if (action == ACTION_EXPAND) 		    { 			msg_hist_off = TRUE;	// reset in msg_trunc_attr() 			vim_snprintf((char*)IObuff, IOSIZE, 				_(""Scanning included file: %s""), 				(char *)new_fname); 			msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R)); 		    } 		    else if (p_verbose >= 5) 		    { 			verbose_enter(); 			smsg(_(""Searching included file %s""), 							   (char *)new_fname); 			verbose_leave(); 		    }  		} 	    } 	} 	else 	{ 	    /* 	     * Check if the line is a define (type == FIND_DEFINE) 	     */ 	    p = line; search_line: 	    define_matched = FALSE; 	    if (def_regmatch.regprog != NULL 			      && vim_regexec(&def_regmatch, line, (colnr_T)0)) 	    { 		/* 		 * Pattern must be first identifier after 'define', so skip 		 * to that position before checking for match of pattern.  Also 		 * don't let it match beyond the end of this identifier. 		 */ 		p = def_regmatch.endp[0]; 		while (*p && !vim_iswordc(*p)) 		    p++; 		define_matched = TRUE; 	    }  	    /* 	     * Look for a match.  Don't do this if we are looking for a 	     * define and this line didn't match define_prog above. 	     */ 	    if (def_regmatch.regprog == NULL || define_matched) 	    { 		if (define_matched || compl_status_sol()) 		{ 		    // compare the first ""len"" chars from ""ptr"" 		    startp = skipwhite(p); 		    if (p_ic) 			matched = !MB_STRNICMP(startp, ptr, len); 		    else 			matched = !STRNCMP(startp, ptr, len); 		    if (matched && define_matched && whole 						  && vim_iswordc(startp[len])) 			matched = FALSE; 		} 		else if (regmatch.regprog != NULL 			 && vim_regexec(&regmatch, line, (colnr_T)(p - line))) 		{ 		    matched = TRUE; 		    startp = regmatch.startp[0]; 		    /* 		     * Check if the line is not a comment line (unless we are 		     * looking for a define).  A line starting with ""# define"" 		     * is not considered to be a comment line. 		     */ 		    if (!define_matched && skip_comments) 		    { 			if ((*line != '#' || 				STRNCMP(skipwhite(line + 1), ""define"", 6) != 0) 				&& get_leader_len(line, NULL, FALSE, TRUE)) 			    matched = FALSE;  			/* 			 * Also check for a ""/ *"" or ""/ /"" before the match. 			 * Skips lines like ""int backwards;  / * normal index 			 * * /"" when looking for ""normal"". 			 * Note: Doesn't skip ""/ *"" in comments. 			 */ 			p = skipwhite(line); 			if (matched 				|| (p[0] == '/' && p[1] == '*') || p[0] == '*') 			    for (p = line; *p && p < startp; ++p) 			    { 				if (matched 					&& p[0] == '/' 					&& (p[1] == '*' || p[1] == '/')) 				{ 				    matched = FALSE; 				    // After ""//"" all text is comment 				    if (p[1] == '/') 					break; 				    ++p; 				} 				else if (!matched && p[0] == '*' && p[1] == '/') 				{ 				    // Can find match after ""* /"". 				    matched = TRUE; 				    ++p; 				} 			    } 		    } 		} 	    } 	} 	if (matched) 	{ 	    if (action == ACTION_EXPAND) 	    { 		int	cont_s_ipos = FALSE; 		int	add_r; 		char_u	*aux;  		if (depth == -1 && lnum == curwin->w_cursor.lnum) 		    break; 		found = TRUE; 		aux = p = startp; 		if (compl_status_adding()) 		{ 		    p += ins_compl_len(); 		    if (vim_iswordp(p)) 			goto exit_matched; 		    p = find_word_start(p); 		} 		p = find_word_end(p); 		i = (int)(p - aux);  		if (compl_status_adding() && i == ins_compl_len()) 		{ 		    // IOSIZE > compl_length, so the STRNCPY works 		    STRNCPY(IObuff, aux, i);  		    // Get the next line: when ""depth"" < 0  from the current 		    // buffer, otherwise from the included file.  Jump to 		    // exit_matched when past the last line. 		    if (depth < 0) 		    { 			if (lnum >= end_lnum) 			    goto exit_matched; 			line = ml_get(++lnum); 		    } 		    else if (vim_fgets(line = file_line, 						      LSIZE, files[depth].fp)) 			goto exit_matched;  		    // we read a line, set ""already"" to check this ""line"" later 		    // if depth >= 0 we'll increase files[depth].lnum far 		    // below  -- Acevedo 		    already = aux = p = skipwhite(line); 		    p = find_word_start(p); 		    p = find_word_end(p); 		    if (p > aux) 		    { 			if (*aux != ')' && IObuff[i-1] != TAB) 			{ 			    if (IObuff[i-1] != ' ') 				IObuff[i++] = ' '; 			    // IObuf =~ ""\(\k\|\i\).* "", thus i >= 2 			    if (p_js 				&& (IObuff[i-2] == '.' 				    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL 					&& (IObuff[i-2] == '?' 					    || IObuff[i-2] == '!')))) 				IObuff[i++] = ' '; 			} 			// copy as much as possible of the new word 			if (p - aux >= IOSIZE - i) 			    p = aux + IOSIZE - i - 1; 			STRNCPY(IObuff + i, aux, p - aux); 			i += (int)(p - aux); 			cont_s_ipos = TRUE; 		    } 		    IObuff[i] = NUL; 		    aux = IObuff;  		    if (i == ins_compl_len()) 			goto exit_matched; 		}  		add_r = ins_compl_add_infercase(aux, i, p_ic, 			curr_fname == curbuf->b_fname ? NULL : curr_fname, 			dir, cont_s_ipos); 		if (add_r == OK) 		    // if dir was BACKWARD then honor it just once 		    dir = FORWARD; 		else if (add_r == FAIL) 		    break; 	    } 	    else if (action == ACTION_SHOW_ALL) 	    { 		found = TRUE; 		if (!did_show) 		    gotocmdline(TRUE);		// cursor at status line 		if (curr_fname != prev_fname) 		{ 		    if (did_show) 			msg_putchar('\n');	// cursor below last one 		    if (!got_int)		// don't display if 'q' typed 						// at ""--more--"" message 			msg_home_replace_hl(curr_fname); 		    prev_fname = curr_fname; 		} 		did_show = TRUE; 		if (!got_int) 		    show_pat_in_path(line, type, TRUE, action, 			    (depth == -1) ? NULL : files[depth].fp, 			    (depth == -1) ? &lnum : &files[depth].lnum, 			    match_count++);  		// Set matched flag for this file and all the ones that 		// include it 		for (i = 0; i <= depth; ++i) 		    files[i].matched = TRUE; 	    } 	    else if (--count <= 0) 	    { 		found = TRUE; 		if (depth == -1 && lnum == curwin->w_cursor.lnum #if defined(FEAT_QUICKFIX) 						      && g_do_tagpreview == 0 #endif 						      ) 		    emsg(_(e_match_is_on_current_line)); 		else if (action == ACTION_SHOW) 		{ 		    show_pat_in_path(line, type, did_show, action, 			(depth == -1) ? NULL : files[depth].fp, 			(depth == -1) ? &lnum : &files[depth].lnum, 1L); 		    did_show = TRUE; 		} 		else 		{ #ifdef FEAT_GUI 		    need_mouse_correct = TRUE; #endif #if defined(FEAT_QUICKFIX) 		    // "":psearch"" uses the preview window 		    if (g_do_tagpreview != 0) 		    { 			curwin_save = curwin; 			prepare_tagpreview(TRUE, TRUE, FALSE); 		    } #endif 		    if (action == ACTION_SPLIT) 		    { 			if (win_split(0, 0) == FAIL) 			    break; 			RESET_BINDING(curwin); 		    } 		    if (depth == -1) 		    { 			// match in current file #if defined(FEAT_QUICKFIX) 			if (g_do_tagpreview != 0) 			{ 			    if (!win_valid(curwin_save)) 				break; 			    if (!GETFILE_SUCCESS(getfile( 					   curwin_save->w_buffer->b_fnum, NULL, 						     NULL, TRUE, lnum, FALSE))) 				break;	// failed to jump to file 			} 			else #endif 			    setpcmark(); 			curwin->w_cursor.lnum = lnum; 			check_cursor(); 		    } 		    else 		    { 			if (!GETFILE_SUCCESS(getfile( 					0, files[depth].name, NULL, TRUE, 						    files[depth].lnum, FALSE))) 			    break;	// failed to jump to file 			// autocommands may have changed the lnum, we don't 			// want that here 			curwin->w_cursor.lnum = files[depth].lnum; 		    } 		} 		if (action != ACTION_SHOW) 		{ 		    curwin->w_cursor.col = (colnr_T)(startp - line); 		    curwin->w_set_curswant = TRUE; 		}  #if defined(FEAT_QUICKFIX) 		if (g_do_tagpreview != 0 			   && curwin != curwin_save && win_valid(curwin_save)) 		{ 		    // Return cursor to where we were 		    validate_cursor(); 		    redraw_later(VALID); 		    win_enter(curwin_save, TRUE); 		} # ifdef FEAT_PROP_POPUP 		else if (WIN_IS_POPUP(curwin)) 		    // can't keep focus in popup window 		    win_enter(firstwin, TRUE); # endif #endif 		break; 	    } exit_matched: 	    matched = FALSE; 	    // look for other matches in the rest of the line if we 	    // are not at the end of it already 	    if (def_regmatch.regprog == NULL 		    && action == ACTION_EXPAND 		    && !compl_status_sol() 		    && *startp != NUL 		    && *(p = startp + mb_ptr2len(startp)) != NUL) 		goto search_line; 	} 	line_breakcheck(); 	if (action == ACTION_EXPAND) 	    ins_compl_check_keys(30, FALSE); 	if (got_int || ins_compl_interrupted()) 	    break;  	/* 	 * Read the next line.  When reading an included file and encountering 	 * end-of-file, close the file and continue in the file that included 	 * it. 	 */ 	while (depth >= 0 && !already 		&& vim_fgets(line = file_line, LSIZE, files[depth].fp)) 	{ 	    fclose(files[depth].fp); 	    --old_files; 	    files[old_files].name = files[depth].name; 	    files[old_files].matched = files[depth].matched; 	    --depth; 	    curr_fname = (depth == -1) ? curbuf->b_fname 				       : files[depth].name; 	    if (depth < depth_displayed) 		depth_displayed = depth; 	} 	if (depth >= 0)		// we could read the line 	{ 	    files[depth].lnum++; 	    // Remove any CR and LF from the line. 	    i = (int)STRLEN(line); 	    if (i > 0 && line[i - 1] == '\n') 		line[--i] = NUL; 	    if (i > 0 && line[i - 1] == '\r') 		line[--i] = NUL; 	} 	else if (!already) 	{ 	    if (++lnum > end_lnum) 		break; 	    line = ml_get(lnum); 	} 	already = NULL;     }     // End of big for (;;) loop.      // Close any files that are still open.     for (i = 0; i <= depth; i++)     { 	fclose(files[i].fp); 	vim_free(files[i].name);     }     for (i = old_files; i < max_path_depth; i++) 	vim_free(files[i].name);     vim_free(files);      if (type == CHECK_PATH)     { 	if (!did_show) 	{ 	    if (action != ACTION_SHOW_ALL) 		msg(_(""All included files were found"")); 	    else 		msg(_(""No included files"")); 	}     }     else if (!found && action != ACTION_EXPAND)     { 	if (got_int || ins_compl_interrupted()) 	    emsg(_(e_interrupted)); 	else if (type == FIND_DEFINE) 	    emsg(_(e_couldnt_find_definition)); 	else 	    emsg(_(e_couldnt_find_pattern));     }     if (action == ACTION_SHOW || action == ACTION_SHOW_ALL) 	msg_end();  fpip_end:     vim_free(file_line);     vim_regfree(regmatch.regprog);     vim_regfree(incl_regmatch.regprog);     vim_regfree(def_regmatch.regprog); }"
"196578_CWE-787.c","CWE-787","yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space) {     char_u	*pnew;      if (exclude_trailing_space) 	bd->endspaces = 0;     if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1)) 								      == NULL) 	return FAIL;     y_current->y_array[y_idx] = pnew;     vim_memset(pnew, ' ', (size_t)bd->startspaces);     pnew += bd->startspaces;     mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);     pnew += bd->textlen;     vim_memset(pnew, ' ', (size_t)bd->endspaces);     pnew += bd->endspaces;     if (exclude_trailing_space)     { 	int s = bd->textlen + bd->endspaces;  	while (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0) 	{ 	    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1; 	    pnew--; 	}     }     *pnew = NUL;     return OK; }"
"196587_CWE-369.cc","CWE-369","  void DoCompute(OpKernelContext* c) {     core::RefCountPtr<Var> v;     OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));     Tensor* params = v->tensor();     const Tensor& indices = c->input(1);     const Tensor& updates = c->input(2);      // Check that rank(updates.shape) = rank(indices.shape + params.shape[1:])     OP_REQUIRES(c,                 updates.dims() == 0 ||                     updates.dims() == indices.dims() + params->dims() - 1,                 errors::InvalidArgument(                     ""Must have updates.shape = indices.shape + ""                     ""params.shape[1:] or updates.shape = [], got "",                     ""updates.shape "", updates.shape().DebugString(),                     "", indices.shape "", indices.shape().DebugString(),                     "", params.shape "", params->shape().DebugString()));      // Check that we have enough index space     const int64_t N_big = indices.NumElements();     OP_REQUIRES(         c, N_big <= std::numeric_limits<Index>::max(),         errors::InvalidArgument(""indices has too many elements for "",                                 DataTypeString(DataTypeToEnum<Index>::v()),                                 "" indexing: "", N_big, "" > "",                                 std::numeric_limits<Index>::max()));     const Index N = static_cast<Index>(N_big);     OP_REQUIRES(         c, params->dim_size(0) <= std::numeric_limits<Index>::max(),         errors::InvalidArgument(""params.shape[0] too large for "",                                 DataTypeString(DataTypeToEnum<Index>::v()),                                 "" indexing: "", params->dim_size(0), "" > "",                                 std::numeric_limits<Index>::max()));      if (N > 0) {       auto indices_flat = indices.flat<Index>();       auto params_flat = params->flat_outer_dims<T>();       if (TensorShapeUtils::IsScalar(updates.shape())) {         const auto update = updates.scalar<T>();          functor::ScatterScalarFunctor<Device, T, Index, op> functor;         const Index bad_i = functor(c, c->template eigen_device<Device>(),                                     params_flat, update, indices_flat);         OP_REQUIRES(c, bad_i < 0,                     errors::InvalidArgument(                         ""indices"", SliceDebugString(indices.shape(), bad_i),                         "" = "", indices_flat(bad_i), "" is not in [0, "",                         params->dim_size(0), "")""));       } else {         int64_t num_updates = updates.NumElements();         OP_REQUIRES(             c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),             errors::InvalidArgument(                 ""The shape of indices ("", indices.shape().DebugString(),                 "") must be a prefix of the shape of updates ("",                 updates.shape().DebugString(), "")""));         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});          functor::ScatterFunctor<Device, T, Index, op> functor;         const Index bad_i = functor(c, c->template eigen_device<Device>(),                                     params_flat, updates_flat, indices_flat);         OP_REQUIRES(c, bad_i < 0,                     errors::InvalidArgument(                         ""indices"", SliceDebugString(indices.shape(), bad_i),                         "" = "", indices_flat(bad_i), "" is not in [0, "",                         params->dim_size(0), "")""));       }     }   }"
"196611_CWE-284.c","CWE-284","static int setup_config(int type) { 	int rv;  	rv = read_config(cl.configfile, type); 	if (rv < 0) 		goto out;  	if (is_auth_req()) { 		rv = read_authkey(); 		if (rv < 0) 			goto out; #if HAVE_LIBGCRYPT 		if (!gcry_check_version(NULL)) { 			log_error(""gcry_check_version""); 			rv = -ENOENT; 			goto out; 		} 		gcry_control(GCRYCTL_DISABLE_SECMEM, 0); 		gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0); #endif 	}  	/* Set ""local"" pointer, ignoring errors. */ 	if (cl.type == DAEMON && cl.site[0]) { 		if (!find_site_by_name(cl.site, &local, 1)) { 			log_error(""Cannot find \""%s\"" in the configuration."", 					cl.site); 			return -EINVAL; 		} 		local->local = 1; 	} else 		find_myself(NULL, type == CLIENT || type == GEOSTORE);   	rv = check_config(type); 	if (rv < 0) 		goto out;   	/* Per default the PID file name is derived from the 	 * configuration name. */ 	if (!cl.lockfile[0]) { 		snprintf(cl.lockfile, sizeof(cl.lockfile)-1, 				""%s/%s.pid"", BOOTH_RUN_DIR, booth_conf->name); 	}  out: 	return rv; }"
"196620_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* context) override {     const Tensor& input = context->input(0);     const TensorShape& input_shape = input.shape();     const int32_t input_dims = input_shape.dims();      const Tensor& segment_id = context->input(1);     const TensorShape& segment_id_shape = segment_id.shape();     const int32_t segment_dims = segment_id_shape.dims();      const Tensor& num_segments_tensor = context->input(2);     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,                 errors::InvalidArgument(""Number of segments cannot be empty.""));     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();      OP_REQUIRES(context, num_segments > 0,                 errors::InvalidArgument(""Number of segments must be positive""));     OP_REQUIRES(context, segment_dims != 0,                 errors::InvalidArgument(""Segment_id cannot have rank 0""));      OP_REQUIRES(         context, segment_dims <= input_dims,         errors::OutOfRange(""Invalid segment_id rank "", segment_dims,                            "" for input with "", input_dims, "" dimension(s)""));     for (auto i = 0; i < segment_dims; i++) {       OP_REQUIRES(           context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),           errors::InvalidArgument(               ""Segment dimension is "", segment_id_shape.dim_size(i),               "" while input dimension is "", input_dims, "" in rank "", i));     }      // Making output tensor.     Tensor* output_tensor = nullptr;     TensorShape output_shape =         GetOutputShape(input_shape, segment_id_shape, num_segments);     OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,                                                      &output_tensor));      // Preparating flat tensors.     auto output_flat = output_tensor->flat<tstring>();     auto flat_segment_id = segment_id.flat<INDICES_TYPE>();     auto flat_input = input.flat<tstring>();      for (int i = 0; i < flat_segment_id.size(); i++) {       OP_REQUIRES(           context,           ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),           errors::InvalidArgument(               ""segment_ids are not allowed to exceed num_segments or""               "" to have negative values.""));     }      int64_t big_stride;     int64_t small_stride;     std::tie(big_stride, small_stride) =         GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);     auto relative_offset_set =         GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);     for (auto start_offset = 0; start_offset < big_stride; start_offset++) {       for (auto i = 0; i < relative_offset_set.size(); i++) {         auto output_index = start_offset + flat_segment_id(i) * big_stride;         auto offset = start_offset + relative_offset_set[i];         if (output_flat(output_index).length() != 0)           output_flat(output_index).append(separator_.c_str());         output_flat(output_index).append(flat_input(offset));       }     }   }"
"196621_CWE-787.c","CWE-787","mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid) {   mt_tbl *h;    MRB_CLASS_ORIGIN(c);   h = c->mt;    if (h && mt_del(mrb, h, mid)) return;   mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c); }"
"196629_CWE-354.cc","CWE-354","  void ComputeAsync(OpKernelContext* context, DoneCallback done) final {     const Tensor& input = context->input(0);     const Tensor& rhs = context->input(1);     const int ndims = input.dims();     const int64 n = input.dim_size(ndims - 1);     const int64 nrhs = rhs.dim_size(ndims - 1);     // Validate inputs.     OP_REQUIRES_ASYNC(         context, ndims >= 2,         errors::InvalidArgument(""Input must have rank >= 2, got "", ndims),         done);     OP_REQUIRES_ASYNC(context, rhs.dims() == ndims,                       errors::InvalidArgument(                           ""Input and right-hand side must have same rank, got "",                           ndims, "" != "", rhs.dims()),                       done);     OP_REQUIRES_ASYNC(         context, input.dim_size(ndims - 2) == n,         errors::InvalidArgument(""Input matrices must be squares, got"",                                 input.dim_size(ndims - 2), "" != "", n),         done);     OP_REQUIRES_ASYNC(context, rhs.dim_size(ndims - 2) == n,                       errors::InvalidArgument(                           ""Input matrix and right-hand side must have the ""                           ""same number of rows, got"",                           n, "" != "", rhs.dim_size(ndims - 2)),                       done);      // Allocate output.     Tensor* output;     OP_REQUIRES_OK_ASYNC(         context,         context->forward_input_or_allocate_output({1}, 0, rhs.shape(), &output),         done);      // To be consistent with the MatrixInverse op, we define the solution for     // an empty set of equations as the empty matrix.     if (input.NumElements() == 0 || rhs.NumElements() == 0) {       done();       return;     }      // TODO(rmlarsen): Convert to std::make_unique when available.     std::unique_ptr<CudaSolver> solver(new CudaSolver(context));      // Make a copy of the input for the factorization step, or, if adjoint_ is     // false, try to reuse the input buffer if this op owns it exclusively.     Tensor input_copy;     const GPUDevice& device = context->eigen_device<GPUDevice>();     if (adjoint_) {       // For the adjoint case, it is simpler to always make a transposed copy up       // front.       OP_REQUIRES_OK_ASYNC(           context,           solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,                                          input.shape(), &input_copy),           done);       OP_REQUIRES_OK_ASYNC(context,                            DoMatrixTranspose(device, input, &input_copy), done);     } else {       OP_REQUIRES_OK_ASYNC(           context,           solver->forward_input_or_allocate_scoped_tensor(               {0}, DataTypeToEnum<Scalar>::value, input.shape(), &input_copy),           done);       if (!input.SharesBufferWith(input_copy)) {         device.memcpy(input_copy.flat<Scalar>().data(),                       input.flat<Scalar>().data(),                       input.NumElements() * sizeof(Scalar));       }     }     auto input_copy_reshaped = input_copy.template flat_inner_dims<Scalar, 3>();     const int64 batch_size = input_copy_reshaped.dimension(0);      // Allocate pivots on the device.     Tensor pivots;     OP_REQUIRES_OK_ASYNC(         context,         solver->allocate_scoped_tensor(DataTypeToEnum<int>::value,                                        TensorShape{batch_size, n}, &pivots),         done);     auto pivots_mat = pivots.template matrix<int>();      // 1. Compute the partially pivoted LU factorization(s) of the     // matrix/matrices.     std::vector<DeviceLapackInfo> dev_info;     auto input_copy_ptrs = solver->GetScratchSpace<uint8>(         sizeof(Scalar*) * batch_size, ""input_copt_ptrs"",         /* on_host */ true);     const int kMaxMatrixSizeToBatchSizeRatio = 128;     const bool use_batched_solver =         n <= kMaxMatrixSizeToBatchSizeRatio * batch_size;     if (use_batched_solver) {       // For small matrices or large batch sizes, we use the batched interface       // from cuBlas.       const Scalar** input_copy_ptrs_base =           reinterpret_cast<const Scalar**>(input_copy_ptrs.mutable_data());       for (int batch = 0; batch < batch_size; ++batch) {         input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);       }       dev_info.push_back(           solver->GetDeviceLapackInfo(batch_size, ""getrfBatched""));       OP_REQUIRES_OK_ASYNC(           context,           solver->GetrfBatched(n, input_copy_ptrs_base, n, pivots_mat.data(),                                &dev_info.back(), batch_size),           done);     } else {       // For small batch sizes or large matrices, we use the non-batched       // interface from cuSolver, which is much faster for large matrices.       dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, ""getrf""));       for (int batch = 0; batch < batch_size; ++batch) {         OP_REQUIRES_OK_ASYNC(             context,             solver->Getrf(n, n, &input_copy_reshaped(batch, 0, 0), n,                           &pivots_mat(batch, 0), &dev_info.back()(batch)),             done);       }     }      // 2. Make a transposed copy of the right-hand sides. This is necessary     // because cuBLAS assumes column-major storage while TensorFlow TF uses     // row-major.     TensorShape transposed_rhs_shape(rhs.shape());     transposed_rhs_shape.RemoveLastDims(2);     transposed_rhs_shape.AddDim(nrhs);     transposed_rhs_shape.AddDim(n);     Tensor transposed_rhs;     OP_REQUIRES_OK_ASYNC(         context,         solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,                                        transposed_rhs_shape, &transposed_rhs),         done);     if (nrhs > 1) {       OP_REQUIRES_OK_ASYNC(           context, DoMatrixTranspose(device, rhs, &transposed_rhs), done);     } else {       device.memcpy(transposed_rhs.flat<Scalar>().data(),                     rhs.flat<Scalar>().data(),                     rhs.NumElements() * sizeof(Scalar));     }      // 3. Solve op(A) X = B (in column major form).     // We use a trick here: If adjoint_ is true, we converted A to column major     // form above. If adjoint is false then I leave A in row-major form and use     // trans_a = CUBLAS_OP_T to effectively transform it to column-major on the     // fly. (This means that we actually use the LU-factorization of A^T in that     // case, but that is equally good for solving AX=B). This way we save an     // explicit transpose in the more common case of adjoint_ == false.     auto input_copy_ptr_array = solver->GetScratchSpace<uint8>(         sizeof(Scalar*) * batch_size, ""input_copy_ptr_array"",         /* on_host */ true);     auto transposed_rhs_ptr_array = solver->GetScratchSpace<uint8>(         sizeof(Scalar*) * batch_size, ""transposed_rhs_ptr_array"",         /* on_host */ true);     auto transposed_rhs_reshaped =         transposed_rhs.template flat_inner_dims<Scalar, 3>();     if (use_batched_solver) {       const Scalar** input_copy_ptrs_base =           reinterpret_cast<const Scalar**>(input_copy_ptr_array.mutable_data());       const Scalar** transposed_rhs_ptrs_base =           reinterpret_cast<const Scalar**>(               transposed_rhs_ptr_array.mutable_data());       for (int batch = 0; batch < batch_size; ++batch) {         input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);         transposed_rhs_ptrs_base[batch] = &transposed_rhs_reshaped(batch, 0, 0);       }       int host_info = 0;       OP_REQUIRES_OK_ASYNC(           context,           solver->GetrsBatched(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,                                input_copy_ptrs_base, n, pivots_mat.data(),                                transposed_rhs_ptrs_base, n, &host_info,                                batch_size),           done);       OP_REQUIRES_ASYNC(           context, host_info == 0,           errors::InvalidArgument(""The "", -host_info,                                   ""'th argument to cublas*getrsBatched had ""                                   ""an illegal value.""),           done);     } else {       dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, ""getrs""));       for (int batch = 0; batch < batch_size; ++batch) {         OP_REQUIRES_OK_ASYNC(             context,             solver->Getrs(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,                           &input_copy_reshaped(batch, 0, 0), n,                           &pivots_mat(batch, 0),                           &transposed_rhs_reshaped(batch, 0, 0), n,                           &dev_info.back()(batch)),             done);       }     }      // 4. Transpose X to get the final result in row-major form.     if (nrhs > 1) {       OP_REQUIRES_OK_ASYNC(           context, DoMatrixTranspose(device, transposed_rhs, output), done);     } else {       device.memcpy(output->flat<Scalar>().data(),                     transposed_rhs.flat<Scalar>().data(),                     transposed_rhs.NumElements() * sizeof(Scalar));     }      // Callback for checking info after kernels finish. Also capture the     // temporary Tensors/ScratchSpace so they don't get deallocated before the     // kernels run. TODO(rmlarsen): Use move capture once C++14 becomes     // available.     auto info_checker = [context, done, dev_info](                             const Status& status,                             const std::vector<HostLapackInfo>& host_infos) {       if (!status.ok() && errors::IsInvalidArgument(status) &&           !host_infos.empty()) {         for (int i = 0; i < host_infos[0].size(); ++i) {           // Match the CPU error message for singular matrices. Otherwise           // just print the original error message from the status below.           OP_REQUIRES_ASYNC(context, host_infos[0].data()[i] <= 0,                             errors::InvalidArgument(kErrMsg), done);         }       }       OP_REQUIRES_OK_ASYNC(context, status, done);       done();     };     CudaSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,                                                     std::move(info_checker));   }"
"196689_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     Buffer* buf = nullptr;     OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));     core::ScopedUnref scope(buf);     Buffer::Tuple tuple;      std::size_t index = ctx->input(0).scalar<int>()();      OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));      OP_REQUIRES(         ctx, tuple.size() == (size_t)ctx->num_outputs(),         errors::InvalidArgument(""Mismatch stage/unstage: "", tuple.size(),                                 "" vs. "", ctx->num_outputs()));      for (size_t i = 0; i < tuple.size(); ++i) {       ctx->set_output(i, tuple[i]);     }   }"
"196691_CWE-703.c","CWE-703","static GF_Err isoffin_process(GF_Filter *filter) { 	ISOMReader *read = gf_filter_get_udta(filter); 	u32 i, count = gf_list_count(read->channels); 	Bool is_active = GF_FALSE; 	Bool in_is_eos = GF_FALSE; 	Bool check_forced_end = GF_FALSE; 	Bool has_new_data = GF_FALSE; 	u64 min_offset_plus_one = 0; 	u32 nb_forced_end=0; 	if (read->in_error) 		return read->in_error;  	if (read->pid) { 		Bool fetch_input = GF_TRUE;  		//we failed at loading the init segment during a dash switch, retry 		if (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) { 			isoffin_configure_pid(filter, read->pid, GF_FALSE); 			if (read->moov_not_loaded) return GF_OK; 		} 		if (read->mem_load_mode==2) { 			if (!read->force_fetch && read->mem_blob.size > read->mstore_size) { 				fetch_input = GF_FALSE; 			} 			read->force_fetch = GF_FALSE; 		} 		while (fetch_input) { 			GF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid); 			if (!pck) { 				//we issued a seek, wait for the first packet to be received before fetching channels 				//otherwise we could end up reading from the wrong cache 				if (read->wait_for_source) { 					//something went wrong during the seek request 					if (gf_filter_pid_is_eos(read->pid)) 						return GF_EOS; 					return GF_OK; 				} 				break; 			} 			read->wait_for_source = GF_FALSE;  			if (read->mem_load_mode) { 				u32 data_size; 				const u8 *pck_data = gf_filter_pck_get_data(pck, &data_size); 				isoffin_push_buffer(filter, read, pck_data, data_size); 			} 			//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it 			else if (read->moov_not_loaded==2) { 				gf_filter_pid_drop_packet(read->pid); 				return GF_OK; 			} 			gf_filter_pid_drop_packet(read->pid); 			has_new_data = GF_TRUE; 			if (read->in_error) 				return read->in_error; 		} 		if (gf_filter_pid_is_eos(read->pid)) { 			read->input_loaded = GF_TRUE; 			in_is_eos = GF_TRUE; 		} 		if (read->input_is_stop) { 			read->input_loaded = GF_TRUE; 			in_is_eos = GF_TRUE; 			read->input_is_stop = GF_FALSE; 		} 		if (!read->frag_type && read->input_loaded) { 			in_is_eos = GF_TRUE; 		}         //segment is invalid, wait for eos on input an send eos on all channels         if (read->invalid_segment) {             if (!in_is_eos) return GF_OK;             read->invalid_segment = GF_FALSE;              for (i=0; i<count; i++) {                 ISOMChannel *ch = gf_list_get(read->channels, i);                 if (!ch->playing) {                     continue;                 }                 if (!ch->eos_sent) {                     ch->eos_sent = GF_TRUE;                     gf_filter_pid_set_eos(ch->pid);                 }             }             read->eos_signaled = GF_TRUE;             return GF_EOS;         } 	} else if (read->extern_mov) { 		in_is_eos = GF_TRUE; 		read->input_loaded = GF_TRUE; 	} 	if (read->moov_not_loaded==1) { 		if (read->mem_load_mode) 			return GF_OK; 		read->moov_not_loaded = GF_FALSE; 		return isoffin_setup(filter, read); 	}  	if (read->refresh_fragmented) { 		const GF_PropertyValue *prop;  		if (in_is_eos) { 			read->refresh_fragmented = GF_FALSE; 		} else { 			prop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED); 			if (prop && prop->value.boolean) 				read->refresh_fragmented = GF_FALSE; 		}  		if (has_new_data) { 			u64 bytesMissing=0; 			GF_Err e; 			const char *new_url = NULL; 			prop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH); 			if (prop) new_url = prop->value.string;  			e = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);  			if (e && (e!= GF_ISOM_INCOMPLETE_FILE)) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (""[IsoMedia] Failed to refresh current segment: %s\n"", gf_error_to_string(e) )); 				read->refresh_fragmented = GF_FALSE; 			} else { 				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (""[IsoMedia] Refreshing current segment at UTC ""LLU"" - ""LLU"" bytes still missing - input is EOS %d\n"", gf_net_get_utc(), bytesMissing, in_is_eos)); 			}  			if (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) { 				GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (""[IsoMedia] Incomplete Segment received - ""LLU"" bytes missing but EOF found\n"", bytesMissing )); 			}  #ifndef GPAC_DISABLE_LOG 			if (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) { 				for (i=0; i<count; i++) { 					ISOMChannel *ch = gf_list_get(read->channels, i); 					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (""[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\n"", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) )); 				} 			} #endif 			isor_check_producer_ref_time(read); 			if (!read->frag_type) 				read->refresh_fragmented = GF_FALSE; 		} 	}  	for (i=0; i<count; i++) { 		u8 *data; 		u32 nb_pck=50; 		ISOMChannel *ch; 		ch = gf_list_get(read->channels, i); 		if (!ch->playing) { 			nb_forced_end++; 			continue; 		} 		//eos not sent on this channel, we are active 		if (!ch->eos_sent) 			is_active = GF_TRUE;  		while (nb_pck) { 			ch->sample_data_offset = 0; 			if (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) ) 				break;  			if (ch->item_id) { 				isor_reader_get_sample_from_item(ch); 			} else { 				isor_reader_get_sample(ch); 			}  			if (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) { 				isor_reader_release_sample(ch); 				continue; 			} 			if (ch->sample) { 				u32 sample_dur; 				u8 dep_flags; 				u8 *subs_buf; 				u32 subs_buf_size; 				GF_FilterPacket *pck; 				if (ch->needs_pid_reconfig) { 					isor_update_channel_config(ch); 					ch->needs_pid_reconfig = GF_FALSE; 				}  				//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed 				if (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) { 					ch->check_has_rap = GF_FALSE; 					ch->has_rap = GF_TRUE; 					gf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) ); 				}  				//strip param sets from payload, trigger reconfig if needed 				isor_reader_check_config(ch);  				if (read->nodata) { 					pck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL); 					if (!pck) return GF_OUT_OF_MEM; 				} else { 					pck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data); 					if (!pck) return GF_OUT_OF_MEM;  					memcpy(data, ch->sample->data, ch->sample->dataLength); 				} 				gf_filter_pck_set_dts(pck, ch->dts); 				gf_filter_pck_set_cts(pck, ch->cts); 				if (ch->sample->IsRAP==-1) { 					gf_filter_pck_set_sap(pck, GF_FILTER_SAP_1); 					ch->redundant = 1; 				} else { 					gf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP); 				}  				if (ch->sap_3) 					gf_filter_pck_set_sap(pck, GF_FILTER_SAP_3); 				else if (ch->sap_4_type) { 					gf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4); 					gf_filter_pck_set_roll_info(pck, ch->roll); 				}  				sample_dur = ch->au_duration; 				if (ch->sample->nb_pack) 					sample_dur *= ch->sample->nb_pack; 				gf_filter_pck_set_duration(pck, sample_dur); 				gf_filter_pck_set_seek_flag(pck, ch->seek_flag);  				//for now we only signal xPS mask for non-sap 				if (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) { 					gf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) ); 				}  				dep_flags = ch->isLeading; 				dep_flags <<= 2; 				dep_flags |= ch->dependsOn; 				dep_flags <<= 2; 				dep_flags |= ch->dependedOn; 				dep_flags <<= 2; 				dep_flags |= ch->redundant;  				if (dep_flags) 					gf_filter_pck_set_dependency_flags(pck, dep_flags);  				gf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0); 				gf_filter_pck_set_seq_num(pck, ch->sample_num);   				subs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size); 				if (subs_buf) { 					gf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) ); 				}  				if (ch->sai_buffer && ch->pck_encrypted) { 					assert(ch->sai_buffer_size); 					gf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) ); 				}  				if (read->sigfrag) { 					GF_ISOFragmentBoundaryInfo finfo; 					if (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) { 						u64 start=0; 						u32 traf_start = finfo.seg_start_plus_one ? 2 : 1;  						if (finfo.seg_start_plus_one) 							gf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));  						gf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));  						start = finfo.frag_start; 						if (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1; 						gf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end)); 						if (finfo.moof_template) { 							gf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size)); 						} 						if (finfo.sidx_end) { 							gf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end)); 						}  						if (read->seg_name_changed) { 							const GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL); 							read->seg_name_changed = GF_FALSE; 							if (p && p->value.string) { 								gf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string)); 							} 						} 					} 				} 				if (ch->sender_ntp) { 					gf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp)); 					if (ch->ntp_at_server_ntp) { 						gf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp)); 					} 				} 				ch->eos_sent = GF_FALSE;  				//this might not be the true end of stream 				if ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) { 					gf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE)); 				}  				gf_filter_pck_send(pck); 				isor_reader_release_sample(ch);  				ch->last_valid_sample_data_offset = ch->sample_data_offset; 				nb_pck--; 			} else if (ch->last_state==GF_EOS) { 				if (ch->playing == 2) { 					if (in_is_eos) { 						ch->playing = GF_FALSE; 					} else { 						nb_forced_end++; 						check_forced_end = GF_TRUE; 					} 				} 				if (in_is_eos && !ch->eos_sent) { 					void *tfrf; 					const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);  					ch->eos_sent = GF_TRUE; 					read->eos_signaled = GF_TRUE;  					tfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track); 					if (tfrf) { 						gf_filter_pid_set_info_str(ch->pid, ""smooth_tfrf"", &PROP_POINTER(tfrf) ); 						ch->last_has_tfrf = GF_TRUE; 					} else if (ch->last_has_tfrf) { 						gf_filter_pid_set_info_str(ch->pid, ""smooth_tfrf"", NULL); 						ch->last_has_tfrf = GF_FALSE; 					}  					gf_filter_pid_set_eos(ch->pid); 				} 				break; 			} else { 				read->force_fetch = GF_TRUE; 				break; 			} 		} 		if (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset)) 			min_offset_plus_one = 1 + ch->last_valid_sample_data_offset; 	} 	if (read->mem_load_mode && min_offset_plus_one) { 		isoffin_purge_mem(read, min_offset_plus_one-1); 	}  	//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input 	if (read->pid && check_forced_end && (nb_forced_end==count)) { 		//abort input 		GF_FilterEvent evt; 		GF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid); 		gf_filter_pid_send_event(read->pid, &evt); 	}   	if (!is_active) { 		return GF_EOS; 	} 	//if (in_is_eos) //	gf_filter_ask_rt_reschedule(filter, 1); 	return GF_OK;  }"
"196698_CWE-125.cc","CWE-125","void SparseFillEmptyRowsOpImpl(OpKernelContext* context,                                AsyncOpKernel::DoneCallback done = nullptr) {   // Note that setting this empty lambda as the default parameter value directly   // can cause strange compiler/linker errors, so we do it like this instead.   if (!done) {     done = [] {};   }    const int kIndicesInput = 0;   const int kValuesInput = 1;   const int kDenseShapeInput = 2;   const int kDefaultValueInput = 3;    const Tensor& indices_t = context->input(kIndicesInput);   const Tensor& values_t = context->input(kValuesInput);   const Tensor& dense_shape_t = context->input(kDenseShapeInput);   const Tensor& default_value_t = context->input(kDefaultValueInput);    OP_REQUIRES_ASYNC(       context, TensorShapeUtils::IsVector(dense_shape_t.shape()),       errors::InvalidArgument(""dense_shape must be a vector, saw: "",                               dense_shape_t.shape().DebugString()),       done);   OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),                     errors::InvalidArgument(""indices must be a matrix, saw: "",                                             indices_t.shape().DebugString()),                     done);   OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),                     errors::InvalidArgument(""values must be a vector, saw: "",                                             values_t.shape().DebugString()),                     done);   OP_REQUIRES_ASYNC(       context, TensorShapeUtils::IsScalar(default_value_t.shape()),       errors::InvalidArgument(""default_value must be a scalar, saw: "",                               default_value_t.shape().DebugString()),       done);   // TODO(ebrevdo): add shape checks between values, indices,   // Also add check that dense rank > 0.   OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,                     errors::InvalidArgument(""Dense shape cannot be empty.""),                     done);    using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;   OP_REQUIRES_OK_ASYNC(context,                        FunctorType()(context, default_value_t, indices_t,                                      values_t, dense_shape_t, done),                        done); }"
"196705_CWE-20.cc","CWE-20","Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,                       const Tensor *a_shape, const Tensor *b) {   if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {     return errors::InvalidArgument(         ""Input a_indices should be a matrix but received shape: "",         a_indices->shape().DebugString());   }   if (!TensorShapeUtils::IsVector(a_values->shape()) ||       !TensorShapeUtils::IsVector(a_shape->shape())) {     return errors::InvalidArgument(         ""Inputs a_values and a_shape should be vectors ""         ""but received shapes: "",         a_values->shape().DebugString(), "" and "",         a_shape->shape().DebugString());   }   if (a_shape->NumElements() != b->dims()) {     return errors::InvalidArgument(         ""Two operands have different ranks; received: "", a_shape->NumElements(),         "" and "", b->dims());   }   const auto a_shape_flat = a_shape->flat<Index>();   for (int i = 0; i < b->dims(); ++i) {     if (a_shape_flat(i) != b->dim_size(i)) {       return errors::InvalidArgument(           ""Dimension "", i,           "" does not equal (no broadcasting is supported): sparse side "",           a_shape_flat(i), "" vs dense side "", b->dim_size(i));     }   }   return Status::OK(); }"
"196726_CWE-703.c","CWE-703","njs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,     njs_index_t unused) {     int64_t                i, und, len, nlen, length;     njs_int_t              ret, fast_path;     njs_array_t            *array;     njs_value_t            *this, *comparefn, *start, *strings;     njs_array_sort_ctx_t   ctx;     njs_array_sort_slot_t  *p, *end, *slots, *nslots;      comparefn = njs_arg(args, nargs, 1);      if (njs_is_defined(comparefn)) {         if (njs_slow_path(!njs_is_function(comparefn))) {             njs_type_error(vm, ""comparefn must be callable or undefined"");             return NJS_ERROR;         }          ctx.function = njs_function(comparefn);      } else {         ctx.function = NULL;     }      this = njs_argument(args, 0);      ret = njs_value_to_object(vm, this);     if (njs_slow_path(ret != NJS_OK)) {         return ret;     }      ret = njs_value_length(vm, this, &length);     if (njs_slow_path(ret != NJS_OK)) {         return ret;     }      if (njs_slow_path(length < 2)) {         vm->retval = *this;         return NJS_OK;     }      slots = NULL;     ctx.vm = vm;     ctx.strings.separate = 0;     ctx.strings.pointer = 0;     ctx.exception = 0;      fast_path = njs_is_fast_array(this);      if (njs_fast_path(fast_path)) {         array = njs_array(this);         start = array->start;          slots = njs_mp_alloc(vm->mem_pool,                              sizeof(njs_array_sort_slot_t) * length);         if (njs_slow_path(slots == NULL)) {                 return NJS_ERROR;         }          und = 0;         p = slots;          for (i = 0; i < length; i++) {             if (njs_slow_path(!njs_is_valid(&start[i]))) {                 fast_path = 0;                 njs_mp_free(vm->mem_pool, slots);                 slots = NULL;                 goto slow_path;             }              if (njs_slow_path(njs_is_undefined(&start[i]))) {                 und++;                 continue;             }              p->value = start[i];             p->pos = i;             p->str = NULL;             p++;         }          len = p - slots;      } else {  slow_path:          und = 0;         p = NULL;         end = NULL;          for (i = 0; i < length; i++) {             if (p >= end) {                 nlen = njs_min(njs_max((p - slots) * 2, 8), length);                 nslots = njs_mp_alloc(vm->mem_pool,                                       sizeof(njs_array_sort_slot_t) * nlen);                 if (njs_slow_path(nslots == NULL)) {                     njs_memory_error(vm);                     return NJS_ERROR;                 }                  if (slots != NULL) {                     p = (void *) njs_cpymem(nslots, slots,                                   sizeof(njs_array_sort_slot_t) * (p - slots));                     njs_mp_free(vm->mem_pool, slots);                  } else {                     p = nslots;                 }                  slots = nslots;                 end = slots + nlen;             }              ret = njs_value_property_i64(vm, this, i, &p->value);             if (njs_slow_path(ret == NJS_ERROR)) {                 ret = NJS_ERROR;                 goto exception;             }              if (ret == NJS_DECLINED) {                 continue;             }              if (njs_is_undefined(&p->value)) {                 und++;                 continue;             }              p->pos = i;             p->str = NULL;             p++;         }          len = p - slots;     }      strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,                            sizeof(njs_value_t));     if (njs_slow_path(strings == NULL)) {         ret = NJS_ERROR;         goto exception;     }      njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,               &ctx);      if (ctx.exception) {         ret = NJS_ERROR;         goto exception;     }      if (njs_fast_path(fast_path)) {         array = njs_array(this);         start = array->start;          for (i = 0; i < len; i++) {             start[i] = slots[i].value;         }          for (i = len; und-- > 0; i++) {             start[i] = njs_value_undefined;         }      } else {         for (i = 0; i < len; i++) {             if (slots[i].pos != i) {                 ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);                 if (njs_slow_path(ret == NJS_ERROR)) {                     goto exception;                 }             }         }          for (i = len; und-- > 0; i++) {             ret = njs_value_property_i64_set(vm, this, i,                                           njs_value_arg(&njs_value_undefined));             if (njs_slow_path(ret == NJS_ERROR)) {                 goto exception;             }         }          for (; i < length; i++) {             ret = njs_value_property_i64_delete(vm, this, i, NULL);             if (njs_slow_path(ret == NJS_ERROR)) {                 goto exception;             }         }     }      vm->retval = *this;      ret = NJS_OK;  exception:      if (slots != NULL) {         njs_mp_free(vm->mem_pool, slots);     }      njs_arr_destroy(&ctx.strings);      return ret; }"
"196790_CWE-703.cc","CWE-703","Status Examples::Initialize(OpKernelContext* const context,                             const ModelWeights& weights,                             const int num_sparse_features,                             const int num_sparse_features_with_values,                             const int num_dense_features) {   num_features_ = num_sparse_features + num_dense_features;    OpInputList sparse_example_indices_inputs;   TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",                                          &sparse_example_indices_inputs));   if (sparse_example_indices_inputs.size() != num_sparse_features)     return errors::InvalidArgument(         ""Expected "", num_sparse_features,         "" tensors in sparse_example_indices but got "",         sparse_example_indices_inputs.size());   OpInputList sparse_feature_indices_inputs;   TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",                                          &sparse_feature_indices_inputs));   if (sparse_feature_indices_inputs.size() != num_sparse_features)     return errors::InvalidArgument(         ""Expected "", num_sparse_features,         "" tensors in sparse_feature_indices but got "",         sparse_feature_indices_inputs.size());   OpInputList sparse_feature_values_inputs;   if (num_sparse_features_with_values > 0) {     TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",                                            &sparse_feature_values_inputs));     if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)       return errors::InvalidArgument(           ""Expected "", num_sparse_features_with_values,           "" tensors in sparse_feature_values but got "",           sparse_feature_values_inputs.size());   }    const Tensor* example_weights_t;   TF_RETURN_IF_ERROR(context->input(""example_weights"", &example_weights_t));   auto example_weights = example_weights_t->flat<float>();    if (example_weights.size() >= std::numeric_limits<int>::max()) {     return errors::InvalidArgument(strings::Printf(         ""Too many examples in a mini-batch: %zu > %d"", example_weights.size(),         std::numeric_limits<int>::max()));   }    // The static_cast here is safe since num_examples can be at max an int.   const int num_examples = static_cast<int>(example_weights.size());   const Tensor* example_labels_t;   TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));   auto example_labels = example_labels_t->flat<float>();    OpInputList dense_features_inputs;   TF_RETURN_IF_ERROR(       context->input_list(""dense_features"", &dense_features_inputs));    examples_.clear();   examples_.resize(num_examples);   probabilities_.resize(num_examples);   sampled_index_.resize(num_examples);   sampled_count_.resize(num_examples);   for (int example_id = 0; example_id < num_examples; ++example_id) {     Example* const example = &examples_[example_id];     example->sparse_features_.resize(num_sparse_features);     example->dense_vectors_.resize(num_dense_features);     example->example_weight_ = example_weights(example_id);     example->example_label_ = example_labels(example_id);   }   const DeviceBase::CpuWorkerThreads& worker_threads =       *context->device()->tensorflow_cpu_worker_threads();   TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(       worker_threads, num_examples, num_sparse_features, weights,       sparse_example_indices_inputs, sparse_feature_indices_inputs,       sparse_feature_values_inputs, &examples_));   TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(       worker_threads, num_examples, num_dense_features, weights,       dense_features_inputs, &examples_));   TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(       worker_threads, num_examples, num_sparse_features, num_dense_features,       &examples_));   return Status::OK(); }"
"196801_CWE-703.c","CWE-703","GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth) { 	u32 i, sceneT, odT, descIndex, size, size64; 	GF_InitialObjectDescriptor *iod; 	GF_SLConfig slc; 	GF_ISOSample *samp; 	Bool remove_ocr; 	u8 *buffer; 	char buf64[5000], sdpLine[5100];   	gf_isom_sdp_clean(file);  	if (bandwidth) { 		sprintf(buf64, ""b=AS:%d"", bandwidth); 		gf_isom_sdp_add_line(file, buf64); 	}     //xtended attribute for copyright     if (gf_sys_is_test_mode()) {         sprintf(buf64, ""a=x-copyright: %s"", ""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)"");     } else {         sprintf(buf64, ""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s"", gf_gpac_version(), gf_gpac_copyright() );     } 	gf_isom_sdp_add_line(file, buf64);  	if (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;  	odT = sceneT = 0; 	for (i=0; i<gf_isom_get_track_count(file); i++) { 		if (!gf_isom_is_track_in_root_od(file, i+1)) continue; 		switch (gf_isom_get_media_type(file,i+1)) { 		case GF_ISOM_MEDIA_OD: 			odT = i+1; 			break; 		case GF_ISOM_MEDIA_SCENE: 			sceneT = i+1; 			break; 		} 	} 	remove_ocr = 0; 	if (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) { 		IOD_Profile = GF_SDP_IOD_ISMA; 		remove_ocr = 1; 	}  	/*if we want ISMA like iods, we need at least BIFS */ 	if ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;  	/*do NOT change PLs, we assume they are correct*/ 	iod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file); 	if (!iod) return GF_NOT_SUPPORTED;  	/*rewrite an IOD with good SL config - embbed data if possible*/ 	if (IOD_Profile == GF_SDP_IOD_ISMA) { 		GF_ESD *esd; 		Bool is_ok = 1; 		while (gf_list_count(iod->ESDescriptors)) { 			esd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0); 			gf_odf_desc_del((GF_Descriptor *) esd); 			gf_list_rem(iod->ESDescriptors, 0); 		}   		/*get OD esd, and embbed stream data if possible*/ 		if (odT) { 			esd = gf_isom_get_esd(file, odT, 1); 			if (gf_isom_get_sample_count(file, odT)==1) { 				samp = gf_isom_get_sample(file, odT, 1, &descIndex); 				if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) { 					InitSL_NULL(&slc); 					slc.predefined = 0; 					slc.hasRandomAccessUnitsOnlyFlag = 1; 					slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT); 					slc.OCRResolution = 1000; 					slc.startCTS = samp->DTS+samp->CTS_Offset; 					slc.startDTS = samp->DTS; 					//set the SL for future extraction 					gf_isom_set_extraction_slc(file, odT, 1, &slc);  					size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000); 					buf64[size64] = 0; 					sprintf(sdpLine, ""data:application/mpeg4-od-au;base64,%s"", buf64);  					if (esd->decoderConfig) { 						esd->decoderConfig->avgBitrate = 0; 						esd->decoderConfig->bufferSizeDB = samp->dataLength; 						esd->decoderConfig->maxBitrate = 0; 					} 					size64 = (u32) strlen(sdpLine)+1; 					esd->URLString = (char*)gf_malloc(sizeof(char) * size64); 					strcpy(esd->URLString, sdpLine); 				} else { 					GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\n"")); 					is_ok = 0; 				} 				gf_isom_sample_del(&samp); 			} 			if (remove_ocr) esd->OCRESID = 0; 			else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;  			//OK, add this to our IOD 			gf_list_add(iod->ESDescriptors, esd); 		}  		esd = gf_isom_get_esd(file, sceneT, 1); 		if (gf_isom_get_sample_count(file, sceneT)==1) { 			samp = gf_isom_get_sample(file, sceneT, 1, &descIndex); 			if (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {  				slc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT); 				slc.OCRResolution = 1000; 				slc.startCTS = samp->DTS+samp->CTS_Offset; 				slc.startDTS = samp->DTS; 				//set the SL for future extraction 				gf_isom_set_extraction_slc(file, sceneT, 1, &slc); 				//encode in Base64 the sample 				size64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000); 				buf64[size64] = 0; 				sprintf(sdpLine, ""data:application/mpeg4-bifs-au;base64,%s"", buf64);  				if (esd->decoderConfig) { 					esd->decoderConfig->avgBitrate = 0; 					esd->decoderConfig->bufferSizeDB = samp->dataLength; 					esd->decoderConfig->maxBitrate = 0; 				} 				esd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1)); 				strcpy(esd->URLString, sdpLine); 			} else { 				GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\n"")); 				is_ok = 0; 			} 			gf_isom_sample_del(&samp); 		} 		if (remove_ocr) esd->OCRESID = 0; 		else if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;  		gf_list_add(iod->ESDescriptors, esd);  		if (is_ok) { 			u32 has_a, has_v, has_i_a, has_i_v; 			has_a = has_v = has_i_a = has_i_v = 0; 			for (i=0; i<gf_isom_get_track_count(file); i++) { 				esd = gf_isom_get_esd(file, i+1, 1); 				if (!esd) continue; 				if (esd->decoderConfig) { 					if (esd->decoderConfig->streamType==GF_STREAM_VISUAL) { 						if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++; 						else has_v++; 					} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) { 						if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++; 						else has_a++; 					} 				} 				gf_odf_desc_del((GF_Descriptor *)esd); 			} 			/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/ 			if (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) { 				sprintf(sdpLine, ""a=isma-compliance:1,1.0,1""); 				gf_isom_sdp_add_line(file, sdpLine); 			} 		} 	}  	//encode the IOD 	buffer = NULL; 	size = 0; 	gf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size); 	gf_odf_desc_del((GF_Descriptor *)iod);  	//encode in Base64 the iod 	size64 = gf_base64_encode(buffer, size, buf64, 2000); 	buf64[size64] = 0; 	gf_free(buffer);  	sprintf(sdpLine, ""a=mpeg4-iod:\""data:application/mpeg4-iod;base64,%s\"""", buf64); 	gf_isom_sdp_add_line(file, sdpLine);  	return GF_OK; }"
"196805_CWE-787.c","CWE-787","mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc) {   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */   const mrb_irep *irep = proc->body.irep;   const mrb_pool_value *pool = irep->pool;   const mrb_sym *syms = irep->syms;   mrb_code insn;   int ai = mrb_gc_arena_save(mrb);   struct mrb_jmpbuf *prev_jmp = mrb->jmp;   struct mrb_jmpbuf c_jmp;   uint32_t a;   uint16_t b;   uint16_t c;   mrb_sym mid;   const struct mrb_irep_catch_handler *ch;  #ifdef DIRECT_THREADED   static const void * const optable[] = { #define OPCODE(x,_) &&L_OP_ ## x, #include ""mruby/ops.h"" #undef OPCODE   }; #endif    mrb_bool exc_catched = FALSE; RETRY_TRY_BLOCK:    MRB_TRY(&c_jmp) {    if (exc_catched) {     exc_catched = FALSE;     mrb_gc_arena_restore(mrb, ai);     if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)       goto L_BREAK;     goto L_RAISE;   }   mrb->jmp = &c_jmp;   mrb_vm_ci_proc_set(mrb->c->ci, proc);  #define regs (mrb->c->ci->stack)   INIT_DISPATCH {     CASE(OP_NOP, Z) {       /* do nothing */       NEXT;     }      CASE(OP_MOVE, BB) {       regs[a] = regs[b];       NEXT;     }      CASE(OP_LOADL, BB) {       switch (pool[b].tt) {   /* number */       case IREP_TT_INT32:         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);         break;       case IREP_TT_INT64: #if defined(MRB_INT64)         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);         break; #else #if defined(MRB_64BIT)         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);           break;         } #endif         goto L_INT_OVERFLOW; #endif       case IREP_TT_BIGINT:         goto L_INT_OVERFLOW; #ifndef MRB_NO_FLOAT       case IREP_TT_FLOAT:         regs[a] = mrb_float_value(mrb, pool[b].u.f);         break; #endif       default:         /* should not happen (tt:string) */         regs[a] = mrb_nil_value();         break;       }       NEXT;     }      CASE(OP_LOADI, BB) {       SET_FIXNUM_VALUE(regs[a], b);       NEXT;     }      CASE(OP_LOADINEG, BB) {       SET_FIXNUM_VALUE(regs[a], -b);       NEXT;     }      CASE(OP_LOADI__1,B) goto L_LOADI;     CASE(OP_LOADI_0,B) goto L_LOADI;     CASE(OP_LOADI_1,B) goto L_LOADI;     CASE(OP_LOADI_2,B) goto L_LOADI;     CASE(OP_LOADI_3,B) goto L_LOADI;     CASE(OP_LOADI_4,B) goto L_LOADI;     CASE(OP_LOADI_5,B) goto L_LOADI;     CASE(OP_LOADI_6,B) goto L_LOADI;     CASE(OP_LOADI_7, B) {     L_LOADI:       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);       NEXT;     }      CASE(OP_LOADI16, BS) {       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);       NEXT;     }      CASE(OP_LOADI32, BSS) {       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));       NEXT;     }      CASE(OP_LOADSYM, BB) {       SET_SYM_VALUE(regs[a], syms[b]);       NEXT;     }      CASE(OP_LOADNIL, B) {       SET_NIL_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADSELF, B) {       regs[a] = regs[0];       NEXT;     }      CASE(OP_LOADT, B) {       SET_TRUE_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADF, B) {       SET_FALSE_VALUE(regs[a]);       NEXT;     }      CASE(OP_GETGV, BB) {       mrb_value val = mrb_gv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETGV, BB) {       mrb_gv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETSV, BB) {       mrb_value val = mrb_vm_special_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETSV, BB) {       mrb_vm_special_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIV, BB) {       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);       NEXT;     }      CASE(OP_SETIV, BB) {       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETCV, BB) {       mrb_value val;       val = mrb_vm_cv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETCV, BB) {       mrb_vm_cv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIDX, B) {       mrb_value va = regs[a], vb = regs[a+1];       switch (mrb_type(va)) {       case MRB_TT_ARRAY:         if (!mrb_integer_p(vb)) goto getidx_fallback;         regs[a] = mrb_ary_entry(va, mrb_integer(vb));         break;       case MRB_TT_HASH:         regs[a] = mrb_hash_get(mrb, va, vb);         break;       case MRB_TT_STRING:         switch (mrb_type(vb)) {         case MRB_TT_INTEGER:         case MRB_TT_STRING:         case MRB_TT_RANGE:           regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());           break;         default:           goto getidx_fallback;         }         break;       default:       getidx_fallback:         mid = MRB_OPSYM(aref);         goto L_SEND_SYM;       }       NEXT;     }      CASE(OP_SETIDX, B) {       c = 2;       mid = MRB_OPSYM(aset);       SET_NIL_VALUE(regs[a+3]);       goto L_SENDB_SYM;     }      CASE(OP_GETCONST, BB) {       regs[a] = mrb_vm_const_get(mrb, syms[b]);       NEXT;     }      CASE(OP_SETCONST, BB) {       mrb_vm_const_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETMCNST, BB) {       regs[a] = mrb_const_get(mrb, regs[a], syms[b]);       NEXT;     }      CASE(OP_SETMCNST, BB) {       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETUPVAR, BBB) {       mrb_value *regs_a = regs + a;       struct REnv *e = uvenv(mrb, c);        if (e && b < MRB_ENV_LEN(e)) {         *regs_a = e->stack[b];       }       else {         *regs_a = mrb_nil_value();       }       NEXT;     }      CASE(OP_SETUPVAR, BBB) {       struct REnv *e = uvenv(mrb, c);        if (e) {         mrb_value *regs_a = regs + a;          if (b < MRB_ENV_LEN(e)) {           e->stack[b] = *regs_a;           mrb_write_barrier(mrb, (struct RBasic*)e);         }       }       NEXT;     }      CASE(OP_JMP, S) {       pc += (int16_t)a;       JUMP;     }     CASE(OP_JMPIF, BS) {       if (mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNOT, BS) {       if (!mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNIL, BS) {       if (mrb_nil_p(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }      CASE(OP_JMPUW, S) {       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {         struct RBreak *brk = (struct RBreak*)mrb->exc;         mrb_value target = mrb_break_value_get(brk);         mrb_assert(mrb_integer_p(target));         a = (uint32_t)mrb_integer(target);         mrb_assert(a >= 0 && a < irep->ilen);       }       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);         if (ch) {           /* avoiding a jump from a catch handler into the same handler */           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));           }         }       }       CHECKPOINT_END(RBREAK_TAG_JUMP);        mrb->exc = NULL; /* clear break object */       pc = irep->iseq + a;       JUMP;     }      CASE(OP_EXCEPT, B) {       mrb_value exc;        if (mrb->exc == NULL) {         exc = mrb_nil_value();       }       else {         switch (mrb->exc->tt) {         case MRB_TT_BREAK:         case MRB_TT_EXCEPTION:           exc = mrb_obj_value(mrb->exc);           break;         default:           mrb_assert(!""bad mrb_type"");           exc = mrb_nil_value();           break;         }         mrb->exc = NULL;       }       regs[a] = exc;       NEXT;     }     CASE(OP_RESCUE, BB) {       mrb_value exc = regs[a];  /* exc on stack */       mrb_value e = regs[b];       struct RClass *ec;        switch (mrb_type(e)) {       case MRB_TT_CLASS:       case MRB_TT_MODULE:         break;       default:         {           mrb_value exc;            exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                     ""class or module required for rescue clause"");           mrb_exc_set(mrb, exc);           goto L_RAISE;         }       }       ec = mrb_class_ptr(e);       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));       NEXT;     }      CASE(OP_RAISEIF, B) {       mrb_value exc = regs[a];       if (mrb_break_p(exc)) {         mrb->exc = mrb_obj_ptr(exc);         goto L_BREAK;       }       mrb_exc_set(mrb, exc);       if (mrb->exc) {         goto L_RAISE;       }       NEXT;     }      CASE(OP_SSEND, BBB) {       regs[a] = regs[0];       insn = OP_SEND;     }     goto L_SENDB;      CASE(OP_SSENDB, BBB) {       regs[a] = regs[0];     }     goto L_SENDB;      CASE(OP_SEND, BBB)     goto L_SENDB;      L_SEND_SYM:     c = 1;     /* push nil after arguments */     SET_NIL_VALUE(regs[a+2]);     goto L_SENDB_SYM;      CASE(OP_SENDB, BBB)     L_SENDB:     mid = syms[b];     L_SENDB_SYM:     {       mrb_callinfo *ci = mrb->c->ci;       mrb_method_t m;       struct RClass *cls;       mrb_value recv, blk;        ARGUMENT_NORMALIZE(a, &c, insn);        recv = regs[a];       cls = mrb_class(mrb, recv);       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, c);        if (MRB_METHOD_CFUNC_P(m)) {         if (MRB_METHOD_PROC_P(m)) {           struct RProc *p = MRB_METHOD_PROC(m);            mrb_vm_ci_proc_set(ci, p);           recv = p->body.func(mrb, recv);         }         else {           if (MRB_METHOD_NOARG_P(m)) {             check_method_noarg(mrb, ci);           }           recv = MRB_METHOD_FUNC(m)(mrb, recv);         }         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }         if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return recv;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         ci->stack[0] = recv;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }     }     JUMP;      CASE(OP_CALL, Z) {       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv = ci->stack[0];       struct RProc *m = mrb_proc_ptr(recv);        /* replace callinfo */       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);       mrb_vm_ci_proc_set(ci, m);       if (MRB_PROC_ENV_P(m)) {         ci->mid = MRB_PROC_ENV(m)->mid;       }        /* prepare stack */       if (MRB_PROC_CFUNC_P(m)) {         recv = MRB_PROC_CFUNC(m)(mrb, recv);         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;         ci[1].stack[0] = recv;         irep = mrb->c->ci->proc->body.irep;       }       else {         /* setup environment for calling method */         proc = m;         irep = m->body.irep;         if (!irep) {           mrb->c->ci->stack[0] = mrb_nil_value();           a = 0;           c = OP_R_NORMAL;           goto L_OP_RETURN_BODY;         }         mrb_int nargs = mrb_ci_bidx(ci)+1;         if (nargs < irep->nregs) {           mrb_stack_extend(mrb, irep->nregs);           stack_clear(regs+nargs, irep->nregs-nargs);         }         if (MRB_PROC_ENV_P(m)) {           regs[0] = MRB_PROC_ENV(m)->stack[0];         }         pc = irep->iseq;       }       pool = irep->pool;       syms = irep->syms;       JUMP;     }      CASE(OP_SUPER, BB) {       mrb_method_t m;       struct RClass *cls;       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv, blk;       const struct RProc *p = ci->proc;       mrb_sym mid = ci->mid;       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);        if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */         mid = p->e.env->mid;    /* restore old mid */       }        if (mid == 0 || !target_class) {         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {         target_class = mrb_vm_ci_target_class(ci);       }       else if (target_class->tt == MRB_TT_MODULE) {         target_class = mrb_vm_ci_target_class(ci);         if (target_class->tt != MRB_TT_ICLASS) {           goto super_typeerror;         }       }       recv = regs[0];       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {       super_typeerror: ;         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                             ""self has wrong type to call super in this context"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }        ARGUMENT_NORMALIZE(a, &b, OP_SUPER);        cls = target_class->super;       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, b);        /* prepare stack */       ci->stack[0] = recv;        if (MRB_METHOD_CFUNC_P(m)) {         mrb_value v;          if (MRB_METHOD_PROC_P(m)) {           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));         }         v = MRB_METHOD_CFUNC(m)(mrb, recv);         mrb_gc_arena_restore(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         mrb_assert(!mrb_break_p(v));         if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return v;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         mrb->c->ci->stack[0] = v;         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }       JUMP;     }      CASE(OP_ARGARY, BS) {       mrb_int m1 = (b>>11)&0x3f;       mrb_int r  = (b>>10)&0x1;       mrb_int m2 = (b>>5)&0x1f;       mrb_int kd = (b>>4)&0x1;       mrb_int lv = (b>>0)&0xf;       mrb_value *stack;        if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {         mrb_value exc;        L_NOSUPER:         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e) goto L_NOSUPER;         if (MRB_ENV_LEN(e) <= m1+r+m2+1)           goto L_NOSUPER;         stack = e->stack + 1;       }       if (r == 0) {         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);       }       else {         mrb_value *pp = NULL;         struct RArray *rest;         mrb_int len = 0;          if (mrb_array_p(stack[m1])) {           struct RArray *ary = mrb_ary_ptr(stack[m1]);            pp = ARY_PTR(ary);           len = ARY_LEN(ary);         }         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);         rest = mrb_ary_ptr(regs[a]);         if (m1 > 0) {           stack_copy(ARY_PTR(rest), stack, m1);         }         if (len > 0) {           stack_copy(ARY_PTR(rest)+m1, pp, len);         }         if (m2 > 0) {           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);         }         ARY_SET_LEN(rest, m1+len+m2);       }       if (kd) {         regs[a+1] = stack[m1+r+m2];         regs[a+2] = stack[m1+r+m2+1];       }       else {         regs[a+1] = stack[m1+r+m2];       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ENTER, W) {       mrb_int m1 = MRB_ASPEC_REQ(a);       mrb_int o  = MRB_ASPEC_OPT(a);       mrb_int r  = MRB_ASPEC_REST(a);       mrb_int m2 = MRB_ASPEC_POST(a);       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;       /* unused       int b  = MRB_ASPEC_BLOCK(a);       */       mrb_int const len = m1 + o + r + m2;        mrb_callinfo *ci = mrb->c->ci;       mrb_int argc = ci->n;       mrb_value *argv = regs+1;       mrb_value * const argv0 = argv;       mrb_int const kw_pos = len + kd;    /* where kwhash should be */       mrb_int const blk_pos = kw_pos + 1; /* where block should be */       mrb_value blk = regs[mrb_ci_bidx(ci)];       mrb_value kdict = mrb_nil_value();        /* keyword arguments */       if (ci->nk > 0) {         mrb_int kidx = mrb_ci_kidx(ci);         kdict = regs[kidx];         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {           kdict = mrb_nil_value();           ci->nk = 0;         }       }       if (!kd && !mrb_nil_p(kdict)) {         if (argc < 14) {           ci->n++;           argc++;    /* include kdict in normal arguments */         }         else if (argc == 14) {           /* pack arguments and kdict */           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);           argc = ci->n = 15;         }         else {/* argc == 15 */           /* push kdict to packed arguments */           mrb_ary_push(mrb, regs[1], regs[2]);         }         ci->nk = 0;       }       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {         kdict = mrb_hash_dup(mrb, kdict);       }        /* arguments is passed with Array */       if (argc == 15) {         struct RArray *ary = mrb_ary_ptr(regs[1]);         argv = ARY_PTR(ary);         argc = (int)ARY_LEN(ary);         mrb_gc_protect(mrb, regs[1]);       }        /* strict argument check */       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {         if (argc < m1 + m2 || (r == 0 && argc > len)) {           argnum_error(mrb, m1+m2);           goto L_RAISE;         }       }       /* extract first argument array to arguments */       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {         mrb_gc_protect(mrb, argv[0]);         argc = (int)RARRAY_LEN(argv[0]);         argv = RARRAY_PTR(argv[0]);       }        /* rest arguments */       mrb_value rest = mrb_nil_value();       if (argc < len) {         mrb_int mlen = m2;         if (argc < m1+m2) {           mlen = m1 < argc ? argc - m1 : 0;         }          /* copy mandatory and optional arguments */         if (argv0 != argv && argv) {           value_move(&regs[1], argv, argc-mlen); /* m1 + o */         }         if (argc < m1) {           stack_clear(&regs[argc+1], m1-argc);         }         /* copy post mandatory arguments */         if (mlen) {           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);         }         if (mlen < m2) {           stack_clear(&regs[len-m2+mlen+1], m2-mlen);         }         /* initialize rest arguments with empty Array */         if (r) {           rest = mrb_ary_new_capa(mrb, 0);           regs[m1+o+1] = rest;         }         /* skip initializer of passed arguments */         if (o > 0 && argc > m1+m2)           pc += (argc - m1 - m2)*3;       }       else {         mrb_int rnum = 0;         if (argv0 != argv) {           value_move(&regs[1], argv, m1+o);         }         if (r) {           rnum = argc-m1-o-m2;           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);           regs[m1+o+1] = rest;         }         if (m2 > 0 && argc-m2 > m1) {           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);         }         pc += o*3;       }        /* need to be update blk first to protect blk from GC */       regs[blk_pos] = blk;              /* move block */       if (kd) {         if (mrb_nil_p(kdict))           kdict = mrb_hash_new_capa(mrb, 0);         regs[kw_pos] = kdict;           /* set kwhash */       }        /* format arguments for generated code */       mrb->c->ci->n = len;        /* clear local (but non-argument) variables */       if (irep->nlocals-blk_pos-1 > 0) {         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);       }       JUMP;     }      CASE(OP_KARG, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;        if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {         mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       regs[a] = mrb_hash_get(mrb, kdict, k);       mrb_hash_delete_key(mrb, kdict, k);       NEXT;     }      CASE(OP_KEY_P, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;       mrb_bool key_p = FALSE;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {         key_p = mrb_hash_key_p(mrb, kdict, k);       }       regs[a] = mrb_bool_value(key_p);       NEXT;     }      CASE(OP_KEYEND, Z) {       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {         mrb_value keys = mrb_hash_keys(mrb, kdict);         mrb_value key1 = RARRAY_PTR(keys)[0];         mrb_value str = mrb_format(mrb, ""unknown keyword: %v"", key1);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       NEXT;     }      CASE(OP_BREAK, B) {       c = OP_R_BREAK;       goto L_RETURN;     }     CASE(OP_RETURN_BLK, B) {       c = OP_R_RETURN;       goto L_RETURN;     }     CASE(OP_RETURN, B)     c = OP_R_NORMAL;     L_RETURN:     {       mrb_callinfo *ci;        ci = mrb->c->ci;       if (ci->mid) {         mrb_value blk = regs[mrb_ci_bidx(ci)];          if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);            if (!MRB_PROC_STRICT_P(p) &&               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }       }        if (mrb->exc) {       L_RAISE:         ci = mrb->c->ci;         if (ci == mrb->c->cibase) {           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);           if (ch == NULL) goto L_FTOP;           goto L_CATCH;         }         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {           ci = cipop(mrb);           if (ci[1].cci == CINFO_SKIP && prev_jmp) {             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           pc = ci[0].pc;           if (ci == mrb->c->cibase) {             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);             if (ch == NULL) {             L_FTOP:             /* fiber top */               if (mrb->c == mrb->root_c) {                 mrb->c->ci->stack = mrb->c->stbase;                 goto L_STOP;               }               else {                 struct mrb_context *c = mrb->c;                  c->status = MRB_FIBER_TERMINATED;                 mrb->c = c->prev;                 c->prev = NULL;                 goto L_RAISE;               }             }             break;           }         }       L_CATCH:         if (ch == NULL) goto L_STOP;         if (FALSE) {         L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */           ci = mrb->c->ci;         }         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, irep->nregs);         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);       }       else {         mrb_int acc;         mrb_value v;          ci = mrb->c->ci;         v = regs[a];         mrb_gc_protect(mrb, v);         switch (c) {         case OP_R_RETURN:           /* Fall through to OP_R_NORMAL otherwise */           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {             const struct RProc *dst;             mrb_callinfo *cibase;             cibase = mrb->c->cibase;             dst = top_proc(mrb, proc);              if (MRB_PROC_ENV_P(dst)) {               struct REnv *e = MRB_PROC_ENV(dst);                if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }             }             /* check jump destination */             while (cibase <= ci && ci->proc != dst) {               if (ci->cci > CINFO_NONE) { /* jump cross C boundary */                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }               ci--;             }             if (ci <= cibase) { /* no jump destination */               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);               goto L_RAISE;             }             ci = mrb->c->ci;             while (cibase <= ci && ci->proc != dst) {               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {                 cibase = mrb->c->cibase;                 dst = top_proc(mrb, proc);               }               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);               }               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);               ci = cipop(mrb);               pc = ci->pc;             }             proc = ci->proc;             mrb->exc = NULL; /* clear break object */             break;           }           /* fallthrough */         case OP_R_NORMAL:         NORMAL_RETURN:           if (ci == mrb->c->cibase) {             struct mrb_context *c;             c = mrb->c;              if (!c->prev) { /* toplevel return */               regs[irep->nlocals] = v;               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);             }             if (!c->vmexec && c->prev->ci == c->prev->cibase) {               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, ""double resume"");               mrb_exc_set(mrb, exc);               goto L_RAISE;             }             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {               c = mrb->c;             }             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);             /* automatic yield at the end */             c->status = MRB_FIBER_TERMINATED;             mrb->c = c->prev;             mrb->c->status = MRB_FIBER_RUNNING;             c->prev = NULL;             if (c->vmexec) {               mrb_gc_arena_restore(mrb, ai);               c->vmexec = FALSE;               mrb->jmp = prev_jmp;               return v;             }             ci = mrb->c->ci;           }           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_RETURN);           mrb->exc = NULL; /* clear break object */           break;         case OP_R_BREAK:           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;           if (MRB_PROC_ORPHAN_P(proc)) {             mrb_value exc;            L_BREAK_ERROR:             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,                                       ""break from proc-closure"");             mrb_exc_set(mrb, exc);             goto L_RAISE;           }           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {             goto L_BREAK_ERROR;           }           else {             struct REnv *e = MRB_PROC_ENV(proc);              if (e->cxt != mrb->c) {               goto L_BREAK_ERROR;             }           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK);           /* break from fiber block */           if (ci == mrb->c->cibase && ci->pc) {             struct mrb_context *c = mrb->c;              mrb->c = c->prev;             c->prev = NULL;             ci = mrb->c->ci;           }           if (ci->cci > CINFO_NONE) {             ci = cipop(mrb);             mrb_gc_arena_restore(mrb, ai);             mrb->c->vmexec = FALSE;             mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           if (FALSE) {             struct RBreak *brk;            L_BREAK:             brk = (struct RBreak*)mrb->exc;             proc = mrb_break_proc_get(brk);             v = mrb_break_value_get(brk);             ci = mrb->c->ci;              switch (mrb_break_tag_get(brk)) { #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS) #undef DISPATCH_CHECKPOINTS               default:                 mrb_assert(!""wrong break tag"");             }           }           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {             if (ci[-1].cci == CINFO_SKIP) {               goto L_BREAK_ERROR;             }             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {               /* do nothing */             }             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);             ci = cipop(mrb);             pc = ci->pc;           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);           if (ci == mrb->c->cibase) {             goto L_BREAK_ERROR;           }           mrb->exc = NULL; /* clear break object */           break;         default:           /* cannot happen */           break;         }         mrb_assert(ci == mrb->c->ci);         mrb_assert(mrb->exc == NULL);          if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {           mrb_gc_arena_restore(mrb, ai);           mrb->c->vmexec = FALSE;           mrb->jmp = prev_jmp;           return v;         }         acc = ci->cci;         ci = cipop(mrb);         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {           mrb_gc_arena_restore(mrb, ai);           mrb->jmp = prev_jmp;           return v;         }         pc = ci->pc;         DEBUG(fprintf(stderr, ""from :%s\n"", mrb_sym_name(mrb, ci->mid)));         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;          ci[1].stack[0] = v;         mrb_gc_arena_restore(mrb, ai);       }       JUMP;     }      CASE(OP_BLKPUSH, BS) {       int m1 = (b>>11)&0x3f;       int r  = (b>>10)&0x1;       int m2 = (b>>5)&0x1f;       int kd = (b>>4)&0x1;       int lv = (b>>0)&0xf;       mrb_value *stack;        if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||             MRB_ENV_LEN(e) <= m1+r+m2+1) {           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);           goto L_RAISE;         }         stack = e->stack + 1;       }       if (mrb_nil_p(stack[m1+r+m2+kd])) {         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);         goto L_RAISE;       }       regs[a] = stack[m1+r+m2+kd];       NEXT;     }    L_INT_OVERFLOW:     {       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, ""integer overflow"");       mrb_exc_set(mrb, exc);     }     goto L_RAISE;  #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff)) #define OP_MATH(op_name)                                                    \   /* need to check if op is overridden */                                   \   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \     OP_MATH_CASE_INTEGER(op_name);                                          \     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \     OP_MATH_CASE_STRING_##op_name();                                        \     default:                                                                \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATH_CASE_INTEGER(op_name)                                       \   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0 #else #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \     {                                                                           \       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \     }                                                                           \     break #endif #define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW #define OP_MATH_CASE_STRING_add()                                           \   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \     mrb_gc_arena_restore(mrb, ai);                                          \     break #define OP_MATH_CASE_STRING_sub() (void)0 #define OP_MATH_CASE_STRING_mul() (void)0 #define OP_MATH_OP_add + #define OP_MATH_OP_sub - #define OP_MATH_OP_mul * #define OP_MATH_TT_integer MRB_TT_INTEGER #define OP_MATH_TT_float   MRB_TT_FLOAT      CASE(OP_ADD, B) {       OP_MATH(add);     }      CASE(OP_SUB, B) {       OP_MATH(sub);     }      CASE(OP_MUL, B) {       OP_MATH(mul);     }      CASE(OP_DIV, B) { #ifndef MRB_NO_FLOAT       mrb_float x, y, f; #endif        /* need to check if op is overridden */       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):         {           mrb_int x = mrb_integer(regs[a]);           mrb_int y = mrb_integer(regs[a+1]);           mrb_int div = mrb_div_int(mrb, x, y);           SET_INT_VALUE(mrb, regs[a], div);         }         NEXT; #ifndef MRB_NO_FLOAT       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):         x = (mrb_float)mrb_integer(regs[a]);         y = mrb_float(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):         x = mrb_float(regs[a]);         y = (mrb_float)mrb_integer(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):         x = mrb_float(regs[a]);         y = mrb_float(regs[a+1]);         break; #endif       default:         mid = MRB_OPSYM(div);         goto L_SEND_SYM;       }  #ifndef MRB_NO_FLOAT       f = mrb_div_float(x, y);       SET_FLOAT_VALUE(mrb, regs[a], f); #endif       NEXT;     }  #define OP_MATHI(op_name)                                                   \   /* need to check if op is overridden */                                   \   switch (mrb_type(regs[a])) {                                              \     OP_MATHI_CASE_INTEGER(op_name);                                         \     OP_MATHI_CASE_FLOAT(op_name);                                           \     default:                                                                \       SET_INT_VALUE(mrb,regs[a+1], b);                                      \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATHI_CASE_INTEGER(op_name)                                      \   case MRB_TT_INTEGER:                                                      \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATHI_CASE_FLOAT(op_name) (void)0 #else #define OP_MATHI_CASE_FLOAT(op_name)                                        \   case MRB_TT_FLOAT:                                                        \     {                                                                       \       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \     }                                                                       \     break #endif      CASE(OP_ADDI, BB) {       OP_MATHI(add);     }      CASE(OP_SUBI, BB) {       OP_MATHI(sub);     }  #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))  #ifdef MRB_NO_FLOAT #define OP_CMP(op,sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #else #define OP_CMP(op, sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_float,mrb_float);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #endif      CASE(OP_EQ, B) {       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {         SET_TRUE_VALUE(regs[a]);       }       else {         OP_CMP(==,eq);       }       NEXT;     }      CASE(OP_LT, B) {       OP_CMP(<,lt);       NEXT;     }      CASE(OP_LE, B) {       OP_CMP(<=,le);       NEXT;     }      CASE(OP_GT, B) {       OP_CMP(>,gt);       NEXT;     }      CASE(OP_GE, B) {       OP_CMP(>=,ge);       NEXT;     }      CASE(OP_ARRAY, BB) {       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_ARRAY2, BBB) {       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYCAT, B) {       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);       if (mrb_nil_p(regs[a])) {         regs[a] = splat;       }       else {         mrb_assert(mrb_array_p(regs[a]));         mrb_ary_concat(mrb, regs[a], splat);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYPUSH, BB) {       mrb_assert(mrb_array_p(regs[a]));       for (mrb_int i=0; i<b; i++) {         mrb_ary_push(mrb, regs[a], regs[a+i+1]);       }       NEXT;     }      CASE(OP_ARYDUP, B) {       mrb_value ary = regs[a];       if (mrb_array_p(ary)) {         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));       }       else {         ary = mrb_ary_new_from_values(mrb, 1, &ary);       }       regs[a] = ary;       NEXT;     }      CASE(OP_AREF, BBB) {       mrb_value v = regs[b];        if (!mrb_array_p(v)) {         if (c == 0) {           regs[a] = v;         }         else {           SET_NIL_VALUE(regs[a]);         }       }       else {         v = mrb_ary_ref(mrb, v, c);         regs[a] = v;       }       NEXT;     }      CASE(OP_ASET, BBB) {       mrb_assert(mrb_array_p(regs[a]));       mrb_ary_set(mrb, regs[b], c, regs[a]);       NEXT;     }      CASE(OP_APOST, BBB) {       mrb_value v = regs[a];       int pre  = b;       int post = c;       struct RArray *ary;       int len, idx;        if (!mrb_array_p(v)) {         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);       }       ary = mrb_ary_ptr(v);       len = (int)ARY_LEN(ary);       if (len > pre + post) {         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);         regs[a++] = v;         while (post--) {           regs[a++] = ARY_PTR(ary)[len-post-1];         }       }       else {         v = mrb_ary_new_capa(mrb, 0);         regs[a++] = v;         for (idx=0; idx+pre<len; idx++) {           regs[a+idx] = ARY_PTR(ary)[pre+idx];         }         while (idx < post) {           SET_NIL_VALUE(regs[a+idx]);           idx++;         }       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_INTERN, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_sym sym = mrb_intern_str(mrb, regs[a]);       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_SYMBOL, BB) {       size_t len;       mrb_sym sym;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         sym = mrb_intern_static(mrb, pool[b].u.str, len);       }       else {         sym  = mrb_intern(mrb, pool[b].u.str, len);       }       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_STRING, BB) {       mrb_int len;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);       }       else {         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_STRCAT, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_str_concat(mrb, regs[a], regs[a+1]);       NEXT;     }      CASE(OP_HASH, BB) {       mrb_value hash = mrb_hash_new_capa(mrb, b);       int i;       int lim = a+b*2;        for (i=a; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       regs[a] = hash;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_HASHADD, BB) {       mrb_value hash;       int i;       int lim = a+b*2+1;        hash = regs[a];       mrb_ensure_hash_type(mrb, hash);       for (i=a+1; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_HASHCAT, B) {       mrb_value hash = regs[a];        mrb_assert(mrb_hash_p(hash));       mrb_hash_merge(mrb, hash, regs[a+1]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_LAMBDA, BB)     c = OP_L_LAMBDA;     L_MAKE_LAMBDA:     {       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        if (c & OP_L_CAPTURE) {         p = mrb_closure_new(mrb, nirep);       }       else {         p = mrb_proc_new(mrb, nirep);         p->flags |= MRB_PROC_SCOPE;       }       if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;       regs[a] = mrb_obj_value(p);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_BLOCK, BB) {       c = OP_L_BLOCK;       goto L_MAKE_LAMBDA;     }     CASE(OP_METHOD, BB) {       c = OP_L_METHOD;       goto L_MAKE_LAMBDA;     }      CASE(OP_RANGE_INC, B) {       regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_RANGE_EXC, B) {       regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_OCLASS, B) {       regs[a] = mrb_obj_value(mrb->object_class);       NEXT;     }      CASE(OP_CLASS, BB) {       struct RClass *c = 0, *baseclass;       mrb_value base, super;       mrb_sym id = syms[b];        base = regs[a];       super = regs[a+1];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       c = mrb_vm_define_class(mrb, base, super, id);       regs[a] = mrb_obj_value(c);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_MODULE, BB) {       struct RClass *cls = 0, *baseclass;       mrb_value base;       mrb_sym id = syms[b];        base = regs[a];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       cls = mrb_vm_define_module(mrb, base, id);       regs[a] = mrb_obj_value(cls);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_EXEC, BB)     {       mrb_value recv = regs[a];       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        /* prepare closure */       p = mrb_proc_new(mrb, nirep);       p->c = NULL;       mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);       MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));       p->flags |= MRB_PROC_SCOPE;        /* prepare call stack */       cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);        irep = p->body.irep;       pool = irep->pool;       syms = irep->syms;       mrb_stack_extend(mrb, irep->nregs);       stack_clear(regs+1, irep->nregs-1);       pc = irep->iseq;       JUMP;     }      CASE(OP_DEF, BB) {       struct RClass *target = mrb_class_ptr(regs[a]);       struct RProc *p = mrb_proc_ptr(regs[a+1]);       mrb_method_t m;       mrb_sym mid = syms[b];        MRB_METHOD_FROM_PROC(m, p);       mrb_define_method_raw(mrb, target, mid, m);       mrb_method_added(mrb, target, mid);       mrb_gc_arena_restore(mrb, ai);       regs[a] = mrb_symbol_value(mid);       NEXT;     }      CASE(OP_SCLASS, B) {       regs[a] = mrb_singleton_class(mrb, regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_TCLASS, B) {       struct RClass *target = check_target_class(mrb);       if (!target) goto L_RAISE;       regs[a] = mrb_obj_value(target);       NEXT;     }      CASE(OP_ALIAS, BB) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_alias_method(mrb, target, syms[a], syms[b]);       mrb_method_added(mrb, target, syms[a]);       NEXT;     }     CASE(OP_UNDEF, B) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_undef_method_id(mrb, target, syms[a]);       NEXT;     }      CASE(OP_DEBUG, Z) {       FETCH_BBB(); #ifdef MRB_USE_DEBUG_HOOK       mrb->debug_op_hook(mrb, irep, pc, regs); #else #ifndef MRB_NO_STDIO       printf(""OP_DEBUG %d %d %d\n"", a, b, c); #else       abort(); #endif #endif       NEXT;     }      CASE(OP_ERR, B) {       size_t len = pool[a].tt >> 2;       mrb_value exc;        mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);       exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);       mrb_exc_set(mrb, exc);       goto L_RAISE;     }      CASE(OP_EXT1, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT2, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT3, Z) {       uint8_t insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }      CASE(OP_STOP, Z) {       /*        stop VM */       CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {         /* do nothing */       }       CHECKPOINT_MAIN(RBREAK_TAG_STOP) {         UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());       }       CHECKPOINT_END(RBREAK_TAG_STOP);     L_STOP:       mrb->jmp = prev_jmp;       if (mrb->exc) {         mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);         return mrb_obj_value(mrb->exc);       }       return regs[irep->nlocals];     }   }   END_DISPATCH; #undef regs   }   MRB_CATCH(&c_jmp) {     mrb_callinfo *ci = mrb->c->ci;     while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {       ci = cipop(mrb);     }     exc_catched = TRUE;     pc = ci->pc;     goto RETRY_TRY_BLOCK;   }   MRB_END_EXC(&c_jmp); }"
"196817_CWE-703.c","CWE-703","njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array) {     uint32_t           i, length;     njs_value_t        index, value;     njs_object_prop_t  *prop;      njs_set_array(&value, array);     array->object.fast_array = 0;      length = array->length;      for (i = 0; i < length; i++) {         if (njs_is_valid(&array->start[i])) {             njs_uint32_to_string(&index, i);             prop = njs_object_property_add(vm, &value, &index, 0);             if (njs_slow_path(prop == NULL)) {                 return NJS_ERROR;             }              prop->value = array->start[i];         }     }      /* GC: release value. */      njs_mp_free(vm->mem_pool, array->start);     array->start = NULL;      return NJS_OK; }"
"196829_CWE-476.cc","CWE-476","  void Compute(OpKernelContext* ctx) override {     const Tensor& val = ctx->input(0);     int64 id = ctx->session_state()->GetNewId();     TensorStore::TensorAndKey tk{val, id, requested_device()};     OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));      Tensor* handle = nullptr;     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));     if (ctx->expected_output_dtype(0) == DT_RESOURCE) {       ResourceHandle resource_handle = MakeResourceHandle<Tensor>(           ctx, SessionState::kTensorHandleResourceTypeName,           tk.GetHandle(name()));       resource_handle.set_maybe_type_name(           SessionState::kTensorHandleResourceTypeName);       handle->scalar<ResourceHandle>()() = resource_handle;     } else {       // Legacy behavior in V1.       handle->flat<tstring>().setConstant(tk.GetHandle(name()));     }   }"
"196834_CWE-125.cc","CWE-125","Status SparseCountSparseOutputShapeFn(InferenceContext *c) {   auto rank = c->Dim(c->input(0), 1);   auto nvals = c->UnknownDim();   c->set_output(0, c->Matrix(nvals, rank));  // out.indices   c->set_output(1, c->Vector(nvals));        // out.values   c->set_output(2, c->Vector(rank));         // out.dense_shape   return Status::OK(); }"
"196841_CWE-703.cpp","CWE-703","inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {   static char id[32];   bool selectedRow=(i>=sel1.y && i<=sel2.y);   ImGui::TableNextRow(0,lineHeight);   ImGui::TableNextColumn();   float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();   // check if the row is visible   if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {     return;   }   // check if we are in range   if (ord<0 || ord>=e->song.ordersLen) {     return;   }   if (i<0 || i>=e->song.patLen) {     return;   }   bool isPushing=false;   ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];   ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];   ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];   if (e->song.hilightB>0 && !(i%e->song.hilightB)) {     activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];     inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];     rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];   } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {     activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];     inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];     rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];   }   // check overflow highlight   if (settings.overflowHighlight) {     if (edit && cursor.y==i) {       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));     } else if (isPlaying && oldRow==i) {       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));     } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));     } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {       ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));     }   } else {     isPushing=true;     if (edit && cursor.y==i) {       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));     } else if (isPlaying && oldRow==i) {       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));     } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));     } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {       ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));     } else {       isPushing=false;     }   }   // row number   if (settings.patRowsBase==1) {     ImGui::TextColored(rowIndexColor,"" %.2X "",i);   } else {     ImGui::TextColored(rowIndexColor,""%3d "",i);   }   // for each column   for (int j=0; j<chans; j++) {     // check if channel is not hidden     if (!e->song.chanShow[j]) {       patChanX[j]=ImGui::GetCursorPosX();       continue;     }     int chanVolMax=e->getMaxVolumeChan(j);     if (chanVolMax<1) chanVolMax=1;     const DivPattern* pat=patCache[j];     ImGui::TableNextColumn();     patChanX[j]=ImGui::GetCursorPosX();      // selection highlight flags     int sel1XSum=sel1.xCoarse*32+sel1.xFine;     int sel2XSum=sel2.xCoarse*32+sel2.xFine;     int j32=j*32;     bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);     bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);     bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);     bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);     bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);     bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);      // note     sprintf(id,""%s##PN_%d_%d"",noteName(pat->data[i][0],pat->data[i][1]),i,j);     if (pat->data[i][0]==0 && pat->data[i][1]==0) {       ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);     } else {       ImGui::PushStyleColor(ImGuiCol_Text,activeColor);     }     if (cursorNote) {       ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);       ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);       ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);       ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);       demandX=ImGui::GetCursorPosX();       ImGui::PopStyleColor(3);     } else {       if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);       ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);       if (selectedNote) ImGui::PopStyleColor();     }     if (ImGui::IsItemClicked()) {       startSelection(j,0,i);     }     if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {       updateSelection(j,0,i);     }     ImGui::PopStyleColor();      // the following is only visible when the channel is not collapsed     if (!e->song.chanCollapse[j]) {       // instrument       if (pat->data[i][2]==-1) {         ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);         sprintf(id,""..##PI_%d_%d"",i,j);       } else {         if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {           ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);         } else {           DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;           if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);           } else {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);           }         }         sprintf(id,""%.2X##PI_%d_%d"",pat->data[i][2],i,j);       }       ImGui::SameLine(0.0f,0.0f);       if (cursorIns) {         ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);         ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);         ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);         ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);         demandX=ImGui::GetCursorPosX();         ImGui::PopStyleColor(3);       } else {         if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);         ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);         if (selectedIns) ImGui::PopStyleColor();       }       if (ImGui::IsItemClicked()) {         startSelection(j,1,i);       }       if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {         updateSelection(j,1,i);       }       ImGui::PopStyleColor();        // volume       if (pat->data[i][3]==-1) {         sprintf(id,""..##PV_%d_%d"",i,j);         ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);       } else {         int volColor=(pat->data[i][3]*127)/chanVolMax;         if (volColor>127) volColor=127;         if (volColor<0) volColor=0;         sprintf(id,""%.2X##PV_%d_%d"",pat->data[i][3],i,j);         ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);       }       ImGui::SameLine(0.0f,0.0f);       if (cursorVol) {         ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);         ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);         ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);         ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);         demandX=ImGui::GetCursorPosX();         ImGui::PopStyleColor(3);       } else {         if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);         ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);         if (selectedVol) ImGui::PopStyleColor();       }       if (ImGui::IsItemClicked()) {         startSelection(j,2,i);       }       if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {         updateSelection(j,2,i);       }       ImGui::PopStyleColor();        // effects       for (int k=0; k<e->song.pat[j].effectRows; k++) {         int index=4+(k<<1);         bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);         bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);         bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);         bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);                  // effect         if (pat->data[i][index]==-1) {           sprintf(id,""..##PE%d_%d_%d"",k,i,j);           ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);         } else {           sprintf(id,""%.2X##PE%d_%d_%d"",pat->data[i][index],k,i,j);           if (pat->data[i][index]<0x10) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);           } else if (pat->data[i][index]<0x20) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);           } else if (pat->data[i][index]<0x30) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);           } else if (pat->data[i][index]<0x48) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);           } else if (pat->data[i][index]<0x90) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);           } else if (pat->data[i][index]<0xa0) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);           } else if (pat->data[i][index]<0xc0) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);           } else if (pat->data[i][index]<0xd0) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);           } else if (pat->data[i][index]<0xe0) {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);           } else {             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);           }         }         ImGui::SameLine(0.0f,0.0f);         if (cursorEffect) {           ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);             ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);           ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);           ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);           demandX=ImGui::GetCursorPosX();           ImGui::PopStyleColor(3);         } else {           if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);           ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);           if (selectedEffect) ImGui::PopStyleColor();         }         if (ImGui::IsItemClicked()) {           startSelection(j,index-1,i);         }         if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {           updateSelection(j,index-1,i);         }          // effect value         if (pat->data[i][index+1]==-1) {           sprintf(id,""..##PF%d_%d_%d"",k,i,j);         } else {           sprintf(id,""%.2X##PF%d_%d_%d"",pat->data[i][index+1],k,i,j);         }         ImGui::SameLine(0.0f,0.0f);         if (cursorEffectVal) {           ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);             ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);           ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);           ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);           demandX=ImGui::GetCursorPosX();           ImGui::PopStyleColor(3);         } else {           if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);           ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);           if (selectedEffectVal) ImGui::PopStyleColor();         }         if (ImGui::IsItemClicked()) {           startSelection(j,index,i);         }         if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {           updateSelection(j,index,i);         }         ImGui::PopStyleColor();       }     }   }   if (isPushing) {     ImGui::PopStyleColor();   }   ImGui::TableNextColumn();   patChanX[chans]=ImGui::GetCursorPosX(); }"
"196846_CWE-369.cc","CWE-369","TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {   auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);   OpData* data = reinterpret_cast<OpData*>(node->user_data);    const TfLiteTensor* input1;   TF_LITE_ENSURE_OK(context,                     GetInputSafe(context, node, kInputTensor1, &input1));   const TfLiteTensor* input2;   TF_LITE_ENSURE_OK(context,                     GetInputSafe(context, node, kInputTensor2, &input2));   TfLiteTensor* output;   TF_LITE_ENSURE_OK(context,                     GetOutputSafe(context, node, kOutputTensor, &output));    if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {     EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);   } else if (output->type == kTfLiteUInt8) {     TF_LITE_ENSURE_OK(         context, EvalQuantized<kernel_type>(context, node, params, data, input1,                                             input2, output));   } else {     context->ReportError(         context,         ""Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d."",         output->type);     return kTfLiteError;   }    return kTfLiteOk; }"
"196860_CWE-787.cpp","CWE-787","GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs) { 	unsigned int i; 	GF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;  	ISOM_DECREASE_SIZE(ptr, 9) 	ptr->long_ids = gf_bs_read_int(bs, 1); 	ptr->long_offsets = gf_bs_read_int(bs, 1); 	ptr->global_entries = gf_bs_read_int(bs, 1); 	ptr->reserved = gf_bs_read_int(bs, 5); 	ptr->time_scale = gf_bs_read_u32(bs);  	ptr->entry_count = gf_bs_read_u32(bs); 	if (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count) 		return GF_ISOM_INVALID_FILE;  	for (i=0; i<ptr->entry_count; i++) { 		GF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry)); 		if (!ae) return GF_OUT_OF_MEM;  		ISOM_DECREASE_SIZE(ptr, 8) 		ae->time = gf_bs_read_u64(bs); 		if (ptr->long_offsets) { 			ISOM_DECREASE_SIZE(ptr, 8) 			ae->offset = gf_bs_read_u64(bs); 		} else { 			ISOM_DECREASE_SIZE(ptr, 4) 			ae->offset = gf_bs_read_u32(bs); 		}  		gf_list_insert(ptr->local_access_entries, ae, i); 	}  	if (ptr->global_entries) { 		ISOM_DECREASE_SIZE(ptr, 4) 		ptr->global_entry_count = gf_bs_read_u32(bs); 		for (i=0; i<ptr->global_entry_count; i++) { 			GF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry)); 			if (!ae) return GF_OUT_OF_MEM; 			ISOM_DECREASE_SIZE(ptr, 8) 			ae->time = gf_bs_read_u64(bs); 			if (ptr->long_ids) { 				ISOM_DECREASE_SIZE(ptr, 8) 				ae->segment = gf_bs_read_u32(bs); 				ae->fragment = gf_bs_read_u32(bs); 			} else { 				ISOM_DECREASE_SIZE(ptr, 4) 				ae->segment = gf_bs_read_u16(bs); 				ae->fragment = gf_bs_read_u16(bs); 			} 			if (ptr->long_offsets) { 				ISOM_DECREASE_SIZE(ptr, 16) 				ae->afra_offset = gf_bs_read_u64(bs); 				ae->offset_from_afra = gf_bs_read_u64(bs); 			} else { 				ISOM_DECREASE_SIZE(ptr, 8) 				ae->afra_offset = gf_bs_read_u32(bs); 				ae->offset_from_afra = gf_bs_read_u32(bs); 			}  			gf_list_insert(ptr->global_access_entries, ae, i); 		} 	}  	return GF_OK; }"
"196885_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     const Tensor& input = ctx->input(kInputTensorIndex);     const Tensor& input_min = ctx->input(kInputMinIndex);     const Tensor& input_max = ctx->input(kInputMaxIndex);      const size_t depth = input_max.NumElements();     OP_REQUIRES(         ctx, input_min.dim_size(0) == depth,         errors::InvalidArgument(""input_min has incorrect size, expected "",                                 depth, "" was "", input_min.dim_size(0)));     OP_REQUIRES(         ctx, input_max.dim_size(0) == depth,         errors::InvalidArgument(""input_max has incorrect size, expected "",                                 depth, "" was "", input_max.dim_size(0)));      const float* input_min_data = input_min.flat<float>().data();     const float* input_max_data = input_max.flat<float>().data();     std::vector<float> ranges(depth);     bool is_non_negative = true;     Eigen::array<int, 2> shuffling({1, 0});     auto input_matrix = input.flat_inner_dims<qint32>();      // TODO: verify performance of not transposing and finding the min max     // directly from input_matrix vs the one presented below of transposing and     // using the transposed matrix as the transposing operation in itself might     // be more costly.     // Note that this operation is a calibration step for quantization and will     // cease to exist in the final inference graph(will exist as a const node).     auto transposed_input = input_matrix.shuffle(shuffling);      // Find the ranges of each channel in parallel.     float out_min_max = std::numeric_limits<float>::min();  #ifdef ENABLE_ONEDNN_OPENMP #ifdef _MSC_VER #pragma omp parallel for #else #pragma omp parallel for reduction(max : out_min_max) #endif #endif  // ENABLE_ONEDNN_OPENMP     // TODO: Add eigen parallel_for     for (int64_t i = 0; i < depth; ++i) {       Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =           transposed_input.chip<0>(i).minimum();       Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =           transposed_input.chip<0>(i).maximum();       const int32_t min_per_channel = min();       const int32_t max_per_channel = max();       const int32_t abs_max =           std::max(std::abs(min_per_channel), std::abs(max_per_channel));       float scale =           std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));       ranges[i] =           scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);       if (min_per_channel < 0) is_non_negative = false;        // Thread-local out_min_max.       out_min_max = std::max(out_min_max, ranges[i]);     }      // All local out_min_max gets max-reduced into one global out_min_max at     // the end of the loop by specifying reduction(max:out_min_max) along with     // omp parallel for.      // Fixing max to clip_value_max_ (example 6.0 to support relu6)     if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;      Tensor* output_min = nullptr;     Tensor* output_max = nullptr;     OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));     OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));     output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;     output_max->flat<float>()(0) = out_min_max;   }"
"196889_CWE-284.c","CWE-284","int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype, 		 pgpDigParams * ret) {     const uint8_t *p = pkts;     const uint8_t *pend = pkts + pktlen;     pgpDigParams digp = NULL;     struct pgpPkt pkt;     int rc = -1; /* assume failure */      while (p < pend) { 	if (decodePkt(p, (pend - p), &pkt)) 	    break;  	if (digp == NULL) { 	    if (pkttype && pkt.tag != pkttype) { 		break; 	    } else { 		digp = pgpDigParamsNew(pkt.tag); 	    } 	}  	if (pgpPrtPkt(&pkt, digp)) 	    break;  	p += (pkt.body - pkt.head) + pkt.blen; 	if (pkttype == PGPTAG_SIGNATURE) 	    break;     }      rc = (digp && (p == pend)) ? 0 : -1;      if (ret && rc == 0) { 	*ret = digp;     } else { 	pgpDigParamsFree(digp);     }     return rc; }"
"196893_CWE-362.cc","CWE-362","void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,                                                     uint8_t hash_buffer[EVP_MAX_MD_SIZE],                                                     unsigned hash_length) {   int rc;    // Hash all the settings that affect whether the server will allow/accept   // the client connection. This ensures that the client is always validated against   // the correct settings, even if session resumption across different listeners   // is enabled.   if (ca_cert_ != nullptr) {     rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));     RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,                    fmt::format(""invalid SHA256 hash length {}"", hash_length));      rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));   }    for (const auto& hash : verify_certificate_hash_list_) {     rc = EVP_DigestUpdate(md.get(), hash.data(),                           hash.size() *                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));   }    for (const auto& hash : verify_certificate_spki_list_) {     rc = EVP_DigestUpdate(md.get(), hash.data(),                           hash.size() *                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));   } }"
"196894_CWE-399.cpp","CWE-399","Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const { 	DoQuickSanityCheck(); 	ModularArithmetic modn(m_n); 	Integer r, rInv; 	do {	// do this in a loop for people using small numbers for testing 		r.Randomize(rng, Integer::One(), m_n - Integer::One()); 		rInv = modn.MultiplicativeInverse(r); 	} while (rInv.IsZero()); 	Integer re = modn.Square(r); 	re = modn.Multiply(re, x);			// blind  	Integer cp=re%m_p, cq=re%m_q; 	if (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1) 	{ 		cp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1; 		cq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1; 	}  	#pragma omp parallel 		#pragma omp sections 		{ 			#pragma omp section 				cp = ModularSquareRoot(cp, m_p); 			#pragma omp section 				cq = ModularSquareRoot(cq, m_q); 		}  	Integer y = CRT(cq, m_q, cp, m_p, m_u); 	y = modn.Multiply(y, rInv);				// unblind 	y = STDMIN(y, m_n-y); 	if (ApplyFunction(y) != x)				// check 		throw Exception(Exception::OTHER_ERROR, ""InvertibleRWFunction: computational error during private key operation""); 	return y; }"
"196993_CWE-369.cc","CWE-369","Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,                        CodecInOut* io) {   Reader r;   unsigned int id, i, j, w, h, w0, h0, x0, y0;   unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;   unsigned char sig[8];   png_structp png_ptr;   png_infop info_ptr;   CHUNK chunk;   CHUNK chunkIHDR;   std::vector<CHUNK> chunksInfo;   bool isAnimated = false;   bool skipFirst = false;   bool hasInfo = false;   bool all_dispose_bg = true;   APNGFrame frameRaw = {};    r = {bytes.data(), bytes.data() + bytes.size()};   // Not an aPNG => not an error   unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};   if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {     return false;   }   id = read_chunk(&r, &chunkIHDR);    io->frames.clear();   io->dec_pixels = 0;   io->metadata.m.SetUintSamples(8);   io->metadata.m.SetAlphaBits(8);   io->metadata.m.color_encoding =       ColorEncoding::SRGB();  // todo: get data from png metadata   (void)io->dec_hints.Foreach(       [](const std::string& key, const std::string& /*value*/) {         JXL_WARNING(""APNG decoder ignoring %s hint"", key.c_str());         return true;       });    bool errorstate = true;   if (id == kId_IHDR && chunkIHDR.size == 25) {     w0 = w = png_get_uint_32(chunkIHDR.p + 8);     h0 = h = png_get_uint_32(chunkIHDR.p + 12);      if (w > cMaxPNGSize || h > cMaxPNGSize) {       return false;     }      x0 = 0;     y0 = 0;     delay_num = 1;     delay_den = 10;     dop = 0;     bop = 0;     rowbytes = w * 4;     imagesize = h * rowbytes;      frameRaw.p = new unsigned char[imagesize];     frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];     for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;      if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,                           chunkIHDR, chunksInfo)) {       bool last_base_was_none = true;       while (!r.Eof()) {         id = read_chunk(&r, &chunk);         if (!id) break;         JXL_ASSERT(chunk.p != nullptr);          if (id == kId_acTL && !hasInfo && !isAnimated) {           isAnimated = true;           skipFirst = true;           io->metadata.m.have_animation = true;           io->metadata.m.animation.tps_numerator = 1000;         } else if (id == kId_IEND ||                    (id == kId_fcTL && (!hasInfo || isAnimated))) {           if (hasInfo) {             if (!processing_finish(png_ptr, info_ptr)) {               ImageBundle bundle(&io->metadata.m);               bundle.duration = delay_num * 1000 / delay_den;               bundle.origin.x0 = x0;               bundle.origin.y0 = y0;               // TODO(veluca): this could in principle be implemented.               if (last_base_was_none && !all_dispose_bg &&                   (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {                 return JXL_FAILURE(                     ""APNG with dispose-to-0 is not supported for non-full or ""                     ""blended frames"");               }               switch (dop) {                 case 0:                   bundle.use_for_next_frame = true;                   last_base_was_none = false;                   all_dispose_bg = false;                   break;                 case 2:                   bundle.use_for_next_frame = false;                   all_dispose_bg = false;                   break;                 default:                   bundle.use_for_next_frame = false;                   last_base_was_none = true;               }               bundle.blend = bop != 0;               io->dec_pixels += w0 * h0;                Image3F sub_frame(w0, h0);               ImageF sub_frame_alpha(w0, h0);               for (size_t y = 0; y < h0; ++y) {                 float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);                 float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);                 float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);                 float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);                 uint8_t* const f = frameRaw.rows[y];                 for (size_t x = 0; x < w0; ++x) {                   if (f[4 * x + 3] == 0) {                     row_alpha[x] = 0;                     row_r[x] = 0;                     row_g[x] = 0;                     row_b[x] = 0;                     continue;                   }                   row_r[x] = f[4 * x + 0] * (1.f / 255);                   row_g[x] = f[4 * x + 1] * (1.f / 255);                   row_b[x] = f[4 * x + 2] * (1.f / 255);                   row_alpha[x] = f[4 * x + 3] * (1.f / 255);                 }               }               bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());               bundle.SetAlpha(std::move(sub_frame_alpha),                               /*alpha_is_premultiplied=*/false);               io->frames.push_back(std::move(bundle));             } else {               delete[] chunk.p;               break;             }           }            if (id == kId_IEND) {             errorstate = false;             break;           }           // At this point the old frame is done. Let's start a new one.           w0 = png_get_uint_32(chunk.p + 12);           h0 = png_get_uint_32(chunk.p + 16);           x0 = png_get_uint_32(chunk.p + 20);           y0 = png_get_uint_32(chunk.p + 24);           delay_num = png_get_uint_16(chunk.p + 28);           delay_den = png_get_uint_16(chunk.p + 30);           dop = chunk.p[32];           bop = chunk.p[33];            if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||               y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||               bop > 1) {             delete[] chunk.p;             break;           }            if (hasInfo) {             memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);             if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,                                  chunkIHDR, chunksInfo)) {               delete[] chunk.p;               break;             }           } else             skipFirst = false;            if (io->frames.size() == (skipFirst ? 1 : 0)) {             bop = 0;             if (dop == 2) dop = 1;           }         } else if (id == kId_IDAT) {           hasInfo = true;           if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {             delete[] chunk.p;             break;           }         } else if (id == kId_fdAT && isAnimated) {           png_save_uint_32(chunk.p + 4, chunk.size - 16);           memcpy(chunk.p + 8, ""IDAT"", 4);           if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {             delete[] chunk.p;             break;           }         } else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||                    !isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {           delete[] chunk.p;           break;         } else if (!hasInfo) {           if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {             delete[] chunk.p;             break;           }           chunksInfo.push_back(chunk);           continue;         }         delete[] chunk.p;       }     }     delete[] frameRaw.rows;     delete[] frameRaw.p;   }    for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;    chunksInfo.clear();   delete[] chunkIHDR.p;    if (errorstate) return false;   SetIntensityTarget(io);   return true; }"
"197015_CWE-476.c","CWE-476","GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving) { 	u32 i, trackCount; 	TrackWriter *writer; 	GF_TrackBox *trak; 	GF_ISOFile *movie = mw->movie;  	mw->total_samples = mw->nb_done = 0; 	if (!movie->moov) return GF_OK;  	trackCount = gf_list_count(movie->moov->trackList); 	for (i = 0; i < trackCount; i++) { 		trak = gf_isom_get_track(movie->moov, i+1);  		GF_SAFEALLOC(writer, TrackWriter); 		if (!writer) goto exit; 		writer->sampleNumber = 1; 		writer->mdia = trak->Media; 		writer->stbl = trak->Media->information->sampleTable; 		writer->timeScale = trak->Media->mediaHeader->timeScale; 		writer->all_dref_mode = Media_SelfContainedType(writer->mdia);  		if (trak->sample_encryption) 			writer->prevent_dispatch = GF_TRUE;  		writer->isDone = 0; 		writer->DTSprev = 0; 		writer->chunkDur = 0; 		writer->chunkSize = 0; 		writer->constant_size = writer->constant_dur = 0; 		if (writer->stbl->SampleSize->sampleSize) 			writer->constant_size = writer->stbl->SampleSize->sampleSize; 		if (writer->stbl->TimeToSample->nb_entries==1) { 			writer->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta; 			if (writer->constant_dur>1) writer->constant_dur = 0; 		} 		if (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10)) 			writer->constant_size = writer->constant_dur = 0;  		writer->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC); 		if (!writer->stsc) return GF_OUT_OF_MEM; 		if (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) { 			writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO); 		} else { 			writer->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64); 		} 		if (!writer->stco) return GF_OUT_OF_MEM; 		/*stops from chunk escape*/ 		if (interleaving) writer->stbl->MaxSamplePerChunk = 0; 		/*for progress, assume only one descIndex*/ 		if (Media_IsSelfContained(writer->mdia, 1)) 			mw->total_samples += writer->stbl->SampleSize->sampleCount; 		/*optimization for interleaving: put audio last (this can be overridden by priorities)*/ 		if (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) { 			gf_list_add(writers, writer); 		} else { 			if (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) { 				gf_list_add(writers, writer); 			} else { 				gf_list_insert(writers, writer, 0); 			} 		} 		if (movie->sample_groups_in_traf && trak->Media->information->sampleTable) { 			gf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription); 			trak->Media->information->sampleTable->sampleGroupsDescription = NULL; 		} 	} 	return GF_OK;  exit: 	CleanWriters(writers); 	return GF_OUT_OF_MEM; }"
"197024_CWE-787.h","CWE-787","  void Compute(OpKernelContext* ctx) override {     const Tensor& in0 = ctx->input(0);     const Tensor& in1 = ctx->input(1);     auto in0_flat = in0.flat<Tin>();     auto in1_flat = in1.flat<Tin>();     const Device& eigen_device = ctx->eigen_device<Device>();      Tensor* out = nullptr;     if (std::is_same<Tin, Tout>::value) {       OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(                               {0, 1}, 0, in0.shape(), &out));     } else {       OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));     }     auto out_flat = out->flat<Tout>();     functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,                                                     in0_flat, in1_flat);   }"
"197057_CWE-552.cpp","CWE-552","int HttpFileImpl::save(const std::string &path) const {     assert(!path.empty());     if (fileName_.empty())         return -1;     filesystem::path fsPath(utils::toNativePath(path));     if (!fsPath.is_absolute() &&         (!fsPath.has_parent_path() ||          (fsPath.begin()->string() != ""."" && fsPath.begin()->string() != "".."")))     {         filesystem::path fsUploadPath(utils::toNativePath(             HttpAppFrameworkImpl::instance().getUploadPath()));         fsPath = fsUploadPath / fsPath;     }     filesystem::path fsFileName(utils::toNativePath(fileName_));     if (!filesystem::exists(fsPath))     {         LOG_TRACE << ""create path:"" << fsPath;         drogon::error_code err;         filesystem::create_directories(fsPath, err);         if (err)         {             LOG_SYSERR;             return -1;         }     }     return saveTo(fsPath / fsFileName); }"
"197095_CWE-369.h","CWE-369","inline void BinaryBroadcastFiveFold(const ArithmeticParams& unswitched_params,                                     const RuntimeShape& unswitched_input1_shape,                                     const T* unswitched_input1_data,                                     const RuntimeShape& unswitched_input2_shape,                                     const T* unswitched_input2_data,                                     const RuntimeShape& output_shape,                                     T* output_data, ElementwiseF elementwise_f,                                     ScalarBroadcastF scalar_broadcast_f) {   ArithmeticParams switched_params = unswitched_params;   switched_params.input1_offset = unswitched_params.input2_offset;   switched_params.input1_multiplier = unswitched_params.input2_multiplier;   switched_params.input1_shift = unswitched_params.input2_shift;   switched_params.input2_offset = unswitched_params.input1_offset;   switched_params.input2_multiplier = unswitched_params.input1_multiplier;   switched_params.input2_shift = unswitched_params.input1_shift;    const bool use_unswitched =       unswitched_params.broadcast_category ==       tflite::BroadcastableOpCategory::kFirstInputBroadcastsFast;    const ArithmeticParams& params =       use_unswitched ? unswitched_params : switched_params;   const T* input1_data =       use_unswitched ? unswitched_input1_data : unswitched_input2_data;   const T* input2_data =       use_unswitched ? unswitched_input2_data : unswitched_input1_data;    // Fivefold nested loops. The second input resets its position for each   // iteration of the second loop. The first input resets its position at the   // beginning of the fourth loop. The innermost loop is an elementwise add of   // sections of the arrays.   T* output_data_ptr = output_data;   const T* input1_data_ptr = input1_data;   const T* input2_data_reset = input2_data;   // In the fivefold pattern, y0, y2 and y4 are not broadcast, and so shared   // between input shapes. y3 for input 1 is always broadcast, and so the   // dimension there is 1, whereas optionally y1 might be broadcast for   // input 2. Put another way, input1.shape.FlatSize = y0 * y1 * y2 * y4,   // input2.shape.FlatSize = y0 * y2 * y3 * y4.   int y0 = params.broadcast_shape[0];   int y1 = params.broadcast_shape[1];   int y2 = params.broadcast_shape[2];   int y3 = params.broadcast_shape[3];   int y4 = params.broadcast_shape[4];   if (y4 > 1) {     // General fivefold pattern, with y4 > 1 so there is a non-broadcast inner     // dimension.     for (int i0 = 0; i0 < y0; ++i0) {       const T* input2_data_ptr = nullptr;       for (int i1 = 0; i1 < y1; ++i1) {         input2_data_ptr = input2_data_reset;         for (int i2 = 0; i2 < y2; ++i2) {           for (int i3 = 0; i3 < y3; ++i3) {             elementwise_f(y4, params, input1_data_ptr, input2_data_ptr,                           output_data_ptr);             input2_data_ptr += y4;             output_data_ptr += y4;           }           // We have broadcast y4 of input1 data y3 times, and now move on.           input1_data_ptr += y4;         }       }       // We have broadcast y2*y3*y4 of input2 data y1 times, and now move on.       input2_data_reset = input2_data_ptr;     }   } else {     // Special case of y4 == 1, in which the innermost loop is a single     // element and can be combined with the next (y3) as an inner broadcast.     //     // Note that this handles the case of pure scalar broadcast when     // y0 == y1 == y2 == 1. With low overhead it handles cases such as scalar     // broadcast with batch (as y2 > 1).     //     // NOTE The process is the same as the above general case except     // simplified for y4 == 1 and the loop over y3 is contained within the     // AddScalarBroadcast function.     for (int i0 = 0; i0 < y0; ++i0) {       const T* input2_data_ptr = nullptr;       for (int i1 = 0; i1 < y1; ++i1) {         input2_data_ptr = input2_data_reset;         for (int i2 = 0; i2 < y2; ++i2) {           scalar_broadcast_f(y3, params, *input1_data_ptr, input2_data_ptr,                              output_data_ptr);           input2_data_ptr += y3;           output_data_ptr += y3;           input1_data_ptr += 1;         }       }       input2_data_reset = input2_data_ptr;     }   } }"
"197110_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* c) override {     core::RefCountPtr<Var> v;     OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));     OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get()));     // NOTE: We hold the lock for the whole gather operation instead     // of increasing the reference count of v->tensor() to avoid a     // situation where a write to the same variable will see a     // reference count greater than one and make a copy of the     // (potentially very large) tensor buffer.     tf_shared_lock ml(*v->mu());     const Tensor& params = *v->tensor();     const Tensor& indices = c->input(1);     OP_REQUIRES(         c, TensorShapeUtils::IsVectorOrHigher(params.shape()),         errors::InvalidArgument(""params must be at least 1 dimensional""));      // Check that we have enough index space     const int64_t N = indices.NumElements();     OP_REQUIRES(         c, params.dim_size(0) <= std::numeric_limits<Index>::max(),         errors::InvalidArgument(""params.shape[0] too large for "",                                 DataTypeString(DataTypeToEnum<Index>::v()),                                 "" indexing: "", params.dim_size(0), "" > "",                                 std::numeric_limits<Index>::max()));      // The result shape is params.shape[:batch_dims] +     // indices.shape[batch_dims:] + params.shape[batch_dims+1:].     TensorShape result_shape;     for (int i = 0; i < batch_dims_; ++i) {       result_shape.AddDim(params.dim_size(i));     }     for (int i = batch_dims_; i < indices.dims(); ++i) {       result_shape.AddDim(indices.dim_size(i));     }     for (int i = batch_dims_ + 1; i < params.dims(); ++i) {       result_shape.AddDim(params.dim_size(i));     }      Tensor* out = nullptr;     Tensor tmp;     if (params.dtype() == DT_VARIANT) {       tmp = Tensor(DT_VARIANT, result_shape);       c->set_output(0, tmp);       out = &tmp;     } else {       OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out));     }      if (N > 0) {       Tensor tmp_indices;        // Points to the original or updated (if batch_dims is set) indices.       const Tensor* op_indices = &indices;       if (batch_dims_ > 0) {         OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),                                            &tmp_indices));         functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;         copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),                      indices.flat<Index>());          AddBatchOffsets(&tmp_indices, params);         op_indices = &tmp_indices;       }        int64_t gather_dim_size = 1;       for (int idx = 0; idx <= batch_dims_; ++idx) {         gather_dim_size *= params.dim_size(idx);       }       int64_t inner_size = 1;       for (int i = batch_dims_ + 1; i < params.dims(); ++i) {         inner_size *= params.dim_size(i);       }       auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size});       const auto indices_flat = op_indices->flat<Index>();       auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N});        functor::GatherFunctor<Device, T, Index> functor;       int64_t bad_i = functor(c, params_flat, indices_flat, out_flat);        OP_REQUIRES(           c, bad_i < 0,           errors::InvalidArgument(               ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "",               indices_flat(bad_i), "" is not in [0, "", params.dim_size(0), "")""));     }   }"
"197111_CWE-20.h","CWE-20","static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,                        const std::vector<tinyexr::tinyexr_uint64> &offsets,                        const unsigned char *head, const size_t size,                        std::string *err) {   int num_channels = exr_header->num_channels;    int num_scanline_blocks = 1;   if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {     num_scanline_blocks = 16;   } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {     num_scanline_blocks = 32;   } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {     num_scanline_blocks = 16;   }    int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;   int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;    if ((data_width < 0) || (data_height < 0)) {     if (err) {       std::stringstream ss;       ss << ""Invalid data width or data height: "" << data_width << "", ""          << data_height << std::endl;       (*err) += ss.str();     }     return TINYEXR_ERROR_INVALID_DATA;   }    // Do not allow too large data_width and data_height. header invalid?   {     const int threshold = 1024 * 8192;  // heuristics     if ((data_width > threshold) || (data_height > threshold)) {       if (err) {         std::stringstream ss;         ss << ""data_with or data_height too large. data_width: "" << data_width            << "", ""            << ""data_height = "" << data_height << std::endl;         (*err) += ss.str();       }       return TINYEXR_ERROR_INVALID_DATA;     }   }    size_t num_blocks = offsets.size();    std::vector<size_t> channel_offset_list;   int pixel_data_size = 0;   size_t channel_offset = 0;   if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,                                      &channel_offset, num_channels,                                      exr_header->channels)) {     if (err) {       (*err) += ""Failed to compute channel layout.\n"";     }     return TINYEXR_ERROR_INVALID_DATA;   }    bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.    if (exr_header->tiled) {     // value check     if (exr_header->tile_size_x < 0) {       if (err) {         std::stringstream ss;         ss << ""Invalid tile size x : "" << exr_header->tile_size_x << ""\n"";         (*err) += ss.str();       }       return TINYEXR_ERROR_INVALID_HEADER;     }      if (exr_header->tile_size_y < 0) {       if (err) {         std::stringstream ss;         ss << ""Invalid tile size y : "" << exr_header->tile_size_y << ""\n"";         (*err) += ss.str();       }       return TINYEXR_ERROR_INVALID_HEADER;     }      size_t num_tiles = offsets.size();  // = # of blocks      exr_image->tiles = static_cast<EXRTile *>(         calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));      for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {       // Allocate memory for each tile.       exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(           num_channels, exr_header->channels, exr_header->requested_pixel_types,           exr_header->tile_size_x, exr_header->tile_size_y);        // 16 byte: tile coordinates       // 4 byte : data size       // ~      : data(uncompressed or compressed)       if (offsets[tile_idx] + sizeof(int) * 5 > size) {         if (err) {           (*err) += ""Insufficient data size.\n"";         }         return TINYEXR_ERROR_INVALID_DATA;       }        size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));       const unsigned char *data_ptr =           reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);        int tile_coordinates[4];       memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));        // @todo{ LoD }       if (tile_coordinates[2] != 0) {         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;       }       if (tile_coordinates[3] != 0) {         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;       }        int data_len;       memcpy(&data_len, data_ptr + 16,              sizeof(int));  // 16 = sizeof(tile_coordinates)       tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));        if (data_len < 4 || size_t(data_len) > data_size) {         if (err) {           (*err) += ""Insufficient data length.\n"";         }         return TINYEXR_ERROR_INVALID_DATA;       }        // Move to data addr: 20 = 16 + 4;       data_ptr += 20;        tinyexr::DecodeTiledPixelData(           exr_image->tiles[tile_idx].images,           &(exr_image->tiles[tile_idx].width),           &(exr_image->tiles[tile_idx].height),           exr_header->requested_pixel_types, data_ptr,           static_cast<size_t>(data_len), exr_header->compression_type,           exr_header->line_order, data_width, data_height, tile_coordinates[0],           tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,           static_cast<size_t>(pixel_data_size),           static_cast<size_t>(exr_header->num_custom_attributes),           exr_header->custom_attributes,           static_cast<size_t>(exr_header->num_channels), exr_header->channels,           channel_offset_list);        exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];       exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];       exr_image->tiles[tile_idx].level_x = tile_coordinates[2];       exr_image->tiles[tile_idx].level_y = tile_coordinates[3];        exr_image->num_tiles = static_cast<int>(num_tiles);     }   } else {  // scanline format      // Don't allow too large image(256GB * pixel_data_size or more). Workaround     // for #104.     size_t total_data_len =         size_t(data_width) * size_t(data_height) * size_t(num_channels);     const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;     if ((total_data_len == 0) || total_data_len_overflown ) {       if (err) {         std::stringstream ss;         ss << ""Image data size is zero or too large: width = "" << data_width            << "", height = "" << data_height << "", channels = "" << num_channels            << std::endl;         (*err) += ss.str();       }       return TINYEXR_ERROR_INVALID_DATA;     }      exr_image->images = tinyexr::AllocateImage(         num_channels, exr_header->channels, exr_header->requested_pixel_types,         data_width, data_height);  #ifdef _OPENMP #pragma omp parallel for #endif     for (int y = 0; y < static_cast<int>(num_blocks); y++) {       size_t y_idx = static_cast<size_t>(y);        if (offsets[y_idx] + sizeof(int) * 2 > size) {         invalid_data = true;       } else {         // 4 byte: scan line         // 4 byte: data size         // ~     : pixel data(uncompressed or compressed)         size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));         const unsigned char *data_ptr =             reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);          int line_no;         memcpy(&line_no, data_ptr, sizeof(int));         int data_len;         memcpy(&data_len, data_ptr + 4, sizeof(int));         tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));         tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));          if (size_t(data_len) > data_size) {           invalid_data = true;         } else if (data_len == 0) {           // TODO(syoyo): May be ok to raise the threshold for example `data_len           // < 4`           invalid_data = true;         } else {           // line_no may be negative.           int end_line_no = (std::min)(line_no + num_scanline_blocks,                                        (exr_header->data_window[3] + 1));            int num_lines = end_line_no - line_no;            if (num_lines <= 0) {             invalid_data = true;           } else {             // Move to data addr: 8 = 4 + 4;             data_ptr += 8;              // Adjust line_no with data_window.bmin.y              // overflow check             tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);             if (lno > std::numeric_limits<int>::max()) {               line_no = -1; // invalid             } else if (lno < -std::numeric_limits<int>::max()) {               line_no = -1; // invalid             } else {               line_no -= exr_header->data_window[1];             }              if (line_no < 0) {               invalid_data = true;             } else {               if (!tinyexr::DecodePixelData(                       exr_image->images, exr_header->requested_pixel_types,                       data_ptr, static_cast<size_t>(data_len),                       exr_header->compression_type, exr_header->line_order,                       data_width, data_height, data_width, y, line_no,                       num_lines, static_cast<size_t>(pixel_data_size),                       static_cast<size_t>(exr_header->num_custom_attributes),                       exr_header->custom_attributes,                       static_cast<size_t>(exr_header->num_channels),                       exr_header->channels, channel_offset_list)) {                 invalid_data = true;               }             }           }         }       }     }  // omp parallel   }    if (invalid_data) {     if (err) {       std::stringstream ss;       (*err) += ""Invalid data found when decoding pixels.\n"";     }     return TINYEXR_ERROR_INVALID_DATA;   }    // Overwrite `pixel_type` with `requested_pixel_type`.   {     for (int c = 0; c < exr_header->num_channels; c++) {       exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];     }   }    {     exr_image->num_channels = num_channels;      exr_image->width = data_width;     exr_image->height = data_height;   }    return TINYEXR_SUCCESS; }"
"197128_CWE-125.c","CWE-125","gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) {   int idx;   int type = nint(tree->car);    switch (type) {   case NODE_GVAR:   case NODE_ARG:   case NODE_LVAR:   case NODE_IVAR:   case NODE_CVAR:   case NODE_CONST:   case NODE_NIL:   case NODE_MASGN:     if (rhs) {       codegen(s, rhs, VAL);       pop();       sp = cursp();     }     break;    case NODE_COLON2:   case NODE_CALL:   case NODE_SCALL:     /* keep evaluation order */     break;    case NODE_NVAR:     codegen_error(s, ""Can't assign to numbered parameter"");     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }    tree = tree->cdr;   switch (type) {   case NODE_GVAR:     gen_setxv(s, OP_SETGV, sp, nsym(tree), val);     break;   case NODE_ARG:   case NODE_LVAR:     idx = lv_idx(s, nsym(tree));     if (idx > 0) {       if (idx != sp) {         gen_move(s, idx, sp, val);       }       break;     }     else {                      /* upvar */       gen_setupvar(s, sp, nsym(tree));     }     break;   case NODE_IVAR:     gen_setxv(s, OP_SETIV, sp, nsym(tree), val);     break;   case NODE_CVAR:     gen_setxv(s, OP_SETCV, sp, nsym(tree), val);     break;   case NODE_CONST:     gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);     break;   case NODE_COLON2:     if (sp) {       gen_move(s, cursp(), sp, 0);     }     sp = cursp();     push();     codegen(s, tree->car, VAL);     if (rhs) {       codegen(s, rhs, VAL); pop();       gen_move(s, sp, cursp(), 0);     }     pop_n(2);     idx = new_sym(s, nsym(tree->cdr));     genop_2(s, OP_SETMCNST, sp, idx);     break;    case NODE_CALL:   case NODE_SCALL:     {       int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;       mrb_sym mid = nsym(tree->cdr->car);        top = cursp();       if (val || sp == cursp()) {         push();                   /* room for retval */       }       call = cursp();       if (!tree->car) {         noself = 1;         push();       }       else {         codegen(s, tree->car, VAL); /* receiver */       }       if (safe) {         int recv = cursp()-1;         gen_move(s, cursp(), recv, 1);         skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);       }       tree = tree->cdr->cdr->car;       if (tree) {         if (tree->car) {            /* positional arguments */           n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);           if (n < 0) {              /* variable length */             n = 15;             push();           }         }         if (tree->cdr->car) {       /* keyword arguments */           if (n == 14) {             pop_n(n);             genop_2(s, OP_ARRAY, cursp(), n);             push();             n = 15;           }           gen_hash(s, tree->cdr->car->cdr, VAL, 0);           if (n < 14) {             n++;           }           else {             pop_n(2);             genop_2(s, OP_ARYPUSH, cursp(), 1);           }           push();         }       }       if (rhs) {         codegen(s, rhs, VAL);         pop();       }       else {         gen_move(s, cursp(), sp, 0);       }       if (val) {         gen_move(s, top, cursp(), 1);       }       if (n < 14) {         n++;       }       else {         pop();         genop_2(s, OP_ARYPUSH, cursp(), 1);       }       s->sp = call;       if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {         genop_1(s, OP_SETIDX, cursp());       }       else {         genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);       }       if (safe) {         dispatch(s, skip);       }       s->sp = top;     }     break;    case NODE_MASGN:     gen_vmassignment(s, tree->car, sp, val);     break;    /* splat without assignment */   case NODE_NIL:     break;    default:     codegen_error(s, ""unknown lhs"");     break;   }   if (val) push(); }"
"197135_CWE-703.c","CWE-703","ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd) { 	struct ccp_aes_engine *aes = &cmd->u.aes; 	struct ccp_dm_workarea key, ctx, final_wa, tag; 	struct ccp_data src, dst; 	struct ccp_data aad; 	struct ccp_op op; 	unsigned int dm_offset; 	unsigned int authsize; 	unsigned int jobid; 	unsigned int ilen; 	bool in_place = true; /* Default value */ 	__be64 *final; 	int ret;  	struct scatterlist *p_inp, sg_inp[2]; 	struct scatterlist *p_tag, sg_tag[2]; 	struct scatterlist *p_outp, sg_outp[2]; 	struct scatterlist *p_aad;  	if (!aes->iv) 		return -EINVAL;  	if (!((aes->key_len == AES_KEYSIZE_128) || 		(aes->key_len == AES_KEYSIZE_192) || 		(aes->key_len == AES_KEYSIZE_256))) 		return -EINVAL;  	if (!aes->key) /* Gotta have a key SGL */ 		return -EINVAL;  	/* Zero defaults to 16 bytes, the maximum size */ 	authsize = aes->authsize ? aes->authsize : AES_BLOCK_SIZE; 	switch (authsize) { 	case 16: 	case 15: 	case 14: 	case 13: 	case 12: 	case 8: 	case 4: 		break; 	default: 		return -EINVAL; 	}  	/* First, decompose the source buffer into AAD & PT, 	 * and the destination buffer into AAD, CT & tag, or 	 * the input into CT & tag. 	 * It is expected that the input and output SGs will 	 * be valid, even if the AAD and input lengths are 0. 	 */ 	p_aad = aes->src; 	p_inp = scatterwalk_ffwd(sg_inp, aes->src, aes->aad_len); 	p_outp = scatterwalk_ffwd(sg_outp, aes->dst, aes->aad_len); 	if (aes->action == CCP_AES_ACTION_ENCRYPT) { 		ilen = aes->src_len; 		p_tag = scatterwalk_ffwd(sg_tag, p_outp, ilen); 	} else { 		/* Input length for decryption includes tag */ 		ilen = aes->src_len - authsize; 		p_tag = scatterwalk_ffwd(sg_tag, p_inp, ilen); 	}  	jobid = CCP_NEW_JOBID(cmd_q->ccp);  	memset(&op, 0, sizeof(op)); 	op.cmd_q = cmd_q; 	op.jobid = jobid; 	op.sb_key = cmd_q->sb_key; /* Pre-allocated */ 	op.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */ 	op.init = 1; 	op.u.aes.type = aes->type;  	/* Copy the key to the LSB */ 	ret = ccp_init_dm_workarea(&key, cmd_q, 				   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES, 				   DMA_TO_DEVICE); 	if (ret) 		return ret;  	dm_offset = CCP_SB_BYTES - aes->key_len; 	ret = ccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len); 	if (ret) 		goto e_key; 	ret = ccp_copy_to_sb(cmd_q, &key, op.jobid, op.sb_key, 			     CCP_PASSTHRU_BYTESWAP_256BIT); 	if (ret) { 		cmd->engine_error = cmd_q->cmd_error; 		goto e_key; 	}  	/* Copy the context (IV) to the LSB. 	 * There is an assumption here that the IV is 96 bits in length, plus 	 * a nonce of 32 bits. If no IV is present, use a zeroed buffer. 	 */ 	ret = ccp_init_dm_workarea(&ctx, cmd_q, 				   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES, 				   DMA_BIDIRECTIONAL); 	if (ret) 		goto e_key;  	dm_offset = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - aes->iv_len; 	ret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len); 	if (ret) 		goto e_ctx;  	ret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx, 			     CCP_PASSTHRU_BYTESWAP_256BIT); 	if (ret) { 		cmd->engine_error = cmd_q->cmd_error; 		goto e_ctx; 	}  	op.init = 1; 	if (aes->aad_len > 0) { 		/* Step 1: Run a GHASH over the Additional Authenticated Data */ 		ret = ccp_init_data(&aad, cmd_q, p_aad, aes->aad_len, 				    AES_BLOCK_SIZE, 				    DMA_TO_DEVICE); 		if (ret) 			goto e_ctx;  		op.u.aes.mode = CCP_AES_MODE_GHASH; 		op.u.aes.action = CCP_AES_GHASHAAD;  		while (aad.sg_wa.bytes_left) { 			ccp_prepare_data(&aad, NULL, &op, AES_BLOCK_SIZE, true);  			ret = cmd_q->ccp->vdata->perform->aes(&op); 			if (ret) { 				cmd->engine_error = cmd_q->cmd_error; 				goto e_aad; 			}  			ccp_process_data(&aad, NULL, &op); 			op.init = 0; 		} 	}  	op.u.aes.mode = CCP_AES_MODE_GCTR; 	op.u.aes.action = aes->action;  	if (ilen > 0) { 		/* Step 2: Run a GCTR over the plaintext */ 		in_place = (sg_virt(p_inp) == sg_virt(p_outp)) ? true : false;  		ret = ccp_init_data(&src, cmd_q, p_inp, ilen, 				    AES_BLOCK_SIZE, 				    in_place ? DMA_BIDIRECTIONAL 					     : DMA_TO_DEVICE); 		if (ret) 			goto e_ctx;  		if (in_place) { 			dst = src; 		} else { 			ret = ccp_init_data(&dst, cmd_q, p_outp, ilen, 					    AES_BLOCK_SIZE, DMA_FROM_DEVICE); 			if (ret) 				goto e_src; 		}  		op.soc = 0; 		op.eom = 0; 		op.init = 1; 		while (src.sg_wa.bytes_left) { 			ccp_prepare_data(&src, &dst, &op, AES_BLOCK_SIZE, true); 			if (!src.sg_wa.bytes_left) { 				unsigned int nbytes = ilen % AES_BLOCK_SIZE;  				if (nbytes) { 					op.eom = 1; 					op.u.aes.size = (nbytes * 8) - 1; 				} 			}  			ret = cmd_q->ccp->vdata->perform->aes(&op); 			if (ret) { 				cmd->engine_error = cmd_q->cmd_error; 				goto e_dst; 			}  			ccp_process_data(&src, &dst, &op); 			op.init = 0; 		} 	}  	/* Step 3: Update the IV portion of the context with the original IV */ 	ret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx, 			       CCP_PASSTHRU_BYTESWAP_256BIT); 	if (ret) { 		cmd->engine_error = cmd_q->cmd_error; 		goto e_dst; 	}  	ret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len); 	if (ret) 		goto e_dst;  	ret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx, 			     CCP_PASSTHRU_BYTESWAP_256BIT); 	if (ret) { 		cmd->engine_error = cmd_q->cmd_error; 		goto e_dst; 	}  	/* Step 4: Concatenate the lengths of the AAD and source, and 	 * hash that 16 byte buffer. 	 */ 	ret = ccp_init_dm_workarea(&final_wa, cmd_q, AES_BLOCK_SIZE, 				   DMA_BIDIRECTIONAL); 	if (ret) 		goto e_dst; 	final = (__be64 *)final_wa.address; 	final[0] = cpu_to_be64(aes->aad_len * 8); 	final[1] = cpu_to_be64(ilen * 8);  	memset(&op, 0, sizeof(op)); 	op.cmd_q = cmd_q; 	op.jobid = jobid; 	op.sb_key = cmd_q->sb_key; /* Pre-allocated */ 	op.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */ 	op.init = 1; 	op.u.aes.type = aes->type; 	op.u.aes.mode = CCP_AES_MODE_GHASH; 	op.u.aes.action = CCP_AES_GHASHFINAL; 	op.src.type = CCP_MEMTYPE_SYSTEM; 	op.src.u.dma.address = final_wa.dma.address; 	op.src.u.dma.length = AES_BLOCK_SIZE; 	op.dst.type = CCP_MEMTYPE_SYSTEM; 	op.dst.u.dma.address = final_wa.dma.address; 	op.dst.u.dma.length = AES_BLOCK_SIZE; 	op.eom = 1; 	op.u.aes.size = 0; 	ret = cmd_q->ccp->vdata->perform->aes(&op); 	if (ret) 		goto e_dst;  	if (aes->action == CCP_AES_ACTION_ENCRYPT) { 		/* Put the ciphered tag after the ciphertext. */ 		ccp_get_dm_area(&final_wa, 0, p_tag, 0, authsize); 	} else { 		/* Does this ciphered tag match the input? */ 		ret = ccp_init_dm_workarea(&tag, cmd_q, authsize, 					   DMA_BIDIRECTIONAL); 		if (ret) 			goto e_tag; 		ret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize); 		if (ret) 			goto e_tag;  		ret = crypto_memneq(tag.address, final_wa.address, 				    authsize) ? -EBADMSG : 0; 		ccp_dm_free(&tag); 	}  e_tag: 	ccp_dm_free(&final_wa);  e_dst: 	if (ilen > 0 && !in_place) 		ccp_free_data(&dst, cmd_q);  e_src: 	if (ilen > 0) 		ccp_free_data(&src, cmd_q);  e_aad: 	if (aes->aad_len) 		ccp_free_data(&aad, cmd_q);  e_ctx: 	ccp_dm_free(&ctx);  e_key: 	ccp_dm_free(&key);  	return ret; }"
"197142_CWE-476.cc","CWE-476","  void Compute(OpKernelContext* ctx) override {     const Tensor& input = ctx->input(0);     const Tensor& input_min_range = ctx->input(1);     const Tensor& input_max_range = ctx->input(2);      int num_slices = 1;     if (axis_ > -1) {       num_slices = input.dim_size(axis_);     }      const TensorShape& minmax_shape = ctx->input(1).shape();     Tensor* output = nullptr;     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));      Tensor* output_min_tensor = nullptr;     Tensor* output_max_tensor = nullptr;      if (num_slices == 1) {       OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));       OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));       const float min_range = input_min_range.template flat<float>()(0);       const float max_range = input_max_range.template flat<float>()(0);       QuantizeTensor(ctx, input, min_range, max_range, output,                      output_min_tensor, output_max_tensor);       return;     }      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,                 errors::Unimplemented(""MIN_FIRST mode is not implemented for ""                                       ""Quantize with axis != -1.""));     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(1, minmax_shape, &output_min_tensor));     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(2, minmax_shape, &output_max_tensor));      auto input_tensor =         input.template flat_inner_outer_dims<float, 3>(axis_ - 1);     int64_t pre_dim = 1, post_dim = 1;     for (int i = 0; i < axis_; ++i) {       pre_dim *= output->dim_size(i);     }     for (int i = axis_ + 1; i < output->dims(); ++i) {       post_dim *= output->dim_size(i);     }     auto output_tensor = output->template bit_casted_shaped<T, 3>(         {pre_dim, num_slices, post_dim});     auto min_ranges = input_min_range.template vec<float>();     auto max_ranges = input_max_range.template vec<float>();     for (int i = 0; i < num_slices; ++i) {       QuantizeSlice(ctx->eigen_device<Device>(), ctx,                     input_tensor.template chip<1>(i), min_ranges(i),                     max_ranges(i), output_tensor.template chip<1>(i),                     &output_min_tensor->flat<float>()(i),                     &output_max_tensor->flat<float>()(i));     }   }"
"197185_CWE-252.c","CWE-252","static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size) {     GetBitContext gb;     PutBitContext pb;     MPEG4AudioConfig m4ac;     int off;      init_get_bits(&gb, buf, size * 8);     off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);     if (off < 0)         return off;     skip_bits_long(&gb, off);     adts->objecttype        = m4ac.object_type - 1;     adts->sample_rate_index = m4ac.sampling_index;     adts->channel_conf      = m4ac.chan_config;      if (adts->objecttype > 3U) {         av_log(s, AV_LOG_ERROR, ""MPEG-4 AOT %d is not allowed in ADTS\n"", adts->objecttype+1);         return AVERROR_INVALIDDATA;     }     if (adts->sample_rate_index == 15) {         av_log(s, AV_LOG_ERROR, ""Escape sample rate index illegal in ADTS\n"");         return AVERROR_INVALIDDATA;     }     if (get_bits(&gb, 1)) {         av_log(s, AV_LOG_ERROR, ""960/120 MDCT window is not allowed in ADTS\n"");         return AVERROR_INVALIDDATA;     }     if (get_bits(&gb, 1)) {         av_log(s, AV_LOG_ERROR, ""Scalable configurations are not allowed in ADTS\n"");         return AVERROR_INVALIDDATA;     }     if (get_bits(&gb, 1)) {         av_log(s, AV_LOG_ERROR, ""Extension flag is not allowed in ADTS\n"");         return AVERROR_INVALIDDATA;     }     if (!adts->channel_conf) {         init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);          put_bits(&pb, 3, 5); //ID_PCE         adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;         flush_put_bits(&pb);     }      adts->write_adts = 1;      return 0; }"
"197223_CWE-787.c","CWE-787","njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info) {     char        *p;     size_t      length;     njs_bool_t  trail;     char        src[NJS_MAX_PATH + 1];      trail = 0;     length = info->name.length;      if (dir != NULL) {         length = dir->length;          if (length == 0) {             return NJS_DECLINED;         }          trail = (dir->start[dir->length - 1] != '/');          if (trail) {             length++;         }     }      if (njs_slow_path(length > NJS_MAX_PATH)) {         return NJS_ERROR;     }      p = &src[0];      if (dir != NULL) {         p = (char *) njs_cpymem(p, dir->start, dir->length);          if (trail) {             *p++ = '/';         }     }      p = (char *) njs_cpymem(p, info->name.start, info->name.length);     *p = '\0';      p = realpath(&src[0], &info->path[0]);     if (p == NULL) {         return NJS_DECLINED;     }      info->fd = open(&info->path[0], O_RDONLY);     if (info->fd < 0) {         return NJS_DECLINED;     }       info->file.start = (u_char *) &info->path[0];     info->file.length = njs_strlen(info->file.start);      return NJS_OK; }"
"197239_CWE-20.cc","CWE-20","  void Compute(OpKernelContext* ctx) override {     try {       const Tensor& input = ctx->input(kInputTensorIndex);       const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);       float* input_min_vec_data = (float*)const_cast<void*>(           static_cast<const void*>(input_min_vec.flat<float>().data()));       const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);       float* input_max_vec_data = (float*)const_cast<void*>(           static_cast<const void*>(input_max_vec.flat<float>().data()));        const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);       const float input_requested_min_float =           input_requested_min.flat<float>()(0);       const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);       const float input_requested_max_float =           input_requested_max.flat<float>()(0);        size_t depth = input_min_vec.NumElements();       OP_REQUIRES(           ctx, input.dims() == 4,           errors::InvalidArgument(""Current RequantizePerChannel operator""                                   ""supports 4D tensors only.""));       OP_REQUIRES(           ctx, input_min_vec.dim_size(0) == depth,           errors::InvalidArgument(""input_min has incorrect size, expected "",                                   depth, "" was "", input_min_vec.dim_size(0)));       OP_REQUIRES(           ctx, input_max_vec.dim_size(0) == depth,           errors::InvalidArgument(""input_max has incorrect size, expected "",                                   depth, "" was "", input_max_vec.dim_size(0)));        if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);        const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;       const float requested_min_max =           std::max(std::abs(input_requested_min_float),                    std::abs(input_requested_max_float));       Tensor* output = nullptr;       OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,                                                input.shape(), &output));        std::vector<float> scales(depth);       for (int i = 0; i < depth; ++i) {         float min_max_from_vec = std::max(std::abs(input_min_vec_data[i]),                                           std::abs(input_max_vec_data[i]));         scales[i] = factor * (min_max_from_vec / requested_min_max /                               static_cast<float>(1L << 31));       }        mkldnn::primitive_attr reorder_attr;       reorder_attr.set_output_scales(2, scales);        memory::dims dims_mkl_order =           TFShapeToMklDnnDimsInNCHW(input.shape(), FORMAT_NHWC);       memory::desc input_md = memory::desc(dims_mkl_order, MklDnnType<qint32>(),                                            memory::format_tag::nhwc);       memory::desc output_md =           (out_type_ == DT_QINT8)               ? memory::desc(dims_mkl_order, MklDnnType<qint8>(),                              memory::format_tag::nhwc)               : memory::desc(dims_mkl_order, MklDnnType<quint8>(),                              memory::format_tag::nhwc);        void* input_buf =           static_cast<void*>(const_cast<qint32*>(input.flat<qint32>().data()));       void* output_buf;       if (out_type_ == DT_QINT8) {         output_buf = static_cast<void*>(             const_cast<qint8*>(output->flat<qint8>().data()));       } else {         output_buf = static_cast<void*>(             const_cast<quint8*>(output->flat<quint8>().data()));       }        std::unique_ptr<memory> input_mem_prim(           new memory(input_md, cpu_engine_, input_buf));       std::unique_ptr<memory> output_mem_prim(           new memory(output_md, cpu_engine_, output_buf));        mkldnn::reorder::primitive_desc reorder_pd =           ReorderPd(cpu_engine_, input_mem_prim->get_desc(), cpu_engine_,                     output_mem_prim->get_desc(), reorder_attr);       std::shared_ptr<stream> reorder_stream;       MklDnnThreadPool eigen_tp(ctx);       reorder_stream.reset(CreateStream(&eigen_tp, cpu_engine_));       std::unordered_map<int, mkldnn::memory> reorder_args = {           {MKLDNN_ARG_FROM, *input_mem_prim},           {MKLDNN_ARG_TO, *output_mem_prim}};       std::unique_ptr<mkldnn::primitive> reorder_prim(           new mkldnn::reorder(reorder_pd));       reorder_prim->execute(*reorder_stream, reorder_args);        Tensor* output_min = nullptr;       Tensor* output_max = nullptr;       OP_REQUIRES_OK(ctx,                      ctx->allocate_output(kOutputMinIndex, {}, &output_min));       OP_REQUIRES_OK(ctx,                      ctx->allocate_output(kOutputMaxIndex, {}, &output_max));        output_min->flat<float>()(0) = input_requested_min_float;       output_max->flat<float>()(0) = input_requested_max_float;     } catch (mkldnn::error& e) {       string error_msg = ""Status: "" + std::to_string(e.status) +                          "", message: "" + std::string(e.message) + "", in file "" +                          std::string(__FILE__) + "":"" + std::to_string(__LINE__);       OP_REQUIRES_OK(           ctx, errors::Aborted(""Operation received an exception:"", error_msg));     }   }"
"197242_CWE-908.cc","CWE-908","TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {   const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);   OpData* op_data = reinterpret_cast<OpData*>(node->user_data);   int scratch_tensor_index = op_data->scratch_tensor_index;    // Check we have all the inputs and outputs we need.   TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);   TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);    const TfLiteTensor* input;   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));   const TfLiteTensor* weights_feature;   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,                                           &weights_feature));   const TfLiteTensor* weights_time;   TF_LITE_ENSURE_OK(       context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));    TF_LITE_ENSURE(context,                  input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);    // Check all the parameters of tensor match within themselves and match the   // input configuration.   const int rank = params->rank;   const int batch_size = input->dims->data[0];   const int num_filters = weights_feature->dims->data[0];   TF_LITE_ENSURE(context, rank != 0);   TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);   const int num_units = num_filters / rank;   const int memory_size = weights_time->dims->data[1];   TF_LITE_ENSURE_EQ(context, input->dims->data[1],                     weights_feature->dims->data[1]);   TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);    const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);   if (bias) {     TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);   }    const TfLiteTensor* state;   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));   TfLiteTensor* output;   TF_LITE_ENSURE_OK(context,                     GetOutputSafe(context, node, kOutputTensor, &output));    // Check the shape of input state tensors.   TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);   TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);   TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),                     memory_size * num_filters);    // Resize output.   TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);   output_size_array->data[0] = batch_size;   output_size_array->data[1] = num_units;   TF_LITE_ENSURE_OK(context,                     context->ResizeTensor(context, output, output_size_array));    // The weights are of consistent type, so it suffices to check one.   const bool is_hybrid_op = IsHybridOp(input, weights_feature);   const bool is_full_integer = input->type == kTfLiteInt8;    // Resize scratch.   TfLiteIntArrayFree(node->temporaries);   if (is_hybrid_op) {     node->temporaries = TfLiteIntArrayCreate(6);   } else if (is_full_integer) {     node->temporaries = TfLiteIntArrayCreate(2);   } else {     node->temporaries = TfLiteIntArrayCreate(1);   }   node->temporaries->data[0] = scratch_tensor_index;    TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);   scratch_size_array->data[0] = batch_size;   scratch_size_array->data[1] = num_filters;    TfLiteTensor* scratch_tensor;   TF_LITE_ENSURE_OK(       context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));    // The scratch buffer is of type int32 for full integer svdf and it's of type   // float32 for hybrid and float case.   if (is_full_integer) {     scratch_tensor->type = kTfLiteInt32;   } else {     scratch_tensor->type = kTfLiteFloat32;   }   scratch_tensor->allocation_type = kTfLiteArenaRw;   TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,                                                    scratch_size_array));    if (is_hybrid_op) {     op_data->compute_row_sums = true;     // Tell interpreter to allocate temporary tensors to store quantized values     // of input tensors.     node->temporaries->data[1] = scratch_tensor_index + 1;     TfLiteTensor* input_quantized;     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,                                                 &input_quantized));     input_quantized->type = weights_feature->type;     input_quantized->allocation_type = kTfLiteArenaRw;     if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {       TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,                                                        input_quantized_size));     }      // Tell interpreter to allocate temporary tensors to store scaling factors.     node->temporaries->data[2] = scratch_tensor_index + 2;     TfLiteTensor* scaling_factors;     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,                                                 &scaling_factors));     scaling_factors->type = kTfLiteFloat32;     scaling_factors->allocation_type = kTfLiteArenaRw;     int scaling_dims[1] = {batch_size};     if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {       TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);       scaling_factors_size->data[0] = batch_size;       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,                                                        scaling_factors_size));     }      // Used to store dequantized weights_time matrix for hybrid computation of     // matmul(state, weights_time), which occurs in floating point.     node->temporaries->data[3] = scratch_tensor_index + 3;     TfLiteTensor* float_weights_time;     TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,                                                 &float_weights_time));     float_weights_time->type = kTfLiteFloat32;     // Persistent so that we can compute the dequantized weights only once.     float_weights_time->allocation_type = kTfLiteArenaRwPersistent;     if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {       TfLiteIntArray* float_weights_time_size =           TfLiteIntArrayCopy(weights_time->dims);       TF_LITE_ENSURE_OK(context,                         context->ResizeTensor(context, float_weights_time,                                               float_weights_time_size));     }      node->temporaries->data[4] = scratch_tensor_index + 4;     TfLiteTensor* zero_points;     TF_LITE_ENSURE_OK(         context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));     zero_points->type = kTfLiteFloat32;     zero_points->allocation_type = kTfLiteArenaRw;     int zero_points_dims[1] = {batch_size};     if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {       TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);       zero_points_size->data[0] = zero_points_dims[0];       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,                                                        zero_points_size));     }      node->temporaries->data[5] = scratch_tensor_index + 5;     TfLiteTensor* row_sums;     TF_LITE_ENSURE_OK(context,                       GetTemporarySafe(context, node, /*index=*/5, &row_sums));     row_sums->type = kTfLiteFloat32;     row_sums->allocation_type = kTfLiteArenaRwPersistent;     int row_sums_dims[1] = {num_filters};     if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {       TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);       row_sums_size->data[0] = row_sums_dims[0];       TF_LITE_ENSURE_OK(           context, context->ResizeTensor(context, row_sums, row_sums_size));     }   }   if (is_full_integer) {     // Allocated one extra tensor.     TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);     output_temp_size_array->data[0] = num_units;     output_temp_size_array->data[1] = batch_size;     node->temporaries->data[1] = scratch_tensor_index + 1;     TfLiteTensor* output_temp;     TF_LITE_ENSURE_OK(         context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));     output_temp->type = kTfLiteInt32;     output_temp->allocation_type = kTfLiteArenaRw;     TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,                                                      output_temp_size_array));      // Calculate effective scales.     auto* input_params =         reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);     auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(         weights_feature->quantization.params);     auto* state_params =         reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);     auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(         weights_time->quantization.params);     auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(         output->quantization.params);     const double effective_scale_1 = input_params->scale->data[0] *                                      weights_feature_params->scale->data[0] /                                      state_params->scale->data[0];     const double effective_scale_2 = state_params->scale->data[0] *                                      weight_time_params->scale->data[0] /                                      output_params->scale->data[0];     QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,                        &op_data->effective_scale_1_b);     QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,                        &op_data->effective_scale_2_b);   }   return kTfLiteOk; }"
"197247_CWE-369.cpp","CWE-369","Status ShapeRefiner::InferShapesForFunctionSubNode(     const Node* node, InferenceContext* outer_context) {   TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));   InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));    if (StringPiece(node->type_string()) == kArgOp) {     // Handle special node: function input.     // Shapes for these nodes are provided in the outer inference     // context.      int index;     TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), ""index"", &index));      if (index < 0 || outer_context->num_inputs() <= index) {       return errors::Internal(           ""Function instantiation included invalid input index: "", index,           "" not in [0, "", outer_context->num_inputs(), "")."");     }      // TODO(b/134547156): TEMPORARY WORKAROUND. If input shape handle is not set     // in outer context, set _Arg node output shape to unknown.     if (outer_context->input(index).SameHandle(ShapeHandle())) {       VLOG(1) << ""Function instantiation has undefined input shape at ""               << ""index: "" << index << "" in the outer inference context."";       node_context->set_output(0, node_context->UnknownShape());     } else {       node_context->set_output(0, outer_context->input(index));     }      auto* resource = outer_context->input_handle_shapes_and_types(index);     if (resource) {       node_context->set_output_handle_shapes_and_types(0, *resource);     }   } else if (StringPiece(node->type_string()) == kRetvalOp) {     // Handle special node: function output.     // Shapes inferred for these nodes go into the outer inference     // context.      int index;     TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), ""index"", &index));      if (index < 0 || outer_context->num_outputs() <= index) {       return errors::Internal(           ""Function instantiation included invalid output index: "", index,           "" not in [0, "", outer_context->num_outputs(), "")."");     }      // outer_context outlives node_context, therefore we need to create     // a new shape handle owned by outer_context instead.     ShapeHandle handle;     TensorShapeProto proto;     node_context->ShapeHandleToProto(node_context->input(0), &proto);     TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));     outer_context->set_output(index, handle);      auto* resource = node_context->input_handle_shapes_and_types(0);     if (resource) {       outer_context->set_output_handle_shapes_and_types(index, *resource);     }   }    return Status::OK(); }"
"197262_CWE-125.cc","CWE-125","  void Compute(OpKernelContext* ctx) override {     const Tensor& a = ctx->input(0);     const Tensor& b = ctx->input(1);     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),                 errors::InvalidArgument(""a is not a matrix""));     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),                 errors::InvalidArgument(""b is not a matrix""));      const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);     const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);     const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);     const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);      OP_REQUIRES(ctx, k == k2,                 errors::InvalidArgument(                     ""Matrix size incompatible: a: "", a.shape().DebugString(),                     "", b: "", b.shape().DebugString()));     Tensor* output = nullptr;     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));      if (k == 0) {       // If the inner dimension k in the matrix multiplication is zero, we fill       // the output with zeros.       functor::SetZeroFunctor<CPUDevice, float> f;       f(ctx->eigen_device<CPUDevice>(), output->flat<float>());       return;     }      auto out = output->matrix<float>();      std::unique_ptr<Tensor> a_float;     std::unique_ptr<Tensor> b_float;     if (!a_is_sparse_ && !b_is_sparse_) {       auto left = &a;       auto right = &b;       // TODO(agarwal): multi-thread the conversions from bfloat16 to float.       if (std::is_same<TL, bfloat16>::value) {         a_float.reset(new Tensor(DT_FLOAT, a.shape()));         BFloat16ToFloat(a.flat<bfloat16>().data(),                         a_float->flat<float>().data(), a.NumElements());         left = a_float.get();       }       if (std::is_same<TR, bfloat16>::value) {         b_float.reset(new Tensor(DT_FLOAT, b.shape()));         BFloat16ToFloat(b.flat<bfloat16>().data(),                         b_float->flat<float>().data(), b.NumElements());         right = b_float.get();       }       Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;       dim_pair[0].first = transpose_a_ ? 0 : 1;       dim_pair[0].second = transpose_b_ ? 1 : 0;        out.device(ctx->template eigen_device<CPUDevice>()) =           left->matrix<float>().contract(right->matrix<float>(), dim_pair);       return;     }      auto left = &a;     auto right = &b;     bool transpose_output = false;     bool transpose_a = transpose_a_;     bool transpose_b = transpose_b_;     if (!a_is_sparse_) {       // Swap the order of multiplications using the identity:       // A * B = (B' *  A')'.       std::swap(left, right);       std::swap(transpose_a, transpose_b);       transpose_a = !transpose_a;       transpose_b = !transpose_b;       transpose_output = !transpose_output;     }      std::unique_ptr<Tensor> right_tr;     if (transpose_b) {       // TODO(agarwal): avoid transposing the matrix here and directly handle       // transpose in CreateDenseSlices.       OP_REQUIRES(ctx, right->dim_size(0) != 0,                   errors::InvalidArgument(""b has an entry 0 in it's shape.""));       OP_REQUIRES(ctx, right->dim_size(1) != 0,                   errors::InvalidArgument(""b has an entry 0 in it's shape.""));       right_tr.reset(           new Tensor(right->dtype(),                      TensorShape({right->dim_size(1), right->dim_size(0)})));        const auto perm = dsizes_10();       if (transpose_output) {         right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =             right->matrix<TL>().shuffle(perm);       } else {         right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =             right->matrix<TR>().shuffle(perm);       }       right = right_tr.get();     }      if (transpose_output) {       DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),                                 right->matrix<TL>(), transpose_a,                                 ctx->device()->tensorflow_cpu_worker_threads(),                                 transpose_output, &out);     } else {       DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),                                 right->matrix<TR>(), transpose_a,                                 ctx->device()->tensorflow_cpu_worker_threads(),                                 transpose_output, &out);     }   }"
"197305_CWE-200.c","CWE-200","PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi( 					const void *buf, 					pj_size_t length, 					pjmedia_rtcp_fb_rpsi *rpsi) {     pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;     pj_uint8_t *p;     pj_uint8_t padlen;     pj_size_t rpsi_len;      PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);     PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);      /* RPSI uses pt==RTCP_PSFB and FMT==3 */     if (hdr->pt != RTCP_PSFB || hdr->count != 3) 	return PJ_ENOTFOUND;      rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;     if (length < rpsi_len + 12) 	return PJ_ETOOSMALL;      p = (pj_uint8_t*)hdr + sizeof(*hdr);     padlen = *p++;     rpsi->pt = (*p++ & 0x7F);     rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;     pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);      return PJ_SUCCESS; }"
"197318_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     const Tensor& handle = ctx->input(0);     const string& name = handle.scalar<tstring>()();     auto session_state = ctx->session_state();     OP_REQUIRES(ctx, session_state != nullptr,                 errors::FailedPrecondition(                     ""DeleteSessionTensor called on null session state""));     OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));   }"
"197326_CWE-703.h","CWE-703","  static Status ParseEquation(const string& equation,                               OperandLabels* input_labels,                               Labels* output_labels,                               std::vector<DimensionType>* label_types,                               OperandLabelCounts* input_label_counts,                               LabelCounts* output_label_counts,                               gtl::InlinedVector<bool, 2>* input_has_ellipsis,                               bool* output_has_ellipsis) {     gtl::InlinedVector<string, 2> input_str;     string output_str;     TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));      // Temporary map from single character labels to (consecutive) integer     // labels.     absl::flat_hash_map<char, int> label_mapping;     int num_inputs = input_str.size();     input_labels->resize(num_inputs);      // Map from single characters to integer labels.     for (int i = 0; i < num_inputs; ++i) {       MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);     }     MapToLabels(output_str, output_labels, &label_mapping);      // Compute counts for input and output labels.     int num_labels = label_mapping.size();     input_label_counts->resize(num_inputs);     input_has_ellipsis->resize(num_inputs);     for (int i = 0; i < num_inputs; ++i) {       input_label_counts->at(i).resize(num_labels);       for (const int label : input_labels->at(i)) {         if (label != kEllipsisLabel)           input_label_counts->at(i)[label] += 1;         else           input_has_ellipsis->at(i) = true;       }     }     output_label_counts->resize(num_labels);     for (const int label : *output_labels) {       if (label != kEllipsisLabel)         output_label_counts->at(label) += 1;       else         *output_has_ellipsis = true;     }      // Map each label to a unique DimensionType.     label_types->resize(num_labels);     for (int label = 0; label < num_labels; ++label) {       if (label == kEllipsisLabel) continue;       bool removed = (*output_label_counts)[label] == 0;       bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||                     (*input_label_counts)[1][label] == 0;       (*label_types)[label] = GetDimensionType(removed, unique);     }     return Status::OK();   }"
"197359_CWE-703.cc","CWE-703","Status AutoParallel::Initialize(const GrapplerItem& item) {   num_gpus_ = GetNumAvailableGPUs();   LOG(INFO) << ""Number of GPUs: "" << num_gpus_;   item_ = &item;   graph_ = item.graph;   LOG(INFO) << ""Original graph size: "" << graph_.node_size();   if (item.fetch.empty()) {     return Status(error::INVALID_ARGUMENT, ""No fetch nodes provided."");   }    if (item.MainVariables().empty()) {     return Status(error::INVALID_ARGUMENT, ""No variables provided."");   }    for (const auto& init : item.init_ops) {     VLOG(1) << ""Init node: "" << init;   }    for (const auto& fetch : item.fetch) {     VLOG(1) << ""Fetch node: "" << fetch;   }    for (const auto& var : item.MainVariables()) {     VLOG(2) << ""Variable: "" << var->name();   }    const std::set<string> apply_gradients_ops = {""ApplyGradientDescent"",                                                 ""ApplyProximalGradientDescent"",                                                 ""ApplyAdadelta"",                                                 ""ApplyAdagrad"",                                                 ""ApplyProximalAdagrad"",                                                 ""ApplyAdagradDA"",                                                 ""ApplyFtrl"",                                                 ""ApplyMomentum"",                                                 ""ApplyAdam"",                                                 ""ApplyRMSProp"",                                                 ""ApplyCenteredRMSProp""};   for (int i = 0; i < graph_.node_size(); i++) {     all_nodes_.insert(         std::make_pair(graph_.node(i).name(), graph_.mutable_node(i)));     if (apply_gradients_ops.find(graph_.node(i).op()) !=         apply_gradients_ops.end()) {       apply_gradients_nodes_.insert(graph_.node(i).name());       VLOG(2) << ""Apply gradients node: "" << graph_.node(i).name();     }   }    auto div_const_node = AddNodeDivConst();   all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node));   std::map<string, int> gradient_pos = {{""ApplyGradientDescent"", 2},                                         {""ApplyProximalGradientDescent"", 4},                                         {""ApplyAdadelta"", 6},                                         {""ApplyAdagrad"", 3},                                         {""ApplyProximalAdagrad"", 5},                                         {""ApplyAdagradDA"", 3},                                         {""ApplyFtrl"", 3},                                         {""ApplyMomentum"", 3},                                         {""ApplyAdam"", 9},                                         {""ApplyRMSProp"", 7},                                         {""ApplyCenteredRMSProp"", 8}};   for (const auto& apply_gradient_node_name : apply_gradients_nodes_) {     auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op();     auto apply_gradients_node = all_nodes_[apply_gradient_node_name];      auto div_node = AddNodeDiv(         apply_gradient_node_name,         apply_gradients_node->input(gradient_pos[apply_gradients_op]),         div_const_node->name());     all_nodes_.insert(std::make_pair(div_node->name(), div_node));     *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =         div_node->name();   }   LOG(INFO) << ""Graph size after adding div nodes: "" << all_nodes_.size();    std::vector<const NodeDef*> train_nodes;   TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));   LOG(INFO) << ""Number of training nodes: "" << train_nodes.size();    const NodeDef* dequeue_node;   for (const auto& train_node : train_nodes) {     if (IsDequeueOp(*train_node)) {       dequeue_node = train_node;       break;     }   }    std::vector<const NodeDef*> input_nodes;   if (dequeue_node) {     LOG(INFO) << ""Dequeue node: "" << dequeue_node->name();     TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()},                                               {}, &input_nodes));   }   LOG(INFO) << ""Number of input nodes: "" << input_nodes.size();    std::set<string> dont_replicate_nodes;   for (const auto& variable : item.MainVariables()) {     dont_replicate_nodes.insert(variable->name());   }    for (const auto& init : item.init_ops) {     dont_replicate_nodes.insert(NodeName(init));   }    // Don't replicate all input nodes, except the dequeue node.   for (const auto& input_node : input_nodes) {     if (input_node->name() != dequeue_node->name()) {       dont_replicate_nodes.insert(input_node->name());     }   }    for (const auto& node : train_nodes) {     if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) {       replica_nodes_.insert(node->name());     }   }   LOG(INFO) << ""Number of replica nodes: "" << replica_nodes_.size();    for (const auto& node : all_nodes_) {     if (replica_nodes_.find(node.first) == replica_nodes_.end()) {       shared_nodes_.insert(node.first);     }   }   LOG(INFO) << ""Number of shared nodes: "" << shared_nodes_.size();   return Status::OK(); }"
"197395_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* context) override {     const Tensor& input = context->input(0);     const Tensor& dims = context->input(1);      if (TensorShapeUtils::IsScalar(input.shape())) {       context->set_output(0, input);     } else {       const int input_dims = input.dims();       OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),                   errors::InvalidArgument(""'dims' must be 1-dimension, not "",                                           dims.dims()));        OP_REQUIRES(           context, input_dims == dims.dim_size(0),           errors::InvalidArgument(               ""'dims' must have the same number of values as 'input' has ""               ""dimensions. 'input' has "",               input_dims, ""'dims' has "", dims.dim_size(0), "" values""));       OP_REQUIRES(context, input_dims <= 8,                   errors::Unimplemented(                       ""reverse is not implemented for tensors of rank > 8.""));        Tensor* output = nullptr;       OP_REQUIRES_OK(context,                      context->allocate_output(0, input.shape(), &output));  #define HANDLE_REVERSE(NDIMS)                                               \   case NDIMS:                                                               \     HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \     return;        switch (input_dims) {         HANDLE_REVERSE(0);         HANDLE_REVERSE(1);         HANDLE_REVERSE(2);         HANDLE_REVERSE(3);         HANDLE_REVERSE(4);         HANDLE_REVERSE(5);         HANDLE_REVERSE(6);         HANDLE_REVERSE(7);         HANDLE_REVERSE(8);       } #undef HANDLE_REVERSE     }   }"
"197466_CWE-476.cc","CWE-476","void RestoreTensor(OpKernelContext* context,                    checkpoint::TensorSliceReader::OpenTableFunction open_func,                    int preferred_shard, bool restore_slice, int restore_index) {   const Tensor& file_pattern_t = context->input(0);   {     const int64_t size = file_pattern_t.NumElements();     OP_REQUIRES(         context, size == 1,         errors::InvalidArgument(             ""Input 0 (file_pattern) must be a string scalar; got a tensor of "",             size, ""elements""));   }   const string& file_pattern = file_pattern_t.flat<tstring>()(0);    const Tensor& tensor_name_t = context->input(1);   const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);    // If we cannot find a cached reader we will allocate our own.   std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;    const checkpoint::TensorSliceReader* reader = nullptr;    if (context->slice_reader_cache()) {     reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,                                                       preferred_shard);   }   if (!reader) {     allocated_reader.reset(new checkpoint::TensorSliceReader(         file_pattern, open_func, preferred_shard));     reader = allocated_reader.get();   }   OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());    // Get the shape and type from the save file.   DataType type;   TensorShape saved_shape;   OP_REQUIRES(       context, reader->HasTensor(tensor_name, &saved_shape, &type),       errors::NotFound(""Tensor name \"""", tensor_name,                        ""\"" not found in checkpoint files "", file_pattern));   OP_REQUIRES(       context, type == context->expected_output_dtype(restore_index),       errors::InvalidArgument(""Expected to restore a tensor of type "",                               DataTypeString(context->expected_output_dtype(0)),                               "", got a tensor of type "", DataTypeString(type),                               "" instead: tensor_name = "", tensor_name));    // Shape of the output and slice to load.   TensorShape output_shape(saved_shape);   TensorSlice slice_to_load(saved_shape.dims());   if (restore_slice) {     const tstring& shape_spec =         context->input(2).flat<tstring>()(restore_index);     if (!shape_spec.empty()) {       TensorShape parsed_shape;       OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(                                   shape_spec, &parsed_shape, &slice_to_load,                                   &output_shape));       OP_REQUIRES(           context, parsed_shape.IsSameSize(saved_shape),           errors::InvalidArgument(               ""Shape in shape_and_slice spec does not match the shape in the ""               ""save file: "",               parsed_shape.DebugString(),               "", save file shape: "", saved_shape.DebugString()));     }   }    Tensor* t = nullptr;   OP_REQUIRES_OK(context,                  context->allocate_output(restore_index, output_shape, &t));    if (output_shape.num_elements() == 0) return;  #define READER_COPY(T)                                                \   case DataTypeToEnum<T>::value:                                      \     OP_REQUIRES(context,                                              \                 reader->CopySliceData(tensor_name, slice_to_load,     \                                       t->flat<T>().data()),           \                 errors::InvalidArgument(""Error copying slice data"")); \     break;    switch (type) {     TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)     default:       context->SetStatus(errors::Unimplemented(           ""Restoring data type "", DataTypeString(type), "" not yet supported""));   } #undef READER_COPY }"
"197499_CWE-416.c","CWE-416","GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com) { 	GF_Err e; 	u32 NbBits, nbFields; 	u32 i; 	GF_ChildNodeItem *last; 	u8 qp_local, qp_on, initial_qp; 	GF_FieldInfo sffield;  	memset(&sffield, 0, sizeof(GF_FieldInfo)); 	sffield.fieldIndex = field->fieldIndex; 	sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType); 	sffield.NDTtype = field->NDTtype; 	sffield.name = field->name;  	initial_qp = qp_local = qp_on = 0;  	//vector description - alloc the MF size before 	NbBits = gf_bs_read_int(bs, 5); 	nbFields = gf_bs_read_int(bs, NbBits);  	if (codec->ActiveQP) { 		initial_qp = 1; 		/*this is for QP 14*/ 		gf_bifs_dec_qp14_set_length(codec, nbFields); 	}  	if (field->fieldType != GF_SG_VRML_MFNODE) { 		e = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields); 		if (e) return e;  		for (i=0; i<nbFields; i++) { 			e = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i); 			if (e) return e; 			e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE); 			if (e) return e; 		} 	} else { 		last = NULL; 		for (i=0; i<nbFields; i++) { 			GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype); 			if (new_node) { 				e = gf_node_register(new_node, is_mem_com ? NULL : node); 				if (e) return e;  				if (node) { 					/*special case for QP, register as the current QP*/ 					if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) { 						qp_local = ((M_QuantizationParameter *)new_node)->isLocal; 						/*we have a QP in the same scope, remove previous 						NB: we assume this is the right behavior, the spec doesn't say 						whether QP is cumulative or not*/ 						if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);  						e = gf_bifs_dec_qp_set(codec, new_node); 						if (e) return e; 						qp_on = 1; 						if (qp_local) qp_local = 2; 						if (codec->force_keep_qp) { 							e = gf_node_list_add_child_last(field->far_ptr, new_node, &last); 							if (e) return e; 						} else { 							gf_node_register(new_node, NULL); 							gf_node_unregister(new_node, node); 						} 					} else { 						e = gf_node_list_add_child_last(field->far_ptr, new_node, &last); 						if (e) return e; 					} 				} 				/*proto coding*/ 				else if (codec->pCurrentProto) { 					/*TO DO: what happens if this is a QP node on the interface ?*/ 					e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last); 					if (e) return e; 				} 			} else { 				return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM; 			} 		} 		/*according to the spec, the QP applies to the current node itself, not just children. 		If IsLocal is TRUE remove the node*/ 		if (qp_on && qp_local) { 			if (qp_local == 2) { //				qp_local = 1; 			} else { 				//ask to get rid of QP and reactivate if we had a QP when entering the node 				gf_bifs_dec_qp_remove(codec, initial_qp); //				qp_local = 0; 			} 		} 	} 	/*finally delete the QP if any (local or not) as we get out of this node*/ 	if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE); 	return GF_OK; }"
"197511_CWE-787.cpp","CWE-787","void HierarchicalBitmapRequester::PrepareForDecoding(void) { #if ACCUSOFT_CODE    UBYTE i;    BuildCommon();    if (m_ppDecodingMCU == NULL) {     m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);     memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);   }    if (m_ppUpsampler == NULL) {     m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);     memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);      for(i = 0;i < m_ucCount;i++) {       class Component *comp = m_pFrame->ComponentOf(i);       UBYTE sx = comp->SubXOf();       UBYTE sy = comp->SubYOf();        if (sx > 1 || sy > 1) {         m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,                                                           m_ulPixelWidth,m_ulPixelHeight,                                                           m_pFrame->TablesOf()->isChromaCentered());         m_bSubsampling   = true;       }     }   }    if (m_pLargestScale)     m_pLargestScale->PrepareForDecoding(); #endif }"
"197517_CWE-787.c","CWE-787","static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {   json_t * j_error = json_array(), * j_return;   cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;   int i, ret;   char * message = NULL;   gnutls_pubkey_t pubkey = NULL;   gnutls_x509_crt_t cert = NULL;   gnutls_datum_t cert_dat, data, signature, cert_issued_by;   unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];   size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;      if (j_error != NULL) {     do {       if (gnutls_x509_crt_init(&cert)) {         json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_x509_crt_init""));         break;       }       if (gnutls_pubkey_init(&pubkey)) {         json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_pubkey_init""));         break;       }              // Step 1       if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {         json_array_append_new(j_error, json_string(""CBOR map value 'attStmt' invalid format""));         break;       }       for (i=0; i<2; i++) {         key = cbor_map_handle(att_stmt)[i].key;         if (cbor_isa_string(key)) {           if (0 == o_strncmp((const char *)cbor_string_handle(key), ""x5c"", MIN(o_strlen(""x5c""), cbor_string_length(key)))) {             x5c = cbor_map_handle(att_stmt)[i].value;           } else if (0 == o_strncmp((const char *)cbor_string_handle(key), ""sig"", MIN(o_strlen(""sig""), cbor_string_length(key)))) {             sig = cbor_map_handle(att_stmt)[i].value;           } else {             message = msprintf(""attStmt map element %d key is not valid: '%.*s'"", i, cbor_string_length(key), cbor_string_handle(key));             json_array_append_new(j_error, json_string(message));             o_free(message);             break;           }         } else {           message = msprintf(""attStmt map element %d key is not a string"", i);           json_array_append_new(j_error, json_string(message));           o_free(message);           break;         }       }       if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {         json_array_append_new(j_error, json_string(""CBOR map value 'x5c' invalid format""));         break;       }       att_cert = cbor_array_get(x5c, 0);       cert_dat.data = cbor_bytestring_handle(att_cert);       cert_dat.size = cbor_bytestring_length(att_cert);       if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {         json_array_append_new(j_error, json_string(""Error importing x509 certificate""));         y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d"", ret);         break;       }       if (json_object_get(j_params, ""root-ca-list"") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {         json_array_append_new(j_error, json_string(""Unrecognized certificate authority""));         if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {           message = msprintf(""Unrecognized certificate autohority: %.*s"", cert_issued_by.size, cert_issued_by.data);           y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - %s"", message);           o_free(message);           gnutls_free(cert_issued_by.data);         } else {           y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)"");         }         break;       }       if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {         json_array_append_new(j_error, json_string(""Error importing x509 certificate""));         y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d"", ret);         break;       }       if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {         json_array_append_new(j_error, json_string(""Error exporting x509 certificate""));         y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d"", ret);         break;       }       if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {         json_array_append_new(j_error, json_string(""Internal error""));         y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error o_base64_encode cert_export"");         break;       }       if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {         json_array_append_new(j_error, json_string(""Internal error""));         y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error generate_digest_raw client_data"");         break;       }        if (sig == NULL || !cbor_isa_bytestring(sig)) {         json_array_append_new(j_error, json_string(""Error sig is not a bytestring""));         break;       }              // Build bytestring to verify signature       data_signed[0] = 0x0;       data_signed_offset = 1;              memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);       data_signed_offset += rpid_hash_len;              memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);       data_signed_offset+=client_data_hash_len;              memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);       data_signed_offset+=credential_id_len;              data_signed[data_signed_offset] = 0x04;       data_signed_offset++;              memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);       data_signed_offset+=cert_x_len;              memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);       data_signed_offset+=cert_y_len;                // Let's verify sig over data_signed       data.data = data_signed;       data.size = data_signed_offset;              signature.data = cbor_bytestring_handle(sig);       signature.size = cbor_bytestring_length(sig);              if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {         json_array_append_new(j_error, json_string(""Invalid signature""));       }            } while (0);          if (json_array_size(j_error)) {       j_return = json_pack(""{sisO}"", ""result"", G_ERROR_PARAM, ""error"", j_error);     } else {       j_return = json_pack(""{sis{ss%}}"", ""result"", G_OK, ""data"", ""certificate"", cert_export_b64, cert_export_b64_len);     }     json_decref(j_error);     gnutls_pubkey_deinit(pubkey);     gnutls_x509_crt_deinit(cert);     if (att_cert != NULL) {       cbor_decref(&att_cert);     }        } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error allocating resources for j_error"");     j_return = json_pack(""{si}"", ""result"", G_ERROR);   }   return j_return; }"
"197518_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     const Tensor& gradient = ctx->input(0);     const Tensor& input = ctx->input(1);     Tensor* input_backprop = nullptr;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(0, input.shape(), &input_backprop));     OP_REQUIRES(         ctx, axis_ >= -1,         errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));     OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),                 errors::InvalidArgument(                     ""Axis should be -1 or 0 or a positive value less than "",                     input.shape().dims(), ""but given axis value was "", axis_));      OP_REQUIRES(         ctx, input.IsSameSize(gradient),         errors::InvalidArgument(""gradient and input must be the same size""));     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);     const Tensor& input_min_tensor = ctx->input(2);     OP_REQUIRES(ctx,                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,                 errors::InvalidArgument(                     ""Input min tensor must have dimension 1. Recieved "",                     input_min_tensor.dims(), "".""));     const Tensor& input_max_tensor = ctx->input(3);     OP_REQUIRES(ctx,                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,                 errors::InvalidArgument(                     ""Input max tensor must have dimension 1. Recieved "",                     input_max_tensor.dims(), "".""));     if (axis_ != -1) {       OP_REQUIRES(           ctx, input_min_tensor.dim_size(0) == depth,           errors::InvalidArgument(""min has incorrect size, expected "", depth,                                   "" was "", input_min_tensor.dim_size(0)));       OP_REQUIRES(           ctx, input_max_tensor.dim_size(0) == depth,           errors::InvalidArgument(""max has incorrect size, expected "", depth,                                   "" was "", input_max_tensor.dim_size(0)));     }      TensorShape min_max_shape(input_min_tensor.shape());     Tensor* input_min_backprop;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(1, min_max_shape, &input_min_backprop));      Tensor* input_max_backprop;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));      if (axis_ == -1) {       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),         input.template flat<T>(), input_min_tensor.scalar<T>(),         input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),         input_min_backprop->template scalar<T>(),         input_max_backprop->template scalar<T>());     } else {       functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;       f(ctx->eigen_device<Device>(),         gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),         input.template flat_inner_outer_dims<T, 3>(axis_ - 1),         &input_min_tensor, &input_max_tensor,         input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),         input_min_backprop->template flat<T>(),         input_max_backprop->template flat<T>());     }   }"
"197565_CWE-787.c","CWE-787","static int MqttClient_WaitType(MqttClient *client, void *packet_obj,     byte wait_type, word16 wait_packet_id, int timeout_ms) {     int rc;     word16 packet_id;     MqttPacketType packet_type; #ifdef WOLFMQTT_MULTITHREAD     MqttPendResp *pendResp;     int readLocked; #endif     MqttMsgStat* mms_stat;     int waitMatchFound;      if (client == NULL || packet_obj == NULL) {         return MQTT_CODE_ERROR_BAD_ARG;     }      /* all packet type structures must have MqttMsgStat at top */     mms_stat = (MqttMsgStat*)packet_obj;  wait_again:      /* initialize variables */     packet_id = 0;     packet_type = MQTT_PACKET_TYPE_RESERVED; #ifdef WOLFMQTT_MULTITHREAD     pendResp = NULL;     readLocked = 0; #endif     waitMatchFound = 0;  #ifdef WOLFMQTT_DEBUG_CLIENT     PRINTF(""MqttClient_WaitType: Type %s (%d), ID %d"",         MqttPacket_TypeDesc((MqttPacketType)wait_type),             wait_type, wait_packet_id); #endif      switch ((int)*mms_stat)     {         case MQTT_MSG_BEGIN:         {         #ifdef WOLFMQTT_MULTITHREAD             /* Lock recv socket mutex */             rc = wm_SemLock(&client->lockRecv);             if (rc != 0) {                 PRINTF(""MqttClient_WaitType: recv lock error!"");                 return rc;             }             readLocked = 1;         #endif              /* reset the packet state */             client->packet.stat = MQTT_PK_BEGIN;         }         FALL_THROUGH;      #ifdef WOLFMQTT_V5         case MQTT_MSG_AUTH:     #endif         case MQTT_MSG_WAIT:         {         #ifdef WOLFMQTT_MULTITHREAD             /* Check to see if packet type and id have already completed */             pendResp = NULL;             rc = wm_SemLock(&client->lockClient);             if (rc == 0) {                 if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,                      wait_packet_id, &pendResp)) {                     if (pendResp->packetDone) {                         /* pending response is already done, so return */                         rc = pendResp->packet_ret;                     #ifdef WOLFMQTT_DEBUG_CLIENT                         PRINTF(""PendResp already Done %p: Rc %d"", pendResp, rc);                     #endif                         MqttClient_RespList_Remove(client, pendResp);                         wm_SemUnlock(&client->lockClient);                         wm_SemUnlock(&client->lockRecv);                         return rc;                     }                 }                 wm_SemUnlock(&client->lockClient);             }             else {                 break; /* error */             }         #endif /* WOLFMQTT_MULTITHREAD */              *mms_stat = MQTT_MSG_WAIT;              /* Wait for packet */             rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,                     timeout_ms);             /* handle failure */             if (rc <= 0) {                 break;             }              /* capture length read */             client->packet.buf_len = rc;              /* Decode Packet - get type and id */             rc = MqttClient_DecodePacket(client, client->rx_buf,                 client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);             if (rc < 0) {                 break;             }          #ifdef WOLFMQTT_DEBUG_CLIENT             PRINTF(""Read Packet: Len %d, Type %d, ID %d"",                 client->packet.buf_len, packet_type, packet_id);         #endif              *mms_stat = MQTT_MSG_READ;         }         FALL_THROUGH;          case MQTT_MSG_READ:         case MQTT_MSG_READ_PAYLOAD:         {             MqttPacketType use_packet_type;             void* use_packet_obj;          #ifdef WOLFMQTT_MULTITHREAD             readLocked = 1; /* if in this state read is locked */         #endif              /* read payload state only happens for publish messages */             if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {                 packet_type = MQTT_PACKET_TYPE_PUBLISH;             }              /* Determine if we received data for this request */             if ((wait_type == MQTT_PACKET_TYPE_ANY ||                  wait_type == packet_type ||                  MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&                (wait_packet_id == 0 || wait_packet_id == packet_id))             {                 use_packet_obj = packet_obj;                 waitMatchFound = 1;             }             else {                 /* use generic packet object */                 use_packet_obj = &client->msg;             }             use_packet_type = packet_type;          #ifdef WOLFMQTT_MULTITHREAD             /* Check to see if we have a pending response for this packet */             pendResp = NULL;             rc = wm_SemLock(&client->lockClient);             if (rc == 0) {                 if (MqttClient_RespList_Find(client, packet_type, packet_id,                                                                &pendResp)) {                     /* we found packet match this incoming read packet */                     pendResp->packetProcessing = 1;                     use_packet_obj = pendResp->packet_obj;                     use_packet_type = pendResp->packet_type;                     /* req from another thread... not a match */                     waitMatchFound = 0;                 }                 wm_SemUnlock(&client->lockClient);             }             else {                 break; /* error */             }         #endif /* WOLFMQTT_MULTITHREAD */              /* Perform packet handling for publish callback and QoS */             rc = MqttClient_HandlePacket(client, use_packet_type,                 use_packet_obj, timeout_ms);          #ifdef WOLFMQTT_NONBLOCK             if (rc == MQTT_CODE_CONTINUE) {                 /* we have received some data, so keep the recv                     mutex lock active and return */                 return rc;             }         #endif              /* handle success case */             if (rc >= 0) {                 rc = MQTT_CODE_SUCCESS;             }          #ifdef WOLFMQTT_MULTITHREAD             if (pendResp) {                 /* Mark pending response entry done */                 if (wm_SemLock(&client->lockClient) == 0) {                     pendResp->packetDone = 1;                     pendResp->packet_ret = rc;                 #ifdef WOLFMQTT_DEBUG_CLIENT                     PRINTF(""PendResp Done %p"", pendResp);                 #endif                     pendResp = NULL;                     wm_SemUnlock(&client->lockClient);                 }             }         #endif /* WOLFMQTT_MULTITHREAD */             break;         }          case MQTT_MSG_WRITE:         case MQTT_MSG_WRITE_PAYLOAD:         default:         {         #ifdef WOLFMQTT_DEBUG_CLIENT             PRINTF(""MqttClient_WaitType: Invalid state %d!"", *mms_stat);         #endif             rc = MQTT_CODE_ERROR_STAT;             break;         }     } /* switch (*mms_stat) */  #ifdef WOLFMQTT_NONBLOCK     if (rc != MQTT_CODE_CONTINUE) #endif     {         /* reset state */         *mms_stat = MQTT_MSG_BEGIN;     }  #ifdef WOLFMQTT_MULTITHREAD     if (readLocked) {         wm_SemUnlock(&client->lockRecv);     } #endif     if (rc < 0) {     #ifdef WOLFMQTT_DEBUG_CLIENT         PRINTF(""MqttClient_WaitType: Failure: %s (%d)"",             MqttClient_ReturnCodeToString(rc), rc);     #endif         return rc;     }      if (!waitMatchFound) {         /* if we get here, then the we are still waiting for a packet */         goto wait_again;     }      return rc; }"
"197593_CWE-416.c","CWE-416","njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc) {     size_t              value_count, n;     njs_value_t         *start, *end, *p, **new, *value, **local;     njs_function_t      *function;     njs_native_frame_t  *active, *native;      *frame = *vm->active_frame;     frame->previous_active_frame = NULL;      native = &frame->native;      active = &vm->active_frame->native;     value_count = njs_function_frame_value_count(active);      function = active->function;      new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);     value = (njs_value_t *) (new + value_count                              + function->u.lambda->temp);       native->arguments = value;     native->arguments_offset = value + (function->args_offset - 1);     native->local = new + njs_function_frame_args_count(active);     native->temp = new + value_count;     native->pc = pc;      start = njs_function_frame_values(active, &end);     p = native->arguments;      while (start < end) {         *p = *start++;         *new++ = p++;     }      /* Move all arguments. */      p = native->arguments;     local = native->local + function->args_offset;      for (n = 0; n < function->args_count; n++) {         if (!njs_is_valid(p)) {             njs_set_undefined(p);         }          *local++ = p++;     }      return NJS_OK; }"
"197615_CWE-345.cc","CWE-345","Status TensorSliceReader::GetTensor(     const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {   DataType type;   TensorShape shape;   TensorSlice slice;   {     mutex_lock l(mu_);     const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);     if (tss == nullptr) {       return errors::NotFound(name, "" not found in checkpoint file"");     }      if (tss->Slices().size() > 1) {       // TODO(sherrym): Support multi-slice checkpoints.       return errors::Unimplemented(""Sliced checkpoints are not supported"");     }      type = tss->type();     shape = tss->shape();     slice = tss->Slices().begin()->second.slice;   }    std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));   bool success = false;  #define READER_COPY(dt)                                                  \   case dt:                                                               \     success = CopySliceData(name, slice,                                 \                             t->flat<EnumToDataType<dt>::Type>().data()); \     break;    switch (type) {     READER_COPY(DT_FLOAT);     READER_COPY(DT_DOUBLE);     READER_COPY(DT_INT32);     READER_COPY(DT_UINT8);     READER_COPY(DT_INT16);     READER_COPY(DT_INT8);     READER_COPY(DT_INT64);     READER_COPY(DT_STRING);     default:       return errors::Unimplemented(""Data type not supported"");   } #undef READER_COPY    if (!success) {     return errors::NotFound(name, "" not found in checkpoint file"");   }   std::swap(*out_tensor, t);    return Status::OK(); }"
"197621_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* const context) override {     // node_id_range     const Tensor* node_id_range_t;     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));     const auto node_id_range = node_id_range_t->vec<int32>();     const int32_t node_id_first = node_id_range(0);  // inclusive     const int32_t node_id_last = node_id_range(1);   // exclusive      const Tensor* stats_summary_indices_t;     OP_REQUIRES_OK(context, context->input(""stats_summary_indices"",                                            &stats_summary_indices_t));     const auto stats_summary_indices = stats_summary_indices_t->matrix<int32>();     const int32_t num_sparse_entries = stats_summary_indices_t->dim_size(0);      const Tensor* stats_summary_values_t;     OP_REQUIRES_OK(context, context->input(""stats_summary_values"",                                            &stats_summary_values_t));     const auto stats_summary_values = stats_summary_values_t->vec<float>();      const Tensor* stats_summary_shape_t;     OP_REQUIRES_OK(         context, context->input(""stats_summary_shape"", &stats_summary_shape_t));     const auto stats_summary_shape = stats_summary_shape_t->vec<int32>();     const int32_t num_buckets = stats_summary_shape(2) - 1;     const int32_t stats_dims = stats_summary_shape(3);      const Tensor* l1_t;     OP_REQUIRES_OK(context, context->input(""l1"", &l1_t));     const auto l1 = l1_t->scalar<float>()();      const Tensor* l2_t;     OP_REQUIRES_OK(context, context->input(""l2"", &l2_t));     const auto l2 = l2_t->scalar<float>()();      const Tensor* tree_complexity_t;     OP_REQUIRES_OK(context,                    context->input(""tree_complexity"", &tree_complexity_t));     const auto tree_complexity = tree_complexity_t->scalar<float>()();      const Tensor* min_node_weight_t;     OP_REQUIRES_OK(context,                    context->input(""min_node_weight"", &min_node_weight_t));     const auto min_node_weight = min_node_weight_t->scalar<float>()();      std::vector<int32> output_node_ids;     std::vector<float> output_gains;     std::vector<int32> output_feature_dimensions;     std::vector<int32> output_thresholds;     std::vector<float> output_left_node_contribs;     std::vector<float> output_right_node_contribs;     std::vector<string> output_split_types;      FeatureMap f_map;      int32_t previous_node_id = -1;     for (int idx = 0; idx < num_sparse_entries; ++idx) {       int32_t node_id = stats_summary_indices(idx, 0);       if (node_id != previous_node_id) {         process_node(f_map, &output_node_ids, &output_gains,                      &output_feature_dimensions, &output_thresholds,                      &output_left_node_contribs, &output_right_node_contribs,                      &output_split_types, previous_node_id, min_node_weight, l1,                      l2, num_buckets);         f_map.clear();       }       previous_node_id = node_id;       DCHECK_LE(node_id_first, node_id);       DCHECK_LT(node_id, node_id_last);       const int32_t feature_dim = stats_summary_indices(idx, 1);       const int32_t bucket_id = stats_summary_indices(idx, 2);       const int32_t stat_dim = stats_summary_indices(idx, 3);       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(           FeatureMapIterator::value_type(feature_dim, BucketMap()));       auto& b_map = f_insert_result.first->second;       std::pair<BucketMapIterator, bool> const& b_insert_result =           b_map.insert(BucketMapIterator::value_type(               bucket_id, std::vector<float>(stats_dims)));       auto& stats = b_insert_result.first->second;       stats[stat_dim] = stats_summary_values(idx);     }  // for node_id     // process the last node id     process_node(f_map, &output_node_ids, &output_gains,                  &output_feature_dimensions, &output_thresholds,                  &output_left_node_contribs, &output_right_node_contribs,                  &output_split_types, previous_node_id, min_node_weight, l1, l2,                  num_buckets);      const int num_nodes = output_node_ids.size();     // output_node_ids     Tensor* output_node_ids_t = nullptr;     OP_REQUIRES_OK(context, context->allocate_output(""node_ids"", {num_nodes},                                                      &output_node_ids_t));     auto output_node_ids_vec = output_node_ids_t->vec<int32>();      // output_gains     Tensor* output_gains_t;     OP_REQUIRES_OK(context, context->allocate_output(""gains"", {num_nodes},                                                      &output_gains_t));     auto output_gains_vec = output_gains_t->vec<float>();      // output_feature_dimensions     Tensor* output_feature_dimension_t;     OP_REQUIRES_OK(context,                    context->allocate_output(""feature_dimensions"", {num_nodes},                                             &output_feature_dimension_t));     auto output_feature_dimensions_vec =         output_feature_dimension_t->vec<int32>();      // output_thresholds     Tensor* output_thresholds_t;     OP_REQUIRES_OK(context, context->allocate_output(""thresholds"", {num_nodes},                                                      &output_thresholds_t));     auto output_thresholds_vec = output_thresholds_t->vec<int32>();      // output_left_node_contribs     Tensor* output_left_node_contribs_t;     OP_REQUIRES_OK(         context, context->allocate_output(""left_node_contribs"", {num_nodes, 1},                                           &output_left_node_contribs_t));     auto output_left_node_contribs_matrix =         output_left_node_contribs_t->matrix<float>();      // output_right_node_contribs     Tensor* output_right_node_contribs_t;     OP_REQUIRES_OK(         context, context->allocate_output(""right_node_contribs"", {num_nodes, 1},                                           &output_right_node_contribs_t));     auto output_right_node_contribs_matrix =         output_right_node_contribs_t->matrix<float>();      // split type     Tensor* output_split_types_t;     OP_REQUIRES_OK(         context, context->allocate_output(""split_with_default_directions"",                                           {num_nodes}, &output_split_types_t));     auto output_split_types_vec = output_split_types_t->vec<tstring>();      // Sets output tensors from vectors.     for (int i = 0; i < num_nodes; ++i) {       output_node_ids_vec(i) = output_node_ids[i];       // Adjust the gains to penalize by tree complexity.       output_gains_vec(i) = output_gains[i] - tree_complexity;       output_feature_dimensions_vec(i) = output_feature_dimensions[i];       output_thresholds_vec(i) = output_thresholds[i];       // TODO(crawles): change this for multi-class.       output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];       output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];       output_split_types_vec(i) = output_split_types[i];     }   }"
"197632_CWE-269.c","CWE-269","njs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,     njs_value_t *fulfilled, njs_value_t *rejected,     njs_promise_capability_t *capability) {     njs_int_t               ret;     njs_value_t             arguments[2];     njs_promise_t           *promise;     njs_function_t          *function;     njs_promise_data_t      *data;     njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;      if (!njs_is_function(fulfilled)) {         fulfilled = njs_value_arg(&njs_value_undefined);     }      if (!njs_is_function(rejected)) {         rejected = njs_value_arg(&njs_value_undefined);     }      promise = njs_promise(value);     data = njs_data(&promise->value);      fulfilled_reaction = njs_mp_alloc(vm->mem_pool,                                       sizeof(njs_promise_reaction_t));     if (njs_slow_path(fulfilled_reaction == NULL)) {         njs_memory_error(vm);         return NJS_ERROR;     }      fulfilled_reaction->capability = capability;     fulfilled_reaction->handler = *fulfilled;     fulfilled_reaction->type = NJS_PROMISE_FULFILL;      rejected_reaction = njs_mp_alloc(vm->mem_pool,                                      sizeof(njs_promise_reaction_t));     if (njs_slow_path(rejected_reaction == NULL)) {         njs_memory_error(vm);         return NJS_ERROR;     }      rejected_reaction->capability = capability;     rejected_reaction->handler = *rejected;     rejected_reaction->type = NJS_PROMISE_REJECTED;      if (data->state == NJS_PROMISE_PENDING) {         njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);         njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);      } else {         function = njs_promise_create_function(vm,                                                sizeof(njs_promise_context_t));         function->u.native = njs_promise_reaction_job;          if (data->state == NJS_PROMISE_REJECTED) {             njs_set_data(&arguments[0], rejected_reaction, 0);              ret = njs_promise_host_rejection_tracker(vm, promise,                                                      NJS_PROMISE_HANDLE);             if (njs_slow_path(ret != NJS_OK)) {                 return ret;             }          } else {             njs_set_data(&arguments[0], fulfilled_reaction, 0);         }          arguments[1] = data->result;          ret = njs_promise_add_event(vm, function, arguments, 2);         if (njs_slow_path(ret != NJS_OK)) {             return ret;         }     }      data->is_handled = 1;      if (capability == NULL) {         njs_vm_retval_set(vm, &njs_value_undefined);      } else {         njs_vm_retval_set(vm, &capability->promise);     }      return NJS_OK; }"
"197666_CWE-703.c","CWE-703","njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,     njs_iterator_handler_t handler) {     double              idx;     int64_t             i, from, to, length;     njs_int_t           ret;     njs_array_t         *array, *keys;     njs_value_t         *entry, *value, prop, character, string_obj;     const u_char        *p, *end, *pos;     njs_string_prop_t   string_prop;     njs_object_value_t  *object;      value = args->value;     from = args->from;     to = args->to;      if (njs_is_array(value)) {         array = njs_array(value);          from += 1;          while (from-- > to) {             if (njs_slow_path(!array->object.fast_array)) {                 goto process_object;             }              if (njs_fast_path(from < array->length                               && njs_is_valid(&array->start[from])))             {                 ret = handler(vm, args, &array->start[from], from);              } else {                 entry = njs_value_arg(&njs_value_invalid);                 ret = njs_value_property_i64(vm, value, from, &prop);                 if (njs_slow_path(ret != NJS_DECLINED)) {                     if (ret == NJS_ERROR) {                         return NJS_ERROR;                     }                      entry = &prop;                 }                  ret = handler(vm, args, entry, from);             }              if (njs_slow_path(ret != NJS_OK)) {                 if (ret == NJS_DONE) {                     return NJS_DONE;                 }                  return NJS_ERROR;             }         }          return NJS_OK;     }      if (njs_is_string(value) || njs_is_object_string(value)) {          if (njs_is_string(value)) {             object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);             if (njs_slow_path(object == NULL)) {                 return NJS_ERROR;             }              njs_set_object_value(&string_obj, object);              args->value = &string_obj;         }         else {             value = njs_object_value(value);         }          length = njs_string_prop(&string_prop, value);         end = string_prop.start + string_prop.size;          if ((size_t) length == string_prop.size) {             /* Byte or ASCII string. */              p = string_prop.start + from;              i = from + 1;              while (i-- > to) {                 /* This cannot fail. */                 (void) njs_string_new(vm, &character, p, 1, 1);                  ret = handler(vm, args, &character, i);                 if (njs_slow_path(ret != NJS_OK)) {                     if (ret == NJS_DONE) {                         return NJS_DONE;                     }                      return NJS_ERROR;                 }                  p--;             }          } else {             /* UTF-8 string. */              p = njs_string_offset(string_prop.start, end, from);             p = njs_utf8_next(p, end);              i = from + 1;              while (i-- > to) {                 pos = njs_utf8_prev(p);                  /* This cannot fail. */                 (void) njs_string_new(vm, &character, pos, p - pos , 1);                  ret = handler(vm, args, &character, i);                 if (njs_slow_path(ret != NJS_OK)) {                     if (ret == NJS_DONE) {                         return NJS_DONE;                     }                      return NJS_ERROR;                 }                  p = pos;             }         }          return NJS_OK;     }      if (!njs_is_object(value)) {         return NJS_OK;     }  process_object:      if (!njs_fast_object(from - to)) {         keys = njs_array_indices(vm, value);         if (njs_slow_path(keys == NULL)) {             return NJS_ERROR;         }          i = keys->length;          while (i > 0) {             idx = njs_string_to_index(&keys->start[--i]);              if (idx < to || idx > from) {                 continue;             }              ret = njs_iterator_object_handler(vm, handler, args,                                               &keys->start[i], idx);             if (njs_slow_path(ret != NJS_OK)) {                 njs_array_destroy(vm, keys);                 return ret;             }         }          njs_array_destroy(vm, keys);          return NJS_OK;     }      i = from + 1;      while (i-- > to) {         ret = njs_iterator_object_handler(vm, handler, args, NULL, i);         if (njs_slow_path(ret != NJS_OK)) {             return ret;         }     }      return NJS_OK; }"
"197719_CWE-125.cc","CWE-125","  void Compute(OpKernelContext* context) override {     // Read ragged_splits inputs.     OpInputList ragged_nested_splits_in;     OP_REQUIRES_OK(context, context->input_list(""rt_nested_splits"",                                                 &ragged_nested_splits_in));     const int ragged_nested_splits_len = ragged_nested_splits_in.size();     RaggedTensorVariant batched_ragged_input;     // Read ragged_values input.     batched_ragged_input.set_values(context->input(ragged_nested_splits_len));     batched_ragged_input.mutable_nested_splits()->reserve(         ragged_nested_splits_len);     for (int i = 0; i < ragged_nested_splits_len; i++) {       batched_ragged_input.append_splits(ragged_nested_splits_in[i]);     }      if (!batched_input_) {       // Encode as a Scalar Variant Tensor.       Tensor* encoded_scalar;       OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),                                                        &encoded_scalar));       encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);       return;     }      // Unbatch the Ragged Tensor and encode the components.     std::vector<RaggedTensorVariant> unbatched_ragged_input;     auto batched_splits_top_vec =         batched_ragged_input.splits(0).vec<SPLIT_TYPE>();     int num_components = batched_splits_top_vec.size() - 1;     OP_REQUIRES(context, num_components >= 0,                 errors::Internal(""Invalid split argument.""));     OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(                                 batched_ragged_input, &unbatched_ragged_input));      // Bundle the encoded scalar Variant Tensors into a rank-1 Variant Tensor.     Tensor* encoded_vector;     int output_size = unbatched_ragged_input.size();     OP_REQUIRES_OK(context,                    context->allocate_output(0, TensorShape({output_size}),                                             &encoded_vector));     auto encoded_vector_t = encoded_vector->vec<Variant>();     for (int i = 0; i < output_size; i++) {       encoded_vector_t(i) = unbatched_ragged_input[i];     }   }"
"197748_CWE-703.cc","CWE-703","Status TransposeShapeFn(InferenceContext* c) {   ShapeHandle input = c->input(0);   ShapeHandle perm_shape = c->input(1);   const Tensor* perm = c->input_tensor(1);   DimensionHandle perm_elems = c->NumElements(perm_shape);   // If we don't have rank information on the input or value information on   // perm we can't return any shape information, otherwise we have enough   // information to at least find the rank of the output.   if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {     c->set_output(0, c->UnknownShape());     return Status::OK();   }    // Find our value of the rank.   int64_t rank;   if (c->RankKnown(input)) {     rank = c->Rank(input);   } else if (c->ValueKnown(perm_elems)) {     rank = c->Value(perm_elems);   } else {     rank = perm->NumElements();   }   if (!c->RankKnown(input) && rank < 2) {     // A permutation array containing a single element is ambiguous. It could     // indicate either a scalar or a 1-dimensional array, both of which the     // transpose op returns unchanged.     c->set_output(0, input);     return Status::OK();   }    std::vector<DimensionHandle> dims;   dims.resize(rank);   TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));   // Ensure that perm is a vector and has rank elements.   TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));   TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));    // If we know the rank of the input and the value of perm, we can return   // all shape information, otherwise we can only return rank information,   // but no information for the dimensions.   if (perm != nullptr) {     std::vector<int64_t> data;     if (perm->dtype() == DT_INT32) {       data = AsInt64<int32>(perm, rank);     } else {       data = AsInt64<int64_t>(perm, rank);     }      for (int32_t i = 0; i < rank; ++i) {       int64_t in_idx = data[i];       if (in_idx >= rank) {         return errors::InvalidArgument(""perm dim "", in_idx,                                        "" is out of range of input rank "", rank);       }       dims[i] = c->Dim(input, in_idx);     }   } else {     for (int i = 0; i < rank; ++i) {       dims[i] = c->UnknownDim();     }   }    c->set_output(0, c->MakeShape(dims));   return Status::OK(); }"
"197760_CWE-125.cc","CWE-125","TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,                           const TfLiteTensor* indices, TfLiteTensor* output) {   switch (params->type) {     case kTfLiteFloat32:       return GatherNd<float, IndicesT>(params, indices, output);     case kTfLiteUInt8:       return GatherNd<uint8_t, IndicesT>(params, indices, output);     case kTfLiteInt8:       return GatherNd<int8_t, IndicesT>(params, indices, output);     case kTfLiteInt16:       return GatherNd<int16_t, IndicesT>(params, indices, output);     case kTfLiteInt32:       return GatherNd<int32_t, IndicesT>(params, indices, output);     case kTfLiteInt64:       return GatherNd<int64_t, IndicesT>(params, indices, output);     case kTfLiteString:       return GatherNdString<IndicesT>(params, indices, output);     default:       context->ReportError(context,                            ""Params type '%s' are not supported by gather_nd."",                            TfLiteTypeGetName(params->type));       return kTfLiteError;   } }"
"197796_CWE-703.c","CWE-703","static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len) {     int i;     uint16_t limit;     VncDisplay *vd = vs->vd;      if (data[0] > 3) {         update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);     }      switch (data[0]) {     case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:         if (len == 1)             return 20;          set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),                          read_u8(data, 6), read_u8(data, 7),                          read_u16(data, 8), read_u16(data, 10),                          read_u16(data, 12), read_u8(data, 14),                          read_u8(data, 15), read_u8(data, 16));         break;     case VNC_MSG_CLIENT_SET_ENCODINGS:         if (len == 1)             return 4;          if (len == 4) {             limit = read_u16(data, 2);             if (limit > 0)                 return 4 + (limit * 4);         } else             limit = read_u16(data, 2);          for (i = 0; i < limit; i++) {             int32_t val = read_s32(data, 4 + (i * 4));             memcpy(data + 4 + (i * 4), &val, sizeof(val));         }          set_encodings(vs, (int32_t *)(data + 4), limit);         break;     case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:         if (len == 1)             return 10;          framebuffer_update_request(vs,                                    read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),                                    read_u16(data, 6), read_u16(data, 8));         break;     case VNC_MSG_CLIENT_KEY_EVENT:         if (len == 1)             return 8;          key_event(vs, read_u8(data, 1), read_u32(data, 4));         break;     case VNC_MSG_CLIENT_POINTER_EVENT:         if (len == 1)             return 6;          pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));         break;     case VNC_MSG_CLIENT_CUT_TEXT:         if (len == 1)             return 8;          if (len == 8) {             uint32_t dlen = read_u32(data, 4);             if (dlen > 0)                 return 8 + dlen;         }          client_cut_text(vs, read_u32(data, 4), data + 8);         break;     case VNC_MSG_CLIENT_QEMU:         if (len == 1)             return 2;          switch (read_u8(data, 1)) {         case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:             if (len == 2)                 return 12;              ext_key_event(vs, read_u16(data, 2),                           read_u32(data, 4), read_u32(data, 8));             break;         case VNC_MSG_CLIENT_QEMU_AUDIO:             if (len == 2)                 return 4;              switch (read_u16 (data, 2)) {             case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:                 audio_add(vs);                 break;             case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:                 audio_del(vs);                 break;             case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:                 if (len == 4)                     return 10;                 switch (read_u8(data, 4)) {                 case 0: vs->as.fmt = AUD_FMT_U8; break;                 case 1: vs->as.fmt = AUD_FMT_S8; break;                 case 2: vs->as.fmt = AUD_FMT_U16; break;                 case 3: vs->as.fmt = AUD_FMT_S16; break;                 case 4: vs->as.fmt = AUD_FMT_U32; break;                 case 5: vs->as.fmt = AUD_FMT_S32; break;                 default:                     printf(""Invalid audio format %d\n"", read_u8(data, 4));                     vnc_client_error(vs);                     break;                 }                 vs->as.nchannels = read_u8(data, 5);                 if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {                     printf(""Invalid audio channel coount %d\n"",                            read_u8(data, 5));                     vnc_client_error(vs);                     break;                 }                 vs->as.freq = read_u32(data, 6);                 break;             default:                 printf (""Invalid audio message %d\n"", read_u8(data, 4));                 vnc_client_error(vs);                 break;             }             break;          default:             printf(""Msg: %d\n"", read_u16(data, 0));             vnc_client_error(vs);             break;         }         break;     default:         printf(""Msg: %d\n"", data[0]);         vnc_client_error(vs);         break;     }      vnc_read_when(vs, protocol_client_msg, 1);     return 0; }"
"197801_CWE-345.h","CWE-345","bool TensorSliceReader::CopySliceData(const string& name,                                       const TensorSlice& slice, T* data) const {   std::vector<std::pair<TensorSlice, string>> details;   const TensorSliceSet* tss;   {     mutex_lock l(mu_);     tss = FindTensorSlice(name, slice, &details);     if (!tss && !all_shards_loaded_) {       VLOG(1) << ""Did not find slice in preferred shard, loading all shards.""               << name << "": "" << slice.DebugString();       LoadAllShards();       tss = FindTensorSlice(name, slice, &details);     }     if (!tss) {       // No such tensor       return false;     }   }   // We have the data -- copy it over.   string value;   for (const auto& x : details) {     const TensorSlice& slice_s = x.first;     const string& fname = x.second;     int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);     CHECK_GE(idx, 0) << ""Failed to find the index for filename "" << fname;     // We read a record in the corresponding sstable     const string key = EncodeTensorNameSlice(name, slice_s);     if (!sss_[idx]->Get(key, &value)) {       VLOG(1) << ""Failed to seek to the record for tensor "" << name               << "", slice "" << slice_s.DebugString()               << "": computed key = "" << key;       return false;     }     SavedTensorSlices sts;     if (!ParseProtoUnlimited(&sts, value)) {       VLOG(1) << ""Failed to parse the record for tensor "" << name << "", slice ""               << slice_s.DebugString() << "": computed key = "" << key;       return false;     }     CopyDataFromTensorSliceToTensorSlice(         tss->shape(), slice_s, slice,         checkpoint::TensorProtoData<T>(sts.data().data()), data);   }   return true; }"
"197808_CWE-787.c","CWE-787","mrb_f_send(mrb_state *mrb, mrb_value self) {   mrb_sym name;   mrb_value block, *regs;   mrb_method_t m;   struct RClass *c;   mrb_callinfo *ci = mrb->c->ci;   int n = ci->n;    if (ci->cci > CINFO_NONE) {   funcall:;     const mrb_value *argv;     mrb_int argc;     mrb_get_args(mrb, ""n*&"", &name, &argv, &argc, &block);     return mrb_funcall_with_block(mrb, self, name, argc, argv, block);   }    regs = mrb->c->ci->stack+1;    if (n == 0) {     mrb_argnum_error(mrb, 0, 1, -1);   }   else if (n == 15) {     name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);   }   else {     name = mrb_obj_to_sym(mrb, regs[0]);   }    c = mrb_class(mrb, self);   m = mrb_method_search_vm(mrb, &c, name);   if (MRB_METHOD_UNDEF_P(m)) {            /* call method_mising */     goto funcall;   }    ci->mid = name;   ci->u.target_class = c;   /* remove first symbol from arguments */   if (n == 15) {     /* variable length arguments */     regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);   }   else { /* n > 0 */     for (int i=0; i<n; i++) {       regs[i] = regs[i+1];     }     regs[n] = regs[n+1];        /* copy kdict or block */     if (ci->nk > 0) {       regs[n+1] = regs[n+2];    /* copy block */     }     ci->n--;   }    if (MRB_METHOD_CFUNC_P(m)) {     if (MRB_METHOD_NOARG_P(m)) {       check_method_noarg(mrb, ci);     }      if (MRB_METHOD_PROC_P(m)) {       mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));     }     return MRB_METHOD_CFUNC(m)(mrb, self);   }   return exec_irep(mrb, self, MRB_METHOD_PROC(m)); }"
"197824_CWE-416.c","CWE-416","static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list) { 	GF_Node *node; 	GF_Command *com; 	GF_CommandField *inf; 	node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode); 	if (!node) return GF_NON_COMPLIANT_BITSTREAM;  	/*reset global QP*/ 	if (codec->scenegraph->global_qp) { 		gf_node_unregister(codec->scenegraph->global_qp, NULL); 	} 	codec->ActiveQP = NULL; 	codec->scenegraph->global_qp = NULL;  	if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) { 		gf_node_unregister(node, NULL); 		return GF_NON_COMPLIANT_BITSTREAM; 	}  	/*register global QP*/ 	codec->ActiveQP = (M_QuantizationParameter *) node; 	codec->ActiveQP->isLocal = 0; 	codec->scenegraph->global_qp = node;  	/*register TWICE: once for the command, and for the scenegraph globalQP*/ 	node->sgprivate->num_instances = 2;  	com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER); 	inf = gf_sg_command_field_new(com); 	inf->new_node = node; 	inf->field_ptr = &inf->new_node; 	inf->fieldType = GF_SG_VRML_SFNODE; 	gf_list_add(com_list, com); 	return GF_OK; }"
"197826_CWE-824.cc","CWE-824","bool IsConstantFoldable(     const Node* n,     const std::unordered_map<string, std::vector<PartialTensorShape>>*         shape_map,     const std::function<bool(const Node*)>& consider,     int64_t max_constant_size_in_bytes,     std::unordered_map<const Node*, std::vector<Tensor>>*         shape_replacement_map) {   if (n->IsConstant()) {     return true;   }   if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {     return true;   }   if (n->op_def().is_stateful()) {     return false;   }   if (consider && !consider(n)) {     return false;   }   if (shape_map != nullptr) {     // We can skip the node if an output is known to be oversized.     auto shape_it = shape_map->find(n->name());     if (shape_it != shape_map->end()) {       for (int64_t i = 0; i < shape_it->second.size(); ++i) {         const auto& out_shape = shape_it->second[i];         if (out_shape.IsFullyDefined() &&             out_shape.num_elements() * DataTypeSize(n->output_type(i)) >                 max_constant_size_in_bytes) {           return false;         }       }     }   }   if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {     return false;   }   // TODO(yuanbyu): For now disable these session handle operations.   if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||       n->IsDeleteSessionTensor()) {     return false;   }   if (n->IsSource()) {     return false;   }   if (n->IsSink()) {     return false;   }   if (n->IsFakeParam()) {     return false;   }   // Since constant-folding runs on the CPU, do not attempt to constant-fold   // operators that have no CPU kernel. Also implies that we will not   // constant-fold functions.   // TODO(phawkins): allow constant-folding for functions; functions may   // be arbitrarily expensive to execute.   if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {     return false;   }   // Do not constant fold nodes which will be allocated by ScopedAllocator.   // This is because the constant-folding graph will not contain the   // `_ScopedAllocator` node, and that is necessary to be able to run a node   // that will use this allocator.   if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {     VLOG(2) << ""Skip node ["" << n->DebugString()             << ""] for constant folding due to scoped allocator"";     return false;   }   return true; }"
"197893_CWE-703.cc","CWE-703","TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,                     const TfLiteTensor* positions, TfLiteTensor* output) {   tflite::GatherParams op_params;   op_params.axis = params.axis;   op_params.batch_dims = params.batch_dims;   optimized_ops::Gather(op_params, GetTensorShape(input),                         GetTensorData<InputT>(input), GetTensorShape(positions),                         GetTensorData<PositionsT>(positions),                         GetTensorShape(output), GetTensorData<InputT>(output));   return kTfLiteOk; }"
"197898_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     const Tensor& gradient = ctx->input(0);     const Tensor& input = ctx->input(1);     Tensor* input_backprop = nullptr;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(0, input.shape(), &input_backprop));      OP_REQUIRES(         ctx, input.IsSameSize(gradient),         errors::InvalidArgument(""gradient and input must be the same size""));     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);     const Tensor& input_min_tensor = ctx->input(2);     OP_REQUIRES(ctx,                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,                 errors::InvalidArgument(                     ""Input min tensor must have dimension 1. Recieved "",                     input_min_tensor.dims(), "".""));     const Tensor& input_max_tensor = ctx->input(3);     OP_REQUIRES(ctx,                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,                 errors::InvalidArgument(                     ""Input max tensor must have dimension 1. Recieved "",                     input_max_tensor.dims(), "".""));     if (axis_ != -1) {       OP_REQUIRES(           ctx, input_min_tensor.dim_size(0) == depth,           errors::InvalidArgument(""min has incorrect size, expected "", depth,                                   "" was "", input_min_tensor.dim_size(0)));       OP_REQUIRES(           ctx, input_max_tensor.dim_size(0) == depth,           errors::InvalidArgument(""max has incorrect size, expected "", depth,                                   "" was "", input_max_tensor.dim_size(0)));     }      TensorShape min_max_shape(input_min_tensor.shape());     Tensor* input_min_backprop;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(1, min_max_shape, &input_min_backprop));      Tensor* input_max_backprop;     OP_REQUIRES_OK(ctx,                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));      if (axis_ == -1) {       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),         input.template flat<T>(), input_min_tensor.scalar<T>(),         input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),         input_min_backprop->template scalar<T>(),         input_max_backprop->template scalar<T>());     } else {       functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;       f(ctx->eigen_device<Device>(),         gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),         input.template flat_inner_outer_dims<T, 3>(axis_ - 1),         &input_min_tensor, &input_max_tensor,         input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),         input_min_backprop->template flat<T>(),         input_max_backprop->template flat<T>());     }   }"
"197973_CWE-276.c","CWE-276","crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err) {   int first_arg = 0, ret = 0;   libcrun_context_t crun_context = {     0,   };   cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;   struct libcrun_container_exec_options_s exec_opts;    memset (&exec_opts, 0, sizeof (exec_opts));   exec_opts.struct_size = sizeof (exec_opts);    crun_context.preserve_fds = 0;   crun_context.listen_fds = 0;    argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);   crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);    ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);   if (UNLIKELY (ret < 0))     return ret;    crun_context.detach = exec_options.detach;   crun_context.console_socket = exec_options.console_socket;   crun_context.pid_file = exec_options.pid_file;   crun_context.preserve_fds = exec_options.preserve_fds;    if (getenv (""LISTEN_FDS""))     {       crun_context.listen_fds = strtoll (getenv (""LISTEN_FDS""), NULL, 10);       crun_context.preserve_fds += crun_context.listen_fds;     }    if (exec_options.process)     exec_opts.path = exec_options.process;   else     {       process = xmalloc0 (sizeof (*process));       int i;        process->args_len = argc;       process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));       for (i = 0; i < argc - first_arg; i++)         process->args[i] = xstrdup (argv[first_arg + i + 1]);       process->args[i] = NULL;       if (exec_options.cwd)         process->cwd = exec_options.cwd;       process->terminal = exec_options.tty;       process->env = exec_options.env;       process->env_len = exec_options.env_size;       process->user = make_oci_process_user (exec_options.user);        if (exec_options.process_label != NULL)         process->selinux_label = exec_options.process_label;        if (exec_options.apparmor != NULL)         process->apparmor_profile = exec_options.apparmor;        if (exec_options.cap_size > 0)         {           runtime_spec_schema_config_schema_process_capabilities *capabilities               = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));            capabilities->effective = exec_options.cap;           capabilities->effective_len = exec_options.cap_size;            capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);           capabilities->inheritable_len = exec_options.cap_size;            capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);           capabilities->bounding_len = exec_options.cap_size;            capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);           capabilities->ambient_len = exec_options.cap_size;            capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);           capabilities->permitted_len = exec_options.cap_size;            process->capabilities = capabilities;         }        // noNewPriviledges will remain `false` if basespec has `false` unless specified       // Default is always `true` in generated basespec config       if (exec_options.no_new_privs)         process->no_new_privileges = 1;        exec_opts.process = process;     }    exec_opts.cgroup = exec_options.cgroup;    return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err); }"
"197998_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* context) override {     const Tensor& input = context->input(0);     const TensorShape& input_shape = input.shape();     const int32 input_dims = input_shape.dims();      const Tensor& segment_id = context->input(1);     const TensorShape& segment_id_shape = segment_id.shape();     const int32 segment_dims = segment_id_shape.dims();      const Tensor& num_segments_tensor = context->input(2);     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();      OP_REQUIRES(context, segment_dims != 0,                 errors::InvalidArgument(""Segment_id cannot have rank 0""));      OP_REQUIRES(         context, segment_dims <= input_dims,         errors::OutOfRange(""Invalid segment_id rank "", segment_dims,                            "" for input with "", input_dims, "" dimension(s)""));     for (auto i = 0; i < segment_dims; i++) {       OP_REQUIRES(           context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),           errors::InvalidArgument(               ""Segment dimension is "", segment_id_shape.dim_size(i),               "" while input dimension is "", input_dims, "" in rank "", i));     }      // Making output tensor.     Tensor* output_tensor = nullptr;     TensorShape output_shape =         GetOutputShape(input_shape, segment_id_shape, num_segments);     OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,                                                      &output_tensor));      // Preparating flat tensors.     auto output_flat = output_tensor->flat<tstring>();     auto flat_segment_id = segment_id.flat<INDICES_TYPE>();     auto flat_input = input.flat<tstring>();      for (int i = 0; i < flat_segment_id.size(); i++) {       OP_REQUIRES(           context,           ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),           errors::InvalidArgument(               ""segment_ids are not allowed to exceed num_segments or""               "" to have negative values.""));     }      int64 big_stride;     int64 small_stride;     std::tie(big_stride, small_stride) =         GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);     auto relative_offset_set =         GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);     for (auto start_offset = 0; start_offset < big_stride; start_offset++) {       for (auto i = 0; i < relative_offset_set.size(); i++) {         auto output_index = start_offset + flat_segment_id(i) * big_stride;         auto offset = start_offset + relative_offset_set[i];         if (output_flat(output_index).length() != 0)           output_flat(output_index).append(separator_.c_str());         output_flat(output_index).append(flat_input(offset));       }     }   }"
"198003_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* ctx) override {     auto x = ctx->input(0);     auto i = ctx->input(1);     auto v = ctx->input(2);      OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),                 errors::InvalidArgument(""i must be a vector. "",                                         i.shape().DebugString()));     OP_REQUIRES(ctx, x.dims() == v.dims(),                 errors::InvalidArgument(                     ""x and v shape doesn't match (ranks differ): "",                     x.shape().DebugString(), "" vs. "", v.shape().DebugString()));     for (int i = 1; i < x.dims(); ++i) {       OP_REQUIRES(           ctx, x.dim_size(i) == v.dim_size(i),           errors::InvalidArgument(""x and v shape doesn't match at index "", i,                                   "" : "", x.shape().DebugString(), "" vs. "",                                   v.shape().DebugString()));     }     OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),                 errors::InvalidArgument(                     ""i and x shape doesn't match at index 0: "",                     i.shape().DebugString(), "" vs. "", v.shape().DebugString()));      Tensor y = x;  // This creates an alias intentionally.     // Skip processing if tensors are empty.     if (x.NumElements() > 0 || v.NumElements() > 0) {       OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));     }     ctx->set_output(0, y);   }"
"198004_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* context) override {     // boxes: [batch_size, num_anchors, q, 4]     const Tensor& boxes = context->input(0);     // scores: [batch_size, num_anchors, num_classes]     const Tensor& scores = context->input(1);     OP_REQUIRES(         context, (boxes.dim_size(0) == scores.dim_size(0)),         errors::InvalidArgument(""boxes and scores must have same batch size""));      // max_output_size: scalar     const Tensor& max_output_size = context->input(2);     OP_REQUIRES(         context, TensorShapeUtils::IsScalar(max_output_size.shape()),         errors::InvalidArgument(""max_size_per_class must be 0-D, got shape "",                                 max_output_size.shape().DebugString()));     const int max_size_per_class = max_output_size.scalar<int>()();     // max_total_size: scalar     const Tensor& max_total_size = context->input(3);     OP_REQUIRES(         context, TensorShapeUtils::IsScalar(max_total_size.shape()),         errors::InvalidArgument(""max_total_size must be 0-D, got shape "",                                 max_total_size.shape().DebugString()));     const int max_total_size_per_batch = max_total_size.scalar<int>()();     OP_REQUIRES(context, max_total_size_per_batch > 0,                 errors::InvalidArgument(""max_total_size must be > 0""));     // Throw warning when `max_total_size` is too large as it may cause OOM.     if (max_total_size_per_batch > pow(10, 6)) {       LOG(WARNING) << ""Detected a large value for `max_total_size`. This may ""                    << ""cause OOM error. (max_total_size: ""                    << max_total_size.scalar<int>()() << "")"";     }     // iou_threshold: scalar     const Tensor& iou_threshold = context->input(4);     OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),                 errors::InvalidArgument(""iou_threshold must be 0-D, got shape "",                                         iou_threshold.shape().DebugString()));     const float iou_threshold_val = iou_threshold.scalar<float>()();      // score_threshold: scalar     const Tensor& score_threshold = context->input(5);     OP_REQUIRES(         context, TensorShapeUtils::IsScalar(score_threshold.shape()),         errors::InvalidArgument(""score_threshold must be 0-D, got shape "",                                 score_threshold.shape().DebugString()));     const float score_threshold_val = score_threshold.scalar<float>()();      OP_REQUIRES(context, iou_threshold_val >= 0 && iou_threshold_val <= 1,                 errors::InvalidArgument(""iou_threshold must be in [0, 1]""));     int num_boxes = 0;     const int num_classes = scores.dim_size(2);     ParseAndCheckCombinedNMSBoxSizes(context, boxes, &num_boxes, num_classes);     CheckCombinedNMSScoreSizes(context, num_boxes, scores);      if (!context->status().ok()) {       return;     }     BatchedNonMaxSuppressionOp(context, boxes, scores, num_boxes,                                max_size_per_class, max_total_size_per_batch,                                score_threshold_val, iou_threshold_val,                                pad_per_class_, clip_boxes_);   }"
"198010_CWE-125.c","CWE-125","static int string_scan_range(RList *list, RBinFile *bf, int min, 			      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) { 	RBin *bin = bf->rbin; 	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE]; 	ut64 str_start, needle = from; 	int count = 0, i, rc, runes; 	int str_type = R_STRING_TYPE_DETECT;  	// if list is null it means its gonna dump 	r_return_val_if_fail (bf, -1);  	if (type == -1) { 		type = R_STRING_TYPE_DETECT; 	} 	if (from == to) { 		return 0; 	} 	if (from > to) { 		eprintf (""Invalid range to find strings 0x%""PFMT64x"" .. 0x%""PFMT64x""\n"", from, to); 		return -1; 	} 	st64 len = (st64)(to - from); 	if (len < 1 || len > ST32_MAX) { 		eprintf (""String scan range is invalid (%""PFMT64d"" bytes)\n"", len); 		return -1; 	} 	ut8 *buf = calloc (len, 1); 	if (!buf || !min) { 		free (buf); 		return -1; 	} 	st64 vdelta = 0, pdelta = 0; 	RBinSection *s = NULL; 	bool ascii_only = false; 	PJ *pj = NULL; 	if (bf->strmode == R_MODE_JSON && !list) { 		pj = pj_new (); 		if (pj) { 			pj_a (pj); 		} 	} 	r_buf_read_at (bf->buf, from, buf, len); 	char *charset = r_sys_getenv (""RABIN2_CHARSET""); 	if (!R_STR_ISEMPTY (charset)) { 		RCharset *ch = r_charset_new (); 		if (r_charset_use (ch, charset)) { 			int outlen = len * 4; 			ut8 *out = calloc (len, 4); 			if (out) { 				int res = r_charset_encode_str (ch, out, outlen, buf, len); 				int i; 				// TODO unknown chars should be translated to null bytes 				for (i = 0; i < res; i++) { 					if (out[i] == '?') { 						out[i] = 0; 					} 				} 				len = res; 				free (buf); 				buf = out; 			} else { 				eprintf (""Cannot allocate\n""); 			} 		} else { 			eprintf (""Invalid value for RABIN2_CHARSET.\n""); 		} 		r_charset_free (ch); 	} 	free (charset); 	RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL; 	// may oobread 	while (needle < to) { 		if (is_breaked && is_breaked ()) { 			break; 		} 		// smol optimization 		if (needle + 4 < to) { 			ut32 n1 = r_read_le32 (buf + needle - from); 			if (!n1) { 				needle += 4; 				continue; 			} 		} 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL); 		if (!rc) { 			needle++; 			continue; 		} 		bool addr_aligned = !(needle % 4);  		if (type == R_STRING_TYPE_DETECT) { 			char *w = (char *)buf + needle + rc - from; 			if (((to - needle) > 8 + rc)) { 				// TODO: support le and be 				bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]); 				// reduce false positives 				if (is_wide32le) { 					if (!w[5] && !w[6] && w[7] && w[8]) { 						is_wide32le = false; 					} 				} 				if (!addr_aligned) { 					is_wide32le = false; 				} 				///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff; 				if (is_wide32le  && addr_aligned) { 					str_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32? 				} else { 					// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff)); 					bool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4]; 					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII; 				} 			} else { 				if (rc > 1) { 					str_type = R_STRING_TYPE_UTF8; // could be charset if set :? 				} else { 					str_type = R_STRING_TYPE_ASCII; 				} 			} 		} else if (type == R_STRING_TYPE_UTF8) { 			str_type = R_STRING_TYPE_ASCII; // initial assumption 		} else { 			str_type = type; 		} 		runes = 0; 		str_start = needle;  		/* Eat a whole C string */ 		for (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) { 			RRune r = {0}; 			if (str_type == R_STRING_TYPE_WIDE32) { 				rc = r_utf32le_decode (buf + needle - from, to - needle, &r); 				if (rc) { 					rc = 4; 				} 			} else if (str_type == R_STRING_TYPE_WIDE) { 				rc = r_utf16le_decode (buf + needle - from, to - needle, &r); 				if (rc == 1) { 					rc = 2; 				} 			} else { 				rc = r_utf8_decode (buf + needle - from, to - needle, &r); 				if (rc > 1) { 					str_type = R_STRING_TYPE_UTF8; 				} 			}  			/* Invalid sequence detected */ 			if (!rc || (ascii_only && r > 0x7f)) { 				needle++; 				break; 			}  			needle += rc;  			if (r_isprint (r) && r != '\\') { 				if (str_type == R_STRING_TYPE_WIDE32) { 					if (r == 0xff) { 						r = 0; 					} 				} 				rc = r_utf8_encode (tmp + i, r); 				runes++; 				/* Print the escape code */ 			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) { 				if ((i + 32) < sizeof (tmp) && r < 93) { 					tmp[i + 0] = '\\'; 					tmp[i + 1] = ""       abtnvfr             e  "" 					             ""                              "" 					             ""                              "" 					             ""  \\""[r]; 				} else { 					// string too long 					break; 				} 				rc = 2; 				runes++; 			} else { 				/* \0 marks the end of C-strings */ 				break; 			} 		}  		tmp[i++] = '\0';  		if (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) { 			// back up past the \0 to the last char just in case it starts a wide string 			needle -= 2; 		} 		if (runes >= min) { 			// reduce false positives 			int j, num_blocks, *block_list; 			int *freq_list = NULL, expected_ascii, actual_ascii, num_chars; 			if (str_type == R_STRING_TYPE_ASCII) { 				for (j = 0; j < i; j++) { 					char ch = tmp[j]; 					if (ch != '\n' && ch != '\r' && ch != '\t') { 						if (!IS_PRINTABLE (tmp[j])) { 							continue; 						} 					} 				} 			} 			switch (str_type) { 			case R_STRING_TYPE_UTF8: 			case R_STRING_TYPE_WIDE: 			case R_STRING_TYPE_WIDE32: 				num_blocks = 0; 				block_list = r_utf_block_list ((const ut8*)tmp, i - 1, 						str_type == R_STRING_TYPE_WIDE? &freq_list: NULL); 				if (block_list) { 					for (j = 0; block_list[j] != -1; j++) { 						num_blocks++; 					} 				} 				if (freq_list) { 					num_chars = 0; 					actual_ascii = 0; 					for (j = 0; freq_list[j] != -1; j++) { 						num_chars += freq_list[j]; 						if (!block_list[j]) { // ASCII 							actual_ascii = freq_list[j]; 						} 					} 					free (freq_list); 					expected_ascii = num_blocks ? num_chars / num_blocks : 0; 					if (actual_ascii > expected_ascii) { 						ascii_only = true; 						needle = str_start; 						free (block_list); 						continue; 					} 				} 				free (block_list); 				if (num_blocks > R_STRING_MAX_UNI_BLOCKS) { 					needle++; 					continue; 				} 			} 			RBinString *bs = R_NEW0 (RBinString); 			if (!bs) { 				break; 			} 			bs->type = str_type; 			bs->length = runes; 			bs->size = needle - str_start; 			bs->ordinal = count++; 			// TODO: move into adjust_offset 			switch (str_type) { 			case R_STRING_TYPE_WIDE: 				if (str_start - from > 1) { 					const ut8 *p = buf + str_start - 2 - from; 					if (p[0] == 0xff && p[1] == 0xfe) { 						str_start -= 2; // \xff\xfe 					} 				} 				break; 			case R_STRING_TYPE_WIDE32: 				if (str_start - from > 3) { 					const ut8 *p = buf + str_start - 4 - from; 					if (p[0] == 0xff && p[1] == 0xfe) { 						str_start -= 4; // \xff\xfe\x00\x00 					} 				} 				break; 			} 			if (!s) { 				if (section) { 					s = section; 				} else if (bf->o) { 					s = r_bin_get_section_at (bf->o, str_start, false); 				} 				if (s) { 					vdelta = s->vaddr; 					pdelta = s->paddr; 				} 			} 			ut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr; 			bs->paddr = str_start + baddr; 			bs->vaddr = str_start - pdelta + vdelta + baddr; 			bs->string = r_str_ndup ((const char *)tmp, i); 			if (list) { 				r_list_append (list, bs); 				if (bf->o) { 					ht_up_insert (bf->o->strings_db, bs->vaddr, bs); 				} 			} else { 				print_string (bf, bs, raw, pj); 				r_bin_string_free (bs); 			} 			if (from == 0 && to == bf->size) { 				/* force lookup section at the next one */ 				s = NULL; 			} 		} 		ascii_only = false; 	} 	free (buf); 	if (pj) { 		pj_end (pj); 		if (bin) { 			RIO *io = bin->iob.io; 			if (io) { 				io->cb_printf (""%s"", pj_string (pj)); 			} 		} 		pj_free (pj); 	} 	return count; }"
"198013_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* context) override {     // Checks what we're remapping and inverts the relevant remapping Tensors to     // be maps with key = old ID, value = new ID.     std::unordered_map<int64_t, int64_t> old_row_to_new_row_map;     std::vector<bool> row_id_present;     const Tensor* row_remapping_t;     OP_REQUIRES_OK(context, context->input(""row_remapping"", &row_remapping_t));     const auto row_remapping = row_remapping_t->vec<int64_t>();     OP_REQUIRES(context, row_remapping.size() == num_rows_,                 errors::InvalidArgument(strings::StrCat(                     ""Size of row_remapping is "", row_remapping.size(),                     "" instead of being equal to num_rows="", num_rows_)));     OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,                                              &old_row_to_new_row_map));      // Calculates the min/max old row ID that we need to read, to save us from     // reading some unnecessary slices of the old tensor.     int64_t min_old_row = -1;     int64_t max_old_row = -1;     for (int i = 0; i < row_remapping.size(); ++i) {       if (min_old_row < 0 ||           (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {         min_old_row = row_remapping(i);       }       if (max_old_row < 0 ||           (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {         max_old_row = row_remapping(i);       }     }      // Processes the remapping for columns.     std::unordered_map<int64_t, int64_t> old_col_to_new_col_map;     std::vector<bool> col_id_present;     const Tensor* col_remapping_t;     OP_REQUIRES_OK(context, context->input(""col_remapping"", &col_remapping_t));     const auto col_remapping = col_remapping_t->vec<int64_t>();     // Note that we always ""remap rows"", even when the row vocabulary does     // not change, because partitioning requires a mapping from partitioned     // Variables to the full checkpoints we load.     const bool remap_cols = col_remapping.size() > 0;     if (remap_cols) {       OP_REQUIRES(           context, col_remapping.size() == num_cols_,           errors::InvalidArgument(strings::StrCat(               ""Provided col_remapping, but its size is "", col_remapping.size(),               "" instead of being equal to num_cols="", num_cols_)));       OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,                                                &old_col_to_new_col_map));     } else {       col_id_present.clear();       col_id_present.resize(num_cols_, true);     }      // Processes the checkpoint source and the provided Tensor name.     const Tensor* ckpt_path_t;     OP_REQUIRES_OK(context, context->input(""ckpt_path"", &ckpt_path_t));     OP_REQUIRES(         context, ckpt_path_t->NumElements() == 1,         errors::InvalidArgument(""The `ckpt_path` tensor must have exactly one ""                                 ""element, got tensor of shape "",                                 ckpt_path_t->shape().DebugString()));     const string& ckpt_path = ckpt_path_t->scalar<tstring>()();     const Tensor* old_tensor_name_t;     OP_REQUIRES_OK(context,                    context->input(""old_tensor_name"", &old_tensor_name_t));     const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();      LOG(INFO) << ""Processing checkpoint : "" << ckpt_path;     BundleReader reader(context->env(), ckpt_path);     OP_REQUIRES_OK(context, reader.status());      DataType tensor_type;     TensorShape tensor_shape;     OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(                                 old_tensor_name, &tensor_type, &tensor_shape));     OP_REQUIRES(context, tensor_type == DT_FLOAT,                 errors::InvalidArgument(strings::StrCat(                     ""Tensor "", old_tensor_name, "" has invalid type "",                     DataTypeString(tensor_type), "" instead of expected type "",                     DataTypeString(DT_FLOAT))));     // This op is limited to loading Tensors of rank 2 (matrices).     OP_REQUIRES(         context, tensor_shape.dims() == 2,         errors::InvalidArgument(strings::StrCat(             ""Tensor "", old_tensor_name, "" has shape "",             tensor_shape.DebugString(), "" of invalid rank "",             tensor_shape.dims(), "" instead of expected shape of rank 2."")));      if (!remap_cols) {       // TODO(weiho): Consider relaxing this restriction to allow partial column       // loading (even when no column remapping is specified) if there turns out       // to be a use case for it.       OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),                   errors::InvalidArgument(strings::StrCat(                       ""Tensor "", old_tensor_name, "" has shape "",                       tensor_shape.DebugString(),                       "", where the size of its 2nd dimension is "",                       tensor_shape.dim_size(1),                       "" instead of being equal to num_cols="", num_cols_)));     }      // Uses TensorSlice to potentially load the old tensor in chunks in case     // memory usage is a concern.     std::vector<TensorSlice> tensor_slices;     TensorSlice slice(tensor_shape.dims());     if (min_old_row >= 0 && max_old_row >= 0) {       int64_t row_start = min_old_row;       // TODO(weiho): Given the list of old row IDs of interest (the keys of       // old_row_to_new_row_map), we could also try something smarter to       // find some minimal set of covering ranges for the list of old row IDs       // such that the size of each range is less than max_rows_in_memory_.       while (row_start <= max_old_row) {         const int64_t slice_length =             max_rows_in_memory_ <= 0                 // If max_rows_in_memory_ <= 0, we just load the entire chunk.                 ? max_old_row - row_start + 1                 : std::min(max_rows_in_memory_, max_old_row - row_start + 1);         slice.set_start(0, row_start);         slice.set_length(0, slice_length);         tensor_slices.push_back(slice);         row_start += slice_length;       }     }      // Allocates the output matrix.     Tensor* output_matrix_t = nullptr;     OP_REQUIRES_OK(context,                    context->allocate_output(""output_matrix"",                                             TensorShape({num_rows_, num_cols_}),                                             &output_matrix_t));     auto output_matrix = output_matrix_t->matrix<float>();      // Iterates through tensor slices and copies over values from the old tensor     // to the output matrix.     int64_t row_index = min_old_row;     int64_t rows_copied = 0;     Tensor loaded_tensor_t;     for (const TensorSlice& tensor_slice : tensor_slices) {       LOG(INFO) << ""Loading slice "" << tensor_slice.DebugString();       TensorShape slice_shape;       OP_REQUIRES_OK(context,                      tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));       // Potentially re-allocates the tensor buffer since the last slice may       // have fewer rows than the other slices.       if (loaded_tensor_t.shape() != slice_shape) {         loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);       }       OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,                                                  &loaded_tensor_t));        // Iterates through the old loaded tensor slice row-by-row.       for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {         if (row_index % 500000 == min_old_row) {           LOG(INFO) << ""Processing old row "" << row_index;         }          // If the old row ID is not found in old_row_to_new_row_map, continue         // to the next row; otherwise, copy it to the output matrix.         const int64_t* new_row_ptr =             gtl::FindOrNull(old_row_to_new_row_map, row_index);         if (new_row_ptr == nullptr) {           continue;         }         ++rows_copied;         const int64_t new_row = *new_row_ptr;          // Copies over the row element-by-element, in case remapping is needed         // along the column axis.         const auto& loaded_tensor = loaded_tensor_t.matrix<float>();         for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);              ++old_col) {           int64_t new_col = old_col;           if (remap_cols) {             const int64_t* new_col_ptr =                 gtl::FindOrNull(old_col_to_new_col_map, old_col);             if (new_col_ptr == nullptr) {               // Column remapping is specified, but this column is not found in               // old_col_to_new_col_map, so we leave it uninitialized, to be               // filled in with initializing_values later.               continue;             }             new_col = *new_col_ptr;           }            OP_REQUIRES(context,                       new_row < num_rows_ && new_col < num_cols_ &&                           new_row >= 0 && new_col >= 0,                       errors::Internal(strings::StrCat(                           ""new_row="", new_row, "" and new_col="", new_col,                           "" should have been less than num_rows_="", num_rows_,                           "" and num_cols_="", num_cols_,                           "" and non-negative. This should never have happened ""                           ""if the code were correct. Please file a bug."")));           output_matrix(new_row, new_col) = loaded_tensor(row, old_col);         }       }     }     LOG(INFO) << ""Copied "" << rows_copied << "" rows from old matrix (with ""               << tensor_shape.dim_size(0) << "" rows) to new matrix (with ""               << num_rows_ << "" rows)."";      // At this point, there are potentially whole rows/columns uninitialized     // (corresponding to the indices where row_id_present/col_id_present are     // false). We fill this in cell-by-cell using row_id_present and     // col_id_present while dequeuing from the initializing_values vector.     const Tensor* initializing_values_t;     OP_REQUIRES_OK(         context, context->input(""initializing_values"", &initializing_values_t));     const auto initializing_values = initializing_values_t->flat<float>();     int64_t initializing_values_index = 0;     for (int i = 0; i < num_rows_; ++i) {       for (int j = 0; j < num_cols_; ++j) {         if (row_id_present[i] && col_id_present[j]) continue;         OP_REQUIRES(             context, initializing_values_index < initializing_values.size(),             errors::InvalidArgument(                 ""initializing_values contained "", initializing_values.size(),                 "" elements, but more missing values remain.""));         output_matrix(i, j) = initializing_values(initializing_values_index);         ++initializing_values_index;       }     }      // Checks that we used all the given initializing values.     OP_REQUIRES(         context, initializing_values_index == initializing_values.size(),         errors::InvalidArgument(             ""initializing_values contained "", initializing_values.size(),             "" elements, but only "", initializing_values_index,             "" elements were used to fill in missing values.""));   }"
"198116_CWE-125.cc","CWE-125","  void Compute(OpKernelContext *ctx) override {     const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;     OP_REQUIRES_OK(ctx, ctx->input(""input_indices"", &indices_t));     OP_REQUIRES_OK(ctx, ctx->input(""input_values"", &values_t));     OP_REQUIRES_OK(ctx, ctx->input(""input_shape"", &shape_t));     OP_REQUIRES_OK(ctx, ctx->input(""reduction_axes"", &reduction_axes_t));      OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));      // TODO(zongheng): we will call Reorder() below, which will modify     // in-place the underlying indices and values buffers.  To avoid     // surprises of this kernel being stateful, we work around the above by     // making deep copies here.  Remove this if/when we change Reorder()'s     // semantics.     const auto shape_vec = shape_t->vec<int64>();     SparseTensor sp;     OP_REQUIRES_OK(ctx, SparseTensor::Create(         tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),                     TensorShape(shape_vec), &sp));     ReduceDetails reduction = SparseTensorReduceHelper(         sp, reduction_axes_t->flat<int32>(), keep_dims_);      Tensor *out_values;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));     auto out_flat = out_values->flat<T>();     out_flat.setZero();      Tensor tmp_reduced_val;     OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,                                            TensorShape({}), &tmp_reduced_val));     auto reduced_val = tmp_reduced_val.scalar<T>();      // Compute strides, and use it to convert coords to flat index.  The     // coordinates returned by .group() have the same ndims as group_by_dims.     gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());     if (!output_strides.empty()) {  // Do this iff we don't reduce all.       output_strides.back() = 1;       for (int d = output_strides.size() - 2; d >= 0; --d) {         output_strides[d] =             output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);       }     }      auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,                                      ArraySlice<int64> strides) -> int64 {       if (strides.empty()) {  // Reduce all.         return 0;       }       CHECK_EQ(coords.size(), strides.size());       int64_t idx = 0;       for (int i = 0; i < coords.size(); ++i) {         idx += coords[i] * strides[i];       }       return idx;     };      // Each group maps one-on-one onto a value in the reduced tensor.     // g.group() provides the coordinates of a particular reduced value.     sp.Reorder<T>(reduction.reorder_dims);     for (const auto &g : sp.group(reduction.group_by_dims)) {       Op::template Run<T>(ctx, reduced_val, g.template values<T>());       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);       out_flat(idx) = reduced_val();       VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")               << ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""               << reduced_val();     }   }"
"198117_CWE-476.cc","CWE-476","  void Compute(OpKernelContext* context) override {     // Here's the basic idea:     // Batch and depth dimension are independent from row and col dimension. And     // because FractionalAvgPool currently only support pooling along row and     // col, we can basically think of this 4D tensor backpropagation as     // operation of a series of 2D planes.     //     // For each element of a 'slice' (2D plane) of output_backprop, we need to     // figure out its contributors when doing FractionalAvgPool operation. This     // can be done based on row_pooling_sequence, col_pooling_seq and     // overlapping.     // Once we figure out the original contributors, we just need to evenly     // divide the value of this element among these contributors.     //     // Internally, we divide the out_backprop tensor and store it in a temporary     // tensor of double type. And cast it to the corresponding type.     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>         ConstEigenMatrixMap;     typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>         EigenDoubleMatrixMap;      // Grab the inputs.     const Tensor& orig_input_tensor_shape = context->input(0);     OP_REQUIRES(context,                 orig_input_tensor_shape.dims() == 1 &&                     orig_input_tensor_shape.NumElements() == 4,                 errors::InvalidArgument(""original input tensor shape must be""                                         ""1-dimensional and 4 elements""));     const Tensor& out_backprop = context->input(1);     const Tensor& row_seq_tensor = context->input(2);     const Tensor& col_seq_tensor = context->input(3);      const int64_t out_batch = out_backprop.dim_size(0);     const int64_t out_rows = out_backprop.dim_size(1);     const int64_t out_cols = out_backprop.dim_size(2);     const int64_t out_depth = out_backprop.dim_size(3);      OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,                 errors::InvalidArgument(""Given out_backprop shape "",                                         out_backprop.shape().DebugString(),                                         "", row_seq_tensor must have at least "",                                         out_rows + 1, "" elements, but got "",                                         row_seq_tensor.NumElements()));     OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,                 errors::InvalidArgument(""Given out_backprop shape "",                                         out_backprop.shape().DebugString(),                                         "", col_seq_tensor must have at least "",                                         out_cols + 1, "" elements, but got "",                                         col_seq_tensor.NumElements()));      auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();     auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();      const int64_t in_batch = orig_input_tensor_shape_flat(0);     const int64_t in_rows = orig_input_tensor_shape_flat(1);     const int64_t in_cols = orig_input_tensor_shape_flat(2);     const int64_t in_depth = orig_input_tensor_shape_flat(3);      constexpr int tensor_in_and_out_dims = 4;     // Transform orig_input_tensor_shape into TensorShape     TensorShape in_shape;     for (auto i = 0; i < tensor_in_and_out_dims; ++i) {       in_shape.AddDim(orig_input_tensor_shape_flat(i));     }      // Create intermediate in_backprop.     Tensor in_backprop_tensor_temp;     OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(                                 {0}, DataTypeToEnum<double>::v(), in_shape,                                 &in_backprop_tensor_temp));     in_backprop_tensor_temp.flat<double>().setZero();     // Transform 4D tensor to 2D matrix.     EigenDoubleMatrixMap in_backprop_tensor_temp_mat(         in_backprop_tensor_temp.flat<double>().data(), in_depth,         in_cols * in_rows * in_batch);     ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),                                          out_depth,                                          out_cols * out_rows * out_batch);     // Loop through each element of out_backprop and evenly distribute the     // element to the corresponding pooling cell.     const int64_t in_max_row_index = in_rows - 1;     const int64_t in_max_col_index = in_cols - 1;     for (int64_t b = 0; b < out_batch; ++b) {       for (int64_t r = 0; r < out_rows; ++r) {         const int64_t in_row_start = row_seq_tensor_flat(r);         int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)                                           : row_seq_tensor_flat(r + 1) - 1;         in_row_end = std::min(in_row_end, in_max_row_index);         for (int64_t c = 0; c < out_cols; ++c) {           const int64_t in_col_start = col_seq_tensor_flat(c);           int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)                                             : col_seq_tensor_flat(c + 1) - 1;           in_col_end = std::min(in_col_end, in_max_col_index);            const int64_t num_elements_in_pooling_cell =               (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);           const int64_t out_index = (b * out_rows + r) * out_cols + c;           // Now we can evenly distribute out_backprop(b, h, w, *) to           // in_backprop(b, hs:he, ws:we, *).           for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {             for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {               const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;               // Walk through each channel (depth).               for (int64_t d = 0; d < out_depth; ++d) {                 const double out_backprop_element = static_cast<double>(                     out_backprop_mat.coeffRef(d, out_index));                 double& in_backprop_ref =                     in_backprop_tensor_temp_mat.coeffRef(d, in_index);                 in_backprop_ref +=                     out_backprop_element / num_elements_in_pooling_cell;               }             }           }         }       }     }      // Depending on the type, cast double to type T.     Tensor* in_backprop_tensor = nullptr;     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(                                 {0}, 0, in_shape, &in_backprop_tensor));     auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();     auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();     for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {       in_backprop_tensor_flat(i) =           static_cast<T>(in_backprop_tensor_temp_flat(i));     }   }"
"198146_CWE-824.cc","CWE-824","  void Compute(OpKernelContext* const context) override {     // node_id_range     const Tensor* node_id_range_t;     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));     const auto node_id_range = node_id_range_t->vec<int32>();     const int32_t node_id_first = node_id_range(0);  // inclusive     const int32_t node_id_last = node_id_range(1);   // exclusive      const Tensor* stats_summary_t;     OP_REQUIRES_OK(context, context->input(""stats_summary"", &stats_summary_t));     TTypes<float, 4>::ConstTensor stats_summary =         stats_summary_t->tensor<float, 4>();     const int32_t feature_dims = stats_summary_t->dim_size(1);     // The last bucket is for default/missing value.     const int32_t num_buckets = stats_summary_t->dim_size(2) - 1;     const int32_t logits_dim = logits_dim_;     const int32_t hessian_dim = stats_summary_t->dim_size(3) - logits_dim;     DCHECK_GT(hessian_dim, 0);     DCHECK_LE(hessian_dim, logits_dim * logits_dim);      const Tensor* l1_t;     OP_REQUIRES_OK(context, context->input(""l1"", &l1_t));     const auto l1 = l1_t->scalar<float>()();     DCHECK_GE(l1, 0);     if (logits_dim_ > 1) {       // Multi-class L1 regularization not supported yet.       DCHECK_EQ(l1, 0);     }      const Tensor* l2_t;     OP_REQUIRES_OK(context, context->input(""l2"", &l2_t));     const auto l2 = l2_t->scalar<float>()();     DCHECK_GE(l2, 0);      const Tensor* tree_complexity_t;     OP_REQUIRES_OK(context,                    context->input(""tree_complexity"", &tree_complexity_t));     const auto tree_complexity = tree_complexity_t->scalar<float>()();      const Tensor* min_node_weight_t;     OP_REQUIRES_OK(context,                    context->input(""min_node_weight"", &min_node_weight_t));     const auto min_node_weight = min_node_weight_t->scalar<float>()();      std::vector<int32> output_node_ids;     std::vector<float> output_gains;     std::vector<int32> output_feature_dimensions;     std::vector<int32> output_thresholds;     std::vector<Eigen::VectorXf> output_left_node_contribs;     std::vector<Eigen::VectorXf> output_right_node_contribs;     std::vector<string> output_split_types;      // TODO(tanzheny) parallelize the computation.     // Iterate each node and find the best gain per node.     for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {       float best_gain = std::numeric_limits<float>::lowest();       int32_t best_bucket = 0;       int32_t best_f_dim = 0;       string best_split_type;       Eigen::VectorXf best_contrib_for_left(logits_dim);       Eigen::VectorXf best_contrib_for_right(logits_dim);       float parent_gain;        // Including default bucket.       ConstMatrixMap stats_mat(&stats_summary(node_id, 0, 0, 0),                                num_buckets + 1, logits_dim + hessian_dim);       const Eigen::VectorXf total_grad =           stats_mat.leftCols(logits_dim).colwise().sum();       const Eigen::VectorXf total_hess =           stats_mat.rightCols(hessian_dim).colwise().sum();       if (total_hess.norm() < min_node_weight) {         continue;       }       Eigen::VectorXf parent_weight(logits_dim);       CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &parent_weight,                                &parent_gain);        if (split_type_ == ""inequality"") {         CalculateBestInequalitySplit(             stats_summary, node_id, feature_dims, logits_dim, hessian_dim,             num_buckets, min_node_weight, l1, l2, &best_gain, &best_bucket,             &best_f_dim, &best_split_type, &best_contrib_for_left,             &best_contrib_for_right);       } else {         CalculateBestEqualitySplit(             stats_summary, total_grad, total_hess, node_id, feature_dims,             logits_dim, hessian_dim, num_buckets, l1, l2, &best_gain,             &best_bucket, &best_f_dim, &best_split_type, &best_contrib_for_left,             &best_contrib_for_right);       }        if (best_gain == std::numeric_limits<float>::lowest()) {         // Do not add the node if not split if found.         continue;       }       output_node_ids.push_back(node_id);       // Remove the parent gain for the parent node.       output_gains.push_back(best_gain - parent_gain);       output_feature_dimensions.push_back(best_f_dim);       // default direction is fixed for dense splits.       // TODO(tanzheny) account for default values.       output_split_types.push_back(best_split_type);       output_thresholds.push_back(best_bucket);       output_left_node_contribs.push_back(best_contrib_for_left);       output_right_node_contribs.push_back(best_contrib_for_right);     }  // for node id     const int num_nodes = output_node_ids.size();     // output_node_ids     Tensor* output_node_ids_t = nullptr;     OP_REQUIRES_OK(context, context->allocate_output(""node_ids"", {num_nodes},                                                      &output_node_ids_t));     auto output_node_ids_vec = output_node_ids_t->vec<int32>();      // output_gains     Tensor* output_gains_t;     OP_REQUIRES_OK(context, context->allocate_output(""gains"", {num_nodes},                                                      &output_gains_t));     auto output_gains_vec = output_gains_t->vec<float>();      // output_feature_dimensions     Tensor* output_feature_dimension_t;     OP_REQUIRES_OK(context,                    context->allocate_output(""feature_dimensions"", {num_nodes},                                             &output_feature_dimension_t));     auto output_feature_dimensions_vec =         output_feature_dimension_t->vec<int32>();      // output_thresholds     Tensor* output_thresholds_t;     OP_REQUIRES_OK(context, context->allocate_output(""thresholds"", {num_nodes},                                                      &output_thresholds_t));     auto output_thresholds_vec = output_thresholds_t->vec<int32>();      // output_left_node_contribs     Tensor* output_left_node_contribs_t;     OP_REQUIRES_OK(context, context->allocate_output(                                 ""left_node_contribs"", {num_nodes, logits_dim},                                 &output_left_node_contribs_t));     auto output_left_node_contribs_matrix =         output_left_node_contribs_t->matrix<float>();      // output_right_node_contribs     Tensor* output_right_node_contribs_t;     OP_REQUIRES_OK(context, context->allocate_output(                                 ""right_node_contribs"", {num_nodes, logits_dim},                                 &output_right_node_contribs_t));     auto output_right_node_contribs_matrix =         output_right_node_contribs_t->matrix<float>();      // split type     Tensor* output_split_types_t;     OP_REQUIRES_OK(         context, context->allocate_output(""split_with_default_directions"",                                           {num_nodes}, &output_split_types_t));     auto output_split_types_vec = output_split_types_t->vec<tstring>();      // Sets output tensors from vectors.     for (int i = 0; i < num_nodes; ++i) {       output_node_ids_vec(i) = output_node_ids[i];       // Adjust the gains to penalize by tree complexity.       output_gains_vec(i) = output_gains[i] - tree_complexity;       output_feature_dimensions_vec(i) = output_feature_dimensions[i];       output_thresholds_vec(i) = output_thresholds[i];       for (int j = 0; j < logits_dim; ++j) {         output_left_node_contribs_matrix(i, j) =             output_left_node_contribs[i][j];         output_right_node_contribs_matrix(i, j) =             output_right_node_contribs[i][j];       }       output_split_types_vec(i) = output_split_types[i];     }   }"
"198161_CWE-125.c","CWE-125","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception) {   Image *image, *image2=NULL,    *rotated_image;   register Quantum *q;    unsigned int status;   MATHeader MATLAB_HDR;   size_t size;     size_t CellType;   QuantumInfo *quantum_info;   ImageInfo *clone_info;   int i;   ssize_t ldblk;   unsigned char *BImgBuff = NULL;   double MinVal, MaxVal;   unsigned z, z2;   unsigned Frames;   int logging;   int sample_size;   MagickOffsetType filepos=0x80;   BlobInfo *blob;   size_t one;      unsigned int (*ReadBlobXXXLong)(Image *image);   unsigned short (*ReadBlobXXXShort)(Image *image);   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);     assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");     /*      Open image file.    */   image = AcquireImage(image_info,exception);    status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*      Read MATLAB image.    */   clone_info=CloneImageInfo(image_info);   if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   MATLAB_HDR.Version = ReadBlobLSBShort(image);   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",         MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);   if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))   {     ReadBlobXXXLong = ReadBlobLSBLong;     ReadBlobXXXShort = ReadBlobLSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesLSB;     ReadBlobFloatsXXX = ReadBlobFloatsLSB;     image->endian = LSBEndian;   }    else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))   {     ReadBlobXXXLong = ReadBlobMSBLong;     ReadBlobXXXShort = ReadBlobMSBShort;     ReadBlobDoublesXXX = ReadBlobDoublesMSB;     ReadBlobFloatsXXX = ReadBlobFloatsMSB;     image->endian = MSBEndian;   }   else      goto MATLAB_KO;    /* unsupported endian */    if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6)) MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");    filepos = TellBlob(image);   while(!EOFBlob(image)) /* object parser loop */   {     Frames = 1;     (void) SeekBlob(image,filepos,SEEK_SET);     /* printf(""pos=%X\n"",TellBlob(image)); */      MATLAB_HDR.DataType = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);     if(EOFBlob(image)) break;     filepos += MATLAB_HDR.ObjectSize + 4 + 4;      image2 = image; #if defined(MAGICKCORE_ZLIB_DELEGATE)     if(MATLAB_HDR.DataType == miCOMPRESSED)     {       image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);       if(image2==NULL) continue;       MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */     } #endif          if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */       MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);        MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;        MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);     if(image!=image2)       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);            switch(MATLAB_HDR.DimFlag)     {            case  8: z2=z=1; break;      /* 2D matrix*/       case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/            (void) ReadBlobXXXLong(image2);          if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");          break;       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */          if(z!=3 && z!=1)             ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");            Frames = ReadBlobXXXLong(image2);          break;       default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");     }        MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),           ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&          MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */         MATLAB_HDR.StructureClass != mxINT8_CLASS &&         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */         MATLAB_HDR.StructureClass != mxINT16_CLASS &&         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */         MATLAB_HDR.StructureClass != mxINT32_CLASS &&         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */         MATLAB_HDR.StructureClass != mxINT64_CLASS &&         MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */       ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");      switch (MATLAB_HDR.NameFlag)     {       case 0:         size = ReadBlobXXXLong(image2);  /* Object name string size */         size = 4 * (ssize_t) ((size + 3 + 1) / 4);         (void) SeekBlob(image2, size, SEEK_CUR);         break;       case 1:       case 2:       case 3:       case 4:         (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */         break;       default:         goto MATLAB_KO;     }      CellType = ReadBlobXXXLong(image2);    /* Additional object type */     if (logging)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""MATLAB_HDR.CellType: %.20g"",(double) CellType);        (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */      NEXT_FRAME:     switch (CellType)     {       case miINT8:       case miUINT8:         sample_size = 8;         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)            image->depth = 1;         else           image->depth = 8;         /* Byte type cell */         ldblk = (ssize_t) MATLAB_HDR.SizeX;               break;       case miINT16:       case miUINT16:         sample_size = 16;         image->depth = 16;        /* Word type cell */         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);         break;       case miINT32:       case miUINT32:         sample_size = 32;         image->depth = 32;        /* Dword type cell */         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);               break;       case miINT64:       case miUINT64:         sample_size = 64;         image->depth = 64;        /* Qword type cell */         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);               break;          case miSINGLE:         sample_size = 32;         image->depth = 32;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {              /* complex float type cell */   }         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);         break;       case miDOUBLE:         sample_size = 64;          image->depth = 64;        /* double type cell */         (void) SetImageOption(clone_info,""quantum:format"",""floating-point""); DisableMSCWarning(4127)         if (sizeof(double) != 8) RestoreMSCWarning           ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)   {                         /* complex double type cell */           }         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);         break;       default:         ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");     }     (void) sample_size;     image->columns = MATLAB_HDR.SizeX;     image->rows = MATLAB_HDR.SizeY;         quantum_info=AcquireQuantumInfo(clone_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");     one=1;     image->colors = one << image->depth;     if (image->columns == 0 || image->rows == 0)       goto MATLAB_KO;     /* Image is gray when no complex flag is set and 2D Matrix */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       {         image->type=GrayscaleType;         SetImageColorspace(image,GRAYColorspace,exception);       }       /*       If ping is true, then only set image size and colors without       reading any image data.     */     if (image_info->ping)     {       size_t temp = image->columns;       image->columns = image->rows;       image->rows = temp;       goto done_reading; /* !!!!!! BAD  !!!! */     }       status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       return(DestroyImageList(image));    /* ----- Load raster data ----- */     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */     if (BImgBuff == NULL)       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");      MinVal = 0;     MaxVal = 0;     if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */     {       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);     }      /* Main loop for reading all scanlines */     if(z==1) z=0; /* read grey scanlines */     /* else read color scanlines */     do     {       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)       {         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);         if (q == (Quantum *) NULL)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto done_reading;    /* Skip image rotation, when cannot set image pixels    */   }         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))         {           FixLogical((unsigned char *)BImgBuff,ldblk);           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)     { ImportQuantumPixelsFailed:       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),               ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));       break;     }         }         else         {           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)       goto ImportQuantumPixelsFailed;             if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))       FixSignedValues(image,q,MATLAB_HDR.SizeX);         }          if (!SyncAuthenticPixels(image,exception))   {     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),             ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));     goto ExitLoop;   }       }     } while(z-- >= 2); ExitLoop:       /* Read complex part of numbers here */     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)     {        /* Find Min and Max Values for complex parts of floats */       CellType = ReadBlobXXXLong(image2);    /* Additional object type */       i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/        if (CellType==miDOUBLE || CellType==miSINGLE)       {         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);             }        if (CellType==miDOUBLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,             exception);   }        if (CellType==miSINGLE)         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)   {           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,             exception);   }         }        /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */     if ((MATLAB_HDR.DimFlag == 8) &&         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))       image->type=GrayscaleType;     if (image->depth == 1)       image->type=BilevelType;      if(image2==image)         image2 = NULL;    /* Remove shadow copy to an image before rotation. */        /*  Rotate image. */     rotated_image = RotateImage(image, 90.0, exception);     if (rotated_image != (Image *) NULL)     {         /* Remove page offsets added by RotateImage */       rotated_image->page.x=0;       rotated_image->page.y=0;        blob = rotated_image->blob;       rotated_image->blob = image->blob;       rotated_image->colors = image->colors;       image->blob = blob;       AppendImageToList(&image,rotated_image);             DeleteImageFromList(&image);           }  done_reading:      if(image2!=NULL)       if(image2!=image)       {         DeleteImageFromList(&image2);    if(clone_info)   {           if(clone_info->file)     {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);     }         }           }        /* Allocate next image structure. */         AcquireNextImage(image_info,image,exception);     if (image->next == (Image *) NULL) break;                     image=SyncNextImageInList(image);     image->columns=image->rows=0;     image->colors=0;            /* row scan buffer is no longer needed */     RelinquishMagickMemory(BImgBuff);     BImgBuff = NULL;      if(--Frames>0)     {       z = z2;       if(image2==NULL) image2 = image;       goto NEXT_FRAME;     }     if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */       { /*  CloseBlob(image2); */         DeleteImageFromList(&image2);         if(clone_info)         {           if(clone_info->file)           {             fclose(clone_info->file);             clone_info->file = NULL;             (void) remove_utf8(clone_info->filename);           }         }         }   }    clone_info=DestroyImageInfo(clone_info);   RelinquishMagickMemory(BImgBuff);   CloseBlob(image);     {     Image *p;         ssize_t scene=0;          /*       Rewind list, removing any empty images while rewinding.     */     p=image;     image=NULL;     while (p != (Image *) NULL)       {         Image *tmp=p;         if ((p->rows == 0) || (p->columns == 0)) {           p=p->previous;           DeleteImageFromList(&tmp);         } else {           image=p;           p=p->previous;         }       }          /*       Fix scene numbers     */     for (p=image; p != (Image *) NULL; p=p->next)       p->scene=scene++;   }    if(clone_info != NULL)  /* cleanup garbage file from compression */   {     if(clone_info->file)     {       fclose(clone_info->file);       clone_info->file = NULL;       (void) remove_utf8(clone_info->filename);     }     DestroyImageInfo(clone_info);     clone_info = NULL;   }   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");   if(image==NULL)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   return (image); }"
"198169_CWE-369.cc","CWE-369","TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,                                int index) {   TfLiteTensor* tensor = GetMutableInput(context, node, index);   return tensor->is_variable ? tensor : nullptr; }"
"198170_CWE-369.cc","CWE-369","TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {   auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);   OpData* op_data = reinterpret_cast<OpData*>(node->user_data);    const TfLiteTensor* input;   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));   const TfLiteTensor* weights_feature;   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,                                           &weights_feature));   const TfLiteTensor* weights_time;   TF_LITE_ENSURE_OK(       context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));   const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);    TfLiteTensor* scratch;   TF_LITE_ENSURE_OK(context,                     GetTemporarySafe(context, node, /*index=*/0, &scratch));    TfLiteTensor* state = GetVariableInput(context, node, kStateTensor);   TfLiteTensor* output;   TF_LITE_ENSURE_OK(context,                     GetOutputSafe(context, node, kOutputTensor, &output));    switch (weights_feature->type) {     case kTfLiteFloat32: {       reference_ops::EvalFloatSVDF(           params, GetTensorShape(input), GetTensorData<float>(input),           GetTensorShape(weights_feature),           GetTensorData<float>(weights_feature), GetTensorShape(weights_time),           GetTensorData<float>(weights_time), GetTensorShape(bias),           GetTensorData<float>(bias), GetTensorData<float>(scratch),           GetTensorData<float>(state), GetTensorShape(output),           GetTensorData<float>(output));       return kTfLiteOk;     }     case kTfLiteUInt8:     case kTfLiteInt8: {       if (input->type == kTfLiteFloat32) {         TfLiteTensor* input_quantized;         TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,                                                     &input_quantized));         TfLiteTensor* scaling_factors;         TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,                                                     &scaling_factors));         TfLiteTensor* float_weights_time;         TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,                                                     &float_weights_time));         TfLiteTensor* zero_points;         TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/4,                                                     &zero_points));         TfLiteTensor* row_sums;         TF_LITE_ENSURE_OK(             context, GetTemporarySafe(context, node, /*index=*/5, &row_sums));         // Dequantize weights time.         // TODO(alanchiao): this dequantization initialization only needs to         // happen once per model and should theoretically be placed in either         // Init or Prepare. However, TFLite doesn't allocate float_weights_time         // until the Eval function.         // TODO(alanchiao): refactor logic out into dequantize function.         if (!op_data->float_weights_time_initialized) {           const float dequantization_scale = weights_time->params.scale;           const int8_t* weights_time_ptr = GetTensorData<int8_t>(weights_time);           float* float_weights_time_ptr =               GetTensorData<float>(float_weights_time);           for (int i = 0; i < NumElements(float_weights_time); ++i) {             float_weights_time_ptr[i] =                 weights_time_ptr[i] * dequantization_scale;           }           op_data->float_weights_time_initialized = true;         }          int32_t* zero_points_ptr = nullptr;         int32_t* row_sums_ptr = nullptr;         if (params->asymmetric_quantize_inputs && row_sums != nullptr) {           zero_points_ptr = GetTensorData<int32_t>(zero_points);           row_sums_ptr = GetTensorData<int32_t>(row_sums);         }          reference_ops::EvalHybridSVDF(             params, GetTensorShape(input), GetTensorData<float>(input),             GetTensorShape(weights_feature),             GetTensorData<int8_t>(weights_feature),             weights_feature->params.scale, GetTensorShape(float_weights_time),             GetTensorData<float>(float_weights_time), GetTensorShape(bias),             GetTensorData<float>(bias), GetTensorData<float>(scratch),             GetTensorData<float>(scaling_factors),             GetTensorData<int8_t>(input_quantized), GetTensorData<float>(state),             GetTensorShape(output), GetTensorData<float>(output),             zero_points_ptr, row_sums_ptr, &op_data->compute_row_sums);         return kTfLiteOk;       }       auto* input_params = reinterpret_cast<TfLiteAffineQuantization*>(           input->quantization.params);       auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(           output->quantization.params);       TfLiteTensor* output_temp;       TF_LITE_ENSURE_OK(           context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));        // Currently supports only ReLU.       // TODO(jianlijianli): support other activations.       TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActRelu);        reference_ops::EvalIntegerSVDF(           params, GetTensorShape(input), GetTensorData<int8_t>(input),           GetTensorShape(weights_feature),           GetTensorData<int8_t>(weights_feature), GetTensorShape(weights_time),           GetTensorData<int16_t>(weights_time), GetTensorShape(bias),           GetTensorData<int32_t>(bias), GetTensorData<int16_t>(state),           GetTensorShape(output), GetTensorData<int8_t>(output),           GetTensorData<int32_t>(scratch), GetTensorData<int32_t>(output_temp),           op_data->effective_scale_1_a, op_data->effective_scale_1_b,           op_data->effective_scale_2_a, op_data->effective_scale_2_b,           input_params->zero_point->data[0],           output_params->zero_point->data[0]);       return kTfLiteOk;     }     default:       context->ReportError(context, ""Type %s not currently supported."",                            TfLiteTypeGetName(weights_feature->type));       return kTfLiteError;   } }"
"198198_CWE-125.cc","CWE-125","  void DoCompute(OpKernelContext* c) {     core::RefCountPtr<Var> v;     OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));     Tensor* params = v->tensor();     const Tensor& indices = c->input(1);     const Tensor& updates = c->input(2);      // Check that rank(updates.shape) = rank(indices.shape + params.shape[1:])     OP_REQUIRES(c,                 updates.dims() == 0 ||                     updates.dims() == indices.dims() + params->dims() - 1,                 errors::InvalidArgument(                     ""Must have updates.shape = indices.shape + ""                     ""params.shape[1:] or updates.shape = [], got "",                     ""updates.shape "", updates.shape().DebugString(),                     "", indices.shape "", indices.shape().DebugString(),                     "", params.shape "", params->shape().DebugString()));      // Check that we have enough index space     const int64_t N_big = indices.NumElements();     OP_REQUIRES(         c, N_big <= std::numeric_limits<Index>::max(),         errors::InvalidArgument(""indices has too many elements for "",                                 DataTypeString(DataTypeToEnum<Index>::v()),                                 "" indexing: "", N_big, "" > "",                                 std::numeric_limits<Index>::max()));     const Index N = static_cast<Index>(N_big);     OP_REQUIRES(         c, params->dim_size(0) <= std::numeric_limits<Index>::max(),         errors::InvalidArgument(""params.shape[0] too large for "",                                 DataTypeString(DataTypeToEnum<Index>::v()),                                 "" indexing: "", params->dim_size(0), "" > "",                                 std::numeric_limits<Index>::max()));      if (N > 0) {       auto indices_flat = indices.flat<Index>();       auto params_flat = params->flat_outer_dims<T>();       if (TensorShapeUtils::IsScalar(updates.shape())) {         const auto update = updates.scalar<T>();          functor::ScatterScalarFunctor<Device, T, Index, op> functor;         const Index bad_i = functor(c, c->template eigen_device<Device>(),                                     params_flat, update, indices_flat);         OP_REQUIRES(c, bad_i < 0,                     errors::InvalidArgument(                         ""indices"", SliceDebugString(indices.shape(), bad_i),                         "" = "", indices_flat(bad_i), "" is not in [0, "",                         params->dim_size(0), "")""));       } else {         int64_t num_updates = updates.NumElements();         OP_REQUIRES(c, num_updates % N == 0,                     errors::InvalidArgument(                         ""shape of indices ("", indices.shape().DebugString(),                         "") is not compatible with the shape of updates ("",                         updates.shape().DebugString(), "")""));         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});          functor::ScatterFunctor<Device, T, Index, op> functor;         const Index bad_i = functor(c, c->template eigen_device<Device>(),                                     params_flat, updates_flat, indices_flat);         OP_REQUIRES(c, bad_i < 0,                     errors::InvalidArgument(                         ""indices"", SliceDebugString(indices.shape(), bad_i),                         "" = "", indices_flat(bad_i), "" is not in [0, "",                         params->dim_size(0), "")""));       }     }   }"
"198239_CWE-200.c","CWE-200","static int check_passwd(unsigned char *passwd, size_t length) { 	struct digest *d = NULL; 	unsigned char *passwd1_sum; 	unsigned char *passwd2_sum; 	int ret = 0; 	int hash_len;  	if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { 		hash_len = PBKDF2_LENGTH; 	} else { 		d = digest_alloc(PASSWD_SUM); 		if (!d) { 			pr_err(""No such digest: %s\n"", 			       PASSWD_SUM ? PASSWD_SUM : ""NULL""); 			return -ENOENT; 		}  		hash_len = digest_length(d); 	}  	passwd1_sum = calloc(hash_len * 2, sizeof(unsigned char)); 	if (!passwd1_sum) 		return -ENOMEM;  	passwd2_sum = passwd1_sum + hash_len;  	if (is_passwd_env_enable()) 		ret = read_env_passwd(passwd2_sum, hash_len); 	else if (is_passwd_default_enable()) 		ret = read_default_passwd(passwd2_sum, hash_len); 	else 		ret = -EINVAL;  	if (ret < 0) 		goto err;  	if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { 		char *key = passwd2_sum + PBKDF2_SALT_LEN; 		char *salt = passwd2_sum; 		int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;  		ret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt, 			PBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum); 		if (ret) 			goto err;  		if (strncmp(passwd1_sum, key, keylen) == 0) 			ret = 1; 	} else { 		ret = digest_digest(d, passwd, length, passwd1_sum);  		if (ret) 			goto err;  		if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0) 			ret = 1; 	}  err: 	free(passwd1_sum); 	digest_free(d);  	return ret; }"
"198259_CWE-369.cc","CWE-369","  void Compute(OpKernelContext* context) override {     // Get the input Tensors.     OpInputList params_nested_splits_in;     OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",                                                 &params_nested_splits_in));     const Tensor& params_dense_values_in =         context->input(params_nested_splits_in.size());     const Tensor& indices_in =         context->input(params_nested_splits_in.size() + 1);      DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));      OP_REQUIRES(context, params_dense_values_in.dims() > 0,                 errors::InvalidArgument(""params.rank must be nonzero""));     SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);      // Calculate the `splits`, and store the value slices that we need to     // copy in `value_slices`.     std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;     SPLITS_TYPE num_values = 0;     std::vector<std::vector<SPLITS_TYPE>> out_splits;     OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,                                        num_params_dense_values, &out_splits,                                        &value_slices, &num_values));      // Write the output tensors.     OP_REQUIRES_OK(context, WriteSplits(out_splits, context));     OP_REQUIRES_OK(context,                    WriteValues(params_dense_values_in, value_slices,                                out_splits.size(), num_values, context));   }"
"198282_CWE-369.cc","CWE-369","void ReshapeSparseTensor(OpKernelContext *context,                          const Tensor &input_indices_in,                          const Tensor &input_shape_in,                          const Tensor &target_shape_in, int output_indices_idx,                          int output_shape_idx) {   OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),               errors::InvalidArgument(                   ""Input indices should be a matrix but received shape "",                   input_indices_in.shape().DebugString()));   OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),               errors::InvalidArgument(                   ""Input shape should be a vector but received shape "",                   input_shape_in.shape().DebugString()));   OP_REQUIRES(context, TensorShapeUtils::IsVector(target_shape_in.shape()),               errors::InvalidArgument(                   ""Target shape should be a vector but received shape "",                   target_shape_in.shape().DebugString()));    const int64_t output_rank = target_shape_in.NumElements();   const TensorShape input_shape(input_shape_in.vec<int64>());   const int64_t dense_size = input_shape.num_elements();   const int64_t nnz = input_indices_in.shape().dim_size(0);    // Compute the output shape. Determine product of specified dimensions, and   // find the index of the unspecified one.   TensorShape output_shape;   int64_t product = 1;   int unknown_index = -1;   auto target_shape = target_shape_in.vec<int64>();   for (int d = 0; d < output_rank; ++d) {     const int64_t size = target_shape(d);     if (size == -1) {       OP_REQUIRES(           context, unknown_index == -1,           errors::InvalidArgument(""only one output dimension may be -1, ""                                   ""not both "",                                   unknown_index, "" and "", d));       unknown_index = d;       output_shape.AddDim(1);     } else {       OP_REQUIRES(context, size >= 0,                   errors::InvalidArgument(""size "", d,                                           "" must be non-negative, not "", size));       product *= size;       output_shape.AddDim(size);     }   }   if (unknown_index != -1) {     OP_REQUIRES(         context, product > 0,         errors::InvalidArgument(""reshape cannot infer the missing ""                                 ""input size for an empty tensor unless all ""                                 ""specified input sizes are non-zero""));     const int64_t missing = dense_size / product;     OP_REQUIRES(         context, product * missing == dense_size,         errors::InvalidArgument(             ""Input to reshape is a SparseTensor with "", dense_size,             "" dense values, but the requested shape requires a multiple of "",             product, "". input_shape="", input_shape.DebugString(),             "" output_shape="", output_shape.DebugString()));     output_shape.set_dim(unknown_index, missing);   }    OP_REQUIRES(       context, output_shape.num_elements() == dense_size,       errors::InvalidArgument(""Input to reshape is a tensor with "", dense_size,                               "" dense values, but the requested shape has "",                               output_shape.num_elements(),                               "". input_shape="", input_shape.DebugString(),                               "" output_shape="", output_shape.DebugString()));    // Optimize for reshaping to the same shape.   if (input_shape == output_shape) {     context->set_output(output_indices_idx, input_indices_in);     context->set_output(output_shape_idx, input_shape_in);     return;   }    Tensor *result_shape = nullptr;   OP_REQUIRES_OK(context, context->allocate_output(output_shape_idx,                                                    TensorShape({output_rank}),                                                    &result_shape));   auto output_shape_vec = result_shape->vec<int64>();   for (int j = 0; j < output_shape.dims(); ++j) {     output_shape_vec(j) = output_shape.dim_size(j);   }    Tensor *result_indices = nullptr;   OP_REQUIRES_OK(context,                  context->allocate_output(output_indices_idx,                                           TensorShape({nnz, output_rank}),                                           &result_indices));   if (nnz > 0) {     OP_REQUIRES_OK(context, functor::ReshapeSparseTensorFunctor<Device>()(                                 context, input_shape, output_shape,                                 input_indices_in.matrix<int64>(),                                 result_indices->matrix<int64>()));   } }"
"198350_CWE-416.c","CWE-416","net_bind(short unsigned *port, int type, const char *log_service_name) {   struct addrinfo hints = { 0 };   struct addrinfo *servinfo;   struct addrinfo *ptr;   const char *cfgaddr;   char addr[INET6_ADDRSTRLEN];   char strport[8];   int yes = 1;   int no = 0;   int fd;   int ret;    cfgaddr = cfg_getstr(cfg_getsec(cfg, ""general""), ""bind_address"");    hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, ""general""), ""ipv6"")) ? AF_INET6 : AF_INET;   hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;    snprintf(strport, sizeof(strport), ""%hu"", *port);   ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);   if (ret < 0)     {       DPRINTF(E_LOG, L_MISC, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", strport, gai_strerror(ret));       return -1;     }    for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)     {       if (fd >= 0) 	close(fd);        fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);       if (fd < 0) 	continue;        // TODO libevent sets this, we do the same?       ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));       if (ret < 0) 	continue;        ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));       if (ret < 0) 	continue;        if (ptr->ai_family == AF_INET6) 	{ 	  // We want to be sure the service is dual stack 	  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no)); 	  if (ret < 0) 	    continue; 	}        ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);       if (ret < 0) 	continue;        break;     }    freeaddrinfo(servinfo);    if (!ptr)     {       DPRINTF(E_LOG, L_MISC, ""Could not create service '%s' with address %s, port %hu: %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", *port, strerror(errno));       goto error;     }    // Get the port that was assigned   ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);   if (ret < 0)     {       DPRINTF(E_LOG, L_MISC, ""Could not find address of service '%s': %s\n"", log_service_name, strerror(errno));       goto error;     }    net_port_get(port, (union net_sockaddr *)ptr->ai_addr);   net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);    DPRINTF(E_DBG, L_MISC, ""Service '%s' bound to %s, port %hu, socket %d\n"", log_service_name, addr, *port, fd);    return fd;   error:   close(fd);   return -1; }"
"198374_CWE-703.cc","CWE-703","  void Compute(OpKernelContext* ctx) override {     const Tensor* x_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""x"", &x_tensor));      const Tensor* cs_prev_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""cs_prev"", &cs_prev_tensor));      const Tensor* h_prev_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""h_prev"", &h_prev_tensor));      const Tensor* w_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""w"", &w_tensor));      const Tensor* wci_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wci"", &wci_tensor));      const Tensor* wcf_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wcf"", &wcf_tensor));      const Tensor* wco_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wco"", &wco_tensor));      const Tensor* b_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""b"", &b_tensor));      const int64_t batch_size = x_tensor->dim_size(0);     const int64_t input_size = x_tensor->dim_size(1);     const int64_t cell_size = cs_prev_tensor->dim_size(1);      // Sanity checks for our input shapes.     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,                 errors::InvalidArgument(""cs_prev.dims(0) != batch_size: "",                                         cs_prev_tensor->dim_size(0), "" vs. "",                                         batch_size));     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,                 errors::InvalidArgument(""cs_prev.dims(1) != cell_size: "",                                         cs_prev_tensor->dim_size(1), "" vs. "",                                         cell_size));      OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,                 errors::InvalidArgument(""h_prev.dims(0) != batch_size: "",                                         h_prev_tensor->dim_size(0), "" vs. "",                                         batch_size));     OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,                 errors::InvalidArgument(                     ""h_prev.dims(1) != cell_size: "", h_prev_tensor->dim_size(1),                     "" vs. "", cell_size));      OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,                 errors::InvalidArgument(                     ""w.dim_size(0) != input_size + cell_size: "",                     w_tensor->dim_size(0), "" vs. "", input_size + cell_size));     OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,                 errors::InvalidArgument(                     ""w.dim_size(1) != cell_size * 4: "", w_tensor->dim_size(1),                     "" vs. "", cell_size * 4));      OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,                 errors::InvalidArgument(                     ""b.dim_size(0) != cell_size * 4: "", b_tensor->dim_size(0),                     "" vs. "", cell_size * 4));      // Allocate our output tensors.     Tensor* i_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(                             {""h_prev""}, ""i"",                             TensorShape({batch_size, cell_size}), &i_tensor));      Tensor* cs_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""cs"", TensorShape({batch_size, cell_size}),                                   &cs_tensor));      Tensor* f_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""f"", TensorShape({batch_size, cell_size}),                                   &f_tensor));      Tensor* o_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(                             {""cs_prev""}, ""o"",                             TensorShape({batch_size, cell_size}), &o_tensor));      Tensor* ci_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""ci"", TensorShape({batch_size, cell_size}),                                   &ci_tensor));      Tensor* co_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""co"", TensorShape({batch_size, cell_size}),                                   &co_tensor));      Tensor* h_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""h"", TensorShape({batch_size, cell_size}),                                   &h_tensor));      // Allocate our temp tensors.     Tensor xh_tensor;     OP_REQUIRES_OK(ctx, ctx->allocate_temp(                             DataTypeToEnum<T>::v(),                             TensorShape({batch_size, input_size + cell_size}),                             &xh_tensor));      Tensor gates_tensor;     OP_REQUIRES_OK(ctx,                    ctx->allocate_temp(DataTypeToEnum<T>::v(),                                       TensorShape({batch_size, cell_size * 4}),                                       &gates_tensor));      const Device& device = ctx->eigen_device<Device>();      functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(         batch_size, input_size, cell_size)(         ctx, device, forget_bias_, cell_clip_, use_peephole_,         x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),         h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),         wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),         xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),         f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),         co_tensor->matrix<T>(), gates_tensor.matrix<T>(),         h_tensor->matrix<T>());   }"
"198399_CWE-787.c","CWE-787","static void handle_PORT(ctrl_t *ctrl, char *str) { 	int a, b, c, d, e, f; 	char addr[INET_ADDRSTRLEN]; 	struct sockaddr_in sin;  	if (ctrl->data_sd > 0) { 		uev_io_stop(&ctrl->data_watcher); 		close(ctrl->data_sd); 		ctrl->data_sd = -1; 	}  	/* Convert PORT command's argument to IP address + port */ 	sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f); 	sprintf(addr, ""%d.%d.%d.%d"", a, b, c, d);  	/* Check IPv4 address using inet_aton(), throw away converted result */ 	if (!inet_aton(addr, &(sin.sin_addr))) { 		ERR(0, ""Invalid address '%s' given to PORT command"", addr); 		send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n""); 		return; 	}  	strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address)); 	ctrl->data_port = e * 256 + f;  	DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port); 	send_msg(ctrl->sd, ""200 PORT command successful.\r\n""); }"
"198439_CWE-288.c","CWE-288","mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc) {   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */   const mrb_irep *irep = proc->body.irep;   const mrb_pool_value *pool = irep->pool;   const mrb_sym *syms = irep->syms;   mrb_code insn;   int ai = mrb_gc_arena_save(mrb);   struct mrb_jmpbuf *prev_jmp = mrb->jmp;   struct mrb_jmpbuf c_jmp;   uint32_t a;   uint16_t b;   uint16_t c;   mrb_sym mid;   const struct mrb_irep_catch_handler *ch;  #ifdef DIRECT_THREADED   static const void * const optable[] = { #define OPCODE(x,_) &&L_OP_ ## x, #include ""mruby/ops.h"" #undef OPCODE   }; #endif    mrb_bool exc_catched = FALSE; RETRY_TRY_BLOCK:    MRB_TRY(&c_jmp) {    if (exc_catched) {     exc_catched = FALSE;     mrb_gc_arena_restore(mrb, ai);     if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)       goto L_BREAK;     goto L_RAISE;   }   mrb->jmp = &c_jmp;   mrb_vm_ci_proc_set(mrb->c->ci, proc);  #define regs (mrb->c->ci->stack)   INIT_DISPATCH {     CASE(OP_NOP, Z) {       /* do nothing */       NEXT;     }      CASE(OP_MOVE, BB) {       regs[a] = regs[b];       NEXT;     }      CASE(OP_LOADL, BB) {       switch (pool[b].tt) {   /* number */       case IREP_TT_INT32:         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);         break;       case IREP_TT_INT64: #if defined(MRB_INT64)         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);         break; #else #if defined(MRB_64BIT)         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);           break;         } #endif         goto L_INT_OVERFLOW; #endif       case IREP_TT_BIGINT:         goto L_INT_OVERFLOW; #ifndef MRB_NO_FLOAT       case IREP_TT_FLOAT:         regs[a] = mrb_float_value(mrb, pool[b].u.f);         break; #endif       default:         /* should not happen (tt:string) */         regs[a] = mrb_nil_value();         break;       }       NEXT;     }      CASE(OP_LOADI, BB) {       SET_FIXNUM_VALUE(regs[a], b);       NEXT;     }      CASE(OP_LOADINEG, BB) {       SET_FIXNUM_VALUE(regs[a], -b);       NEXT;     }      CASE(OP_LOADI__1,B) goto L_LOADI;     CASE(OP_LOADI_0,B) goto L_LOADI;     CASE(OP_LOADI_1,B) goto L_LOADI;     CASE(OP_LOADI_2,B) goto L_LOADI;     CASE(OP_LOADI_3,B) goto L_LOADI;     CASE(OP_LOADI_4,B) goto L_LOADI;     CASE(OP_LOADI_5,B) goto L_LOADI;     CASE(OP_LOADI_6,B) goto L_LOADI;     CASE(OP_LOADI_7, B) {     L_LOADI:       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);       NEXT;     }      CASE(OP_LOADI16, BS) {       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);       NEXT;     }      CASE(OP_LOADI32, BSS) {       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));       NEXT;     }      CASE(OP_LOADSYM, BB) {       SET_SYM_VALUE(regs[a], syms[b]);       NEXT;     }      CASE(OP_LOADNIL, B) {       SET_NIL_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADSELF, B) {       regs[a] = regs[0];       NEXT;     }      CASE(OP_LOADT, B) {       SET_TRUE_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADF, B) {       SET_FALSE_VALUE(regs[a]);       NEXT;     }      CASE(OP_GETGV, BB) {       mrb_value val = mrb_gv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETGV, BB) {       mrb_gv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETSV, BB) {       mrb_value val = mrb_vm_special_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETSV, BB) {       mrb_vm_special_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIV, BB) {       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);       NEXT;     }      CASE(OP_SETIV, BB) {       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETCV, BB) {       mrb_value val;       val = mrb_vm_cv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETCV, BB) {       mrb_vm_cv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIDX, B) {       mrb_value va = regs[a], vb = regs[a+1];       switch (mrb_type(va)) {       case MRB_TT_ARRAY:         if (!mrb_integer_p(vb)) goto getidx_fallback;         regs[a] = mrb_ary_entry(va, mrb_integer(vb));         break;       case MRB_TT_HASH:         va = mrb_hash_get(mrb, va, vb);         regs[a] = va;         break;       case MRB_TT_STRING:         switch (mrb_type(vb)) {         case MRB_TT_INTEGER:         case MRB_TT_STRING:         case MRB_TT_RANGE:           va = mrb_str_aref(mrb, va, vb, mrb_undef_value());           regs[a] = va;           break;         default:           goto getidx_fallback;         }         break;       default:       getidx_fallback:         mid = MRB_OPSYM(aref);         goto L_SEND_SYM;       }       NEXT;     }      CASE(OP_SETIDX, B) {       c = 2;       mid = MRB_OPSYM(aset);       SET_NIL_VALUE(regs[a+3]);       goto L_SENDB_SYM;     }      CASE(OP_GETCONST, BB) {       mrb_value v = mrb_vm_const_get(mrb, syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETCONST, BB) {       mrb_vm_const_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETMCNST, BB) {       mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETMCNST, BB) {       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETUPVAR, BBB) {       mrb_value *regs_a = regs + a;       struct REnv *e = uvenv(mrb, c);        if (e && b < MRB_ENV_LEN(e)) {         *regs_a = e->stack[b];       }       else {         *regs_a = mrb_nil_value();       }       NEXT;     }      CASE(OP_SETUPVAR, BBB) {       struct REnv *e = uvenv(mrb, c);        if (e) {         mrb_value *regs_a = regs + a;          if (b < MRB_ENV_LEN(e)) {           e->stack[b] = *regs_a;           mrb_write_barrier(mrb, (struct RBasic*)e);         }       }       NEXT;     }      CASE(OP_JMP, S) {       pc += (int16_t)a;       JUMP;     }     CASE(OP_JMPIF, BS) {       if (mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNOT, BS) {       if (!mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNIL, BS) {       if (mrb_nil_p(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }      CASE(OP_JMPUW, S) {       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {         struct RBreak *brk = (struct RBreak*)mrb->exc;         mrb_value target = mrb_break_value_get(brk);         mrb_assert(mrb_integer_p(target));         a = (uint32_t)mrb_integer(target);         mrb_assert(a >= 0 && a < irep->ilen);       }       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);         if (ch) {           /* avoiding a jump from a catch handler into the same handler */           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));           }         }       }       CHECKPOINT_END(RBREAK_TAG_JUMP);        mrb->exc = NULL; /* clear break object */       pc = irep->iseq + a;       JUMP;     }      CASE(OP_EXCEPT, B) {       mrb_value exc;        if (mrb->exc == NULL) {         exc = mrb_nil_value();       }       else {         switch (mrb->exc->tt) {         case MRB_TT_BREAK:         case MRB_TT_EXCEPTION:           exc = mrb_obj_value(mrb->exc);           break;         default:           mrb_assert(!""bad mrb_type"");           exc = mrb_nil_value();           break;         }         mrb->exc = NULL;       }       regs[a] = exc;       NEXT;     }     CASE(OP_RESCUE, BB) {       mrb_value exc = regs[a];  /* exc on stack */       mrb_value e = regs[b];       struct RClass *ec;        switch (mrb_type(e)) {       case MRB_TT_CLASS:       case MRB_TT_MODULE:         break;       default:         {           mrb_value exc;            exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                     ""class or module required for rescue clause"");           mrb_exc_set(mrb, exc);           goto L_RAISE;         }       }       ec = mrb_class_ptr(e);       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));       NEXT;     }      CASE(OP_RAISEIF, B) {       mrb_value exc = regs[a];       if (mrb_break_p(exc)) {         mrb->exc = mrb_obj_ptr(exc);         goto L_BREAK;       }       mrb_exc_set(mrb, exc);       if (mrb->exc) {         goto L_RAISE;       }       NEXT;     }      CASE(OP_SSEND, BBB) {       regs[a] = regs[0];       insn = OP_SEND;     }     goto L_SENDB;      CASE(OP_SSENDB, BBB) {       regs[a] = regs[0];     }     goto L_SENDB;      CASE(OP_SEND, BBB)     goto L_SENDB;      L_SEND_SYM:     c = 1;     /* push nil after arguments */     SET_NIL_VALUE(regs[a+2]);     goto L_SENDB_SYM;      CASE(OP_SENDB, BBB)     L_SENDB:     mid = syms[b];     L_SENDB_SYM:     {       mrb_callinfo *ci = mrb->c->ci;       mrb_method_t m;       struct RClass *cls;       mrb_value recv, blk;        ARGUMENT_NORMALIZE(a, &c, insn);        recv = regs[a];       cls = mrb_class(mrb, recv);       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, c);        if (MRB_METHOD_CFUNC_P(m)) {         if (MRB_METHOD_PROC_P(m)) {           struct RProc *p = MRB_METHOD_PROC(m);            mrb_vm_ci_proc_set(ci, p);           recv = p->body.func(mrb, recv);         }         else {           if (MRB_METHOD_NOARG_P(m)) {             check_method_noarg(mrb, ci);           }           recv = MRB_METHOD_FUNC(m)(mrb, recv);         }         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }         if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return recv;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         ci->stack[0] = recv;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }     }     JUMP;      CASE(OP_CALL, Z) {       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv = ci->stack[0];       struct RProc *m = mrb_proc_ptr(recv);        /* replace callinfo */       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);       mrb_vm_ci_proc_set(ci, m);       if (MRB_PROC_ENV_P(m)) {         ci->mid = MRB_PROC_ENV(m)->mid;       }        /* prepare stack */       if (MRB_PROC_CFUNC_P(m)) {         recv = MRB_PROC_CFUNC(m)(mrb, recv);         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;         ci[1].stack[0] = recv;         irep = mrb->c->ci->proc->body.irep;       }       else {         /* setup environment for calling method */         proc = m;         irep = m->body.irep;         if (!irep) {           mrb->c->ci->stack[0] = mrb_nil_value();           a = 0;           c = OP_R_NORMAL;           goto L_OP_RETURN_BODY;         }         mrb_int nargs = mrb_ci_bidx(ci)+1;         if (nargs < irep->nregs) {           mrb_stack_extend(mrb, irep->nregs);           stack_clear(regs+nargs, irep->nregs-nargs);         }         if (MRB_PROC_ENV_P(m)) {           regs[0] = MRB_PROC_ENV(m)->stack[0];         }         pc = irep->iseq;       }       pool = irep->pool;       syms = irep->syms;       JUMP;     }      CASE(OP_SUPER, BB) {       mrb_method_t m;       struct RClass *cls;       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv, blk;       const struct RProc *p = ci->proc;       mrb_sym mid = ci->mid;       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);        if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */         mid = p->e.env->mid;    /* restore old mid */       }        if (mid == 0 || !target_class) {         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {         target_class = mrb_vm_ci_target_class(ci);       }       else if (target_class->tt == MRB_TT_MODULE) {         target_class = mrb_vm_ci_target_class(ci);         if (!target_class || target_class->tt != MRB_TT_ICLASS) {           goto super_typeerror;         }       }       recv = regs[0];       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {       super_typeerror: ;         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                             ""self has wrong type to call super in this context"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }        ARGUMENT_NORMALIZE(a, &b, OP_SUPER);        cls = target_class->super;       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, b);        /* prepare stack */       ci->stack[0] = recv;        if (MRB_METHOD_CFUNC_P(m)) {         mrb_value v;          if (MRB_METHOD_PROC_P(m)) {           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));         }         v = MRB_METHOD_CFUNC(m)(mrb, recv);         mrb_gc_arena_restore(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         mrb_assert(!mrb_break_p(v));         if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return v;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         mrb->c->ci->stack[0] = v;         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }       JUMP;     }      CASE(OP_ARGARY, BS) {       mrb_int m1 = (b>>11)&0x3f;       mrb_int r  = (b>>10)&0x1;       mrb_int m2 = (b>>5)&0x1f;       mrb_int kd = (b>>4)&0x1;       mrb_int lv = (b>>0)&0xf;       mrb_value *stack;        if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {         mrb_value exc;        L_NOSUPER:         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e) goto L_NOSUPER;         if (MRB_ENV_LEN(e) <= m1+r+m2+1)           goto L_NOSUPER;         stack = e->stack + 1;       }       if (r == 0) {         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);       }       else {         mrb_value *pp = NULL;         struct RArray *rest;         mrb_int len = 0;          if (mrb_array_p(stack[m1])) {           struct RArray *ary = mrb_ary_ptr(stack[m1]);            pp = ARY_PTR(ary);           len = ARY_LEN(ary);         }         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);         rest = mrb_ary_ptr(regs[a]);         if (m1 > 0) {           stack_copy(ARY_PTR(rest), stack, m1);         }         if (len > 0) {           stack_copy(ARY_PTR(rest)+m1, pp, len);         }         if (m2 > 0) {           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);         }         ARY_SET_LEN(rest, m1+len+m2);       }       if (kd) {         regs[a+1] = stack[m1+r+m2];         regs[a+2] = stack[m1+r+m2+1];       }       else {         regs[a+1] = stack[m1+r+m2];       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ENTER, W) {       mrb_int m1 = MRB_ASPEC_REQ(a);       mrb_int o  = MRB_ASPEC_OPT(a);       mrb_int r  = MRB_ASPEC_REST(a);       mrb_int m2 = MRB_ASPEC_POST(a);       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;       /* unused       int b  = MRB_ASPEC_BLOCK(a);       */       mrb_int const len = m1 + o + r + m2;        mrb_callinfo *ci = mrb->c->ci;       mrb_int argc = ci->n;       mrb_value *argv = regs+1;       mrb_value * const argv0 = argv;       mrb_int const kw_pos = len + kd;    /* where kwhash should be */       mrb_int const blk_pos = kw_pos + 1; /* where block should be */       mrb_value blk = regs[mrb_ci_bidx(ci)];       mrb_value kdict = mrb_nil_value();        /* keyword arguments */       if (ci->nk > 0) {         mrb_int kidx = mrb_ci_kidx(ci);         kdict = regs[kidx];         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {           kdict = mrb_nil_value();           ci->nk = 0;         }       }       if (!kd && !mrb_nil_p(kdict)) {         if (argc < 14) {           ci->n++;           argc++;    /* include kdict in normal arguments */         }         else if (argc == 14) {           /* pack arguments and kdict */           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);           argc = ci->n = 15;         }         else {/* argc == 15 */           /* push kdict to packed arguments */           mrb_ary_push(mrb, regs[1], regs[2]);         }         ci->nk = 0;       }       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {         kdict = mrb_hash_dup(mrb, kdict);       }        /* arguments is passed with Array */       if (argc == 15) {         struct RArray *ary = mrb_ary_ptr(regs[1]);         argv = ARY_PTR(ary);         argc = (int)ARY_LEN(ary);         mrb_gc_protect(mrb, regs[1]);       }        /* strict argument check */       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {         if (argc < m1 + m2 || (r == 0 && argc > len)) {           argnum_error(mrb, m1+m2);           goto L_RAISE;         }       }       /* extract first argument array to arguments */       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {         mrb_gc_protect(mrb, argv[0]);         argc = (int)RARRAY_LEN(argv[0]);         argv = RARRAY_PTR(argv[0]);       }        /* rest arguments */       mrb_value rest = mrb_nil_value();       if (argc < len) {         mrb_int mlen = m2;         if (argc < m1+m2) {           mlen = m1 < argc ? argc - m1 : 0;         }          /* copy mandatory and optional arguments */         if (argv0 != argv && argv) {           value_move(&regs[1], argv, argc-mlen); /* m1 + o */         }         if (argc < m1) {           stack_clear(&regs[argc+1], m1-argc);         }         /* copy post mandatory arguments */         if (mlen) {           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);         }         if (mlen < m2) {           stack_clear(&regs[len-m2+mlen+1], m2-mlen);         }         /* initialize rest arguments with empty Array */         if (r) {           rest = mrb_ary_new_capa(mrb, 0);           regs[m1+o+1] = rest;         }         /* skip initializer of passed arguments */         if (o > 0 && argc > m1+m2)           pc += (argc - m1 - m2)*3;       }       else {         mrb_int rnum = 0;         if (argv0 != argv) {           value_move(&regs[1], argv, m1+o);         }         if (r) {           rnum = argc-m1-o-m2;           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);           regs[m1+o+1] = rest;         }         if (m2 > 0 && argc-m2 > m1) {           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);         }         pc += o*3;       }        /* need to be update blk first to protect blk from GC */       regs[blk_pos] = blk;              /* move block */       if (kd) {         if (mrb_nil_p(kdict))           kdict = mrb_hash_new_capa(mrb, 0);         regs[kw_pos] = kdict;           /* set kwhash */       }        /* format arguments for generated code */       mrb->c->ci->n = len;        /* clear local (but non-argument) variables */       if (irep->nlocals-blk_pos-1 > 0) {         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);       }       JUMP;     }      CASE(OP_KARG, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict, v;        if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {         mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       v = mrb_hash_get(mrb, kdict, k);       regs[a] = v;       mrb_hash_delete_key(mrb, kdict, k);       NEXT;     }      CASE(OP_KEY_P, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;       mrb_bool key_p = FALSE;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {         key_p = mrb_hash_key_p(mrb, kdict, k);       }       regs[a] = mrb_bool_value(key_p);       NEXT;     }      CASE(OP_KEYEND, Z) {       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {         mrb_value keys = mrb_hash_keys(mrb, kdict);         mrb_value key1 = RARRAY_PTR(keys)[0];         mrb_value str = mrb_format(mrb, ""unknown keyword: %v"", key1);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       NEXT;     }      CASE(OP_BREAK, B) {       c = OP_R_BREAK;       goto L_RETURN;     }     CASE(OP_RETURN_BLK, B) {       c = OP_R_RETURN;       goto L_RETURN;     }     CASE(OP_RETURN, B)     c = OP_R_NORMAL;     L_RETURN:     {       mrb_callinfo *ci;        ci = mrb->c->ci;       if (ci->mid) {         mrb_value blk = regs[mrb_ci_bidx(ci)];          if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);            if (!MRB_PROC_STRICT_P(p) &&               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }       }        if (mrb->exc) {       L_RAISE:         ci = mrb->c->ci;         if (ci == mrb->c->cibase) {           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);           if (ch == NULL) goto L_FTOP;           goto L_CATCH;         }         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {           ci = cipop(mrb);           if (ci[1].cci == CINFO_SKIP && prev_jmp) {             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           pc = ci[0].pc;           if (ci == mrb->c->cibase) {             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);             if (ch == NULL) {             L_FTOP:             /* fiber top */               if (mrb->c == mrb->root_c) {                 mrb->c->ci->stack = mrb->c->stbase;                 goto L_STOP;               }               else {                 struct mrb_context *c = mrb->c;                  c->status = MRB_FIBER_TERMINATED;                 mrb->c = c->prev;                 c->prev = NULL;                 goto L_RAISE;               }             }             break;           }         }       L_CATCH:         if (ch == NULL) goto L_STOP;         if (FALSE) {         L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */           ci = mrb->c->ci;         }         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, irep->nregs);         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);       }       else {         mrb_int acc;         mrb_value v;          ci = mrb->c->ci;         v = regs[a];         mrb_gc_protect(mrb, v);         switch (c) {         case OP_R_RETURN:           /* Fall through to OP_R_NORMAL otherwise */           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {             const struct RProc *dst;             mrb_callinfo *cibase;             cibase = mrb->c->cibase;             dst = top_proc(mrb, proc);              if (MRB_PROC_ENV_P(dst)) {               struct REnv *e = MRB_PROC_ENV(dst);                if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }             }             /* check jump destination */             while (cibase <= ci && ci->proc != dst) {               if (ci->cci > CINFO_NONE) { /* jump cross C boundary */                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }               ci--;             }             if (ci <= cibase) { /* no jump destination */               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);               goto L_RAISE;             }             ci = mrb->c->ci;             while (cibase <= ci && ci->proc != dst) {               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {                 cibase = mrb->c->cibase;                 dst = top_proc(mrb, proc);               }               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);               }               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);               ci = cipop(mrb);               pc = ci->pc;             }             proc = ci->proc;             mrb->exc = NULL; /* clear break object */             break;           }           /* fallthrough */         case OP_R_NORMAL:         NORMAL_RETURN:           if (ci == mrb->c->cibase) {             struct mrb_context *c;             c = mrb->c;              if (!c->prev) { /* toplevel return */               regs[irep->nlocals] = v;               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);             }             if (!c->vmexec && c->prev->ci == c->prev->cibase) {               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, ""double resume"");               mrb_exc_set(mrb, exc);               goto L_RAISE;             }             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {               c = mrb->c;             }             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);             /* automatic yield at the end */             c->status = MRB_FIBER_TERMINATED;             mrb->c = c->prev;             mrb->c->status = MRB_FIBER_RUNNING;             c->prev = NULL;             if (c->vmexec) {               mrb_gc_arena_restore(mrb, ai);               c->vmexec = FALSE;               mrb->jmp = prev_jmp;               return v;             }             ci = mrb->c->ci;           }           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_RETURN);           mrb->exc = NULL; /* clear break object */           break;         case OP_R_BREAK:           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;           if (MRB_PROC_ORPHAN_P(proc)) {             mrb_value exc;            L_BREAK_ERROR:             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,                                       ""break from proc-closure"");             mrb_exc_set(mrb, exc);             goto L_RAISE;           }           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {             goto L_BREAK_ERROR;           }           else {             struct REnv *e = MRB_PROC_ENV(proc);              if (e->cxt != mrb->c) {               goto L_BREAK_ERROR;             }           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK);           /* break from fiber block */           if (ci == mrb->c->cibase && ci->pc) {             struct mrb_context *c = mrb->c;              mrb->c = c->prev;             c->prev = NULL;             ci = mrb->c->ci;           }           if (ci->cci > CINFO_NONE) {             ci = cipop(mrb);             mrb_gc_arena_restore(mrb, ai);             mrb->c->vmexec = FALSE;             mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           if (FALSE) {             struct RBreak *brk;            L_BREAK:             brk = (struct RBreak*)mrb->exc;             proc = mrb_break_proc_get(brk);             v = mrb_break_value_get(brk);             ci = mrb->c->ci;              switch (mrb_break_tag_get(brk)) { #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS) #undef DISPATCH_CHECKPOINTS               default:                 mrb_assert(!""wrong break tag"");             }           }           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {             if (ci[-1].cci == CINFO_SKIP) {               goto L_BREAK_ERROR;             }             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {               /* do nothing */             }             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);             ci = cipop(mrb);             pc = ci->pc;           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);           if (ci == mrb->c->cibase) {             goto L_BREAK_ERROR;           }           mrb->exc = NULL; /* clear break object */           break;         default:           /* cannot happen */           break;         }         mrb_assert(ci == mrb->c->ci);         mrb_assert(mrb->exc == NULL);          if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {           mrb_gc_arena_restore(mrb, ai);           mrb->c->vmexec = FALSE;           mrb->jmp = prev_jmp;           return v;         }         acc = ci->cci;         ci = cipop(mrb);         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {           mrb_gc_arena_restore(mrb, ai);           mrb->jmp = prev_jmp;           return v;         }         pc = ci->pc;         DEBUG(fprintf(stderr, ""from :%s\n"", mrb_sym_name(mrb, ci->mid)));         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;          ci[1].stack[0] = v;         mrb_gc_arena_restore(mrb, ai);       }       JUMP;     }      CASE(OP_BLKPUSH, BS) {       int m1 = (b>>11)&0x3f;       int r  = (b>>10)&0x1;       int m2 = (b>>5)&0x1f;       int kd = (b>>4)&0x1;       int lv = (b>>0)&0xf;       mrb_value *stack;        if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||             MRB_ENV_LEN(e) <= m1+r+m2+1) {           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);           goto L_RAISE;         }         stack = e->stack + 1;       }       if (mrb_nil_p(stack[m1+r+m2+kd])) {         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);         goto L_RAISE;       }       regs[a] = stack[m1+r+m2+kd];       NEXT;     }    L_INT_OVERFLOW:     {       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, ""integer overflow"");       mrb_exc_set(mrb, exc);     }     goto L_RAISE;  #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff)) #define OP_MATH(op_name)                                                    \   /* need to check if op is overridden */                                   \   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \     OP_MATH_CASE_INTEGER(op_name);                                          \     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \     OP_MATH_CASE_STRING_##op_name();                                        \     default:                                                                \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATH_CASE_INTEGER(op_name)                                       \   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0 #else #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \     {                                                                           \       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \     }                                                                           \     break #endif #define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW #define OP_MATH_CASE_STRING_add()                                           \   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \     mrb_gc_arena_restore(mrb, ai);                                          \     break #define OP_MATH_CASE_STRING_sub() (void)0 #define OP_MATH_CASE_STRING_mul() (void)0 #define OP_MATH_OP_add + #define OP_MATH_OP_sub - #define OP_MATH_OP_mul * #define OP_MATH_TT_integer MRB_TT_INTEGER #define OP_MATH_TT_float   MRB_TT_FLOAT      CASE(OP_ADD, B) {       OP_MATH(add);     }      CASE(OP_SUB, B) {       OP_MATH(sub);     }      CASE(OP_MUL, B) {       OP_MATH(mul);     }      CASE(OP_DIV, B) { #ifndef MRB_NO_FLOAT       mrb_float x, y, f; #endif        /* need to check if op is overridden */       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):         {           mrb_int x = mrb_integer(regs[a]);           mrb_int y = mrb_integer(regs[a+1]);           mrb_int div = mrb_div_int(mrb, x, y);           SET_INT_VALUE(mrb, regs[a], div);         }         NEXT; #ifndef MRB_NO_FLOAT       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):         x = (mrb_float)mrb_integer(regs[a]);         y = mrb_float(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):         x = mrb_float(regs[a]);         y = (mrb_float)mrb_integer(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):         x = mrb_float(regs[a]);         y = mrb_float(regs[a+1]);         break; #endif       default:         mid = MRB_OPSYM(div);         goto L_SEND_SYM;       }  #ifndef MRB_NO_FLOAT       f = mrb_div_float(x, y);       SET_FLOAT_VALUE(mrb, regs[a], f); #endif       NEXT;     }  #define OP_MATHI(op_name)                                                   \   /* need to check if op is overridden */                                   \   switch (mrb_type(regs[a])) {                                              \     OP_MATHI_CASE_INTEGER(op_name);                                         \     OP_MATHI_CASE_FLOAT(op_name);                                           \     default:                                                                \       SET_INT_VALUE(mrb,regs[a+1], b);                                      \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATHI_CASE_INTEGER(op_name)                                      \   case MRB_TT_INTEGER:                                                      \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATHI_CASE_FLOAT(op_name) (void)0 #else #define OP_MATHI_CASE_FLOAT(op_name)                                        \   case MRB_TT_FLOAT:                                                        \     {                                                                       \       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \     }                                                                       \     break #endif      CASE(OP_ADDI, BB) {       OP_MATHI(add);     }      CASE(OP_SUBI, BB) {       OP_MATHI(sub);     }  #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))  #ifdef MRB_NO_FLOAT #define OP_CMP(op,sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #else #define OP_CMP(op, sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_float,mrb_float);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #endif      CASE(OP_EQ, B) {       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {         SET_TRUE_VALUE(regs[a]);       }       else {         OP_CMP(==,eq);       }       NEXT;     }      CASE(OP_LT, B) {       OP_CMP(<,lt);       NEXT;     }      CASE(OP_LE, B) {       OP_CMP(<=,le);       NEXT;     }      CASE(OP_GT, B) {       OP_CMP(>,gt);       NEXT;     }      CASE(OP_GE, B) {       OP_CMP(>=,ge);       NEXT;     }      CASE(OP_ARRAY, BB) {       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_ARRAY2, BBB) {       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYCAT, B) {       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);       if (mrb_nil_p(regs[a])) {         regs[a] = splat;       }       else {         mrb_assert(mrb_array_p(regs[a]));         mrb_ary_concat(mrb, regs[a], splat);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYPUSH, BB) {       mrb_assert(mrb_array_p(regs[a]));       for (mrb_int i=0; i<b; i++) {         mrb_ary_push(mrb, regs[a], regs[a+i+1]);       }       NEXT;     }      CASE(OP_ARYDUP, B) {       mrb_value ary = regs[a];       if (mrb_array_p(ary)) {         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));       }       else {         ary = mrb_ary_new_from_values(mrb, 1, &ary);       }       regs[a] = ary;       NEXT;     }      CASE(OP_AREF, BBB) {       mrb_value v = regs[b];        if (!mrb_array_p(v)) {         if (c == 0) {           regs[a] = v;         }         else {           SET_NIL_VALUE(regs[a]);         }       }       else {         v = mrb_ary_ref(mrb, v, c);         regs[a] = v;       }       NEXT;     }      CASE(OP_ASET, BBB) {       mrb_assert(mrb_array_p(regs[a]));       mrb_ary_set(mrb, regs[b], c, regs[a]);       NEXT;     }      CASE(OP_APOST, BBB) {       mrb_value v = regs[a];       int pre  = b;       int post = c;       struct RArray *ary;       int len, idx;        if (!mrb_array_p(v)) {         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);       }       ary = mrb_ary_ptr(v);       len = (int)ARY_LEN(ary);       if (len > pre + post) {         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);         regs[a++] = v;         while (post--) {           regs[a++] = ARY_PTR(ary)[len-post-1];         }       }       else {         v = mrb_ary_new_capa(mrb, 0);         regs[a++] = v;         for (idx=0; idx+pre<len; idx++) {           regs[a+idx] = ARY_PTR(ary)[pre+idx];         }         while (idx < post) {           SET_NIL_VALUE(regs[a+idx]);           idx++;         }       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_INTERN, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_sym sym = mrb_intern_str(mrb, regs[a]);       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_SYMBOL, BB) {       size_t len;       mrb_sym sym;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         sym = mrb_intern_static(mrb, pool[b].u.str, len);       }       else {         sym  = mrb_intern(mrb, pool[b].u.str, len);       }       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_STRING, BB) {       mrb_int len;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);       }       else {         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_STRCAT, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_str_concat(mrb, regs[a], regs[a+1]);       NEXT;     }      CASE(OP_HASH, BB) {       mrb_value hash = mrb_hash_new_capa(mrb, b);       int i;       int lim = a+b*2;        for (i=a; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       regs[a] = hash;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_HASHADD, BB) {       mrb_value hash;       int i;       int lim = a+b*2+1;        hash = regs[a];       mrb_ensure_hash_type(mrb, hash);       for (i=a+1; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_HASHCAT, B) {       mrb_value hash = regs[a];        mrb_assert(mrb_hash_p(hash));       mrb_hash_merge(mrb, hash, regs[a+1]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_LAMBDA, BB)     c = OP_L_LAMBDA;     L_MAKE_LAMBDA:     {       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        if (c & OP_L_CAPTURE) {         p = mrb_closure_new(mrb, nirep);       }       else {         p = mrb_proc_new(mrb, nirep);         p->flags |= MRB_PROC_SCOPE;       }       if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;       regs[a] = mrb_obj_value(p);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_BLOCK, BB) {       c = OP_L_BLOCK;       goto L_MAKE_LAMBDA;     }     CASE(OP_METHOD, BB) {       c = OP_L_METHOD;       goto L_MAKE_LAMBDA;     }      CASE(OP_RANGE_INC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_RANGE_EXC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_OCLASS, B) {       regs[a] = mrb_obj_value(mrb->object_class);       NEXT;     }      CASE(OP_CLASS, BB) {       struct RClass *c = 0, *baseclass;       mrb_value base, super;       mrb_sym id = syms[b];        base = regs[a];       super = regs[a+1];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       c = mrb_vm_define_class(mrb, base, super, id);       regs[a] = mrb_obj_value(c);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_MODULE, BB) {       struct RClass *cls = 0, *baseclass;       mrb_value base;       mrb_sym id = syms[b];        base = regs[a];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       cls = mrb_vm_define_module(mrb, base, id);       regs[a] = mrb_obj_value(cls);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_EXEC, BB)     {       mrb_value recv = regs[a];       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        /* prepare closure */       p = mrb_proc_new(mrb, nirep);       p->c = NULL;       mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);       MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));       p->flags |= MRB_PROC_SCOPE;        /* prepare call stack */       cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);        irep = p->body.irep;       pool = irep->pool;       syms = irep->syms;       mrb_stack_extend(mrb, irep->nregs);       stack_clear(regs+1, irep->nregs-1);       pc = irep->iseq;       JUMP;     }      CASE(OP_DEF, BB) {       struct RClass *target = mrb_class_ptr(regs[a]);       struct RProc *p = mrb_proc_ptr(regs[a+1]);       mrb_method_t m;       mrb_sym mid = syms[b];        MRB_METHOD_FROM_PROC(m, p);       mrb_define_method_raw(mrb, target, mid, m);       mrb_method_added(mrb, target, mid);       mrb_gc_arena_restore(mrb, ai);       regs[a] = mrb_symbol_value(mid);       NEXT;     }      CASE(OP_SCLASS, B) {       regs[a] = mrb_singleton_class(mrb, regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_TCLASS, B) {       struct RClass *target = check_target_class(mrb);       if (!target) goto L_RAISE;       regs[a] = mrb_obj_value(target);       NEXT;     }      CASE(OP_ALIAS, BB) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_alias_method(mrb, target, syms[a], syms[b]);       mrb_method_added(mrb, target, syms[a]);       NEXT;     }     CASE(OP_UNDEF, B) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_undef_method_id(mrb, target, syms[a]);       NEXT;     }      CASE(OP_DEBUG, Z) {       FETCH_BBB(); #ifdef MRB_USE_DEBUG_HOOK       mrb->debug_op_hook(mrb, irep, pc, regs); #else #ifndef MRB_NO_STDIO       printf(""OP_DEBUG %d %d %d\n"", a, b, c); #else       abort(); #endif #endif       NEXT;     }      CASE(OP_ERR, B) {       size_t len = pool[a].tt >> 2;       mrb_value exc;        mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);       exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);       mrb_exc_set(mrb, exc);       goto L_RAISE;     }      CASE(OP_EXT1, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT2, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT3, Z) {       uint8_t insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }      CASE(OP_STOP, Z) {       /*        stop VM */       CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {         /* do nothing */       }       CHECKPOINT_MAIN(RBREAK_TAG_STOP) {         UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());       }       CHECKPOINT_END(RBREAK_TAG_STOP);     L_STOP:       mrb->jmp = prev_jmp;       if (mrb->exc) {         mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);         return mrb_obj_value(mrb->exc);       }       return regs[irep->nlocals];     }   }   END_DISPATCH; #undef regs   }   MRB_CATCH(&c_jmp) {     mrb_callinfo *ci = mrb->c->ci;     while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {       ci = cipop(mrb);     }     exc_catched = TRUE;     pc = ci->pc;     goto RETRY_TRY_BLOCK;   }   MRB_END_EXC(&c_jmp); }"
"198449_CWE-787.c","CWE-787","PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len,  				      pjstun_msg *msg) {     pj_uint16_t msg_type, msg_len;     char *p_attr;      PJ_CHECK_STACK();      msg->hdr = (pjstun_msg_hdr*)buf;     msg_type = pj_ntohs(msg->hdr->type);      switch (msg_type) {     case PJSTUN_BINDING_REQUEST:     case PJSTUN_BINDING_RESPONSE:     case PJSTUN_BINDING_ERROR_RESPONSE:     case PJSTUN_SHARED_SECRET_REQUEST:     case PJSTUN_SHARED_SECRET_RESPONSE:     case PJSTUN_SHARED_SECRET_ERROR_RESPONSE: 	break;     default: 	PJ_LOG(4,(THIS_FILE, ""Error: unknown msg type %d"", msg_type)); 	return PJLIB_UTIL_ESTUNINMSGTYPE;     }      msg_len = pj_ntohs(msg->hdr->length);     if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) { 	PJ_LOG(4,(THIS_FILE, ""Error: invalid msg_len %d (expecting %d)"",  			     msg_len, buf_len - sizeof(pjstun_msg_hdr))); 	return PJLIB_UTIL_ESTUNINMSGLEN;     }      msg->attr_count = 0;     p_attr = (char*)buf + sizeof(pjstun_msg_hdr);      while (msg_len > 0) { 	pjstun_attr_hdr **attr = &msg->attr[msg->attr_count]; 	pj_uint32_t len; 	pj_uint16_t attr_type;  	*attr = (pjstun_attr_hdr*)p_attr; 	len = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr); 	len = (len + 3) & ~3;  	if (msg_len < len) { 	    PJ_LOG(4,(THIS_FILE, ""Error: length mismatch in attr %d"",  				 msg->attr_count)); 	    return PJLIB_UTIL_ESTUNINATTRLEN; 	}  	attr_type = pj_ntohs((*attr)->type); 	if (attr_type > PJSTUN_ATTR_REFLECTED_FROM && 	    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR) 	{ 	    PJ_LOG(5,(THIS_FILE, ""Warning: unknown attr type %x in attr %d. "" 				 ""Attribute was ignored."", 				 attr_type, msg->attr_count)); 	}  	msg_len = (pj_uint16_t)(msg_len - len); 	p_attr += len; 	++msg->attr_count;     }      return PJ_SUCCESS; }"
"198452_CWE-703.cc","CWE-703","void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,                          TfLiteTensor* output, bool requires_broadcast) {   if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {     auto input1_offset = -input1->params.zero_point;     auto input2_offset = -input2->params.zero_point;     const int left_shift = 8;      int32 input1_multiplier;     int input1_shift;     QuantizeMultiplierSmallerThanOneExp(input1->params.scale,                                         &input1_multiplier, &input1_shift);     int32 input2_multiplier;     int input2_shift;     QuantizeMultiplierSmallerThanOneExp(input2->params.scale,                                         &input2_multiplier, &input2_shift);      ComparisonParams op_params;     op_params.left_shift = left_shift;     op_params.input1_offset = input1_offset;     op_params.input1_multiplier = input1_multiplier;     op_params.input1_shift = input1_shift;     op_params.input2_offset = input2_offset;     op_params.input2_multiplier = input2_multiplier;     op_params.input2_shift = input2_shift;     if (requires_broadcast) {       reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(           op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),           GetTensorShape(input2), GetTensorData<input_dtype>(input2),           GetTensorShape(output), GetTensorData<bool>(output));     } else {       reference_ops::ComparisonWithScaling<input_dtype, opname>(           op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),           GetTensorShape(input2), GetTensorData<input_dtype>(input2),           GetTensorShape(output), GetTensorData<bool>(output));     }   } }"
"198476_CWE-416.c","CWE-416","njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,     njs_index_t unused) {     njs_int_t           ret;     njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;     njs_frame_t         *frame, *async_frame;     njs_function_t      *function;     njs_async_ctx_t     *ctx;     njs_native_frame_t  *top, *async;      ctx = vm->top_frame->function->context;      value = njs_arg(args, nargs, 1);     if (njs_is_error(value)) {         goto failed;     }      async_frame = ctx->await;     async = &async_frame->native;     async->previous = vm->top_frame;      function = async->function;      cur_local = vm->levels[NJS_LEVEL_LOCAL];     cur_closures = vm->levels[NJS_LEVEL_CLOSURE];     cur_temp = vm->levels[NJS_LEVEL_TEMP];     top = vm->top_frame;     frame = vm->active_frame;      vm->levels[NJS_LEVEL_LOCAL] = async->local;     vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);     vm->levels[NJS_LEVEL_TEMP] = async->temp;      vm->top_frame = async;     vm->active_frame = async_frame;      *njs_scope_value(vm, ctx->index) = *value;     vm->retval = *value;      vm->top_frame->retval = &vm->retval;      function->context = ctx->capability;     function->await = ctx;      ret = njs_vmcode_interpreter(vm, ctx->pc);      function->context = NULL;     function->await = NULL;      vm->levels[NJS_LEVEL_LOCAL] = cur_local;     vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;     vm->levels[NJS_LEVEL_TEMP] = cur_temp;      vm->top_frame = top;     vm->active_frame = frame;      if (ret == NJS_OK) {         ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),                             &njs_value_undefined, &vm->retval, 1, &vm->retval);          njs_async_context_free(vm, ctx);      } else if (ret == NJS_AGAIN) {         ret = NJS_OK;      } else if (ret == NJS_ERROR) {         if (njs_is_memory_error(vm, &vm->retval)) {             return NJS_ERROR;         }          value = &vm->retval;          goto failed;     }      return ret;  failed:      (void) njs_function_call(vm, njs_function(&ctx->capability->reject),                              &njs_value_undefined, value, 1, &vm->retval);      njs_async_context_free(vm, ctx);      return NJS_ERROR; }"
"198499_CWE-415.c","CWE-415","static int uECC_sign_with_k(const uint8_t *private_key,                             const uint8_t *message_hash,                             unsigned hash_size,                             uECC_word_t *k,                             uint8_t *signature,                             uECC_Curve curve) {      uECC_word_t tmp[uECC_MAX_WORDS];     uECC_word_t s[uECC_MAX_WORDS];     uECC_word_t *k2[2] = {tmp, s}; #if uECC_VLI_NATIVE_LITTLE_ENDIAN     uECC_word_t *p = (uECC_word_t *)signature; #else     uECC_word_t p[uECC_MAX_WORDS * 2]; #endif     uECC_word_t carry;     wordcount_t num_words = curve->num_words;     wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);     bitcount_t num_n_bits = curve->num_n_bits;      /* Make sure 0 < k < curve_n */     if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {         return 0;     }      carry = regularize_k(k, tmp, s, curve);     EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);     if (uECC_vli_isZero(p, num_words)) {         return 0;     }      /* If an RNG function was specified, get a random number        to prevent side channel analysis of k. */     if (!g_rng_function) {         uECC_vli_clear(tmp, num_n_words);         tmp[0] = 1;     } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {         return 0;     }      /* Prevent side channel analysis of uECC_vli_modInv() to determine        bits of k / the private key by premultiplying by a random number */     uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */     uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */     uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */  #if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0     uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */ #endif  #if uECC_VLI_NATIVE_LITTLE_ENDIAN     bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); #else     uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */ #endif      s[num_n_words - 1] = 0;     uECC_vli_set(s, p, num_words);     uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */      bits2int(tmp, message_hash, hash_size, curve);     uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */     uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */     if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {         return 0;     } #if uECC_VLI_NATIVE_LITTLE_ENDIAN     bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes); #else     uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s); #endif         return 1; }"
"198512_CWE-476.c","CWE-476","mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc) {   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */   const mrb_irep *irep = proc->body.irep;   const mrb_pool_value *pool = irep->pool;   const mrb_sym *syms = irep->syms;   mrb_code insn;   int ai = mrb_gc_arena_save(mrb);   struct mrb_jmpbuf *prev_jmp = mrb->jmp;   struct mrb_jmpbuf c_jmp;   uint32_t a;   uint16_t b;   uint16_t c;   mrb_sym mid;   const struct mrb_irep_catch_handler *ch;  #ifdef DIRECT_THREADED   static const void * const optable[] = { #define OPCODE(x,_) &&L_OP_ ## x, #include ""mruby/ops.h"" #undef OPCODE   }; #endif    mrb_bool exc_catched = FALSE; RETRY_TRY_BLOCK:    MRB_TRY(&c_jmp) {    if (exc_catched) {     exc_catched = FALSE;     mrb_gc_arena_restore(mrb, ai);     if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)       goto L_BREAK;     goto L_RAISE;   }   mrb->jmp = &c_jmp;   mrb_vm_ci_proc_set(mrb->c->ci, proc);  #define regs (mrb->c->ci->stack)   INIT_DISPATCH {     CASE(OP_NOP, Z) {       /* do nothing */       NEXT;     }      CASE(OP_MOVE, BB) {       regs[a] = regs[b];       NEXT;     }      CASE(OP_LOADL, BB) {       switch (pool[b].tt) {   /* number */       case IREP_TT_INT32:         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);         break;       case IREP_TT_INT64: #if defined(MRB_INT64)         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);         break; #else #if defined(MRB_64BIT)         if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {           regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);           break;         } #endif         goto L_INT_OVERFLOW; #endif       case IREP_TT_BIGINT:         goto L_INT_OVERFLOW; #ifndef MRB_NO_FLOAT       case IREP_TT_FLOAT:         regs[a] = mrb_float_value(mrb, pool[b].u.f);         break; #endif       default:         /* should not happen (tt:string) */         regs[a] = mrb_nil_value();         break;       }       NEXT;     }      CASE(OP_LOADI, BB) {       SET_FIXNUM_VALUE(regs[a], b);       NEXT;     }      CASE(OP_LOADINEG, BB) {       SET_FIXNUM_VALUE(regs[a], -b);       NEXT;     }      CASE(OP_LOADI__1,B) goto L_LOADI;     CASE(OP_LOADI_0,B) goto L_LOADI;     CASE(OP_LOADI_1,B) goto L_LOADI;     CASE(OP_LOADI_2,B) goto L_LOADI;     CASE(OP_LOADI_3,B) goto L_LOADI;     CASE(OP_LOADI_4,B) goto L_LOADI;     CASE(OP_LOADI_5,B) goto L_LOADI;     CASE(OP_LOADI_6,B) goto L_LOADI;     CASE(OP_LOADI_7, B) {     L_LOADI:       SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);       NEXT;     }      CASE(OP_LOADI16, BS) {       SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);       NEXT;     }      CASE(OP_LOADI32, BSS) {       SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));       NEXT;     }      CASE(OP_LOADSYM, BB) {       SET_SYM_VALUE(regs[a], syms[b]);       NEXT;     }      CASE(OP_LOADNIL, B) {       SET_NIL_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADSELF, B) {       regs[a] = regs[0];       NEXT;     }      CASE(OP_LOADT, B) {       SET_TRUE_VALUE(regs[a]);       NEXT;     }      CASE(OP_LOADF, B) {       SET_FALSE_VALUE(regs[a]);       NEXT;     }      CASE(OP_GETGV, BB) {       mrb_value val = mrb_gv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETGV, BB) {       mrb_gv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETSV, BB) {       mrb_value val = mrb_vm_special_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETSV, BB) {       mrb_vm_special_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIV, BB) {       regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);       NEXT;     }      CASE(OP_SETIV, BB) {       mrb_iv_set(mrb, regs[0], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETCV, BB) {       mrb_value val;       val = mrb_vm_cv_get(mrb, syms[b]);       regs[a] = val;       NEXT;     }      CASE(OP_SETCV, BB) {       mrb_vm_cv_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETIDX, B) {       mrb_value va = regs[a], vb = regs[a+1];       switch (mrb_type(va)) {       case MRB_TT_ARRAY:         if (!mrb_integer_p(vb)) goto getidx_fallback;         regs[a] = mrb_ary_entry(va, mrb_integer(vb));         break;       case MRB_TT_HASH:         va = mrb_hash_get(mrb, va, vb);         regs[a] = va;         break;       case MRB_TT_STRING:         switch (mrb_type(vb)) {         case MRB_TT_INTEGER:         case MRB_TT_STRING:         case MRB_TT_RANGE:           va = mrb_str_aref(mrb, va, vb, mrb_undef_value());           regs[a] = va;           break;         default:           goto getidx_fallback;         }         break;       default:       getidx_fallback:         mid = MRB_OPSYM(aref);         goto L_SEND_SYM;       }       NEXT;     }      CASE(OP_SETIDX, B) {       c = 2;       mid = MRB_OPSYM(aset);       SET_NIL_VALUE(regs[a+3]);       goto L_SENDB_SYM;     }      CASE(OP_GETCONST, BB) {       mrb_value v = mrb_vm_const_get(mrb, syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETCONST, BB) {       mrb_vm_const_set(mrb, syms[b], regs[a]);       NEXT;     }      CASE(OP_GETMCNST, BB) {       mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);       regs[a] = v;       NEXT;     }      CASE(OP_SETMCNST, BB) {       mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);       NEXT;     }      CASE(OP_GETUPVAR, BBB) {       mrb_value *regs_a = regs + a;       struct REnv *e = uvenv(mrb, c);        if (e && b < MRB_ENV_LEN(e)) {         *regs_a = e->stack[b];       }       else {         *regs_a = mrb_nil_value();       }       NEXT;     }      CASE(OP_SETUPVAR, BBB) {       struct REnv *e = uvenv(mrb, c);        if (e) {         mrb_value *regs_a = regs + a;          if (b < MRB_ENV_LEN(e)) {           e->stack[b] = *regs_a;           mrb_write_barrier(mrb, (struct RBasic*)e);         }       }       NEXT;     }      CASE(OP_JMP, S) {       pc += (int16_t)a;       JUMP;     }     CASE(OP_JMPIF, BS) {       if (mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNOT, BS) {       if (!mrb_test(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }     CASE(OP_JMPNIL, BS) {       if (mrb_nil_p(regs[a])) {         pc += (int16_t)b;         JUMP;       }       NEXT;     }      CASE(OP_JMPUW, S) {       a = (uint32_t)((pc - irep->iseq) + (int16_t)a);       CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {         struct RBreak *brk = (struct RBreak*)mrb->exc;         mrb_value target = mrb_break_value_get(brk);         mrb_assert(mrb_integer_p(target));         a = (uint32_t)mrb_integer(target);         mrb_assert(a >= 0 && a < irep->ilen);       }       CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {         ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);         if (ch) {           /* avoiding a jump from a catch handler into the same handler */           if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {             THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));           }         }       }       CHECKPOINT_END(RBREAK_TAG_JUMP);        mrb->exc = NULL; /* clear break object */       pc = irep->iseq + a;       JUMP;     }      CASE(OP_EXCEPT, B) {       mrb_value exc;        if (mrb->exc == NULL) {         exc = mrb_nil_value();       }       else {         switch (mrb->exc->tt) {         case MRB_TT_BREAK:         case MRB_TT_EXCEPTION:           exc = mrb_obj_value(mrb->exc);           break;         default:           mrb_assert(!""bad mrb_type"");           exc = mrb_nil_value();           break;         }         mrb->exc = NULL;       }       regs[a] = exc;       NEXT;     }     CASE(OP_RESCUE, BB) {       mrb_value exc = regs[a];  /* exc on stack */       mrb_value e = regs[b];       struct RClass *ec;        switch (mrb_type(e)) {       case MRB_TT_CLASS:       case MRB_TT_MODULE:         break;       default:         {           mrb_value exc;            exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                     ""class or module required for rescue clause"");           mrb_exc_set(mrb, exc);           goto L_RAISE;         }       }       ec = mrb_class_ptr(e);       regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));       NEXT;     }      CASE(OP_RAISEIF, B) {       mrb_value exc = regs[a];       if (mrb_break_p(exc)) {         mrb->exc = mrb_obj_ptr(exc);         goto L_BREAK;       }       mrb_exc_set(mrb, exc);       if (mrb->exc) {         goto L_RAISE;       }       NEXT;     }      CASE(OP_SSEND, BBB) {       regs[a] = regs[0];       insn = OP_SEND;     }     goto L_SENDB;      CASE(OP_SSENDB, BBB) {       regs[a] = regs[0];     }     goto L_SENDB;      CASE(OP_SEND, BBB)     goto L_SENDB;      L_SEND_SYM:     c = 1;     /* push nil after arguments */     SET_NIL_VALUE(regs[a+2]);     goto L_SENDB_SYM;      CASE(OP_SENDB, BBB)     L_SENDB:     mid = syms[b];     L_SENDB_SYM:     {       mrb_callinfo *ci = mrb->c->ci;       mrb_method_t m;       struct RClass *cls;       mrb_value recv, blk;        ARGUMENT_NORMALIZE(a, &c, insn);        recv = regs[a];       cls = mrb_class(mrb, recv);       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, c);        if (MRB_METHOD_CFUNC_P(m)) {         if (MRB_METHOD_PROC_P(m)) {           struct RProc *p = MRB_METHOD_PROC(m);            mrb_vm_ci_proc_set(ci, p);           recv = p->body.func(mrb, recv);         }         else {           if (MRB_METHOD_NOARG_P(m)) {             check_method_noarg(mrb, ci);           }           recv = MRB_METHOD_FUNC(m)(mrb, recv);         }         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);           if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }         if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return recv;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         ci->stack[0] = recv;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }     }     JUMP;      CASE(OP_CALL, Z) {       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv = ci->stack[0];       struct RProc *m = mrb_proc_ptr(recv);        /* replace callinfo */       ci->u.target_class = MRB_PROC_TARGET_CLASS(m);       mrb_vm_ci_proc_set(ci, m);       if (MRB_PROC_ENV_P(m)) {         ci->mid = MRB_PROC_ENV(m)->mid;       }        /* prepare stack */       if (MRB_PROC_CFUNC_P(m)) {         recv = MRB_PROC_CFUNC(m)(mrb, recv);         mrb_gc_arena_shrink(mrb, ai);         if (mrb->exc) goto L_RAISE;         /* pop stackpos */         ci = cipop(mrb);         pc = ci->pc;         ci[1].stack[0] = recv;         irep = mrb->c->ci->proc->body.irep;       }       else {         /* setup environment for calling method */         proc = m;         irep = m->body.irep;         if (!irep) {           mrb->c->ci->stack[0] = mrb_nil_value();           a = 0;           c = OP_R_NORMAL;           goto L_OP_RETURN_BODY;         }         mrb_int nargs = mrb_ci_bidx(ci)+1;         if (nargs < irep->nregs) {           mrb_stack_extend(mrb, irep->nregs);           stack_clear(regs+nargs, irep->nregs-nargs);         }         if (MRB_PROC_ENV_P(m)) {           regs[0] = MRB_PROC_ENV(m)->stack[0];         }         pc = irep->iseq;       }       pool = irep->pool;       syms = irep->syms;       JUMP;     }      CASE(OP_SUPER, BB) {       mrb_method_t m;       struct RClass *cls;       mrb_callinfo *ci = mrb->c->ci;       mrb_value recv, blk;       const struct RProc *p = ci->proc;       mrb_sym mid = ci->mid;       struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);        if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */         mid = p->e.env->mid;    /* restore old mid */       }        if (mid == 0 || !target_class) {         mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {         target_class = mrb_vm_ci_target_class(ci);       }       else if (target_class->tt == MRB_TT_MODULE) {         target_class = mrb_vm_ci_target_class(ci);         if (target_class->tt != MRB_TT_ICLASS) {           goto super_typeerror;         }       }       recv = regs[0];       if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {       super_typeerror: ;         mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,                                             ""self has wrong type to call super in this context"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }        ARGUMENT_NORMALIZE(a, &b, OP_SUPER);        cls = target_class->super;       m = mrb_method_search_vm(mrb, &cls, mid);       if (MRB_METHOD_UNDEF_P(m)) {         m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);         mid = MRB_SYM(method_missing);       }        /* push callinfo */       ci = cipush(mrb, a, 0, cls, NULL, mid, b);        /* prepare stack */       ci->stack[0] = recv;        if (MRB_METHOD_CFUNC_P(m)) {         mrb_value v;          if (MRB_METHOD_PROC_P(m)) {           mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));         }         v = MRB_METHOD_CFUNC(m)(mrb, recv);         mrb_gc_arena_restore(mrb, ai);         if (mrb->exc) goto L_RAISE;         ci = mrb->c->ci;         mrb_assert(!mrb_break_p(v));         if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */           if (ci->cci == CINFO_RESUMED) {             mrb->jmp = prev_jmp;             return v;           }           else {             mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));             proc = ci[-1].proc;             irep = proc->body.irep;             pool = irep->pool;             syms = irep->syms;           }         }         mrb->c->ci->stack[0] = v;         ci = cipop(mrb);         pc = ci->pc;       }       else {         /* setup environment for calling method */         mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);         pc = irep->iseq;       }       JUMP;     }      CASE(OP_ARGARY, BS) {       mrb_int m1 = (b>>11)&0x3f;       mrb_int r  = (b>>10)&0x1;       mrb_int m2 = (b>>5)&0x1f;       mrb_int kd = (b>>4)&0x1;       mrb_int lv = (b>>0)&0xf;       mrb_value *stack;        if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {         mrb_value exc;        L_NOSUPER:         exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, ""super called outside of method"");         mrb_exc_set(mrb, exc);         goto L_RAISE;       }       if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e) goto L_NOSUPER;         if (MRB_ENV_LEN(e) <= m1+r+m2+1)           goto L_NOSUPER;         stack = e->stack + 1;       }       if (r == 0) {         regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);       }       else {         mrb_value *pp = NULL;         struct RArray *rest;         mrb_int len = 0;          if (mrb_array_p(stack[m1])) {           struct RArray *ary = mrb_ary_ptr(stack[m1]);            pp = ARY_PTR(ary);           len = ARY_LEN(ary);         }         regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);         rest = mrb_ary_ptr(regs[a]);         if (m1 > 0) {           stack_copy(ARY_PTR(rest), stack, m1);         }         if (len > 0) {           stack_copy(ARY_PTR(rest)+m1, pp, len);         }         if (m2 > 0) {           stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);         }         ARY_SET_LEN(rest, m1+len+m2);       }       if (kd) {         regs[a+1] = stack[m1+r+m2];         regs[a+2] = stack[m1+r+m2+1];       }       else {         regs[a+1] = stack[m1+r+m2];       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ENTER, W) {       mrb_int m1 = MRB_ASPEC_REQ(a);       mrb_int o  = MRB_ASPEC_OPT(a);       mrb_int r  = MRB_ASPEC_REST(a);       mrb_int m2 = MRB_ASPEC_POST(a);       mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;       /* unused       int b  = MRB_ASPEC_BLOCK(a);       */       mrb_int const len = m1 + o + r + m2;        mrb_callinfo *ci = mrb->c->ci;       mrb_int argc = ci->n;       mrb_value *argv = regs+1;       mrb_value * const argv0 = argv;       mrb_int const kw_pos = len + kd;    /* where kwhash should be */       mrb_int const blk_pos = kw_pos + 1; /* where block should be */       mrb_value blk = regs[mrb_ci_bidx(ci)];       mrb_value kdict = mrb_nil_value();        /* keyword arguments */       if (ci->nk > 0) {         mrb_int kidx = mrb_ci_kidx(ci);         kdict = regs[kidx];         if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {           kdict = mrb_nil_value();           ci->nk = 0;         }       }       if (!kd && !mrb_nil_p(kdict)) {         if (argc < 14) {           ci->n++;           argc++;    /* include kdict in normal arguments */         }         else if (argc == 14) {           /* pack arguments and kdict */           regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);           argc = ci->n = 15;         }         else {/* argc == 15 */           /* push kdict to packed arguments */           mrb_ary_push(mrb, regs[1], regs[2]);         }         ci->nk = 0;       }       if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {         kdict = mrb_hash_dup(mrb, kdict);       }        /* arguments is passed with Array */       if (argc == 15) {         struct RArray *ary = mrb_ary_ptr(regs[1]);         argv = ARY_PTR(ary);         argc = (int)ARY_LEN(ary);         mrb_gc_protect(mrb, regs[1]);       }        /* strict argument check */       if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {         if (argc < m1 + m2 || (r == 0 && argc > len)) {           argnum_error(mrb, m1+m2);           goto L_RAISE;         }       }       /* extract first argument array to arguments */       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {         mrb_gc_protect(mrb, argv[0]);         argc = (int)RARRAY_LEN(argv[0]);         argv = RARRAY_PTR(argv[0]);       }        /* rest arguments */       mrb_value rest = mrb_nil_value();       if (argc < len) {         mrb_int mlen = m2;         if (argc < m1+m2) {           mlen = m1 < argc ? argc - m1 : 0;         }          /* copy mandatory and optional arguments */         if (argv0 != argv && argv) {           value_move(&regs[1], argv, argc-mlen); /* m1 + o */         }         if (argc < m1) {           stack_clear(&regs[argc+1], m1-argc);         }         /* copy post mandatory arguments */         if (mlen) {           value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);         }         if (mlen < m2) {           stack_clear(&regs[len-m2+mlen+1], m2-mlen);         }         /* initialize rest arguments with empty Array */         if (r) {           rest = mrb_ary_new_capa(mrb, 0);           regs[m1+o+1] = rest;         }         /* skip initializer of passed arguments */         if (o > 0 && argc > m1+m2)           pc += (argc - m1 - m2)*3;       }       else {         mrb_int rnum = 0;         if (argv0 != argv) {           value_move(&regs[1], argv, m1+o);         }         if (r) {           rnum = argc-m1-o-m2;           rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);           regs[m1+o+1] = rest;         }         if (m2 > 0 && argc-m2 > m1) {           value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);         }         pc += o*3;       }        /* need to be update blk first to protect blk from GC */       regs[blk_pos] = blk;              /* move block */       if (kd) {         if (mrb_nil_p(kdict))           kdict = mrb_hash_new_capa(mrb, 0);         regs[kw_pos] = kdict;           /* set kwhash */       }        /* format arguments for generated code */       mrb->c->ci->n = len;        /* clear local (but non-argument) variables */       if (irep->nlocals-blk_pos-1 > 0) {         stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);       }       JUMP;     }      CASE(OP_KARG, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict, v;        if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {         mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       v = mrb_hash_get(mrb, kdict, k);       regs[a] = v;       mrb_hash_delete_key(mrb, kdict, k);       NEXT;     }      CASE(OP_KEY_P, BB) {       mrb_value k = mrb_symbol_value(syms[b]);       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;       mrb_bool key_p = FALSE;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {         key_p = mrb_hash_key_p(mrb, kdict, k);       }       regs[a] = mrb_bool_value(key_p);       NEXT;     }      CASE(OP_KEYEND, Z) {       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);       mrb_value kdict;        if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {         mrb_value keys = mrb_hash_keys(mrb, kdict);         mrb_value key1 = RARRAY_PTR(keys)[0];         mrb_value str = mrb_format(mrb, ""unknown keyword: %v"", key1);         mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));         goto L_RAISE;       }       NEXT;     }      CASE(OP_BREAK, B) {       c = OP_R_BREAK;       goto L_RETURN;     }     CASE(OP_RETURN_BLK, B) {       c = OP_R_RETURN;       goto L_RETURN;     }     CASE(OP_RETURN, B)     c = OP_R_NORMAL;     L_RETURN:     {       mrb_callinfo *ci;        ci = mrb->c->ci;       if (ci->mid) {         mrb_value blk = regs[mrb_ci_bidx(ci)];          if (mrb_proc_p(blk)) {           struct RProc *p = mrb_proc_ptr(blk);            if (!MRB_PROC_STRICT_P(p) &&               ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {             p->flags |= MRB_PROC_ORPHAN;           }         }       }        if (mrb->exc) {       L_RAISE:         ci = mrb->c->ci;         if (ci == mrb->c->cibase) {           ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);           if (ch == NULL) goto L_FTOP;           goto L_CATCH;         }         while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {           ci = cipop(mrb);           if (ci[1].cci == CINFO_SKIP && prev_jmp) {             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           pc = ci[0].pc;           if (ci == mrb->c->cibase) {             ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);             if (ch == NULL) {             L_FTOP:             /* fiber top */               if (mrb->c == mrb->root_c) {                 mrb->c->ci->stack = mrb->c->stbase;                 goto L_STOP;               }               else {                 struct mrb_context *c = mrb->c;                  c->status = MRB_FIBER_TERMINATED;                 mrb->c = c->prev;                 c->prev = NULL;                 goto L_RAISE;               }             }             break;           }         }       L_CATCH:         if (ch == NULL) goto L_STOP;         if (FALSE) {         L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */           ci = mrb->c->ci;         }         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;         mrb_stack_extend(mrb, irep->nregs);         pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);       }       else {         mrb_int acc;         mrb_value v;          ci = mrb->c->ci;         v = regs[a];         mrb_gc_protect(mrb, v);         switch (c) {         case OP_R_RETURN:           /* Fall through to OP_R_NORMAL otherwise */           if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {             const struct RProc *dst;             mrb_callinfo *cibase;             cibase = mrb->c->cibase;             dst = top_proc(mrb, proc);              if (MRB_PROC_ENV_P(dst)) {               struct REnv *e = MRB_PROC_ENV(dst);                if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }             }             /* check jump destination */             while (cibase <= ci && ci->proc != dst) {               if (ci->cci > CINFO_NONE) { /* jump cross C boundary */                 localjump_error(mrb, LOCALJUMP_ERROR_RETURN);                 goto L_RAISE;               }               ci--;             }             if (ci <= cibase) { /* no jump destination */               localjump_error(mrb, LOCALJUMP_ERROR_RETURN);               goto L_RAISE;             }             ci = mrb->c->ci;             while (cibase <= ci && ci->proc != dst) {               CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {                 cibase = mrb->c->cibase;                 dst = top_proc(mrb, proc);               }               CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {                 UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);               }               CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);               ci = cipop(mrb);               pc = ci->pc;             }             proc = ci->proc;             mrb->exc = NULL; /* clear break object */             break;           }           /* fallthrough */         case OP_R_NORMAL:         NORMAL_RETURN:           if (ci == mrb->c->cibase) {             struct mrb_context *c;             c = mrb->c;              if (!c->prev) { /* toplevel return */               regs[irep->nlocals] = v;               goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);             }             if (!c->vmexec && c->prev->ci == c->prev->cibase) {               mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, ""double resume"");               mrb_exc_set(mrb, exc);               goto L_RAISE;             }             CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {               c = mrb->c;             }             CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);             /* automatic yield at the end */             c->status = MRB_FIBER_TERMINATED;             mrb->c = c->prev;             mrb->c->status = MRB_FIBER_RUNNING;             c->prev = NULL;             if (c->vmexec) {               mrb_gc_arena_restore(mrb, ai);               c->vmexec = FALSE;               mrb->jmp = prev_jmp;               return v;             }             ci = mrb->c->ci;           }           CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_RETURN);           mrb->exc = NULL; /* clear break object */           break;         case OP_R_BREAK:           if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;           if (MRB_PROC_ORPHAN_P(proc)) {             mrb_value exc;            L_BREAK_ERROR:             exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,                                       ""break from proc-closure"");             mrb_exc_set(mrb, exc);             goto L_RAISE;           }           if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {             goto L_BREAK_ERROR;           }           else {             struct REnv *e = MRB_PROC_ENV(proc);              if (e->cxt != mrb->c) {               goto L_BREAK_ERROR;             }           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK);           /* break from fiber block */           if (ci == mrb->c->cibase && ci->pc) {             struct mrb_context *c = mrb->c;              mrb->c = c->prev;             c->prev = NULL;             ci = mrb->c->ci;           }           if (ci->cci > CINFO_NONE) {             ci = cipop(mrb);             mrb_gc_arena_restore(mrb, ai);             mrb->c->vmexec = FALSE;             mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);             mrb->jmp = prev_jmp;             MRB_THROW(prev_jmp);           }           if (FALSE) {             struct RBreak *brk;            L_BREAK:             brk = (struct RBreak*)mrb->exc;             proc = mrb_break_proc_get(brk);             v = mrb_break_value_get(brk);             ci = mrb->c->ci;              switch (mrb_break_tag_get(brk)) { #define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);               RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS) #undef DISPATCH_CHECKPOINTS               default:                 mrb_assert(!""wrong break tag"");             }           }           while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {             if (ci[-1].cci == CINFO_SKIP) {               goto L_BREAK_ERROR;             }             CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {               /* do nothing */             }             CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {               UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);             }             CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);             ci = cipop(mrb);             pc = ci->pc;           }           CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {             /* do nothing */           }           CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {             UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);           }           CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);           if (ci == mrb->c->cibase) {             goto L_BREAK_ERROR;           }           mrb->exc = NULL; /* clear break object */           break;         default:           /* cannot happen */           break;         }         mrb_assert(ci == mrb->c->ci);         mrb_assert(mrb->exc == NULL);          if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {           mrb_gc_arena_restore(mrb, ai);           mrb->c->vmexec = FALSE;           mrb->jmp = prev_jmp;           return v;         }         acc = ci->cci;         ci = cipop(mrb);         if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {           mrb_gc_arena_restore(mrb, ai);           mrb->jmp = prev_jmp;           return v;         }         pc = ci->pc;         DEBUG(fprintf(stderr, ""from :%s\n"", mrb_sym_name(mrb, ci->mid)));         proc = ci->proc;         irep = proc->body.irep;         pool = irep->pool;         syms = irep->syms;          ci[1].stack[0] = v;         mrb_gc_arena_restore(mrb, ai);       }       JUMP;     }      CASE(OP_BLKPUSH, BS) {       int m1 = (b>>11)&0x3f;       int r  = (b>>10)&0x1;       int m2 = (b>>5)&0x1f;       int kd = (b>>4)&0x1;       int lv = (b>>0)&0xf;       mrb_value *stack;        if (lv == 0) stack = regs + 1;       else {         struct REnv *e = uvenv(mrb, lv-1);         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||             MRB_ENV_LEN(e) <= m1+r+m2+1) {           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);           goto L_RAISE;         }         stack = e->stack + 1;       }       if (mrb_nil_p(stack[m1+r+m2+kd])) {         localjump_error(mrb, LOCALJUMP_ERROR_YIELD);         goto L_RAISE;       }       regs[a] = stack[m1+r+m2+kd];       NEXT;     }    L_INT_OVERFLOW:     {       mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, ""integer overflow"");       mrb_exc_set(mrb, exc);     }     goto L_RAISE;  #define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff)) #define OP_MATH(op_name)                                                    \   /* need to check if op is overridden */                                   \   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \     OP_MATH_CASE_INTEGER(op_name);                                          \     OP_MATH_CASE_FLOAT(op_name, integer, float);                            \     OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \     OP_MATH_CASE_FLOAT(op_name, float,  float);                             \     OP_MATH_CASE_STRING_##op_name();                                        \     default:                                                                \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATH_CASE_INTEGER(op_name)                                       \   case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0 #else #define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \   case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \     {                                                                           \       mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \       SET_FLOAT_VALUE(mrb, regs[a], z);                                         \     }                                                                           \     break #endif #define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW #define OP_MATH_CASE_STRING_add()                                           \   case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \     regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \     mrb_gc_arena_restore(mrb, ai);                                          \     break #define OP_MATH_CASE_STRING_sub() (void)0 #define OP_MATH_CASE_STRING_mul() (void)0 #define OP_MATH_OP_add + #define OP_MATH_OP_sub - #define OP_MATH_OP_mul * #define OP_MATH_TT_integer MRB_TT_INTEGER #define OP_MATH_TT_float   MRB_TT_FLOAT      CASE(OP_ADD, B) {       OP_MATH(add);     }      CASE(OP_SUB, B) {       OP_MATH(sub);     }      CASE(OP_MUL, B) {       OP_MATH(mul);     }      CASE(OP_DIV, B) { #ifndef MRB_NO_FLOAT       mrb_float x, y, f; #endif        /* need to check if op is overridden */       switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {       case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):         {           mrb_int x = mrb_integer(regs[a]);           mrb_int y = mrb_integer(regs[a+1]);           mrb_int div = mrb_div_int(mrb, x, y);           SET_INT_VALUE(mrb, regs[a], div);         }         NEXT; #ifndef MRB_NO_FLOAT       case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):         x = (mrb_float)mrb_integer(regs[a]);         y = mrb_float(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):         x = mrb_float(regs[a]);         y = (mrb_float)mrb_integer(regs[a+1]);         break;       case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):         x = mrb_float(regs[a]);         y = mrb_float(regs[a+1]);         break; #endif       default:         mid = MRB_OPSYM(div);         goto L_SEND_SYM;       }  #ifndef MRB_NO_FLOAT       f = mrb_div_float(x, y);       SET_FLOAT_VALUE(mrb, regs[a], f); #endif       NEXT;     }  #define OP_MATHI(op_name)                                                   \   /* need to check if op is overridden */                                   \   switch (mrb_type(regs[a])) {                                              \     OP_MATHI_CASE_INTEGER(op_name);                                         \     OP_MATHI_CASE_FLOAT(op_name);                                           \     default:                                                                \       SET_INT_VALUE(mrb,regs[a+1], b);                                      \       mid = MRB_OPSYM(op_name);                                             \       goto L_SEND_SYM;                                                      \   }                                                                         \   NEXT; #define OP_MATHI_CASE_INTEGER(op_name)                                      \   case MRB_TT_INTEGER:                                                      \     {                                                                       \       mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \       if (mrb_int_##op_name##_overflow(x, y, &z))                           \         OP_MATH_OVERFLOW_INT();                                             \       else                                                                  \         SET_INT_VALUE(mrb,regs[a], z);                                      \     }                                                                       \     break #ifdef MRB_NO_FLOAT #define OP_MATHI_CASE_FLOAT(op_name) (void)0 #else #define OP_MATHI_CASE_FLOAT(op_name)                                        \   case MRB_TT_FLOAT:                                                        \     {                                                                       \       mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \       SET_FLOAT_VALUE(mrb, regs[a], z);                                     \     }                                                                       \     break #endif      CASE(OP_ADDI, BB) {       OP_MATHI(add);     }      CASE(OP_SUBI, BB) {       OP_MATHI(sub);     }  #define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))  #ifdef MRB_NO_FLOAT #define OP_CMP(op,sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #else #define OP_CMP(op, sym) do {\   int result;\   /* need to check if - is overridden */\   switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\   case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\     result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\     break;\   case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\     result = OP_CMP_BODY(op,mrb_float,mrb_float);\     break;\   default:\     mid = MRB_OPSYM(sym);\     goto L_SEND_SYM;\   }\   if (result) {\     SET_TRUE_VALUE(regs[a]);\   }\   else {\     SET_FALSE_VALUE(regs[a]);\   }\ } while(0) #endif      CASE(OP_EQ, B) {       if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {         SET_TRUE_VALUE(regs[a]);       }       else {         OP_CMP(==,eq);       }       NEXT;     }      CASE(OP_LT, B) {       OP_CMP(<,lt);       NEXT;     }      CASE(OP_LE, B) {       OP_CMP(<=,le);       NEXT;     }      CASE(OP_GT, B) {       OP_CMP(>,gt);       NEXT;     }      CASE(OP_GE, B) {       OP_CMP(>=,ge);       NEXT;     }      CASE(OP_ARRAY, BB) {       regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_ARRAY2, BBB) {       regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYCAT, B) {       mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);       if (mrb_nil_p(regs[a])) {         regs[a] = splat;       }       else {         mrb_assert(mrb_array_p(regs[a]));         mrb_ary_concat(mrb, regs[a], splat);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_ARYPUSH, BB) {       mrb_assert(mrb_array_p(regs[a]));       for (mrb_int i=0; i<b; i++) {         mrb_ary_push(mrb, regs[a], regs[a+i+1]);       }       NEXT;     }      CASE(OP_ARYDUP, B) {       mrb_value ary = regs[a];       if (mrb_array_p(ary)) {         ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));       }       else {         ary = mrb_ary_new_from_values(mrb, 1, &ary);       }       regs[a] = ary;       NEXT;     }      CASE(OP_AREF, BBB) {       mrb_value v = regs[b];        if (!mrb_array_p(v)) {         if (c == 0) {           regs[a] = v;         }         else {           SET_NIL_VALUE(regs[a]);         }       }       else {         v = mrb_ary_ref(mrb, v, c);         regs[a] = v;       }       NEXT;     }      CASE(OP_ASET, BBB) {       mrb_assert(mrb_array_p(regs[a]));       mrb_ary_set(mrb, regs[b], c, regs[a]);       NEXT;     }      CASE(OP_APOST, BBB) {       mrb_value v = regs[a];       int pre  = b;       int post = c;       struct RArray *ary;       int len, idx;        if (!mrb_array_p(v)) {         v = mrb_ary_new_from_values(mrb, 1, &regs[a]);       }       ary = mrb_ary_ptr(v);       len = (int)ARY_LEN(ary);       if (len > pre + post) {         v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);         regs[a++] = v;         while (post--) {           regs[a++] = ARY_PTR(ary)[len-post-1];         }       }       else {         v = mrb_ary_new_capa(mrb, 0);         regs[a++] = v;         for (idx=0; idx+pre<len; idx++) {           regs[a+idx] = ARY_PTR(ary)[pre+idx];         }         while (idx < post) {           SET_NIL_VALUE(regs[a+idx]);           idx++;         }       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_INTERN, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_sym sym = mrb_intern_str(mrb, regs[a]);       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_SYMBOL, BB) {       size_t len;       mrb_sym sym;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         sym = mrb_intern_static(mrb, pool[b].u.str, len);       }       else {         sym  = mrb_intern(mrb, pool[b].u.str, len);       }       regs[a] = mrb_symbol_value(sym);       NEXT;     }      CASE(OP_STRING, BB) {       mrb_int len;        mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);       len = pool[b].tt >> 2;       if (pool[b].tt & IREP_TT_SFLAG) {         regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);       }       else {         regs[a] = mrb_str_new(mrb, pool[b].u.str, len);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_STRCAT, B) {       mrb_assert(mrb_string_p(regs[a]));       mrb_str_concat(mrb, regs[a], regs[a+1]);       NEXT;     }      CASE(OP_HASH, BB) {       mrb_value hash = mrb_hash_new_capa(mrb, b);       int i;       int lim = a+b*2;        for (i=a; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       regs[a] = hash;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_HASHADD, BB) {       mrb_value hash;       int i;       int lim = a+b*2+1;        hash = regs[a];       mrb_ensure_hash_type(mrb, hash);       for (i=a+1; i<lim; i+=2) {         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);       }       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_HASHCAT, B) {       mrb_value hash = regs[a];        mrb_assert(mrb_hash_p(hash));       mrb_hash_merge(mrb, hash, regs[a+1]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_LAMBDA, BB)     c = OP_L_LAMBDA;     L_MAKE_LAMBDA:     {       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        if (c & OP_L_CAPTURE) {         p = mrb_closure_new(mrb, nirep);       }       else {         p = mrb_proc_new(mrb, nirep);         p->flags |= MRB_PROC_SCOPE;       }       if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;       regs[a] = mrb_obj_value(p);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }     CASE(OP_BLOCK, BB) {       c = OP_L_BLOCK;       goto L_MAKE_LAMBDA;     }     CASE(OP_METHOD, BB) {       c = OP_L_METHOD;       goto L_MAKE_LAMBDA;     }      CASE(OP_RANGE_INC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_RANGE_EXC, B) {       mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);       regs[a] = v;       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_OCLASS, B) {       regs[a] = mrb_obj_value(mrb->object_class);       NEXT;     }      CASE(OP_CLASS, BB) {       struct RClass *c = 0, *baseclass;       mrb_value base, super;       mrb_sym id = syms[b];        base = regs[a];       super = regs[a+1];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       c = mrb_vm_define_class(mrb, base, super, id);       regs[a] = mrb_obj_value(c);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_MODULE, BB) {       struct RClass *cls = 0, *baseclass;       mrb_value base;       mrb_sym id = syms[b];        base = regs[a];       if (mrb_nil_p(base)) {         baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);         if (!baseclass) baseclass = mrb->object_class;         base = mrb_obj_value(baseclass);       }       cls = mrb_vm_define_module(mrb, base, id);       regs[a] = mrb_obj_value(cls);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_EXEC, BB)     {       mrb_value recv = regs[a];       struct RProc *p;       const mrb_irep *nirep = irep->reps[b];        /* prepare closure */       p = mrb_proc_new(mrb, nirep);       p->c = NULL;       mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);       MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));       p->flags |= MRB_PROC_SCOPE;        /* prepare call stack */       cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);        irep = p->body.irep;       pool = irep->pool;       syms = irep->syms;       mrb_stack_extend(mrb, irep->nregs);       stack_clear(regs+1, irep->nregs-1);       pc = irep->iseq;       JUMP;     }      CASE(OP_DEF, BB) {       struct RClass *target = mrb_class_ptr(regs[a]);       struct RProc *p = mrb_proc_ptr(regs[a+1]);       mrb_method_t m;       mrb_sym mid = syms[b];        MRB_METHOD_FROM_PROC(m, p);       mrb_define_method_raw(mrb, target, mid, m);       mrb_method_added(mrb, target, mid);       mrb_gc_arena_restore(mrb, ai);       regs[a] = mrb_symbol_value(mid);       NEXT;     }      CASE(OP_SCLASS, B) {       regs[a] = mrb_singleton_class(mrb, regs[a]);       mrb_gc_arena_restore(mrb, ai);       NEXT;     }      CASE(OP_TCLASS, B) {       struct RClass *target = check_target_class(mrb);       if (!target) goto L_RAISE;       regs[a] = mrb_obj_value(target);       NEXT;     }      CASE(OP_ALIAS, BB) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_alias_method(mrb, target, syms[a], syms[b]);       mrb_method_added(mrb, target, syms[a]);       NEXT;     }     CASE(OP_UNDEF, B) {       struct RClass *target = check_target_class(mrb);        if (!target) goto L_RAISE;       mrb_undef_method_id(mrb, target, syms[a]);       NEXT;     }      CASE(OP_DEBUG, Z) {       FETCH_BBB(); #ifdef MRB_USE_DEBUG_HOOK       mrb->debug_op_hook(mrb, irep, pc, regs); #else #ifndef MRB_NO_STDIO       printf(""OP_DEBUG %d %d %d\n"", a, b, c); #else       abort(); #endif #endif       NEXT;     }      CASE(OP_ERR, B) {       size_t len = pool[a].tt >> 2;       mrb_value exc;        mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);       exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);       mrb_exc_set(mrb, exc);       goto L_RAISE;     }      CASE(OP_EXT1, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT2, Z) {       insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }     CASE(OP_EXT3, Z) {       uint8_t insn = READ_B();       switch (insn) { #define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY; #include ""mruby/ops.h"" #undef OPCODE       }       pc--;       NEXT;     }      CASE(OP_STOP, Z) {       /*        stop VM */       CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {         /* do nothing */       }       CHECKPOINT_MAIN(RBREAK_TAG_STOP) {         UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());       }       CHECKPOINT_END(RBREAK_TAG_STOP);     L_STOP:       mrb->jmp = prev_jmp;       if (mrb->exc) {         mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);         return mrb_obj_value(mrb->exc);       }       return regs[irep->nlocals];     }   }   END_DISPATCH; #undef regs   }   MRB_CATCH(&c_jmp) {     mrb_callinfo *ci = mrb->c->ci;     while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {       ci = cipop(mrb);     }     exc_catched = TRUE;     pc = ci->pc;     goto RETRY_TRY_BLOCK;   }   MRB_END_EXC(&c_jmp); }"
"198523_CWE-416.cc","CWE-416","  void Compute(OpKernelContext* context) override {     // Get the stamp token.     const Tensor* stamp_token_t;     OP_REQUIRES_OK(context, context->input(""stamp_token"", &stamp_token_t));     int64_t stamp_token = stamp_token_t->scalar<int64>()();      // Get the tree ensemble proto.     const Tensor* tree_ensemble_serialized_t;     OP_REQUIRES_OK(context, context->input(""tree_ensemble_serialized"",                                            &tree_ensemble_serialized_t));     std::unique_ptr<BoostedTreesEnsembleResource> result(         new BoostedTreesEnsembleResource());     if (!result->InitFromSerialized(             tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {       result->Unref();       OP_REQUIRES(           context, false,           errors::InvalidArgument(""Unable to parse tree ensemble proto.""));     }      // Only create one, if one does not exist already. Report status for all     // other exceptions.     auto status =         CreateResource(context, HandleFromInput(context, 0), result.release());     if (status.code() != tensorflow::error::ALREADY_EXISTS) {       OP_REQUIRES_OK(context, status);     }   }"
"198545_CWE-787.c","CWE-787","static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc, 		     char *const argv[]) { 	uint	chip; 	uint	addr, length; 	int alen; 	int	j, nbytes, linebytes; 	int ret; #if CONFIG_IS_ENABLED(DM_I2C) 	struct udevice *dev; #endif  	/* We use the last specified parameters, unless new ones are 	 * entered. 	 */ 	chip   = i2c_dp_last_chip; 	addr   = i2c_dp_last_addr; 	alen   = i2c_dp_last_alen; 	length = i2c_dp_last_length;  	if (argc < 3) 		return CMD_RET_USAGE;  	if ((flag & CMD_FLAG_REPEAT) == 0) { 		/* 		 * New command specified. 		 */  		/* 		 * I2C chip address 		 */ 		chip = hextoul(argv[1], NULL);  		/* 		 * I2C data address within the chip.  This can be 1 or 		 * 2 bytes long.  Some day it might be 3 bytes long :-). 		 */ 		addr = hextoul(argv[2], NULL); 		alen = get_alen(argv[2], DEFAULT_ADDR_LEN); 		if (alen > 3) 			return CMD_RET_USAGE;  		/* 		 * If another parameter, it is the length to display. 		 * Length is the number of objects, not number of bytes. 		 */ 		if (argc > 3) 			length = hextoul(argv[3], NULL); 	}  #if CONFIG_IS_ENABLED(DM_I2C) 	ret = i2c_get_cur_bus_chip(chip, &dev); 	if (!ret && alen != -1) 		ret = i2c_set_chip_offset_len(dev, alen); 	if (ret) 		return i2c_report_err(ret, I2C_ERR_READ); #endif  	/* 	 * Print the lines. 	 * 	 * We buffer all read data, so we can make sure data is read only 	 * once. 	 */ 	nbytes = length; 	do { 		unsigned char	linebuf[DISP_LINE_LEN]; 		unsigned char	*cp;  		linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;  #if CONFIG_IS_ENABLED(DM_I2C) 		ret = dm_i2c_read(dev, addr, linebuf, linebytes); #else 		ret = i2c_read(chip, addr, alen, linebuf, linebytes); #endif 		if (ret) 			return i2c_report_err(ret, I2C_ERR_READ); 		else { 			printf(""%04x:"", addr); 			cp = linebuf; 			for (j=0; j<linebytes; j++) { 				printf("" %02x"", *cp++); 				addr++; 			} 			puts (""    ""); 			cp = linebuf; 			for (j=0; j<linebytes; j++) { 				if ((*cp < 0x20) || (*cp > 0x7e)) 					puts ("".""); 				else 					printf(""%c"", *cp); 				cp++; 			} 			putc ('\n'); 		} 		nbytes -= linebytes; 	} while (nbytes > 0);  	i2c_dp_last_chip   = chip; 	i2c_dp_last_addr   = addr; 	i2c_dp_last_alen   = alen; 	i2c_dp_last_length = length;  	return 0; }"
"198552_CWE-787.c","CWE-787","static int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,                            size_t *out_len, const unsigned char *key,                            size_t key_len) {     GOST_KEY_TRANSPORT *gkt = NULL;     EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);     struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);     int pkey_nid = EVP_PKEY_base_id(pubk);     ASN1_OBJECT *crypt_params_obj = (pkey_nid == NID_id_GostR3410_2001 || pkey_nid == NID_id_GostR3410_2001DH) ?         OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet) :         OBJ_nid2obj(NID_id_tc26_gost_28147_param_Z);     const struct gost_cipher_info *param =         get_encryption_params(crypt_params_obj);     unsigned char ukm[8], shared_key[32], crypted_key[44];     int ret = 0;     int key_is_ephemeral = 1;     gost_ctx cctx;     EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);     if (data->shared_ukm_size) {         memcpy(ukm, data->shared_ukm, 8);     } else {         if (RAND_bytes(ukm, 8) <= 0) {             GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);             return 0;         }     }     if (!param)         goto err;     /* Check for private key in the peer_key of context */     if (sec_key) {         key_is_ephemeral = 0;         if (!gost_get0_priv_key(sec_key)) {             GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,                     GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);             goto err;         }     } else {         key_is_ephemeral = 1;         if (out) {             sec_key = EVP_PKEY_new();             if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())                 || !EVP_PKEY_copy_parameters(sec_key, pubk)                 || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {                 GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,                         GOST_R_ERROR_COMPUTING_SHARED_KEY);                 goto err;             }         }     }     if (out) {         int dgst_nid = NID_undef;         EVP_PKEY_get_default_digest_nid(pubk, &dgst_nid);         if (dgst_nid == NID_id_GostR3411_2012_512)             dgst_nid = NID_id_GostR3411_2012_256;          if (!VKO_compute_key(shared_key,                              EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),                              EVP_PKEY_get0(sec_key), ukm, 8, dgst_nid)) {             GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,                     GOST_R_ERROR_COMPUTING_SHARED_KEY);             goto err;         }         gost_init(&cctx, param->sblock);         keyWrapCryptoPro(&cctx, shared_key, ukm, key, crypted_key);     }     gkt = GOST_KEY_TRANSPORT_new();     if (!gkt) {         goto err;     }     if (!ASN1_OCTET_STRING_set(gkt->key_agreement_info->eph_iv, ukm, 8)) {         goto err;     }     if (!ASN1_OCTET_STRING_set(gkt->key_info->imit, crypted_key + 40, 4)) {         goto err;     }     if (!ASN1_OCTET_STRING_set         (gkt->key_info->encrypted_key, crypted_key + 8, 32)) {         goto err;     }     if (key_is_ephemeral) {         if (!X509_PUBKEY_set             (&gkt->key_agreement_info->ephem_key, out ? sec_key : pubk)) {             GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,                     GOST_R_CANNOT_PACK_EPHEMERAL_KEY);             goto err;         }     }     ASN1_OBJECT_free(gkt->key_agreement_info->cipher);     gkt->key_agreement_info->cipher = OBJ_nid2obj(param->nid);     if (key_is_ephemeral)         EVP_PKEY_free(sec_key);     if (!key_is_ephemeral) {         /* Set control ""public key from client certificate used"" */         if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)             <= 0) {             GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);             goto err;         }     }     if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, out ? &out : NULL)) > 0)         ret = 1;     OPENSSL_cleanse(shared_key, sizeof(shared_key));     GOST_KEY_TRANSPORT_free(gkt);     return ret;  err:     OPENSSL_cleanse(shared_key, sizeof(shared_key));     if (key_is_ephemeral)         EVP_PKEY_free(sec_key);     GOST_KEY_TRANSPORT_free(gkt);     return -1; }"
"198556_CWE-703.c","CWE-703","fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec) {   struct mrb_context *c = fiber_check(mrb, self);   struct mrb_context *old_c = mrb->c;   enum mrb_fiber_state status;   mrb_value value;    fiber_check_cfunc(mrb, c);   status = c->status;   switch (status) {   case MRB_FIBER_TRANSFERRED:     if (resume) {       mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber"");     }     break;   case MRB_FIBER_RUNNING:   case MRB_FIBER_RESUMED:     mrb_raise(mrb, E_FIBER_ERROR, ""double resume"");     break;   case MRB_FIBER_TERMINATED:     mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber"");     break;   default:     break;   }   old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);   fiber_switch_context(mrb, c);   if (status == MRB_FIBER_CREATED) {     mrb_value *b, *e;      if (!c->ci->proc) {       mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");     }     mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */     b = c->stbase+1;     e = b + len;     while (b<e) {       *b++ = *a++;     }     if (vmexec) {       c->ci--;                    /* pop dummy callinfo */     }     c->cibase->n = len;     value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];   }   else {     value = fiber_result(mrb, a, len);     if (vmexec) {       c->ci[1].stack[0] = value;     }   }    if (vmexec) {     c->vmexec = TRUE;     value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);     mrb->c = old_c;   }   else {     MARK_CONTEXT_MODIFY(c);   }   return value; }"
"198566_CWE-787.c","CWE-787","MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {     int pos = *decoded_size;     char mod = 'i';     char dir = '<';     char olddir;     unsigned char c;     while ((c = *rule++)) {         if (c <= 4) {             mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */             olddir = dir;             dir = (c & 2) ? '<' : '>'; /* left, right */             if (olddir != dir && olddir) {                 pos = (c & 2) ? *decoded_size : 0;             }         }         else if (c > 10 && c < 20) {             if (dir == '>') {                 pos = *decoded_size;             }             pos -= c - 10;             dir = 0;             if (pos < 0 || pos > *decoded_size) {                 debug_print(""Position setting failed (%s)\n"", decoded);                 return MOBI_DATA_CORRUPT;             }         }         else {             if (mod == 'i') {                 const unsigned char *s = decoded + pos;                 unsigned char *d = decoded + pos + 1;                 const int l = *decoded_size - pos;                 if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {                     debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);                     return MOBI_DATA_CORRUPT;                 }                 memmove(d, s, (size_t) l);                 decoded[pos] = c;                 (*decoded_size)++;                 if (dir == '>') { pos++; }             } else {                 if (dir == '<') { pos--; }                 const unsigned char *s = decoded + pos + 1;                 unsigned char *d = decoded + pos;                 const int l = *decoded_size - pos;                 if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {                     debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);                     return MOBI_DATA_CORRUPT;                 }                 if (decoded[pos] != c) {                     debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", decoded, pos, decoded[pos], c);                     return MOBI_DATA_CORRUPT;                 }                 memmove(d, s, (size_t) l);                 (*decoded_size)--;             }         }     }     return MOBI_SUCCESS; }"
"198588_CWE-787.c","CWE-787","get_lisp_indent(void) {     pos_T	*pos, realpos, paren;     int		amount;     char_u	*that;     colnr_T	col;     colnr_T	firsttry;     int		parencount, quotecount;     int		vi_lisp;      // Set vi_lisp to use the vi-compatible method     vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);      realpos = curwin->w_cursor;     curwin->w_cursor.col = 0;      if ((pos = findmatch(NULL, '(')) == NULL) 	pos = findmatch(NULL, '[');     else     { 	paren = *pos; 	pos = findmatch(NULL, '['); 	if (pos == NULL || LT_POSP(pos, &paren)) 	    pos = &paren;     }     if (pos != NULL)     { 	// Extra trick: Take the indent of the first previous non-white 	// line that is at the same () level. 	amount = -1; 	parencount = 0;  	while (--curwin->w_cursor.lnum >= pos->lnum) 	{ 	    if (linewhite(curwin->w_cursor.lnum)) 		continue; 	    for (that = ml_get_curline(); *that != NUL; ++that) 	    { 		if (*that == ';') 		{ 		    while (*(that + 1) != NUL) 			++that; 		    continue; 		} 		if (*that == '\\') 		{ 		    if (*(that + 1) != NUL) 			++that; 		    continue; 		} 		if (*that == '""' && *(that + 1) != NUL) 		{ 		    while (*++that && *that != '""') 		    { 			// skipping escaped characters in the string 			if (*that == '\\') 			{ 			    if (*++that == NUL) 				break; 			    if (that[1] == NUL) 			    { 				++that; 				break; 			    } 			} 		    } 		} 		if (*that == '(' || *that == '[') 		    ++parencount; 		else if (*that == ')' || *that == ']') 		    --parencount; 	    } 	    if (parencount == 0) 	    { 		amount = get_indent(); 		break; 	    } 	}  	if (amount == -1) 	{ 	    curwin->w_cursor.lnum = pos->lnum; 	    curwin->w_cursor.col = pos->col; 	    col = pos->col;  	    that = ml_get_curline();  	    if (vi_lisp && get_indent() == 0) 		amount = 2; 	    else 	    { 		char_u *line = that;  		amount = 0; 		while (*that && col) 		{ 		    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); 		    col--; 		}  		// Some keywords require ""body"" indenting rules (the 		// non-standard-lisp ones are Scheme special forms): 		// 		// (let ((a 1))    instead    (let ((a 1)) 		//   (...))	      of	   (...))  		if (!vi_lisp && (*that == '(' || *that == '[') 						      && lisp_match(that + 1)) 		    amount += 2; 		else 		{ 		    that++; 		    amount++; 		    firsttry = amount;  		    while (VIM_ISWHITE(*that)) 		    { 			amount += lbr_chartabsize(line, that, (colnr_T)amount); 			++that; 		    }  		    if (*that && *that != ';') // not a comment line 		    { 			// test *that != '(' to accommodate first let/do 			// argument if it is more than one line 			if (!vi_lisp && *that != '(' && *that != '[') 			    firsttry++;  			parencount = 0; 			quotecount = 0;  			if (vi_lisp 				|| (*that != '""' 				    && *that != '\'' 				    && *that != '#' 				    && (*that < '0' || *that > '9'))) 			{ 			    while (*that 				    && (!VIM_ISWHITE(*that) 					|| quotecount 					|| parencount) 				    && (!((*that == '(' || *that == '[') 					    && !quotecount 					    && !parencount 					    && vi_lisp))) 			    { 				if (*that == '""') 				    quotecount = !quotecount; 				if ((*that == '(' || *that == '[') 							       && !quotecount) 				    ++parencount; 				if ((*that == ')' || *that == ']') 							       && !quotecount) 				    --parencount; 				if (*that == '\\' && *(that+1) != NUL) 				    amount += lbr_chartabsize_adv( 						line, &that, (colnr_T)amount); 				amount += lbr_chartabsize_adv( 						line, &that, (colnr_T)amount); 			    } 			} 			while (VIM_ISWHITE(*that)) 			{ 			    amount += lbr_chartabsize( 						 line, that, (colnr_T)amount); 			    that++; 			} 			if (!*that || *that == ';') 			    amount = firsttry; 		    } 		} 	    } 	}     }     else 	amount = 0;	// no matching '(' or '[' found, use zero indent      curwin->w_cursor = realpos;      return amount; }"
"198662_CWE-787.c","CWE-787","ex_copy(linenr_T line1, linenr_T line2, linenr_T n) {     linenr_T	count;     char_u	*p;      count = line2 - line1 + 1;     if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)     { 	curbuf->b_op_start.lnum = n + 1; 	curbuf->b_op_end.lnum = n + count; 	curbuf->b_op_start.col = curbuf->b_op_end.col = 0;     }      /*      * there are three situations:      * 1. destination is above line1      * 2. destination is between line1 and line2      * 3. destination is below line2      *      * n = destination (when starting)      * curwin->w_cursor.lnum = destination (while copying)      * line1 = start of source (while copying)      * line2 = end of source (while copying)      */     if (u_save(n, n + 1) == FAIL) 	return;      curwin->w_cursor.lnum = n;     while (line1 <= line2)     { 	// need to use vim_strsave() because the line will be unlocked within 	// ml_append() 	p = vim_strsave(ml_get(line1)); 	if (p != NULL) 	{ 	    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE); 	    vim_free(p); 	} 	// situation 2: skip already copied lines 	if (line1 == n) 	    line1 = curwin->w_cursor.lnum; 	++line1; 	if (curwin->w_cursor.lnum < line1) 	    ++line1; 	if (curwin->w_cursor.lnum < line2) 	    ++line2; 	++curwin->w_cursor.lnum;     }      appended_lines_mark(n, count);      msgmore((long)count); }"
"198692_CWE-125.c","CWE-125","int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type, 		 struct xfrm_migrate *m, int num_migrate, 		 struct xfrm_kmaddress *k, struct net *net, 		 struct xfrm_encap_tmpl *encap) { 	int i, err, nx_cur = 0, nx_new = 0; 	struct xfrm_policy *pol = NULL; 	struct xfrm_state *x, *xc; 	struct xfrm_state *x_cur[XFRM_MAX_DEPTH]; 	struct xfrm_state *x_new[XFRM_MAX_DEPTH]; 	struct xfrm_migrate *mp;  	if ((err = xfrm_migrate_check(m, num_migrate)) < 0) 		goto out;  	/* Stage 1 - find policy */ 	if ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) { 		err = -ENOENT; 		goto out; 	}  	/* Stage 2 - find and update state(s) */ 	for (i = 0, mp = m; i < num_migrate; i++, mp++) { 		if ((x = xfrm_migrate_state_find(mp, net))) { 			x_cur[nx_cur] = x; 			nx_cur++; 			xc = xfrm_state_migrate(x, mp, encap); 			if (xc) { 				x_new[nx_new] = xc; 				nx_new++; 			} else { 				err = -ENODATA; 				goto restore_state; 			} 		} 	}  	/* Stage 3 - update policy */ 	if ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0) 		goto restore_state;  	/* Stage 4 - delete old state(s) */ 	if (nx_cur) { 		xfrm_states_put(x_cur, nx_cur); 		xfrm_states_delete(x_cur, nx_cur); 	}  	/* Stage 5 - announce */ 	km_migrate(sel, dir, type, m, num_migrate, k, encap);  	xfrm_pol_put(pol);  	return 0; out: 	return err;  restore_state: 	if (pol) 		xfrm_pol_put(pol); 	if (nx_cur) 		xfrm_states_put(x_cur, nx_cur); 	if (nx_new) 		xfrm_states_delete(x_new, nx_new);  	return err; }"
"198695_CWE-787.cpp","CWE-787","mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module) {	 	module->cleanUp();  	// this will make code much easier to read 	TXMHeader*		header = &module->header; 	TXMInstrument*	instr  = module->instr; 	TXMSample*		smp	   = module->smp; 	TXMPattern*		phead  = module->phead;	  	// we're already out of memory here 	if (!phead || !instr || !smp) 		return MP_OUT_OF_MEMORY; 	 	f.read(&header->name,1,28); 	header->whythis1a = f.readByte(); 	 	if (f.readByte() != 16)  		return MP_LOADER_FAILED;	// no ST3 module 	 	f.readByte(); // skip something 	f.readByte(); // skip something 	 	header->ordnum = f.readWord(); // number of positions in order list (songlength) 	 	mp_ubyte* orders = new mp_ubyte[header->ordnum]; 	if (orders == NULL)  		return MP_OUT_OF_MEMORY; 	 	header->insnum = f.readWord(); // number of instruments 	header->patnum = f.readWord(); // number of patterns	 	 	mp_sint32 flags = f.readWord(); // st3 flags	  	mp_sint32 Cvt = f.readWord();  	header->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;  	if (Cvt == 0x1300 || (flags & 64)) 		header->flags |= module->MODULE_OLDS3MVOLSLIDES; 		 	header->flags |= module->MODULE_ST3NOTECUT; 	 	/*mp_uword Ffi = */f.readWord(); 	 	f.read(header->sig,1,4); 	 	header->mainvol = module->vol64to255(f.readByte()); // initial main volume 	 	header->tempo = f.readByte(); // tempo 	 	header->speed = f.readByte(); // speed 	 	f.readByte(); // global volume? skipped... 	 	f.readByte(); // ignore GUS click removal 	 	/*mp_ubyte dp = */f.readByte(); 	 	f.readDword();	// skip something 	f.readDword();	// skip something 	f.readWord();	// skip some more... 	 	mp_ubyte channelSettings[32]; 	f.read(channelSettings,1,32); 	 	mp_sint32 numChannels = 0; 	 	for (numChannels = 0; numChannels < 32; numChannels++) 		if (channelSettings[numChannels] == 255) 			break; 	 	header->channum = numChannels; // number of channels 	 	f.read(orders,1,header->ordnum); 	 	mp_sint32 j = 0, i = 0; 	for (i = 0; i < header->ordnum; i++) 	{ 		if (orders[i] == 255)  			break; 		 		header->ord[j++] = orders[i];		 	} 	 	header->ordnum = j; // final songlength 	 	delete[] orders; 	 	mp_uword* insParaPtrs = new mp_uword[header->insnum]; 	 	if (insParaPtrs == NULL) 		return MP_OUT_OF_MEMORY; 	 	f.readWords(insParaPtrs,header->insnum); 	 	mp_uword* patParaPtrs = new mp_uword[header->patnum]; 	 	if (patParaPtrs == NULL) 	{ 		delete[] insParaPtrs; 		return MP_OUT_OF_MEMORY; 	} 	 	f.readWords(patParaPtrs,header->patnum); 	 	//for (i = 0; i < header->insnum; i++) 	//{ 	//	printf(""%x\n"",insParaPtrs[i]*16); 	//} 		 	////////////////////// 	// read instruments // 	////////////////////// 	mp_uint32* samplePtrs = new mp_uint32[header->insnum]; 	if (samplePtrs == NULL) 	{ 		delete[] insParaPtrs; 		delete[] patParaPtrs; 		return MP_OUT_OF_MEMORY; 	} 	 	memset(samplePtrs,0,sizeof(mp_uint32)*header->insnum); 	 	mp_sint32 s = 0; 	for (i = 0; i < header->insnum; i++) 	{ 		mp_uint32 insOffs = insParaPtrs[i]*16;  		if (insOffs) 		{ 			f.seekWithBaseOffset(insOffs); 		 			// We can only read that if it's a sample 			mp_ubyte type = f.readByte(); 			 			if (type == 1) 			{ 				f.read(smp[s].name,1,12);	// read dos filename 		 				mp_ubyte bOffs = f.readByte(); 				mp_uword wOffs = f.readWord(); 				 				// stupid fileoffsets 				samplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16; 				 				smp[s].flags = 1; 				smp[s].pan = 0x80; 				 				smp[s].samplen = f.readDword(); 				smp[s].loopstart = f.readDword(); 				mp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart); 				if (looplen < 0)  					looplen = 0; 				smp[s].looplen = looplen; 				 				smp[s].vol = module->vol64to255(f.readByte()); 				 				f.readByte(); // skip something 				 				smp[s].res = f.readByte() == 0x04 ? 0xAD : 0; // packing 				 				mp_ubyte flags = f.readByte(); 				 				// looping 				if (flags & 1) 				{ 					smp[s].type = 1;	 				} 				 				// 16 bit sample 				if (flags & 4) 				{ 					smp[s].type |= 16; 					smp[s].samplen >>= 1; 					smp[s].loopstart >>= 1; 					smp[s].looplen >>= 1; 				} 				 				mp_uint32 c4spd = f.readDword(); 				 				XModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);  #ifdef VERBOSE 				printf(""%i, %i\n"",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));				 #endif  				f.readDword(); // skip something 				 				f.readDword(); // skip two internal words 				 				f.readDword(); // skip internal dword  				f.read(instr[i].name,1,28); // instrument name 				 				f.readDword(); // skip signature 				 				if (samplePtrs[i] && smp[s].samplen) 				{ 					instr[i].samp=1; 					for (j=0;j<120;j++)  						instr[i].snum[j] = s; 					s++; 				} 			} 			else if (type == 0) 			{ 				samplePtrs[i] = 0; 			 				mp_ubyte buffer[12]; 				f.read(buffer,1,12);	// read dos filename 		 				f.readByte(); 				f.readWord(); 				 				f.readDword(); 				f.readDword(); 				f.readDword(); 				f.readByte(); 				f.readByte(); // skip something 				f.readByte(); // skip packing 				 				f.readByte(); 				 				f.readDword(); 				 				f.readDword(); // skip something 				 				f.readDword(); // skip two internal words 				 				f.readDword(); // skip internal dword  				f.read(instr[i].name,1,28); // instrument name 				 				f.readDword(); // skip signature				 			} 			else  			{ 				samplePtrs[i] = 0; 			} 			 		}  	} 	 	////////////////////// 	// read patterns	// 	////////////////////// 	mp_ubyte* pattern = new mp_ubyte[64*32*5]; 	if (pattern == NULL) 	{ 		delete[] insParaPtrs; 		delete[] patParaPtrs; 		delete[] samplePtrs; 		return MP_OUT_OF_MEMORY; 	} 	 	mp_uint32 songMaxChannels = 1; 	 	for (i = 0; i < header->patnum; i++) 	{ 		for (j = 0; j < 32*64; j++) 		{ 			pattern[j*5] = 0xFF; 			pattern[j*5+1] = 0; 			pattern[j*5+2] = 0xFF; 			pattern[j*5+3] = 0xFF; 			pattern[j*5+4] = 0; 		} 		 		mp_uint32 patOffs = patParaPtrs[i]*16; 		 		mp_uint32 maxChannels = 1;			 		 		if (patOffs) 		{ 			f.seekWithBaseOffset(patOffs); 			 			mp_uint32 size = f.readWord(); 			 			if (size > 2) 			{ 				size-=2; 				 				mp_ubyte* packed = new mp_ubyte[size+5]; 				if (packed == NULL) 				{ 					delete[] insParaPtrs; 					delete[] patParaPtrs; 					delete[] samplePtrs; 					delete[] pattern; 					return MP_OUT_OF_MEMORY;				 				} 				 				memset(packed, 0, size); 				f.read(packed, 1, size); 				 				mp_uint32 index = 0; 				mp_uint32 row = 0; 				 				while (index<size) 				{ 					 					mp_ubyte pi = safeRead(packed, index, size); 					 					if (pi == 0)  					{ 						row++; 						// one more safety net for incorrectly saved pattern sizes 						if (row >= 64) 						{ 							int i = 0; 							i++; 							i--; 							break; 						} 						continue; 					} 					 					mp_uint32 chn = pi&31; 					 					if (chn>maxChannels && (pi & (32+64+128))) 					{ 						maxChannels = chn; 					} 					 					mp_ubyte* slot = pattern+(row*32*5)+chn*5; 					 					if (pi & 32) 					{ 						slot[0] = safeRead(packed, index, size, 0xFF); 						slot[1] = safeRead(packed, index, size); 					} 					if (pi & 64) 					{ 						slot[2] = safeRead(packed, index, size, 0xFF); 					} 					if (pi & 128) 					{ 						slot[3] = safeRead(packed, index, size, 0xFF); 						slot[4] = safeRead(packed, index, size); 					} 					 				} 				 				maxChannels++; 				 				if (maxChannels > header->channum) 					maxChannels = header->channum; 				 				delete[] packed; 			} 			 			if (maxChannels > songMaxChannels) 				songMaxChannels = maxChannels; 			 		} 		 		convertS3MPattern(&phead[i], pattern, maxChannels, i); 		 		 	} 	 	if (header->channum > songMaxChannels) 		header->channum = songMaxChannels; 	 	delete[] pattern; 	delete[] insParaPtrs; 	delete[] patParaPtrs; 	 	s = 0; 	for (i = 0; i < header->insnum; i++) 	{ 		mp_uint32 smpOffs = samplePtrs[i];  		if (smpOffs) 		{ 			f.seekWithBaseOffset(smpOffs); 			 			if (!smp[s].samplen) 				continue;  			bool adpcm = (smp[s].res == 0xAD);  			mp_sint32 result = module->loadModuleSample(f, s,  										  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED,  										  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED)); 			if (result != MP_OK) 			{ 				delete[] samplePtrs; 				return result; 			} 			 			if (adpcm) 				// no longer needed 				smp[s].res = 0;			 							 			s++; 			 		}  	} 	 	delete[] samplePtrs; 	 	header->smpnum = s; 	 	strcpy(header->tracker,""Screamtracker 3""); 	 	module->setDefaultPanning(); 	 	module->postProcessSamples(); 	 	return MP_OK;	 }"
"198703_CWE-189.c","CWE-189","int CLASS ljpeg_start (struct jhead *jh, int info_only) {   int c, tag, len;   uchar data[0x10000];   const uchar *dp;    memset (jh, 0, sizeof *jh);   jh->restart = INT_MAX;   fread (data, 2, 1, ifp);   if (data[1] != 0xd8) return 0;   do {     fread (data, 2, 2, ifp);     tag =  data[0] << 8 | data[1];     len = (data[2] << 8 | data[3]) - 2;     if (tag <= 0xff00) return 0;     fread (data, 1, len, ifp);     switch (tag) {       case 0xffc3: 	jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;       case 0xffc0: 	jh->bits = data[0]; 	jh->high = data[1] << 8 | data[2]; 	jh->wide = data[3] << 8 | data[4]; 	jh->clrs = data[5] + jh->sraw; 	if (len == 9 && !dng_version) getc(ifp); 	break;       case 0xffc4: 	if (info_only) break; 	for (dp = data; dp < data+len && (c = *dp++) < 4; ) 	  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp); 	break;       case 0xffda: 	jh->psv = data[1+data[0]*2]; 	jh->bits -= data[3+data[0]*2] & 15; 	break;       case 0xffdd: 	jh->restart = data[0] << 8 | data[1];     }   } while (tag != 0xffda);   if (info_only) return 1;   if (jh->clrs > 6 || !jh->huff[0]) return 0;   FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];   if (jh->sraw) {     FORC(4)        jh->huff[2+c] = jh->huff[1];     FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];   }   jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);   merror (jh->row, ""ljpeg_start()"");   return zero_after_ff = 1; }"
"198736_CWE-401.c","CWE-401","static int rsi_send_beacon(struct rsi_common *common) { 	struct sk_buff *skb = NULL; 	u8 dword_align_bytes = 0;  	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE); 	if (!skb) 		return -ENOMEM;  	memset(skb->data, 0, MAX_MGMT_PKT_SIZE);  	dword_align_bytes = ((unsigned long)skb->data & 0x3f); 	if (dword_align_bytes) 		skb_pull(skb, (64 - dword_align_bytes)); 	if (rsi_prepare_beacon(common, skb)) { 		rsi_dbg(ERR_ZONE, ""Failed to prepare beacon\n""); 		return -EINVAL; 	} 	skb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb); 	rsi_set_event(&common->tx_thread.event); 	rsi_dbg(DATA_TX_ZONE, ""%s: Added to beacon queue\n"", __func__);  	return 0; }"
"198743_CWE-125.c","CWE-125","static ptrdiff_t finderrfunc(lua_State *L) {   cTValue *frame = L->base-1, *bot = tvref(L->stack);   void *cf = L->cframe;   while (frame > bot && cf) {     while (cframe_nres(cframe_raw(cf)) < 0) {  /* cframe without frame? */       if (frame >= restorestack(L, -cframe_nres(cf))) 	break;       if (cframe_errfunc(cf) >= 0)  /* Error handler not inherited (-1)? */ 	return cframe_errfunc(cf);       cf = cframe_prev(cf);  /* Else unwind cframe and continue searching. */       if (cf == NULL) 	return 0;     }     switch (frame_typep(frame)) {     case FRAME_LUA:     case FRAME_LUAP:       frame = frame_prevl(frame);       break;     case FRAME_C:       cf = cframe_prev(cf);       /* fallthrough */     case FRAME_VARG:       frame = frame_prevd(frame);       break;     case FRAME_CONT: #if LJ_HASFFI       if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK) 	cf = cframe_prev(cf); #endif       frame = frame_prevd(frame);       break;     case FRAME_CP:       if (cframe_canyield(cf)) return 0;       if (cframe_errfunc(cf) >= 0) 	return cframe_errfunc(cf);       frame = frame_prevd(frame);       break;     case FRAME_PCALL:     case FRAME_PCALLH:       if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))  /* xpcall? */ 	return savestack(L, frame-1);  /* Point to xpcall's errorfunc. */       return 0;     default:       lua_assert(0);       return 0;     }   }   return 0; }"
"198927_CWE-125.c","CWE-125","RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { 	if (!bin->entry_table) { 		return NULL; 	} 	RList *entries = r_list_newf (free); 	if (!entries) { 		return NULL; 	} 	RList *segments = r_bin_ne_get_segments (bin); 	if (!segments) { 		r_list_free (entries); 		return NULL; 	} 	if (bin->ne_header->csEntryPoint) { 		RBinAddr *entry = R_NEW0 (RBinAddr); 		if (!entry) { 			r_list_free (entries); 			return NULL; 		} 		entry->bits = 16; 		ut32 entry_cs = bin->ne_header->csEntryPoint; 		RBinSection *s = r_list_get_n (segments, entry_cs - 1); 		entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);  		r_list_append (entries, entry); 	} 	int off = 0; 	size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; 	while (off < bin->ne_header->EntryTableLength) { 		if (tableat + off >= r_buf_size (bin->buf)) { 			break; 		} 		ut8 bundle_length = *(ut8 *)(bin->entry_table + off); 		if (!bundle_length) { 			break; 		} 		off++; 		ut8 bundle_type = *(ut8 *)(bin->entry_table + off); 		off++; 		int i; 		for (i = 0; i < bundle_length; i++) { 			if (tableat + off + 4 >= r_buf_size (bin->buf)) { 				break; 			} 			RBinAddr *entry = R_NEW0 (RBinAddr); 			if (!entry) { 				r_list_free (entries); 				return NULL; 			} 			off++; 			if (!bundle_type) { // Skip 				off--; 				free (entry); 				break; 			} else if (bundle_type == 0xff) { // moveable 				off += 2; 				ut8 segnum = *(bin->entry_table + off); 				off++; 				ut16 segoff = *(ut16 *)(bin->entry_table + off); 				if (segnum > 0) { 					entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; 				} 			} else { // Fixed 				if (bundle_type < bin->ne_header->SegCount) { 					entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset 						* bin->alignment + *(ut16 *)(bin->entry_table + off); 				} 			} 			off += 2; 			r_list_append (entries, entry); 		} 	} 	r_list_free (segments); 	bin->entries = entries; 	return entries; }"
"198983_CWE-125.c","CWE-125","SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,                         uint32_t *dataoffset, uint16_t *hdrflags,                         uint8_t *hdrversion, bool quiet) {     blobheader *bh = (blobheader *)data;      if (length < sizeof(bh)) {         if (!quiet)             logprintf(STDERR_FILENO,                       ""not enough bytes for header: %u\n"", length);         return TPM_BAD_PARAMETER;     }      if (ntohl(bh->totlen) != length) {         if (!quiet)             logprintf(STDERR_FILENO,                       ""broken header: bh->totlen %u != %u\n"",                       htonl(bh->totlen), length);         return TPM_BAD_PARAMETER;     }      if (bh->min_version > BLOB_HEADER_VERSION) {         if (!quiet)             logprintf(STDERR_FILENO,                       ""Minimum required version for the blob is %d, we ""                       ""only support version %d\n"", bh->min_version,                       BLOB_HEADER_VERSION);         return TPM_BAD_VERSION;     }      *hdrversion = bh->version;     *dataoffset = ntohs(bh->hdrsize);     *hdrflags = ntohs(bh->flags);      return TPM_SUCCESS; }"
"199159_CWE-362.c","CWE-362","static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file) { 	int err = 0; 	unsigned int saved_f_flags; 	struct snd_pcm_substream *substream; 	struct snd_pcm_runtime *runtime; 	snd_pcm_format_t format; 	unsigned long width; 	size_t size;  	substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK]; 	if (substream != NULL) { 		runtime = substream->runtime; 		if (atomic_read(&substream->mmap_count)) 			goto __direct; 		err = snd_pcm_oss_make_ready(substream); 		if (err < 0) 			return err; 		atomic_inc(&runtime->oss.rw_ref); 		if (mutex_lock_interruptible(&runtime->oss.params_lock)) { 			atomic_dec(&runtime->oss.rw_ref); 			return -ERESTARTSYS; 		} 		format = snd_pcm_oss_format_from(runtime->oss.format); 		width = snd_pcm_format_physical_width(format); 		if (runtime->oss.buffer_used > 0) { #ifdef OSS_DEBUG 			pcm_dbg(substream->pcm, ""sync: buffer_used\n""); #endif 			size = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width; 			snd_pcm_format_set_silence(format, 						   runtime->oss.buffer + runtime->oss.buffer_used, 						   size); 			err = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes); 			if (err < 0) 				goto unlock; 		} else if (runtime->oss.period_ptr > 0) { #ifdef OSS_DEBUG 			pcm_dbg(substream->pcm, ""sync: period_ptr\n""); #endif 			size = runtime->oss.period_bytes - runtime->oss.period_ptr; 			snd_pcm_format_set_silence(format, 						   runtime->oss.buffer, 						   size * 8 / width); 			err = snd_pcm_oss_sync1(substream, size); 			if (err < 0) 				goto unlock; 		} 		/* 		 * The ALSA's period might be a bit large than OSS one. 		 * Fill the remain portion of ALSA period with zeros. 		 */ 		size = runtime->control->appl_ptr % runtime->period_size; 		if (size > 0) { 			size = runtime->period_size - size; 			if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) 				snd_pcm_lib_write(substream, NULL, size); 			else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) 				snd_pcm_lib_writev(substream, NULL, size); 		} unlock: 		mutex_unlock(&runtime->oss.params_lock); 		atomic_dec(&runtime->oss.rw_ref); 		if (err < 0) 			return err; 		/* 		 * finish sync: drain the buffer 		 */ 	      __direct: 		saved_f_flags = substream->f_flags; 		substream->f_flags &= ~O_NONBLOCK; 		err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL); 		substream->f_flags = saved_f_flags; 		if (err < 0) 			return err; 		mutex_lock(&runtime->oss.params_lock); 		runtime->oss.prepare = 1; 		mutex_unlock(&runtime->oss.params_lock); 	}  	substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE]; 	if (substream != NULL) { 		err = snd_pcm_oss_make_ready(substream); 		if (err < 0) 			return err; 		runtime = substream->runtime; 		err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL); 		if (err < 0) 			return err; 		mutex_lock(&runtime->oss.params_lock); 		runtime->oss.buffer_used = 0; 		runtime->oss.prepare = 1; 		mutex_unlock(&runtime->oss.params_lock); 	} 	return 0; }"
"199681_CWE-416.c","CWE-416","static int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, 		    unsigned long param) { 	int drive = (long)bdev->bd_disk->private_data; 	int type = ITYPE(drive_state[drive].fd_device); 	int i; 	int ret; 	int size; 	union inparam { 		struct floppy_struct g;	/* geometry */ 		struct format_descr f; 		struct floppy_max_errors max_errors; 		struct floppy_drive_params dp; 	} inparam;		/* parameters coming from user space */ 	const void *outparam;	/* parameters passed back to user space */  	/* convert compatibility eject ioctls into floppy eject ioctl. 	 * We do this in order to provide a means to eject floppy disks before 	 * installing the new fdutils package */ 	if (cmd == CDROMEJECT ||	/* CD-ROM eject */ 	    cmd == 0x6470) {		/* SunOS floppy eject */ 		DPRINT(""obsolete eject ioctl\n""); 		DPRINT(""please use floppycontrol --eject\n""); 		cmd = FDEJECT; 	}  	if (!((cmd & 0xff00) == 0x0200)) 		return -EINVAL;  	/* convert the old style command into a new style command */ 	ret = normalize_ioctl(&cmd, &size); 	if (ret) 		return ret;  	/* permission checks */ 	if (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) || 	    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))) 		return -EPERM;  	if (WARN_ON(size < 0 || size > sizeof(inparam))) 		return -EINVAL;  	/* copyin */ 	memset(&inparam, 0, sizeof(inparam)); 	if (_IOC_DIR(cmd) & _IOC_WRITE) { 		ret = fd_copyin((void __user *)param, &inparam, size); 		if (ret) 			return ret; 	}  	switch (cmd) { 	case FDEJECT: 		if (drive_state[drive].fd_ref != 1) 			/* somebody else has this drive open */ 			return -EBUSY; 		if (lock_fdc(drive)) 			return -EINTR;  		/* do the actual eject. Fails on 		 * non-Sparc architectures */ 		ret = fd_eject(UNIT(drive));  		set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags); 		set_bit(FD_VERIFY_BIT, &drive_state[drive].flags); 		process_fd_request(); 		return ret; 	case FDCLRPRM: 		if (lock_fdc(drive)) 			return -EINTR; 		current_type[drive] = NULL; 		floppy_sizes[drive] = MAX_DISK_SIZE << 1; 		drive_state[drive].keep_data = 0; 		return invalidate_drive(bdev); 	case FDSETPRM: 	case FDDEFPRM: 		return set_geometry(cmd, &inparam.g, drive, type, bdev); 	case FDGETPRM: 		ret = get_floppy_geometry(drive, type, 					  (struct floppy_struct **)&outparam); 		if (ret) 			return ret; 		memcpy(&inparam.g, outparam, 				offsetof(struct floppy_struct, name)); 		outparam = &inparam.g; 		break; 	case FDMSGON: 		drive_params[drive].flags |= FTD_MSG; 		return 0; 	case FDMSGOFF: 		drive_params[drive].flags &= ~FTD_MSG; 		return 0; 	case FDFMTBEG: 		if (lock_fdc(drive)) 			return -EINTR; 		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR) 			return -EINTR; 		ret = drive_state[drive].flags; 		process_fd_request(); 		if (ret & FD_VERIFY) 			return -ENODEV; 		if (!(ret & FD_DISK_WRITABLE)) 			return -EROFS; 		return 0; 	case FDFMTTRK: 		if (drive_state[drive].fd_ref != 1) 			return -EBUSY; 		return do_format(drive, &inparam.f); 	case FDFMTEND: 	case FDFLUSH: 		if (lock_fdc(drive)) 			return -EINTR; 		return invalidate_drive(bdev); 	case FDSETEMSGTRESH: 		drive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f); 		return 0; 	case FDGETMAXERRS: 		outparam = &drive_params[drive].max_errors; 		break; 	case FDSETMAXERRS: 		drive_params[drive].max_errors = inparam.max_errors; 		break; 	case FDGETDRVTYP: 		outparam = drive_name(type, drive); 		SUPBOUND(size, strlen((const char *)outparam) + 1); 		break; 	case FDSETDRVPRM: 		if (!valid_floppy_drive_params(inparam.dp.autodetect, 				inparam.dp.native_format)) 			return -EINVAL; 		drive_params[drive] = inparam.dp; 		break; 	case FDGETDRVPRM: 		outparam = &drive_params[drive]; 		break; 	case FDPOLLDRVSTAT: 		if (lock_fdc(drive)) 			return -EINTR; 		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR) 			return -EINTR; 		process_fd_request(); 		fallthrough; 	case FDGETDRVSTAT: 		outparam = &drive_state[drive]; 		break; 	case FDRESET: 		return user_reset_fdc(drive, (int)param, true); 	case FDGETFDCSTAT: 		outparam = &fdc_state[FDC(drive)]; 		break; 	case FDWERRORCLR: 		memset(&write_errors[drive], 0, sizeof(write_errors[drive])); 		return 0; 	case FDWERRORGET: 		outparam = &write_errors[drive]; 		break; 	case FDRAWCMD: 		if (type) 			return -EINVAL; 		if (lock_fdc(drive)) 			return -EINTR; 		set_floppy(drive); 		i = raw_cmd_ioctl(cmd, (void __user *)param); 		if (i == -EINTR) 			return -EINTR; 		process_fd_request(); 		return i; 	case FDTWADDLE: 		if (lock_fdc(drive)) 			return -EINTR; 		twaddle(current_fdc, current_drive); 		process_fd_request(); 		return 0; 	default: 		return -EINVAL; 	}  	if (_IOC_DIR(cmd) & _IOC_READ) 		return fd_copyout((void __user *)param, outparam, size);  	return 0; }"
"199712_CWE-415.c","CWE-415","static void rtrs_clt_dev_release(struct device *dev) { 	struct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess, 						 dev);  	kfree(clt); }"
"199767_CWE-22.c","CWE-22","inbound_cap_ls (server *serv, char *nick, char *extensions_str, 					 const message_tags_data *tags_data) { 	char buffer[256];	/* buffer for requesting capabilities and emitting the signal */ 	guint32 want_cap; /* format the CAP REQ string based on previous capabilities being requested or not */ 	guint32 want_sasl; /* CAP END shouldn't be sent when SASL is requested, it needs further responses */ 	char **extensions; 	int i;  	EMIT_SIGNAL_TIMESTAMP (XP_TE_CAPLIST, serv->server_session, nick, 								  extensions_str, NULL, NULL, 0, tags_data->timestamp); 	want_cap = 0; 	want_sasl = 0;  	extensions = g_strsplit (extensions_str, "" "", 0);  	strcpy (buffer, ""CAP REQ :"");  	for (i=0; extensions[i]; i++) 	{ 		const char *extension = extensions[i];  		if (!strcmp (extension, ""identify-msg"")) 		{ 			strcat (buffer, ""identify-msg ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""multi-prefix"")) 		{ 			strcat (buffer, ""multi-prefix ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""away-notify"")) 		{ 			strcat (buffer, ""away-notify ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""account-notify"")) 		{ 			strcat (buffer, ""account-notify ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""extended-join"")) 		{ 			strcat (buffer, ""extended-join ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""userhost-in-names"")) 		{ 			strcat (buffer, ""userhost-in-names ""); 			want_cap = 1; 		}  		/* bouncers can prefix a name space to the extension so we should use. 		 * znc <= 1.0 uses ""znc.in/server-time"" and newer use ""znc.in/server-time-iso"". 		 */ 		if (!strcmp (extension, ""znc.in/server-time-iso"")) 		{ 			strcat (buffer, ""znc.in/server-time-iso ""); 			want_cap = 1; 		} 		if (!strcmp (extension, ""znc.in/server-time"")) 		{ 			strcat (buffer, ""znc.in/server-time ""); 			want_cap = 1; 		} 		if (prefs.hex_irc_cap_server_time 			 && !strcmp (extension, ""server-time"")) 		{ 			strcat (buffer, ""server-time ""); 			want_cap = 1; 		} 		 		/* if the SASL password is set AND auth mode is set to SASL, request SASL auth */ 		if (!strcmp (extension, ""sasl"") 			&& ((serv->loginmethod == LOGIN_SASL && strlen (serv->password) != 0) 			|| (serv->loginmethod == LOGIN_SASLEXTERNAL && serv->have_cert))) 		{ 			strcat (buffer, ""sasl ""); 			want_cap = 1; 			want_sasl = 1; 		} 	}  	g_strfreev (extensions);  	if (want_cap) 	{ 		/* buffer + 9 = emit buffer without ""CAP REQ :"" */ 		EMIT_SIGNAL_TIMESTAMP (XP_TE_CAPREQ, serv->server_session, 									  buffer + 9, NULL, NULL, NULL, 0, 									  tags_data->timestamp); 		tcp_sendf (serv, ""%s\r\n"", g_strchomp (buffer)); 	} 	if (!want_sasl) 	{ 		/* if we use SASL, CAP END is dealt via raw numerics */ 		serv->sent_capend = TRUE; 		tcp_send_len (serv, ""CAP END\r\n"", 9); 	} }"
"199778_CWE-444.c","CWE-444","size_t puma_parser_execute(puma_parser *parser, const char *buffer, size_t len, size_t off)  {   const char *p, *pe;   int cs = parser->cs;    assert(off <= len && ""offset past end of buffer"");    p = buffer+off;   pe = buffer+len;    /* assert(*pe == '\0' && ""pointer does not end on NUL""); */   assert((size_t) (pe - p) == len - off && ""pointers aren't same distance"");     #line 87 ""ext/puma_http11/http11_parser.c"" 	{ 	if ( p == pe ) 		goto _test_eof; 	switch ( cs ) 	{ case 1: 	switch( (*p) ) { 		case 36: goto tr0; 		case 95: goto tr0; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto tr0; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto tr0; 	} else 		goto tr0; 	goto st0; st0: cs = 0; 	goto _out; tr0: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st2; st2: 	if ( ++p == pe ) 		goto _test_eof2; case 2: #line 118 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st27; 		case 95: goto st27; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st27; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st27; 	} else 		goto st27; 	goto st0; tr2: #line 50 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_method(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st3; st3: 	if ( ++p == pe ) 		goto _test_eof3; case 3: #line 143 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 42: goto tr4; 		case 43: goto tr5; 		case 47: goto tr6; 		case 58: goto tr7; 	} 	if ( (*p) < 65 ) { 		if ( 45 <= (*p) && (*p) <= 57 ) 			goto tr5; 	} else if ( (*p) > 90 ) { 		if ( 97 <= (*p) && (*p) <= 122 ) 			goto tr5; 	} else 		goto tr5; 	goto st0; tr4: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st4; st4: 	if ( ++p == pe ) 		goto _test_eof4; case 4: #line 167 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr8; 		case 35: goto tr9; 	} 	goto st0; tr8: #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; tr31: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } #line 56 ""ext/puma_http11/http11_parser.rl"" 	{     parser->fragment(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; tr33: #line 56 ""ext/puma_http11/http11_parser.rl"" 	{     parser->fragment(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; tr37: #line 69 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; tr41: #line 60 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(query_start, p); } #line 61 ""ext/puma_http11/http11_parser.rl"" 	{     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; tr44: #line 61 ""ext/puma_http11/http11_parser.rl"" 	{     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st5; st5: 	if ( ++p == pe ) 		goto _test_eof5; case 5: #line 229 ""ext/puma_http11/http11_parser.c"" 	if ( (*p) == 72 ) 		goto tr10; 	goto st0; tr10: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st6; st6: 	if ( ++p == pe ) 		goto _test_eof6; case 6: #line 241 ""ext/puma_http11/http11_parser.c"" 	if ( (*p) == 84 ) 		goto st7; 	goto st0; st7: 	if ( ++p == pe ) 		goto _test_eof7; case 7: 	if ( (*p) == 84 ) 		goto st8; 	goto st0; st8: 	if ( ++p == pe ) 		goto _test_eof8; case 8: 	if ( (*p) == 80 ) 		goto st9; 	goto st0; st9: 	if ( ++p == pe ) 		goto _test_eof9; case 9: 	if ( (*p) == 47 ) 		goto st10; 	goto st0; st10: 	if ( ++p == pe ) 		goto _test_eof10; case 10: 	if ( 48 <= (*p) && (*p) <= 57 ) 		goto st11; 	goto st0; st11: 	if ( ++p == pe ) 		goto _test_eof11; case 11: 	if ( (*p) == 46 ) 		goto st12; 	if ( 48 <= (*p) && (*p) <= 57 ) 		goto st11; 	goto st0; st12: 	if ( ++p == pe ) 		goto _test_eof12; case 12: 	if ( 48 <= (*p) && (*p) <= 57 ) 		goto st13; 	goto st0; st13: 	if ( ++p == pe ) 		goto _test_eof13; case 13: 	if ( (*p) == 13 ) 		goto tr18; 	if ( 48 <= (*p) && (*p) <= 57 ) 		goto st13; 	goto st0; tr18: #line 65 ""ext/puma_http11/http11_parser.rl"" 	{     parser->http_version(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st14; tr26: #line 46 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } #line 47 ""ext/puma_http11/http11_parser.rl"" 	{     parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));   } 	goto st14; tr29: #line 47 ""ext/puma_http11/http11_parser.rl"" 	{     parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));   } 	goto st14; st14: 	if ( ++p == pe ) 		goto _test_eof14; case 14: #line 322 ""ext/puma_http11/http11_parser.c"" 	if ( (*p) == 10 ) 		goto st15; 	goto st0; st15: 	if ( ++p == pe ) 		goto _test_eof15; case 15: 	switch( (*p) ) { 		case 13: goto st16; 		case 33: goto tr21; 		case 124: goto tr21; 		case 126: goto tr21; 	} 	if ( (*p) < 45 ) { 		if ( (*p) > 39 ) { 			if ( 42 <= (*p) && (*p) <= 43 ) 				goto tr21; 		} else if ( (*p) >= 35 ) 			goto tr21; 	} else if ( (*p) > 46 ) { 		if ( (*p) < 65 ) { 			if ( 48 <= (*p) && (*p) <= 57 ) 				goto tr21; 		} else if ( (*p) > 90 ) { 			if ( 94 <= (*p) && (*p) <= 122 ) 				goto tr21; 		} else 			goto tr21; 	} else 		goto tr21; 	goto st0; st16: 	if ( ++p == pe ) 		goto _test_eof16; case 16: 	if ( (*p) == 10 ) 		goto tr22; 	goto st0; tr22: #line 73 ""ext/puma_http11/http11_parser.rl"" 	{     parser->body_start = p - buffer + 1;     parser->header_done(parser, p + 1, pe - p - 1);     {p++; cs = 46; goto _out;}   } 	goto st46; st46: 	if ( ++p == pe ) 		goto _test_eof46; case 46: #line 373 ""ext/puma_http11/http11_parser.c"" 	goto st0; tr21: #line 40 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(field_start, p); } #line 41 ""ext/puma_http11/http11_parser.rl"" 	{ snake_upcase_char((char *)p); } 	goto st17; tr23: #line 41 ""ext/puma_http11/http11_parser.rl"" 	{ snake_upcase_char((char *)p); } 	goto st17; st17: 	if ( ++p == pe ) 		goto _test_eof17; case 17: #line 389 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 33: goto tr23; 		case 58: goto tr24; 		case 124: goto tr23; 		case 126: goto tr23; 	} 	if ( (*p) < 45 ) { 		if ( (*p) > 39 ) { 			if ( 42 <= (*p) && (*p) <= 43 ) 				goto tr23; 		} else if ( (*p) >= 35 ) 			goto tr23; 	} else if ( (*p) > 46 ) { 		if ( (*p) < 65 ) { 			if ( 48 <= (*p) && (*p) <= 57 ) 				goto tr23; 		} else if ( (*p) > 90 ) { 			if ( 94 <= (*p) && (*p) <= 122 ) 				goto tr23; 		} else 			goto tr23; 	} else 		goto tr23; 	goto st0; tr24: #line 42 ""ext/puma_http11/http11_parser.rl"" 	{     parser->field_len = LEN(field_start, p);   } 	goto st18; tr27: #line 46 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st18; st18: 	if ( ++p == pe ) 		goto _test_eof18; case 18: #line 428 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 13: goto tr26; 		case 32: goto tr27; 	} 	goto tr25; tr25: #line 46 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st19; st19: 	if ( ++p == pe ) 		goto _test_eof19; case 19: #line 442 ""ext/puma_http11/http11_parser.c"" 	if ( (*p) == 13 ) 		goto tr29; 	goto st19; tr9: #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st20; tr38: #line 69 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st20; tr42: #line 60 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(query_start, p); } #line 61 ""ext/puma_http11/http11_parser.rl"" 	{     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st20; tr45: #line 61 ""ext/puma_http11/http11_parser.rl"" 	{     parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));   } #line 53 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));   } 	goto st20; st20: 	if ( ++p == pe ) 		goto _test_eof20; case 20: #line 488 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr31; 		case 60: goto st0; 		case 62: goto st0; 		case 127: goto st0; 	} 	if ( (*p) > 31 ) { 		if ( 34 <= (*p) && (*p) <= 35 ) 			goto st0; 	} else if ( (*p) >= 0 ) 		goto st0; 	goto tr30; tr30: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st21; st21: 	if ( ++p == pe ) 		goto _test_eof21; case 21: #line 509 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr33; 		case 60: goto st0; 		case 62: goto st0; 		case 127: goto st0; 	} 	if ( (*p) > 31 ) { 		if ( 34 <= (*p) && (*p) <= 35 ) 			goto st0; 	} else if ( (*p) >= 0 ) 		goto st0; 	goto st21; tr5: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st22; st22: 	if ( ++p == pe ) 		goto _test_eof22; case 22: #line 530 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 43: goto st22; 		case 58: goto st23; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st22; 	} else if ( (*p) > 57 ) { 		if ( (*p) > 90 ) { 			if ( 97 <= (*p) && (*p) <= 122 ) 				goto st22; 		} else if ( (*p) >= 65 ) 			goto st22; 	} else 		goto st22; 	goto st0; tr7: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st23; st23: 	if ( ++p == pe ) 		goto _test_eof23; case 23: #line 555 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr8; 		case 34: goto st0; 		case 35: goto tr9; 		case 60: goto st0; 		case 62: goto st0; 		case 127: goto st0; 	} 	if ( 0 <= (*p) && (*p) <= 31 ) 		goto st0; 	goto st23; tr6: #line 37 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(mark, p); } 	goto st24; st24: 	if ( ++p == pe ) 		goto _test_eof24; case 24: #line 575 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr37; 		case 34: goto st0; 		case 35: goto tr38; 		case 60: goto st0; 		case 62: goto st0; 		case 63: goto tr39; 		case 127: goto st0; 	} 	if ( 0 <= (*p) && (*p) <= 31 ) 		goto st0; 	goto st24; tr39: #line 69 ""ext/puma_http11/http11_parser.rl"" 	{     parser->request_path(parser, PTR_TO(mark), LEN(mark,p));   } 	goto st25; st25: 	if ( ++p == pe ) 		goto _test_eof25; case 25: #line 598 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr41; 		case 34: goto st0; 		case 35: goto tr42; 		case 60: goto st0; 		case 62: goto st0; 		case 127: goto st0; 	} 	if ( 0 <= (*p) && (*p) <= 31 ) 		goto st0; 	goto tr40; tr40: #line 60 ""ext/puma_http11/http11_parser.rl"" 	{ MARK(query_start, p); } 	goto st26; st26: 	if ( ++p == pe ) 		goto _test_eof26; case 26: #line 618 ""ext/puma_http11/http11_parser.c"" 	switch( (*p) ) { 		case 32: goto tr44; 		case 34: goto st0; 		case 35: goto tr45; 		case 60: goto st0; 		case 62: goto st0; 		case 127: goto st0; 	} 	if ( 0 <= (*p) && (*p) <= 31 ) 		goto st0; 	goto st26; st27: 	if ( ++p == pe ) 		goto _test_eof27; case 27: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st28; 		case 95: goto st28; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st28; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st28; 	} else 		goto st28; 	goto st0; st28: 	if ( ++p == pe ) 		goto _test_eof28; case 28: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st29; 		case 95: goto st29; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st29; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st29; 	} else 		goto st29; 	goto st0; st29: 	if ( ++p == pe ) 		goto _test_eof29; case 29: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st30; 		case 95: goto st30; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st30; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st30; 	} else 		goto st30; 	goto st0; st30: 	if ( ++p == pe ) 		goto _test_eof30; case 30: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st31; 		case 95: goto st31; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st31; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st31; 	} else 		goto st31; 	goto st0; st31: 	if ( ++p == pe ) 		goto _test_eof31; case 31: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st32; 		case 95: goto st32; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st32; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st32; 	} else 		goto st32; 	goto st0; st32: 	if ( ++p == pe ) 		goto _test_eof32; case 32: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st33; 		case 95: goto st33; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st33; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st33; 	} else 		goto st33; 	goto st0; st33: 	if ( ++p == pe ) 		goto _test_eof33; case 33: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st34; 		case 95: goto st34; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st34; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st34; 	} else 		goto st34; 	goto st0; st34: 	if ( ++p == pe ) 		goto _test_eof34; case 34: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st35; 		case 95: goto st35; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st35; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st35; 	} else 		goto st35; 	goto st0; st35: 	if ( ++p == pe ) 		goto _test_eof35; case 35: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st36; 		case 95: goto st36; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st36; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st36; 	} else 		goto st36; 	goto st0; st36: 	if ( ++p == pe ) 		goto _test_eof36; case 36: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st37; 		case 95: goto st37; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st37; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st37; 	} else 		goto st37; 	goto st0; st37: 	if ( ++p == pe ) 		goto _test_eof37; case 37: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st38; 		case 95: goto st38; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st38; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st38; 	} else 		goto st38; 	goto st0; st38: 	if ( ++p == pe ) 		goto _test_eof38; case 38: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st39; 		case 95: goto st39; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st39; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st39; 	} else 		goto st39; 	goto st0; st39: 	if ( ++p == pe ) 		goto _test_eof39; case 39: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st40; 		case 95: goto st40; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st40; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st40; 	} else 		goto st40; 	goto st0; st40: 	if ( ++p == pe ) 		goto _test_eof40; case 40: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st41; 		case 95: goto st41; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st41; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st41; 	} else 		goto st41; 	goto st0; st41: 	if ( ++p == pe ) 		goto _test_eof41; case 41: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st42; 		case 95: goto st42; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st42; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st42; 	} else 		goto st42; 	goto st0; st42: 	if ( ++p == pe ) 		goto _test_eof42; case 42: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st43; 		case 95: goto st43; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st43; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st43; 	} else 		goto st43; 	goto st0; st43: 	if ( ++p == pe ) 		goto _test_eof43; case 43: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st44; 		case 95: goto st44; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st44; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st44; 	} else 		goto st44; 	goto st0; st44: 	if ( ++p == pe ) 		goto _test_eof44; case 44: 	switch( (*p) ) { 		case 32: goto tr2; 		case 36: goto st45; 		case 95: goto st45; 	} 	if ( (*p) < 48 ) { 		if ( 45 <= (*p) && (*p) <= 46 ) 			goto st45; 	} else if ( (*p) > 57 ) { 		if ( 65 <= (*p) && (*p) <= 90 ) 			goto st45; 	} else 		goto st45; 	goto st0; st45: 	if ( ++p == pe ) 		goto _test_eof45; case 45: 	if ( (*p) == 32 ) 		goto tr2; 	goto st0; 	} 	_test_eof2: cs = 2; goto _test_eof;  	_test_eof3: cs = 3; goto _test_eof;  	_test_eof4: cs = 4; goto _test_eof;  	_test_eof5: cs = 5; goto _test_eof;  	_test_eof6: cs = 6; goto _test_eof;  	_test_eof7: cs = 7; goto _test_eof;  	_test_eof8: cs = 8; goto _test_eof;  	_test_eof9: cs = 9; goto _test_eof;  	_test_eof10: cs = 10; goto _test_eof;  	_test_eof11: cs = 11; goto _test_eof;  	_test_eof12: cs = 12; goto _test_eof;  	_test_eof13: cs = 13; goto _test_eof;  	_test_eof14: cs = 14; goto _test_eof;  	_test_eof15: cs = 15; goto _test_eof;  	_test_eof16: cs = 16; goto _test_eof;  	_test_eof46: cs = 46; goto _test_eof;  	_test_eof17: cs = 17; goto _test_eof;  	_test_eof18: cs = 18; goto _test_eof;  	_test_eof19: cs = 19; goto _test_eof;  	_test_eof20: cs = 20; goto _test_eof;  	_test_eof21: cs = 21; goto _test_eof;  	_test_eof22: cs = 22; goto _test_eof;  	_test_eof23: cs = 23; goto _test_eof;  	_test_eof24: cs = 24; goto _test_eof;  	_test_eof25: cs = 25; goto _test_eof;  	_test_eof26: cs = 26; goto _test_eof;  	_test_eof27: cs = 27; goto _test_eof;  	_test_eof28: cs = 28; goto _test_eof;  	_test_eof29: cs = 29; goto _test_eof;  	_test_eof30: cs = 30; goto _test_eof;  	_test_eof31: cs = 31; goto _test_eof;  	_test_eof32: cs = 32; goto _test_eof;  	_test_eof33: cs = 33; goto _test_eof;  	_test_eof34: cs = 34; goto _test_eof;  	_test_eof35: cs = 35; goto _test_eof;  	_test_eof36: cs = 36; goto _test_eof;  	_test_eof37: cs = 37; goto _test_eof;  	_test_eof38: cs = 38; goto _test_eof;  	_test_eof39: cs = 39; goto _test_eof;  	_test_eof40: cs = 40; goto _test_eof;  	_test_eof41: cs = 41; goto _test_eof;  	_test_eof42: cs = 42; goto _test_eof;  	_test_eof43: cs = 43; goto _test_eof;  	_test_eof44: cs = 44; goto _test_eof;  	_test_eof45: cs = 45; goto _test_eof;   	_test_eof: {} 	_out: {} 	}  #line 117 ""ext/puma_http11/http11_parser.rl""    if (!puma_parser_has_error(parser))     parser->cs = cs;   parser->nread += p - (buffer + off);    assert(p <= pe && ""buffer overflow after parsing execute"");   assert(parser->nread <= len && ""nread longer than length"");   assert(parser->body_start <= len && ""body starts after buffer end"");   assert(parser->mark < len && ""mark is after buffer end"");   assert(parser->field_len <= len && ""field has length longer than whole buffer"");   assert(parser->field_start < len && ""field starts after buffer end"");    return(parser->nread); }"
"199833_CWE-476.c","CWE-476","gif_internal_decode_frame(gif_animation *gif,                           unsigned int frame,                           bool clear_image) {         unsigned int index = 0;         const unsigned char *gif_data, *gif_end;         ssize_t gif_bytes;         unsigned int width, height, offset_x, offset_y;         unsigned int flags, colour_table_size, interlace;         unsigned int *colour_table;         unsigned int *frame_data = 0;	// Set to 0 for no warnings         unsigned int *frame_scanline;         ssize_t save_buffer_position;         unsigned int return_value = 0;         unsigned int x, y, decode_y, burst_bytes;         register unsigned char colour;          /* Ensure this frame is supposed to be decoded */         if (gif->frames[frame].display == false) {                 return GIF_OK;         }          /* Ensure the frame is in range to decode */         if (frame > gif->frame_count_partial) {                 return GIF_INSUFFICIENT_DATA;         }          /* done if frame is already decoded */         if ((!clear_image) &&             ((int)frame == gif->decoded_frame)) {                 return GIF_OK;         }          /* Get the start of our frame data and the end of the GIF data */         gif_data = gif->gif_data + gif->frames[frame].frame_pointer;         gif_end = gif->gif_data + gif->buffer_size;         gif_bytes = (gif_end - gif_data);          /*          * Ensure there is a minimal amount of data to proceed.  The shortest          * block of data is a 10-byte image descriptor + 1-byte gif trailer          */         if (gif_bytes < 12) {                 return GIF_INSUFFICIENT_FRAME_DATA;         }          /* Save the buffer position */         save_buffer_position = gif->buffer_position;         gif->buffer_position = gif_data - gif->gif_data;          /* Skip any extensions because they have allready been processed */         if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {                 goto gif_decode_frame_exit;         }         gif_data = (gif->gif_data + gif->buffer_position);         gif_bytes = (gif_end - gif_data);          /* Ensure we have enough data for the 10-byte image descriptor + 1-byte          * gif trailer          */         if (gif_bytes < 12) {                 return_value = GIF_INSUFFICIENT_FRAME_DATA;                 goto gif_decode_frame_exit;         }          /* 10-byte Image Descriptor is:          *          *	+0	CHAR	Image Separator (0x2c)          *	+1	SHORT	Image Left Position          *	+3	SHORT	Image Top Position          *	+5	SHORT	Width          *	+7	SHORT	Height          *	+9	CHAR	__Packed Fields__          *			1BIT	Local Colour Table Flag          *			1BIT	Interlace Flag          *			1BIT	Sort Flag          *			2BITS	Reserved          *			3BITS	Size of Local Colour Table          */         if (gif_data[0] != GIF_IMAGE_SEPARATOR) {                 return_value = GIF_DATA_ERROR;                 goto gif_decode_frame_exit;         }         offset_x = gif_data[1] | (gif_data[2] << 8);         offset_y = gif_data[3] | (gif_data[4] << 8);         width = gif_data[5] | (gif_data[6] << 8);         height = gif_data[7] | (gif_data[8] << 8);          /* Boundary checking - shouldn't ever happen except unless the data has          * been modified since initialisation.          */         if ((offset_x + width > gif->width) ||             (offset_y + height > gif->height)) {                 return_value = GIF_DATA_ERROR;                 goto gif_decode_frame_exit;         }          /* Decode the flags */         flags = gif_data[9];         colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);         interlace = flags & GIF_INTERLACE_MASK;          /* Advance data pointer to next block either colour table or image          * data.          */         gif_data += 10;         gif_bytes = (gif_end - gif_data);          /* Set up the colour table */         if (flags & GIF_COLOUR_TABLE_MASK) {                 if (gif_bytes < (int)(3 * colour_table_size)) {                         return_value = GIF_INSUFFICIENT_FRAME_DATA;                         goto gif_decode_frame_exit;                 }                 colour_table = gif->local_colour_table;                 if (!clear_image) {                         for (index = 0; index < colour_table_size; index++) {                                 /* Gif colour map contents are r,g,b.                                  *                                  * We want to pack them bytewise into the                                  * colour table, such that the red component                                  * is in byte 0 and the alpha component is in                                  * byte 3.                                  */                                 unsigned char *entry =                                         (unsigned char *) &colour_table[index];                                  entry[0] = gif_data[0];	/* r */                                 entry[1] = gif_data[1];	/* g */                                 entry[2] = gif_data[2];	/* b */                                 entry[3] = 0xff;	/* a */                                  gif_data += 3;                         }                 } else {                         gif_data += 3 * colour_table_size;                 }                 gif_bytes = (gif_end - gif_data);         } else {                 colour_table = gif->global_colour_table;         }          /* Ensure sufficient data remains */         if (gif_bytes < 1) {                 return_value = GIF_INSUFFICIENT_FRAME_DATA;                 goto gif_decode_frame_exit;         }          /* check for an end marker */         if (gif_data[0] == GIF_TRAILER) {                 return_value = GIF_OK;                 goto gif_decode_frame_exit;         }          /* Get the frame data */         assert(gif->bitmap_callbacks.bitmap_get_buffer);         frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);         if (!frame_data) {                 return GIF_INSUFFICIENT_MEMORY;         }          /* If we are clearing the image we just clear, if not decode */         if (!clear_image) {                 lzw_result res;                 const uint8_t *stack_base;                 const uint8_t *stack_pos;                  /* Ensure we have enough data for a 1-byte LZW code size +                  * 1-byte gif trailer                  */                 if (gif_bytes < 2) {                         return_value = GIF_INSUFFICIENT_FRAME_DATA;                         goto gif_decode_frame_exit;                 }                  /* If we only have a 1-byte LZW code size + 1-byte gif trailer,                  * we're finished                  */                 if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {                         return_value = GIF_OK;                         goto gif_decode_frame_exit;                 }                  /* If the previous frame's disposal method requires we restore                  * the background colour or this is the first frame, clear                  * the frame data                  */                 if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {                         memset((char*)frame_data,                                GIF_TRANSPARENT_COLOUR,                                gif->width * gif->height * sizeof(int));                         gif->decoded_frame = frame;                         /* The line below would fill the image with its                          * background color, but because GIFs support                          * transparency we likely wouldn't want to do that. */                         /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */                 } else if ((frame != 0) &&                            (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {                         return_value = gif_internal_decode_frame(gif,                                                                  (frame - 1),                                                                  true);                         if (return_value != GIF_OK) {                                 goto gif_decode_frame_exit;                         }                  } else if ((frame != 0) &&                            (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {                         /*                          * If the previous frame's disposal method requires we                          * restore the previous image, find the last image set                          * to ""do not dispose"" and get that frame data                          */                         int last_undisposed_frame = frame - 2;                         while ((last_undisposed_frame >= 0) &&                                (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {                                 last_undisposed_frame--;                         }                          /* If we don't find one, clear the frame data */                         if (last_undisposed_frame == -1) {                                 /* see notes above on transparency                                  * vs. background color                                  */                                 memset((char*)frame_data,                                        GIF_TRANSPARENT_COLOUR,                                        gif->width * gif->height * sizeof(int));                         } else {                                 return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);                                 if (return_value != GIF_OK) {                                         goto gif_decode_frame_exit;                                 }                                 /* Get this frame's data */                                 assert(gif->bitmap_callbacks.bitmap_get_buffer);                                 frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);                                 if (!frame_data) {                                         return GIF_INSUFFICIENT_MEMORY;                                 }                         }                 }                 gif->decoded_frame = frame;                 gif->buffer_position = (gif_data - gif->gif_data) + 1;                  /* Initialise the LZW decoding */                 res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,                                 gif->buffer_size, gif->buffer_position,                                 gif_data[0], &stack_base, &stack_pos);                 if (res != LZW_OK) {                         return gif_error_from_lzw(res);                 }                  /* Decompress the data */                 for (y = 0; y < height; y++) {                         if (interlace) {                                 decode_y = gif_interlaced_line(height, y) + offset_y;                         } else {                                 decode_y = y + offset_y;                         }                         frame_scanline = frame_data + offset_x + (decode_y * gif->width);                          /* Rather than decoding pixel by pixel, we try to burst                          * out streams of data to remove the need for end-of                          * data checks every pixel.                          */                         x = width;                         while (x > 0) {                                 burst_bytes = (stack_pos - stack_base);                                 if (burst_bytes > 0) {                                         if (burst_bytes > x) {                                                 burst_bytes = x;                                         }                                         x -= burst_bytes;                                         while (burst_bytes-- > 0) {                                                 colour = *--stack_pos;                                                 if (((gif->frames[frame].transparency) &&                                                      (colour != gif->frames[frame].transparency_index)) ||                                                     (!gif->frames[frame].transparency)) {                                                         *frame_scanline = colour_table[colour];                                                 }                                                 frame_scanline++;                                         }                                 } else {                                         res = lzw_decode(gif->lzw_ctx, &stack_pos);                                         if (res != LZW_OK) {                                                 /* Unexpected end of frame, try to recover */                                                 if (res == LZW_OK_EOD) {                                                         return_value = GIF_OK;                                                 } else {                                                         return_value = gif_error_from_lzw(res);                                                 }                                                 goto gif_decode_frame_exit;                                         }                                 }                         }                 }         } else {                 /* Clear our frame */                 if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {                         for (y = 0; y < height; y++) {                                 frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);                                 if (gif->frames[frame].transparency) {                                         memset(frame_scanline,                                                GIF_TRANSPARENT_COLOUR,                                                width * 4);                                 } else {                                         memset(frame_scanline,                                                colour_table[gif->background_index],                                                width * 4);                                 }                         }                 }         } gif_decode_frame_exit:          /* Check if we should test for optimisation */         if (gif->frames[frame].virgin) {                 if (gif->bitmap_callbacks.bitmap_test_opaque) {                         gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);                 } else {                         gif->frames[frame].opaque = false;                 }                 gif->frames[frame].virgin = false;         }          if (gif->bitmap_callbacks.bitmap_set_opaque) {                 gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);         }          if (gif->bitmap_callbacks.bitmap_modified) {                 gif->bitmap_callbacks.bitmap_modified(gif->frame_image);         }          /* Restore the buffer position */         gif->buffer_position = save_buffer_position;          return return_value; }"
"199834_CWE-125.c","CWE-125","ins_compl_stop(int c, int prev_mode, int retval) {     char_u	*ptr;     int		want_cindent;      // Get here when we have finished typing a sequence of ^N and     // ^P or other completion characters in CTRL-X mode.  Free up     // memory that was used, and make sure we can redo the insert.     if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)     { 	// If any of the original typed text has been changed, eg when 	// ignorecase is set, we must add back-spaces to the redo 	// buffer.  We add as few as necessary to delete just the part 	// of the original text that has changed. 	// When using the longest match, edited the match or used 	// CTRL-E then don't use the current match. 	if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E) 	    ptr = compl_curr_match->cp_str; 	else 	    ptr = NULL; 	ins_compl_fixRedoBufForLeader(ptr);     }      want_cindent = (get_can_cindent() && cindent_on());      // When completing whole lines: fix indent for 'cindent'.     // Otherwise, break line if it's too long.     if (compl_cont_mode == CTRL_X_WHOLE_LINE)     { 	// re-indent the current line 	if (want_cindent) 	{ 	    do_c_expr_indent(); 	    want_cindent = FALSE;	// don't do it again 	}     }     else     { 	int prev_col = curwin->w_cursor.col;  	// put the cursor on the last char, for 'tw' formatting 	if (prev_col > 0) 	    dec_cursor(); 	// only format when something was inserted 	if (!arrow_used && !ins_need_undo_get() && c != Ctrl_E) 	    insertchar(NUL, 0, -1); 	if (prev_col > 0 		&& ml_get_curline()[curwin->w_cursor.col] != NUL) 	    inc_cursor();     }      // If the popup menu is displayed pressing CTRL-Y means accepting     // the selection without inserting anything.  When     // compl_enter_selects is set the Enter key does the same.     if ((c == Ctrl_Y || (compl_enter_selects 		    && (c == CAR || c == K_KENTER || c == NL))) 	    && pum_visible()) 	retval = TRUE;      // CTRL-E means completion is Ended, go back to the typed text.     // but only do this, if the Popup is still visible     if (c == Ctrl_E)     { 	ins_compl_delete(); 	if (compl_leader != NULL) 	    ins_bytes(compl_leader + get_compl_len()); 	else if (compl_first_match != NULL) 	    ins_bytes(compl_orig_text + get_compl_len()); 	retval = TRUE;     }      auto_format(FALSE, TRUE);      // Trigger the CompleteDonePre event to give scripts a chance to     // act upon the completion before clearing the info, and restore     // ctrl_x_mode, so that complete_info() can be used.     ctrl_x_mode = prev_mode;     ins_apply_autocmds(EVENT_COMPLETEDONEPRE);      ins_compl_free();     compl_started = FALSE;     compl_matches = 0;     if (!shortmess(SHM_COMPLETIONMENU)) 	msg_clr_cmdline();	// necessary for ""noshowmode""     ctrl_x_mode = CTRL_X_NORMAL;     compl_enter_selects = FALSE;     if (edit_submode != NULL)     { 	edit_submode = NULL; 	showmode();     }  #ifdef FEAT_CMDWIN     if (c == Ctrl_C && cmdwin_type != 0) 	// Avoid the popup menu remains displayed when leaving the 	// command line window. 	update_screen(0); #endif     // Indent now if a key was typed that is in 'cinkeys'.     if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0))) 	do_c_expr_indent();     // Trigger the CompleteDone event to give scripts a chance to act     // upon the end of completion.     ins_apply_autocmds(EVENT_COMPLETEDONE);      return retval; }"
"199836_CWE-125.c","CWE-125","PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner ) {     int chr = *scanner->curptr;      if (!chr) { 	pj_scan_syntax_err(scanner); 	return 0;     }      ++scanner->curptr;      if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) { 	pj_scan_skip_whitespace(scanner);     }     return chr; }"
"199841_CWE-476.c","CWE-476","static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { 	RBuffer *fbuf = r_buf_ref (buf); 	struct MACH0_(opts_t) opts; 	MACH0_(opts_set_default) (&opts, bf); 	struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts); 	if (!main_mach0) { 		return false; 	}  	RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0); 	RKernelCacheObj *obj = NULL;  	RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0); 	if (!prelink_range) { 		goto beach; 	}  	obj = R_NEW0 (RKernelCacheObj); 	if (!obj) { 		R_FREE (prelink_range); 		goto beach; 	}  	RCFValueDict *prelink_info = NULL; 	if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) { 		prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset, 				prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA); 		if (!prelink_info) { 			R_FREE (prelink_range); 			R_FREE (obj); 			goto beach; 		} 	}  	if (!pending_bin_files) { 		pending_bin_files = r_list_new (); 		if (!pending_bin_files) { 			R_FREE (prelink_range); 			R_FREE (obj); 			R_FREE (prelink_info); 			goto beach; 		} 	}  	obj->mach0 = main_mach0; 	obj->rebase_info = rebase_info; 	obj->prelink_info = prelink_info; 	obj->cache_buf = fbuf; 	obj->pa2va_exec = prelink_range->pa2va_exec; 	obj->pa2va_data = prelink_range->pa2va_data;  	R_FREE (prelink_range);  	*bin_obj = obj;  	r_list_push (pending_bin_files, bf);  	if (rebase_info || main_mach0->chained_starts) { 		RIO *io = bf->rbin->iob.io; 		swizzle_io_read (obj, io); 	}  	return true;  beach: 	r_buf_free (fbuf); 	obj->cache_buf = NULL; 	MACH0_(mach0_free) (main_mach0); 	return false; }"
"199851_CWE-787.c","CWE-787","ex_retab(exarg_T *eap) {     linenr_T	lnum;     int		got_tab = FALSE;     long	num_spaces = 0;     long	num_tabs;     long	len;     long	col;     long	vcol;     long	start_col = 0;		// For start of white-space string     long	start_vcol = 0;		// For start of white-space string     long	old_len;     char_u	*ptr;     char_u	*new_line = (char_u *)1; // init to non-NULL     int		did_undo;		// called u_save for current line #ifdef FEAT_VARTABS     int		*new_vts_array = NULL;     char_u	*new_ts_str;		// string value of tab argument #else     int		temp;     int		new_ts; #endif     int		save_list;     linenr_T	first_line = 0;		// first changed line     linenr_T	last_line = 0;		// last changed line      save_list = curwin->w_p_list;     curwin->w_p_list = 0;	    // don't want list mode here  #ifdef FEAT_VARTABS     new_ts_str = eap->arg;     if (tabstop_set(eap->arg, &new_vts_array) == FAIL) 	return;     while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',') 	++(eap->arg);      // This ensures that either new_vts_array and new_ts_str are freshly     // allocated, or new_vts_array points to an existing array and new_ts_str     // is null.     if (new_vts_array == NULL)     { 	new_vts_array = curbuf->b_p_vts_array; 	new_ts_str = NULL;     }     else 	new_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str); #else     ptr = eap->arg;     new_ts = getdigits(&ptr);     if (new_ts < 0 && *eap->arg == '-')     { 	emsg(_(e_argument_must_be_positive)); 	return;     }     if (new_ts < 0 || new_ts > TABSTOP_MAX)     { 	semsg(_(e_invalid_argument_str), eap->arg); 	return;     }     if (new_ts == 0) 	new_ts = curbuf->b_p_ts; #endif     for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)     { 	ptr = ml_get(lnum); 	col = 0; 	vcol = 0; 	did_undo = FALSE; 	for (;;) 	{ 	    if (VIM_ISWHITE(ptr[col])) 	    { 		if (!got_tab && num_spaces == 0) 		{ 		    // First consecutive white-space 		    start_vcol = vcol; 		    start_col = col; 		} 		if (ptr[col] == ' ') 		    num_spaces++; 		else 		    got_tab = TRUE; 	    } 	    else 	    { 		if (got_tab || (eap->forceit && num_spaces > 1)) 		{ 		    // Retabulate this string of white-space  		    // len is virtual length of white string 		    len = num_spaces = vcol - start_vcol; 		    num_tabs = 0; 		    if (!curbuf->b_p_et) 		    { #ifdef FEAT_VARTABS 			int t, s;  			tabstop_fromto(start_vcol, vcol, 					curbuf->b_p_ts, new_vts_array, &t, &s); 			num_tabs = t; 			num_spaces = s; #else 			temp = new_ts - (start_vcol % new_ts); 			if (num_spaces >= temp) 			{ 			    num_spaces -= temp; 			    num_tabs++; 			} 			num_tabs += num_spaces / new_ts; 			num_spaces -= (num_spaces / new_ts) * new_ts; #endif 		    } 		    if (curbuf->b_p_et || got_tab || 					(num_spaces + num_tabs < len)) 		    { 			if (did_undo == FALSE) 			{ 			    did_undo = TRUE; 			    if (u_save((linenr_T)(lnum - 1), 						(linenr_T)(lnum + 1)) == FAIL) 			    { 				new_line = NULL;	// flag out-of-memory 				break; 			    } 			}  			// len is actual number of white characters used 			len = num_spaces + num_tabs; 			old_len = (long)STRLEN(ptr); 			new_line = alloc(old_len - col + start_col + len + 1); 			if (new_line == NULL) 			    break; 			if (start_col > 0) 			    mch_memmove(new_line, ptr, (size_t)start_col); 			mch_memmove(new_line + start_col + len, 				      ptr + col, (size_t)(old_len - col + 1)); 			ptr = new_line + start_col; 			for (col = 0; col < len; col++) 			    ptr[col] = (col < num_tabs) ? '\t' : ' '; 			if (ml_replace(lnum, new_line, FALSE) == OK) 			    // ""new_line"" may have been copied 			    new_line = curbuf->b_ml.ml_line_ptr; 			if (first_line == 0) 			    first_line = lnum; 			last_line = lnum; 			ptr = new_line; 			col = start_col + len; 		    } 		} 		got_tab = FALSE; 		num_spaces = 0; 	    } 	    if (ptr[col] == NUL) 		break; 	    vcol += chartabsize(ptr + col, (colnr_T)vcol); 	    if (has_mbyte) 		col += (*mb_ptr2len)(ptr + col); 	    else 		++col; 	} 	if (new_line == NULL)		    // out of memory 	    break; 	line_breakcheck();     }     if (got_int) 	emsg(_(e_interrupted));  #ifdef FEAT_VARTABS     // If a single value was given then it can be considered equal to     // either the value of 'tabstop' or the value of 'vartabstop'.     if (tabstop_count(curbuf->b_p_vts_array) == 0 	&& tabstop_count(new_vts_array) == 1 	&& curbuf->b_p_ts == tabstop_first(new_vts_array)) 	; // not changed     else if (tabstop_count(curbuf->b_p_vts_array) > 0         && tabstop_eq(curbuf->b_p_vts_array, new_vts_array)) 	; // not changed     else 	redraw_curbuf_later(NOT_VALID); #else     if (curbuf->b_p_ts != new_ts) 	redraw_curbuf_later(NOT_VALID); #endif     if (first_line != 0) 	changed_lines(first_line, 0, last_line + 1, 0L);      curwin->w_p_list = save_list;	// restore 'list'  #ifdef FEAT_VARTABS     if (new_ts_str != NULL)		// set the new tabstop     { 	// If 'vartabstop' is in use or if the value given to retab has more 	// than one tabstop then update 'vartabstop'. 	int *old_vts_ary = curbuf->b_p_vts_array;  	if (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1) 	{ 	    set_string_option_direct((char_u *)""vts"", -1, new_ts_str, 							OPT_FREE|OPT_LOCAL, 0); 	    curbuf->b_p_vts_array = new_vts_array; 	    vim_free(old_vts_ary); 	} 	else 	{ 	    // 'vartabstop' wasn't in use and a single value was given to 	    // retab then update 'tabstop'. 	    curbuf->b_p_ts = tabstop_first(new_vts_array); 	    vim_free(new_vts_array); 	} 	vim_free(new_ts_str);     } #else     curbuf->b_p_ts = new_ts; #endif     coladvance(curwin->w_curswant);      u_clearline(); }"
"199918_CWE-416.c","CWE-416","spell_move_to(     win_T	*wp,     int		dir,		// FORWARD or BACKWARD     int		allwords,	// TRUE for ""[s""/""]s"", FALSE for ""[S""/""]S""     int		curline,     hlf_T	*attrp)		// return: attributes of bad word or NULL 				// (only when ""dir"" is FORWARD) {     linenr_T	lnum;     pos_T	found_pos;     int		found_len = 0;     char_u	*line;     char_u	*p;     char_u	*endp;     hlf_T	attr;     int		len; #ifdef FEAT_SYN_HL     int		has_syntax = syntax_present(wp); #endif     int		col;     int		can_spell;     char_u	*buf = NULL;     int		buflen = 0;     int		skip = 0;     int		capcol = -1;     int		found_one = FALSE;     int		wrapped = FALSE;      if (no_spell_checking(wp)) 	return 0;      /*      * Start looking for bad word at the start of the line, because we can't      * start halfway a word, we don't know where it starts or ends.      *      * When searching backwards, we continue in the line to find the last      * bad word (in the cursor line: before the cursor).      *      * We concatenate the start of the next line, so that wrapped words work      * (e.g. ""et<line-break>cetera"").  Doesn't work when searching backwards      * though...      */     lnum = wp->w_cursor.lnum;     CLEAR_POS(&found_pos);      while (!got_int)     { 	line = ml_get_buf(wp->w_buffer, lnum, FALSE);  	len = (int)STRLEN(line); 	if (buflen < len + MAXWLEN + 2) 	{ 	    vim_free(buf); 	    buflen = len + MAXWLEN + 2; 	    buf = alloc(buflen); 	    if (buf == NULL) 		break; 	}  	// In first line check first word for Capital. 	if (lnum == 1) 	    capcol = 0;  	// For checking first word with a capital skip white space. 	if (capcol == 0) 	    capcol = getwhitecols(line); 	else if (curline && wp == curwin) 	{ 	    // For spellbadword(): check if first word needs a capital. 	    col = getwhitecols(line); 	    if (check_need_cap(lnum, col)) 		capcol = col;  	    // Need to get the line again, may have looked at the previous 	    // one. 	    line = ml_get_buf(wp->w_buffer, lnum, FALSE); 	}  	// Copy the line into ""buf"" and append the start of the next line if 	// possible. 	STRCPY(buf, line); 	if (lnum < wp->w_buffer->b_ml.ml_line_count) 	    spell_cat_line(buf + STRLEN(buf), 			  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);  	p = buf + skip; 	endp = buf + len; 	while (p < endp) 	{ 	    // When searching backward don't search after the cursor.  Unless 	    // we wrapped around the end of the buffer. 	    if (dir == BACKWARD 		    && lnum == wp->w_cursor.lnum 		    && !wrapped 		    && (colnr_T)(p - buf) >= wp->w_cursor.col) 		break;  	    // start of word 	    attr = HLF_COUNT; 	    len = spell_check(wp, p, &attr, &capcol, FALSE);  	    if (attr != HLF_COUNT) 	    { 		// We found a bad word.  Check the attribute. 		if (allwords || attr == HLF_SPB) 		{ 		    // When searching forward only accept a bad word after 		    // the cursor. 		    if (dir == BACKWARD 			    || lnum != wp->w_cursor.lnum 			    || (wrapped 				|| (colnr_T)(curline ? p - buf + len 						     : p - buf) 						  > wp->w_cursor.col)) 		    { #ifdef FEAT_SYN_HL 			if (has_syntax) 			{ 			    col = (int)(p - buf); 			    (void)syn_get_id(wp, lnum, (colnr_T)col, 						    FALSE, &can_spell, FALSE); 			    if (!can_spell) 				attr = HLF_COUNT; 			} 			else #endif 			    can_spell = TRUE;  			if (can_spell) 			{ 			    found_one = TRUE; 			    found_pos.lnum = lnum; 			    found_pos.col = (int)(p - buf); 			    found_pos.coladd = 0; 			    if (dir == FORWARD) 			    { 				// No need to search further. 				wp->w_cursor = found_pos; 				vim_free(buf); 				if (attrp != NULL) 				    *attrp = attr; 				return len; 			    } 			    else if (curline) 				// Insert mode completion: put cursor after 				// the bad word. 				found_pos.col += len; 			    found_len = len; 			} 		    } 		    else 			found_one = TRUE; 		} 	    }  	    // advance to character after the word 	    p += len; 	    capcol -= len; 	}  	if (dir == BACKWARD && found_pos.lnum != 0) 	{ 	    // Use the last match in the line (before the cursor). 	    wp->w_cursor = found_pos; 	    vim_free(buf); 	    return found_len; 	}  	if (curline) 	    break;	// only check cursor line  	// If we are back at the starting line and searched it again there 	// is no match, give up. 	if (lnum == wp->w_cursor.lnum && wrapped) 	    break;  	// Advance to next line. 	if (dir == BACKWARD) 	{ 	    if (lnum > 1) 		--lnum; 	    else if (!p_ws) 		break;	    // at first line and 'nowrapscan' 	    else 	    { 		// Wrap around to the end of the buffer.  May search the 		// starting line again and accept the last match. 		lnum = wp->w_buffer->b_ml.ml_line_count; 		wrapped = TRUE; 		if (!shortmess(SHM_SEARCH)) 		    give_warning((char_u *)_(top_bot_msg), TRUE); 	    } 	    capcol = -1; 	} 	else 	{ 	    if (lnum < wp->w_buffer->b_ml.ml_line_count) 		++lnum; 	    else if (!p_ws) 		break;	    // at first line and 'nowrapscan' 	    else 	    { 		// Wrap around to the start of the buffer.  May search the 		// starting line again and accept the first match. 		lnum = 1; 		wrapped = TRUE; 		if (!shortmess(SHM_SEARCH)) 		    give_warning((char_u *)_(bot_top_msg), TRUE); 	    }  	    // If we are back at the starting line and there is no match then 	    // give up. 	    if (lnum == wp->w_cursor.lnum && !found_one) 		break;  	    // Skip the characters at the start of the next line that were 	    // included in a match crossing line boundaries. 	    if (attr == HLF_COUNT) 		skip = (int)(p - endp); 	    else 		skip = 0;  	    // Capcol skips over the inserted space. 	    --capcol;  	    // But after empty line check first word in next line 	    if (*skipwhite(line) == NUL) 		capcol = 0; 	}  	line_breakcheck();     }      vim_free(buf);     return 0; }"
"199952_CWE-787.cpp","CWE-787","mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module) { 	mp_ubyte insData[230];		 	mp_sint32 smpReloc[MP_MAXINSSAMPS]; 	mp_ubyte nbu[MP_MAXINSSAMPS]; 	mp_uint32 fileSize = 0; 			 	module->cleanUp();  	// this will make code much easier to read 	TXMHeader*		header = &module->header; 	TXMInstrument*	instr  = module->instr; 	TXMSample*		smp	   = module->smp; 	TXMPattern*		phead  = module->phead;	  	// we're already out of memory here 	if (!phead || !instr || !smp) 		return MP_OUT_OF_MEMORY; 	 	fileSize = f.sizeWithBaseOffset(); 	 	f.read(&header->sig,1,17); 	f.read(&header->name,1,20); 	f.read(&header->whythis1a,1,1); 	header->whythis1a=0; 	f.read(&header->tracker,1,20); 	f.readWords(&header->ver,1); 	 	if (header->ver != 0x102 &&  		header->ver != 0x103 && // untested 		header->ver != 0x104) 		return MP_LOADER_FAILED; 	 	f.readDwords(&header->hdrsize,1); 	 	header->hdrsize-=4; 	 	mp_uint32 hdrSize = 0x110; 	if (header->hdrsize > hdrSize) 		hdrSize = header->hdrsize; 				 	mp_ubyte* hdrBuff = new mp_ubyte[hdrSize]; 	memset(hdrBuff, 0, hdrSize); 	 	f.read(hdrBuff, 1, header->hdrsize); 	 	header->ordnum = LittleEndian::GET_WORD(hdrBuff); 	header->restart = LittleEndian::GET_WORD(hdrBuff+2); 	header->channum = LittleEndian::GET_WORD(hdrBuff+4); 	header->patnum = LittleEndian::GET_WORD(hdrBuff+6); 	header->insnum = LittleEndian::GET_WORD(hdrBuff+8); 	header->freqtab = LittleEndian::GET_WORD(hdrBuff+10); 	header->tempo = LittleEndian::GET_WORD(hdrBuff+12); 	header->speed = LittleEndian::GET_WORD(hdrBuff+14); 	memcpy(header->ord, hdrBuff+16, 256); 	if(header->ordnum > MP_MAXORDERS) 		header->ordnum = MP_MAXORDERS; 	if(header->insnum > MP_MAXINS) 		return MP_LOADER_FAILED;  	delete[] hdrBuff; 	 	header->mainvol=255; 	header->flags = XModule::MODULE_XMNOTECLIPPING |  		XModule::MODULE_XMARPEGGIO |  		XModule::MODULE_XMPORTANOTEBUFFER |  		XModule::MODULE_XMVOLCOLUMNVIBRATO;  	header->uppernotebound = 119; 	 	mp_sint32 i,y,sc; 	for (i=0;i<32;i++) header->pan[i]=0x80; 	 	// old version? 	if (header->ver == 0x102 || header->ver == 0x103) 	{ 		mp_sint32 s = 0; 		mp_sint32 e = 0; 		for (y=0;y<header->insnum;y++) { 			 			f.readDwords(&instr[y].size,1); 			f.read(&instr[y].name,1,22);		 			f.read(&instr[y].type,1,1); 			mp_uword numSamples = 0; 			f.readWords(&numSamples,1); 			if(numSamples > MP_MAXINSSAMPS) 				return MP_LOADER_FAILED; 			instr[y].samp = numSamples;  			if (instr[y].size == 29) 			{ #ifdef MILKYTRACKER 				s+=16; #endif 				for (mp_sint32 i = 0; i < 120; i++) 					instr[y].snum[i] = -1; 				continue; 			}  			f.readDwords(&instr[y].shsize,1);  			memset(insData, 0, 230); 			 			if (instr[y].size - 33 > 230) 				return MP_OUT_OF_MEMORY; 			 			f.read(insData, 1, instr[y].size - 33); 						 			if (instr[y].samp) { 				mp_ubyte* insDataPtr = insData; 				 				memcpy(nbu, insDataPtr, MP_MAXINSSAMPS); 				insDataPtr+=MP_MAXINSSAMPS; 				 				TEnvelope venv; 				TEnvelope penv; 				memset(&venv,0,sizeof(venv)); 				memset(&penv,0,sizeof(penv)); 				 				mp_sint32 k; 				for (k = 0; k < XM_ENVELOPENUMPOINTS; k++) 				{ 					venv.env[k][0] = LittleEndian::GET_WORD(insDataPtr); 					venv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2); 					insDataPtr+=4; 				} 				for (k = 0; k < XM_ENVELOPENUMPOINTS; k++) 				{ 					penv.env[k][0] = LittleEndian::GET_WORD(insDataPtr); 					penv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2); 					insDataPtr+=4; 				} 				 				venv.num = *insDataPtr++;	 				if (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS; 				penv.num = *insDataPtr++;	 				if (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS; 				venv.sustain = *insDataPtr++; 				venv.loops = *insDataPtr++; 				venv.loope = *insDataPtr++; 				penv.sustain = *insDataPtr++; 				penv.loops = *insDataPtr++; 				penv.loope = *insDataPtr++; 				venv.type = *insDataPtr++; 				penv.type = *insDataPtr++;				 				 				mp_ubyte vibtype, vibsweep, vibdepth, vibrate; 				mp_uword volfade; 				 				vibtype = *insDataPtr++; 				vibsweep = *insDataPtr++; 				vibdepth = *insDataPtr++; 				vibrate = *insDataPtr++; 				 				vibdepth<<=1; 				 				volfade = LittleEndian::GET_WORD(insDataPtr); 				insDataPtr+=2; 				volfade<<=1; 				 				//instr[y].res = LittleEndian::GET_WORD(insDataPtr); 				insDataPtr+=2; 				 				for (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) { 					venv.env[l][1]<<=2; 					penv.env[l][1]<<=2; 				} 				 				if (!module->addVolumeEnvelope(venv))  					return MP_OUT_OF_MEMORY; 				if (!module->addPanningEnvelope(penv))  					return MP_OUT_OF_MEMORY; 				 				mp_sint32 g=0, sc; 				for (sc=0;sc<instr[y].samp;sc++) { 					 					smp[g+s].flags=3; 					smp[g+s].venvnum=e+1; 					smp[g+s].penvnum=e+1; 					 					smp[g+s].vibtype=vibtype; 					smp[g+s].vibsweep=vibsweep; 					smp[g+s].vibdepth=vibdepth; 					smp[g+s].vibrate=vibrate; 					smp[g+s].volfade=volfade; 					 					// not sure why I did that, actually doesn't make sense 					//if (!(venv.type&1)) smp[g+s].volfade=0; 					 					f.readDwords(&smp[g+s].samplen,1); 					f.readDwords(&smp[g+s].loopstart,1); 					f.readDwords(&smp[g+s].looplen,1); 					smp[g+s].vol=XModule::vol64to255(f.readByte()); 					//f.read(&smp[g+s].vol,1,1); 					f.read(&smp[g+s].finetune,1,1); 					f.read(&smp[g+s].type,1,1); #ifdef VERBOSE 					printf(""Before: %i, After: %i\n"", smp[g+s].type, smp[g+s].type & (3+16)); #endif 					f.read(&smp[g+s].pan,1,1); 					f.read(&smp[g+s].relnote,1,1); 					f.read(&smp[g+s].res,1,1); 					f.read(&smp[g+s].name,1,22); 					 					char line[30]; 					memset(line, 0, sizeof(line)); 					XModule::convertStr(line, smp[g+s].name, 23, false);					 					if (line[0]) 						module->addSongMessageLine(line); 					 					// ignore empty samples #ifndef MILKYTRACKER 					// ignore empty samples when not being a tracker 					if (smp[g+s].samplen) { 						smpReloc[sc] = g; 						g++; 					} 					else 						smpReloc[sc] = -1; #else 					smpReloc[sc] = g; 					g++; #endif 				}  				instr[y].samp = g;  				for (sc = 0; sc < MP_MAXINSSAMPS; sc++) { 					if (smpReloc[nbu[sc]] == -1) 						instr[y].snum[sc] = -1; 					else 						instr[y].snum[sc] = smpReloc[nbu[sc]]+s;					 				}  				e++; 				 			} 			else 			{ 				for (mp_sint32 i = 0; i < 120; i++) 					instr[y].snum[i] = -1; 			}  #ifdef MILKYTRACKER 			s+=16; #else 			s+=instr[y].samp; #endif				 				 			 		} 		 		header->smpnum=s; 		header->volenvnum=e; 		header->panenvnum=e; 	} 	 	for (y=0;y<header->patnum;y++) { 		 		if (header->ver == 0x104 || header->ver == 0x103) 		{ 			f.readDwords(&phead[y].len,1); 			f.read(&phead[y].ptype,1,1); 			f.readWords(&phead[y].rows,1); 			f.readWords(&phead[y].patdata,1); 		} 		else 		{ 			f.readDwords(&phead[y].len,1); 			f.read(&phead[y].ptype,1,1); 			phead[y].rows = (mp_uword)f.readByte()+1; 			f.readWords(&phead[y].patdata,1);			 		} 		 		phead[y].effnum=2; 		phead[y].channum=(mp_ubyte)header->channum; 		 		phead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6]; 		 		// out of memory? 		if (phead[y].patternData == NULL) 		{ 			return MP_OUT_OF_MEMORY; 		} 		 		memset(phead[y].patternData,0,phead[y].rows*header->channum*6); 		 		if (phead[y].patdata) { 			mp_ubyte *buffer = new mp_ubyte[phead[y].patdata]; 			 			// out of memory? 			if (buffer == NULL) 			{ 				return MP_OUT_OF_MEMORY;			 			} 			 			f.read(buffer,1,phead[y].patdata); 			 			//printf(""%i\n"", phead[y].patdata); 			 			mp_sint32 pc = 0, bc = 0; 			for (mp_sint32 r=0;r<phead[y].rows;r++) { 				for (mp_sint32 c=0;c<header->channum;c++) { 					 					mp_ubyte slot[5]; 					memset(slot,0,5); 					 					if ((buffer[pc]&128)) { 						 						mp_ubyte pb = buffer[pc]; 						pc++; 						 						if ((pb&1)) { 							//phead[y].patternData[bc]=buffer[pc]; 							slot[0]=buffer[pc]; 							pc++; 						} 						if ((pb&2)) { 							//phead[y].patternData[bc+1]=buffer[pc]; 							slot[1]=buffer[pc]; 							pc++; 						} 						if ((pb&4)) { 							//phead[y].patternData[bc+2]=buffer[pc]; 							slot[2]=buffer[pc]; 							pc++; 						} 						if ((pb&8)) { 							//phead[y].patternData[bc+3]=buffer[pc]; 							slot[3]=buffer[pc]; 							pc++; 						} 						if ((pb&16)) { 							//phead[y].patternData[bc+4]=buffer[pc]; 							slot[4]=buffer[pc]; 							pc++; 						} 						 					} 					else { 						//memcpy(phead[y].patternData+bc,buffer+pc,5); 						memcpy(slot,buffer+pc,5); 						pc+=5; 					} 					 					char gl=0; 					for (mp_sint32 i=0;i<XModule::numValidXMEffects;i++) 						if (slot[3]==XModule::validXMEffects[i]) gl=1; 					 					if (!gl) slot[3]=slot[4]=0; 					 					if ((slot[3]==0xC)||(slot[3]==0x10)) { 						slot[4] = XModule::vol64to255(slot[4]); 						/*mp_sint32 bl = slot[4]; 						if (bl>64) bl=64; 						slot[4]=(bl*261120)>>16;*/ 					} 					 					if ((!slot[3])&&(slot[4])) slot[3]=0x20; 					 					if (slot[3]==0xE) { 						slot[3]=(slot[4]>>4)+0x30; 						slot[4]=slot[4]&0xf; 					} 					 					if (slot[3]==0x21) { 						slot[3]=(slot[4]>>4)+0x40; 						slot[4]=slot[4]&0xf; 					} 					 					if (slot[0]==97) slot[0]=XModule::NOTE_OFF; 					 					phead[y].patternData[bc]=slot[0]; 					phead[y].patternData[bc+1]=slot[1]; 					 					XModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);  					phead[y].patternData[bc+4]=slot[3]; 					phead[y].patternData[bc+5]=slot[4]; 					 					/*if ((y==3)&&(c==2)) { 						for (mp_sint32 bl=0;bl<6;bl++) cprintf(""%x "",phead[y].patternData[bc+bl]); 					cprintf(""\r\n""); 					getch(); 					};*/ 					 					/*printf(""Note : %i\r\n"",phead[y].patternData[bc]); 					printf(""Ins  : %i\r\n"",phead[y].patternData[bc+1]); 					printf(""Vol  : %i\r\n"",phead[y].patternData[bc+2]); 					printf(""Eff  : %i\r\n"",phead[y].patternData[bc+3]); 					printf(""Effop: %i\r\n"",phead[y].patternData[bc+4]); 					getch();*/ 					 					bc+=6; 				} // for c 					 			} // for r 				 			delete[] buffer; 		} 			 	} 		 	if (header->ver == 0x104) 	{ 		mp_sint32 s = 0; 		mp_sint32 e = 0; 		for (y=0;y<header->insnum;y++) {  			// fixes MOOH.XM loading problems 			// seems to store more instruments in the header than in the actual file 			if (f.posWithBaseOffset() >= fileSize) 				break; 		 			//TXMInstrument* ins = &instr[y]; 		 			f.readDwords(&instr[y].size,1); 			 			if (instr[y].size < 29) 			{ 				mp_ubyte buffer[29]; 				memset(buffer, 0, sizeof(buffer)); 				f.read(buffer, 1, instr[y].size - 4); 				memcpy(instr[y].name, buffer, 22); 				instr[y].type = buffer[22]; 				instr[y].samp = LittleEndian::GET_WORD(buffer + 23); 			} 			else 			{ 				f.read(&instr[y].name,1,22);		 				f.read(&instr[y].type,1,1); 				f.readWords(&instr[y].samp,1); 			} 			if (instr[y].samp > MP_MAXINSSAMPS) 				return MP_LOADER_FAILED;  			//printf(""%i, %i\n"", instr[y].size, instr[y].samp);  			if (instr[y].size <= 29) 			{ #ifdef MILKYTRACKER 				s+=16; #endif 				for (mp_sint32 i = 0; i < 120; i++) 					instr[y].snum[i] = -1; 				continue; 			}  			f.readDwords(&instr[y].shsize,1); #ifdef VERBOSE 			printf(""%i/%i: %i, %i, %i, %s\n"",y,header->insnum-1,instr[y].size,instr[y].shsize,instr[y].samp,instr[y].name);			 #endif 			memset(insData, 0, 230); 			 			if (instr[y].size - 33 > 230) 			{ 				//return -7; 				break; 			} 			 			f.read(insData, 1, instr[y].size - 33); 			 			/*printf(""%i\r\n"",instr[y].size); 			printf(""%s\r\n"",instr[y].name); 			printf(""%i\r\n"",instr[y].type); 			printf(""%i\r\n"",instr[y].samp); 			printf(""%i\r\n"",instr[y].shsize);*/ 			//getch(); 					 			memset(smpReloc, 0, sizeof(smpReloc)); 			 			if (instr[y].samp) { 				mp_ubyte* insDataPtr = insData; 				 				//f.read(&nbu,1,96); 				 				memcpy(nbu, insDataPtr, MP_MAXINSSAMPS); 				insDataPtr+=MP_MAXINSSAMPS; 				 				TEnvelope venv; 				TEnvelope penv; 				memset(&venv,0,sizeof(venv)); 				memset(&penv,0,sizeof(penv)); 				 				mp_sint32 k; 				for (k = 0; k < XM_ENVELOPENUMPOINTS; k++) 				{ 					venv.env[k][0] = LittleEndian::GET_WORD(insDataPtr); 					venv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2); 					insDataPtr+=4; 				} 				for (k = 0; k < XM_ENVELOPENUMPOINTS; k++) 				{ 					penv.env[k][0] = LittleEndian::GET_WORD(insDataPtr); 					penv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2); 					insDataPtr+=4; 				} 				 				venv.num = *insDataPtr++;	 				if (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS; 				penv.num = *insDataPtr++;					 				if (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS; 				venv.sustain = *insDataPtr++; 				venv.loops = *insDataPtr++; 				venv.loope = *insDataPtr++; 				penv.sustain = *insDataPtr++; 				penv.loops = *insDataPtr++; 				penv.loope = *insDataPtr++; 				venv.type = *insDataPtr++; 				penv.type = *insDataPtr++;				 				 				mp_ubyte vibtype, vibsweep, vibdepth, vibrate; 				mp_uword volfade; 				 				vibtype = *insDataPtr++; 				vibsweep = *insDataPtr++; 				vibdepth = *insDataPtr++; 				vibrate = *insDataPtr++; 				 				vibdepth<<=1; 				 				//f.readWords(&volfade,1); 				volfade = LittleEndian::GET_WORD(insDataPtr); 				insDataPtr+=2; 				volfade<<=1; 				 				//instr[y].res = LittleEndian::GET_WORD(insDataPtr); 				insDataPtr+=2; 				 				for (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) { 					venv.env[l][1]<<=2; 					penv.env[l][1]<<=2; 				} 				 				if (!module->addVolumeEnvelope(venv))  					return MP_OUT_OF_MEMORY; 				if (!module->addPanningEnvelope(penv))  					return MP_OUT_OF_MEMORY; 				 				mp_sint32 g=0, sc; 				for (sc=0;sc<instr[y].samp;sc++) { 					//TXMSample* smpl = &smp[g+s]; 					 					smp[g+s].flags=3; 					smp[g+s].venvnum=e+1; 					smp[g+s].penvnum=e+1; 					 					smp[g+s].vibtype=vibtype; 					smp[g+s].vibsweep=vibsweep; 					smp[g+s].vibdepth=vibdepth; 					smp[g+s].vibrate=vibrate; 					smp[g+s].volfade=volfade; 					 					// not sure why I did that, actually doesn't make sense 					//if (!(venv.type&1)) smp[g+s].volfade=0; 					 					f.readDwords(&smp[g+s].samplen,1); 					 					f.readDwords(&smp[g+s].loopstart,1); 					f.readDwords(&smp[g+s].looplen,1); 					smp[g+s].vol=XModule::vol64to255(f.readByte()); 					//f.read(&smp[g+s].vol,1,1); 					f.read(&smp[g+s].finetune,1,1); 					f.read(&smp[g+s].type,1,1); #ifdef VERBOSE 					printf(""Before: %i, After: %i\n"", smp[g+s].type, smp[g+s].type & (3+16)); #endif 					f.read(&smp[g+s].pan,1,1); 					f.read(&smp[g+s].relnote,1,1); 					f.read(&smp[g+s].res,1,1); 					f.read(&smp[g+s].name,1,22);  					char line[30]; 					memset(line, 0, sizeof(line)); 					XModule::convertStr(line, smp[g+s].name, 23, false);					 					if (line[0]) 						module->addSongMessageLine(line); 					 #ifndef MILKYTRACKER 					// ignore empty samples when not being a tracker 					if (smp[g+s].samplen) { 						smpReloc[sc] = g; 						g++; 					} 					else 						smpReloc[sc] = -1; #else 					smpReloc[sc] = g; 					g++; #endif 				}  				instr[y].samp = g;  				for (sc = 0; sc < MP_MAXINSSAMPS; sc++) {					 					if (smpReloc[nbu[sc]] == -1) 						instr[y].snum[sc] = -1; 					else 						instr[y].snum[sc] = smpReloc[nbu[sc]]+s; 				} 						 				for (sc=0;sc<instr[y].samp;sc++) { 				 					if (smp[s].samplen) 					{ 						bool adpcm = (smp[s].res == 0xAD); 					 						mp_uint32 oldSize = smp[s].samplen; 						if (smp[s].type&16)  						{ 							smp[s].samplen>>=1; 							smp[s].loopstart>>=1; 							smp[s].looplen>>=1; 						} 						 						mp_sint32 result = module->loadModuleSample(f, s,  													 adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_DELTA,  													 adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT),  													 oldSize); 						if (result != MP_OK) 							return result;					 						 						if (adpcm) 							smp[s].res = 0; 					} 					 					s++; 					 					if (s>=MP_MAXSAMPLES) 						return MP_OUT_OF_MEMORY; 					 				}  				e++; 				 			} 			else 			{ 				for (mp_sint32 i = 0; i < 120; i++) 					instr[y].snum[i] = -1; 			}  #ifdef MILKYTRACKER 			s+=16 - instr[y].samp; #endif				 			 		} 		 		header->smpnum=s; 		header->volenvnum=e; 		header->panenvnum=e;		 		 	} 	else 	{ 		mp_sint32 s = 0; 		for (y=0;y<header->insnum;y++) { 			for (sc=0;sc<instr[y].samp;sc++) {  				if (smp[s].samplen) 				{ 					mp_uint32 oldSize = smp[s].samplen; 					if (smp[s].type&16)  					{ 						smp[s].samplen>>=1; 						smp[s].loopstart>>=1; 						smp[s].looplen>>=1; 					} 					 					mp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize); 					if (result != MP_OK) 						return result;					 				} 				 				s++; 				 				if (s>=MP_MAXSAMPLES) 					return MP_OUT_OF_MEMORY;				 			} 			 #ifdef MILKYTRACKER 			s+=16 - instr[y].samp; #endif 			 		}		 	} 	 	// convert modplug stereo samples 	for (mp_sint32 s = 0; s < header->smpnum; s++) 	{ 		if (smp[s].type & 32) 		{		 			// that's what's allowed, stupid modplug tracker 			smp[s].type &= 3+16;					  			if (smp[s].sample == NULL) 				continue; 			 			if (!(smp[s].type&16)) {			 				smp[s].samplen>>=1; 				smp[s].loopstart>>=1; 				smp[s].looplen>>=1; 				 				mp_sbyte* sample = (mp_sbyte*)smp[s].sample; 				mp_sint32 samplen = smp[s].samplen; 				for (mp_sint32 i = 0; i < samplen; i++) 				{ 					mp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1; 					if (s < -128) s = -128; 					if (s > 127) s = 127; 					sample[i] = (mp_sbyte)s; 				} 			} 			else 			{ 				smp[s].samplen>>=1; 				smp[s].loopstart>>=1; 				smp[s].looplen>>=1; 				 				mp_sword* sample = (mp_sword*)smp[s].sample; 				mp_sint32 samplen = smp[s].samplen; 				for (mp_sint32 i = 0; i < samplen; i++) 				{ 					mp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1; 					if (s < -32768) s = -32768; 					if (s > 32767) s = 32767; 					sample[i] = (mp_sword)s; 				} 			} 		} 		 		// correct loop type 0x03 (undefined) 		// will become ping pong loop 		// note that FT2 will refuse to load XM files with such a loop type 		if ((smp[s].type & 0x3) == 0x3) 			smp[s].type&=~1;		 	}  	// correct number of patterns if necessary, otherwise the post processing will remove 	// the ""invalid"" patterns from the order list 	bool addPatterns = false; 	for (i = 0; i < header->ordnum; i++) 		if (header->ord[i]+1 > header->patnum) 		{ 			header->patnum = header->ord[i]+1;	 			addPatterns = true; 		} 	 	// if the pattern number has been adjusted, add some empty patterns 	if (addPatterns) 	{ 		for (i = 0; i < header->patnum; i++) 			if (phead[i].patternData == NULL) 			{ 				phead[i].rows = 64; 				phead[i].effnum = 2; 				phead[i].channum = (mp_ubyte)header->channum;  				phead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6]; 			 				// out of memory? 				if (phead[i].patternData == NULL) 				{ 					return MP_OUT_OF_MEMORY; 				} 		 				memset(phead[i].patternData,0,phead[i].rows*header->channum*6); 			} 	} 	 	// check for MODPLUG extensions 	if (f.posWithBaseOffset() + 8 <= fileSize) 	{ 		char buffer[4]; 		f.read(buffer, 1, 4); 		if (memcmp(buffer, ""text"", 4) == 0) 		{ 			mp_uint32 len = f.readDword(); 			module->allocateSongMessage(len+1); 			 			memset(module->message, 0, len+1); 			 			f.read(module->message, 1, len); 		} 	} 	 	module->postProcessSamples(); 	 	return MP_OK; }"
"199984_CWE-416.c","CWE-416","ex_substitute(exarg_T *eap) {     linenr_T	lnum;     long	i = 0;     regmmatch_T regmatch;     static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE, 							      FALSE, FALSE, 0}; #ifdef FEAT_EVAL     subflags_T	subflags_save; #endif     int		save_do_all;		// remember user specified 'g' flag     int		save_do_ask;		// remember user specified 'c' flag     char_u	*pat = NULL, *sub = NULL;	// init for GCC     int		delimiter;     int		sublen;     int		got_quit = FALSE;     int		got_match = FALSE;     int		temp;     int		which_pat;     char_u	*cmd;     int		save_State;     linenr_T	first_line = 0;		// first changed line     linenr_T	last_line= 0;		// below last changed line AFTER the 					// change     linenr_T	old_line_count = curbuf->b_ml.ml_line_count;     linenr_T	line2;     long	nmatch;			// number of lines in match     char_u	*sub_firstline;		// allocated copy of first sub line     int		endcolumn = FALSE;	// cursor in last column when done     pos_T	old_cursor = curwin->w_cursor;     int		start_nsubs; #ifdef FEAT_EVAL     int		save_ma = 0; #endif      cmd = eap->arg;     if (!global_busy)     { 	sub_nsubs = 0; 	sub_nlines = 0;     }     start_nsubs = sub_nsubs;      if (eap->cmdidx == CMD_tilde) 	which_pat = RE_LAST;	// use last used regexp     else 	which_pat = RE_SUBST;	// use last substitute regexp  				// new pattern and substitution     if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd) 		&& vim_strchr((char_u *)""0123456789cegriIp|\"""", *cmd) == NULL)     { 				// don't accept alphanumeric for separator 	if (check_regexp_delim(*cmd) == FAIL) 	    return; #ifdef FEAT_EVAL 	if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) 								      == FAIL) 	    return; #endif  	/* 	 * undocumented vi feature: 	 *  ""\/sub/"" and ""\?sub?"" use last used search pattern (almost like 	 *  //sub/r).  ""\&sub&"" use last substitute pattern (like //sub/). 	 */ 	if (*cmd == '\\') 	{ 	    ++cmd; 	    if (vim_strchr((char_u *)""/?&"", *cmd) == NULL) 	    { 		emsg(_(e_backslash_should_be_followed_by)); 		return; 	    } 	    if (*cmd != '&') 		which_pat = RE_SEARCH;	    // use last '/' pattern 	    pat = (char_u *)"""";		    // empty search pattern 	    delimiter = *cmd++;		    // remember delimiter character 	} 	else		// find the end of the regexp 	{ 	    which_pat = RE_LAST;	    // use last used regexp 	    delimiter = *cmd++;		    // remember delimiter character 	    pat = cmd;			    // remember start of search pat 	    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(), 							&eap->arg, NULL, NULL); 	    if (cmd[0] == delimiter)	    // end delimiter found 		*cmd++ = NUL;		    // replace it with a NUL 	}  	/* 	 * Small incompatibility: vi sees '\n' as end of the command, but in 	 * Vim we want to use '\n' to find/substitute a NUL. 	 */ 	sub = cmd;	    // remember the start of the substitution 	cmd = skip_substitute(cmd, delimiter);  	if (!eap->skip) 	{ 	    // In POSIX vi "":s/pat/%/"" uses the previous subst. string. 	    if (STRCMP(sub, ""%"") == 0 				 && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL) 	    { 		if (old_sub == NULL)	// there is no previous command 		{ 		    emsg(_(e_no_previous_substitute_regular_expression)); 		    return; 		} 		sub = old_sub; 	    } 	    else 	    { 		vim_free(old_sub); 		old_sub = vim_strsave(sub); 	    } 	}     }     else if (!eap->skip)	// use previous pattern and substitution     { 	if (old_sub == NULL)	// there is no previous command 	{ 	    emsg(_(e_no_previous_substitute_regular_expression)); 	    return; 	} 	pat = NULL;		// search_regcomp() will use previous pattern 	sub = old_sub;  	// Vi compatibility quirk: repeating with "":s"" keeps the cursor in the 	// last column after using ""$"". 	endcolumn = (curwin->w_curswant == MAXCOL);     }      // Recognize "":%s/\n//"" and turn it into a join command, which is much     // more efficient.     // TODO: find a generic solution to make line-joining operations more     // efficient, avoid allocating a string that grows in size.     if (pat != NULL && STRCMP(pat, ""\\n"") == 0 	    && *sub == NUL 	    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l' 					     || *cmd == 'p' || *cmd == '#'))))     { 	linenr_T    joined_lines_count;  	if (eap->skip) 	    return; 	curwin->w_cursor.lnum = eap->line1; 	if (*cmd == 'l') 	    eap->flags = EXFLAG_LIST; 	else if (*cmd == '#') 	    eap->flags = EXFLAG_NR; 	else if (*cmd == 'p') 	    eap->flags = EXFLAG_PRINT;  	// The number of lines joined is the number of lines in the range plus 	// one.  One less when the last line is included. 	joined_lines_count = eap->line2 - eap->line1 + 1; 	if (eap->line2 < curbuf->b_ml.ml_line_count) 	    ++joined_lines_count; 	if (joined_lines_count > 1) 	{ 	    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE); 	    sub_nsubs = joined_lines_count - 1; 	    sub_nlines = 1; 	    (void)do_sub_msg(FALSE); 	    ex_may_print(eap); 	}  	if ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0) 	    save_re_pat(RE_SUBST, pat, magic_isset()); 	// put pattern in history 	add_to_history(HIST_SEARCH, pat, TRUE, NUL);  	return;     }      /*      * Find trailing options.  When '&' is used, keep old options.      */     if (*cmd == '&') 	++cmd;     else     { #ifdef FEAT_EVAL 	if (in_vim9script()) 	{ 	    // ignore 'gdefault' and 'edcompatible' 	    subflags.do_all = FALSE; 	    subflags.do_ask = FALSE; 	} 	else #endif 	if (!p_ed) 	{ 	    if (p_gd)		// default is global on 		subflags.do_all = TRUE; 	    else 		subflags.do_all = FALSE; 	    subflags.do_ask = FALSE; 	} 	subflags.do_error = TRUE; 	subflags.do_print = FALSE; 	subflags.do_list = FALSE; 	subflags.do_count = FALSE; 	subflags.do_number = FALSE; 	subflags.do_ic = 0;     }     while (*cmd)     { 	/* 	 * Note that 'g' and 'c' are always inverted, also when p_ed is off. 	 * 'r' is never inverted. 	 */ 	if (*cmd == 'g') 	    subflags.do_all = !subflags.do_all; 	else if (*cmd == 'c') 	    subflags.do_ask = !subflags.do_ask; 	else if (*cmd == 'n') 	    subflags.do_count = TRUE; 	else if (*cmd == 'e') 	    subflags.do_error = !subflags.do_error; 	else if (*cmd == 'r')	    // use last used regexp 	    which_pat = RE_LAST; 	else if (*cmd == 'p') 	    subflags.do_print = TRUE; 	else if (*cmd == '#') 	{ 	    subflags.do_print = TRUE; 	    subflags.do_number = TRUE; 	} 	else if (*cmd == 'l') 	{ 	    subflags.do_print = TRUE; 	    subflags.do_list = TRUE; 	} 	else if (*cmd == 'i')	    // ignore case 	    subflags.do_ic = 'i'; 	else if (*cmd == 'I')	    // don't ignore case 	    subflags.do_ic = 'I'; 	else 	    break; 	++cmd;     }     if (subflags.do_count) 	subflags.do_ask = FALSE;      save_do_all = subflags.do_all;     save_do_ask = subflags.do_ask;      /*      * check for a trailing count      */     cmd = skipwhite(cmd);     if (VIM_ISDIGIT(*cmd))     { 	i = getdigits(&cmd); 	if (i <= 0 && !eap->skip && subflags.do_error) 	{ 	    emsg(_(e_positive_count_required)); 	    return; 	} 	eap->line1 = eap->line2; 	eap->line2 += i - 1; 	if (eap->line2 > curbuf->b_ml.ml_line_count) 	    eap->line2 = curbuf->b_ml.ml_line_count;     }      /*      * check for trailing command or garbage      */     cmd = skipwhite(cmd);     if (*cmd && *cmd != '""')	    // if not end-of-line or comment     { 	set_nextcmd(eap, cmd); 	if (eap->nextcmd == NULL) 	{ 	    semsg(_(e_trailing_characters_str), cmd); 	    return; 	}     }      if (eap->skip)	    // not executing commands, only parsing 	return;      if (!subflags.do_count && !curbuf->b_p_ma)     { 	// Substitution is not allowed in non-'modifiable' buffer 	emsg(_(e_cannot_make_changes_modifiable_is_off)); 	return;     }      if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)     { 	if (subflags.do_error) 	    emsg(_(e_invalid_command)); 	return;     }      // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'     if (subflags.do_ic == 'i') 	regmatch.rmm_ic = TRUE;     else if (subflags.do_ic == 'I') 	regmatch.rmm_ic = FALSE;      sub_firstline = NULL;      /*      * ~ in the substitute pattern is replaced with the old pattern.      * We do it here once to avoid it to be replaced over and over again.      * But don't do it when it starts with ""\="", then it's an expression.      */     if (!(sub[0] == '\\' && sub[1] == '=')) 	sub = regtilde(sub, magic_isset());      /*      * Check for a match on each line.      */     line2 = eap->line2;     for (lnum = eap->line1; lnum <= line2 && !(got_quit #if defined(FEAT_EVAL) 		|| aborting() #endif 		); ++lnum)     { 	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum, 						       (colnr_T)0, NULL, NULL); 	if (nmatch) 	{ 	    colnr_T	copycol; 	    colnr_T	matchcol; 	    colnr_T	prev_matchcol = MAXCOL; 	    char_u	*new_end, *new_start = NULL; 	    unsigned	new_start_len = 0; 	    char_u	*p1; 	    int		did_sub = FALSE; 	    int		lastone; 	    int		len, copy_len, needed_len; 	    long	nmatch_tl = 0;	// nr of lines matched below lnum 	    int		do_again;	// do it again after joining lines 	    int		skip_match = FALSE; 	    linenr_T	sub_firstlnum;	// nr of first sub line #ifdef FEAT_PROP_POPUP 	    int		apc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE; 	    colnr_T	total_added =  0; #endif  	    /* 	     * The new text is build up step by step, to avoid too much 	     * copying.  There are these pieces: 	     * sub_firstline	The old text, unmodified. 	     * copycol		Column in the old text where we started 	     *			looking for a match; from here old text still 	     *			needs to be copied to the new text. 	     * matchcol		Column number of the old text where to look 	     *			for the next match.  It's just after the 	     *			previous match or one further. 	     * prev_matchcol	Column just after the previous match (if any). 	     *			Mostly equal to matchcol, except for the first 	     *			match and after skipping an empty match. 	     * regmatch.*pos	Where the pattern matched in the old text. 	     * new_start	The new text, all that has been produced so 	     *			far. 	     * new_end		The new text, where to append new text. 	     * 	     * lnum		The line number where we found the start of 	     *			the match.  Can be below the line we searched 	     *			when there is a \n before a \zs in the 	     *			pattern. 	     * sub_firstlnum	The line number in the buffer where to look 	     *			for a match.  Can be different from ""lnum"" 	     *			when the pattern or substitute string contains 	     *			line breaks. 	     * 	     * Special situations: 	     * - When the substitute string contains a line break, the part up 	     *   to the line break is inserted in the text, but the copy of 	     *   the original line is kept.  ""sub_firstlnum"" is adjusted for 	     *   the inserted lines. 	     * - When the matched pattern contains a line break, the old line 	     *   is taken from the line at the end of the pattern.  The lines 	     *   in the match are deleted later, ""sub_firstlnum"" is adjusted 	     *   accordingly. 	     * 	     * The new text is built up in new_start[].  It has some extra 	     * room to avoid using alloc()/free() too often.  new_start_len is 	     * the length of the allocated memory at new_start. 	     * 	     * Make a copy of the old line, so it won't be taken away when 	     * updating the screen or handling a multi-line match.  The ""old_"" 	     * pointers point into this copy. 	     */ 	    sub_firstlnum = lnum; 	    copycol = 0; 	    matchcol = 0;  	    // At first match, remember current cursor position. 	    if (!got_match) 	    { 		setpcmark(); 		got_match = TRUE; 	    }  	    /* 	     * Loop until nothing more to replace in this line. 	     * 1. Handle match with empty string. 	     * 2. If do_ask is set, ask for confirmation. 	     * 3. substitute the string. 	     * 4. if do_all is set, find next match 	     * 5. break if there isn't another match in this line 	     */ 	    for (;;) 	    { 		// Advance ""lnum"" to the line where the match starts.  The 		// match does not start in the first line when there is a line 		// break before \zs. 		if (regmatch.startpos[0].lnum > 0) 		{ 		    lnum += regmatch.startpos[0].lnum; 		    sub_firstlnum += regmatch.startpos[0].lnum; 		    nmatch -= regmatch.startpos[0].lnum; 		    VIM_CLEAR(sub_firstline); 		}  		// Match might be after the last line for ""\n\zs"" matching at 		// the end of the last line. 		if (lnum > curbuf->b_ml.ml_line_count) 		    break;  		if (sub_firstline == NULL) 		{ 		    sub_firstline = vim_strsave(ml_get(sub_firstlnum)); 		    if (sub_firstline == NULL) 		    { 			vim_free(new_start); 			goto outofmem; 		    } 		}  		// Save the line number of the last change for the final 		// cursor position (just like Vi). 		curwin->w_cursor.lnum = lnum; 		do_again = FALSE;  		/* 		 * 1. Match empty string does not count, except for first 		 * match.  This reproduces the strange vi behaviour. 		 * This also catches endless loops. 		 */ 		if (matchcol == prev_matchcol 			&& regmatch.endpos[0].lnum == 0 			&& matchcol == regmatch.endpos[0].col) 		{ 		    if (sub_firstline[matchcol] == NUL) 			// We already were at the end of the line.  Don't look 			// for a match in this line again. 			skip_match = TRUE; 		    else 		    { 			 // search for a match at next column 			if (has_mbyte) 			    matchcol += mb_ptr2len(sub_firstline + matchcol); 			else 			    ++matchcol; 		    } 		    goto skip; 		}  		// Normally we continue searching for a match just after the 		// previous match. 		matchcol = regmatch.endpos[0].col; 		prev_matchcol = matchcol;  		/* 		 * 2. If do_count is set only increase the counter. 		 *    If do_ask is set, ask for confirmation. 		 */ 		if (subflags.do_count) 		{ 		    // For a multi-line match, put matchcol at the NUL at 		    // the end of the line and set nmatch to one, so that 		    // we continue looking for a match on the next line. 		    // Avoids that "":s/\nB\@=//gc"" get stuck. 		    if (nmatch > 1) 		    { 			matchcol = (colnr_T)STRLEN(sub_firstline); 			nmatch = 1; 			skip_match = TRUE; 		    } 		    sub_nsubs++; 		    did_sub = TRUE; #ifdef FEAT_EVAL 		    // Skip the substitution, unless an expression is used, 		    // then it is evaluated in the sandbox. 		    if (!(sub[0] == '\\' && sub[1] == '=')) #endif 			goto skip; 		}  		if (subflags.do_ask) 		{ 		    int typed = 0;  		    // change State to CONFIRM, so that the mouse works 		    // properly 		    save_State = State; 		    State = CONFIRM; 		    setmouse();		// disable mouse in xterm 		    curwin->w_cursor.col = regmatch.startpos[0].col; 		    if (curwin->w_p_crb) 			do_check_cursorbind();  		    // When 'cpoptions' contains ""u"" don't sync undo when 		    // asking for confirmation. 		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL) 			++no_u_sync;  		    /* 		     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed. 		     */ 		    while (subflags.do_ask) 		    { 			if (exmode_active) 			{ 			    char_u	*resp; 			    colnr_T	sc, ec;  			    print_line_no_prefix(lnum, 					 subflags.do_number, subflags.do_list);  			    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL); 			    curwin->w_cursor.col = regmatch.endpos[0].col - 1; 			    if (curwin->w_cursor.col < 0) 				curwin->w_cursor.col = 0; 			    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec); 			    curwin->w_cursor.col = regmatch.startpos[0].col; 			    if (subflags.do_number || curwin->w_p_nu) 			    { 				int numw = number_width(curwin) + 1; 				sc += numw; 				ec += numw; 			    } 			    msg_start(); 			    for (i = 0; i < (long)sc; ++i) 				msg_putchar(' '); 			    for ( ; i <= (long)ec; ++i) 				msg_putchar('^');  			    resp = getexmodeline('?', NULL, 0, TRUE); 			    if (resp != NULL) 			    { 				typed = *resp; 				vim_free(resp); 			    } 			} 			else 			{ 			    char_u *orig_line = NULL; 			    int    len_change = 0; 			    int	   save_p_lz = p_lz; #ifdef FEAT_FOLDING 			    int save_p_fen = curwin->w_p_fen;  			    curwin->w_p_fen = FALSE; #endif 			    // Invert the matched string. 			    // Remove the inversion afterwards. 			    temp = RedrawingDisabled; 			    RedrawingDisabled = 0;  			    // avoid calling update_screen() in vgetorpeek() 			    p_lz = FALSE;  			    if (new_start != NULL) 			    { 				// There already was a substitution, we would 				// like to show this to the user.  We cannot 				// really update the line, it would change 				// what matches.  Temporarily replace the line 				// and change it back afterwards. 				orig_line = vim_strsave(ml_get(lnum)); 				if (orig_line != NULL) 				{ 				    char_u *new_line = concat_str(new_start, 						     sub_firstline + copycol);  				    if (new_line == NULL) 					VIM_CLEAR(orig_line); 				    else 				    { 					// Position the cursor relative to the 					// end of the line, the previous 					// substitute may have inserted or 					// deleted characters before the 					// cursor. 					len_change = (int)STRLEN(new_line) 						     - (int)STRLEN(orig_line); 					curwin->w_cursor.col += len_change; 					ml_replace(lnum, new_line, FALSE); 				    } 				} 			    }  			    search_match_lines = regmatch.endpos[0].lnum 						  - regmatch.startpos[0].lnum; 			    search_match_endcol = regmatch.endpos[0].col 								 + len_change; 			    highlight_match = TRUE;  			    update_topline(); 			    validate_cursor(); 			    update_screen(SOME_VALID); 			    highlight_match = FALSE; 			    redraw_later(SOME_VALID);  #ifdef FEAT_FOLDING 			    curwin->w_p_fen = save_p_fen; #endif 			    if (msg_row == Rows - 1) 				msg_didout = FALSE;	// avoid a scroll-up 			    msg_starthere(); 			    i = msg_scroll; 			    msg_scroll = 0;		// truncate msg when 							// needed 			    msg_no_more = TRUE; 			    // write message same highlighting as for 			    // wait_return 			    smsg_attr(HL_ATTR(HLF_R), 				_(""replace with %s (y/n/a/q/l/^E/^Y)?""), sub); 			    msg_no_more = FALSE; 			    msg_scroll = i; 			    showruler(TRUE); 			    windgoto(msg_row, msg_col); 			    RedrawingDisabled = temp;  #ifdef USE_ON_FLY_SCROLL 			    dont_scroll = FALSE; // allow scrolling here #endif 			    ++no_mapping;	// don't map this key 			    ++allow_keys;	// allow special keys 			    typed = plain_vgetc(); 			    --allow_keys; 			    --no_mapping;  			    // clear the question 			    msg_didout = FALSE;	// don't scroll up 			    msg_col = 0; 			    gotocmdline(TRUE); 			    p_lz = save_p_lz;  			    // restore the line 			    if (orig_line != NULL) 				ml_replace(lnum, orig_line, FALSE); 			}  			need_wait_return = FALSE; // no hit-return prompt 			if (typed == 'q' || typed == ESC || typed == Ctrl_C #ifdef UNIX 				|| typed == intr_char #endif 				) 			{ 			    got_quit = TRUE; 			    break; 			} 			if (typed == 'n') 			    break; 			if (typed == 'y') 			    break; 			if (typed == 'l') 			{ 			    // last: replace and then stop 			    subflags.do_all = FALSE; 			    line2 = lnum; 			    break; 			} 			if (typed == 'a') 			{ 			    subflags.do_ask = FALSE; 			    break; 			} 			if (typed == Ctrl_E) 			    scrollup_clamp(); 			else if (typed == Ctrl_Y) 			    scrolldown_clamp(); 		    } 		    State = save_State; 		    setmouse(); 		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL) 			--no_u_sync;  		    if (typed == 'n') 		    { 			// For a multi-line match, put matchcol at the NUL at 			// the end of the line and set nmatch to one, so that 			// we continue looking for a match on the next line. 			// Avoids that "":%s/\nB\@=//gc"" and "":%s/\n/,\r/gc"" 			// get stuck when pressing 'n'. 			if (nmatch > 1) 			{ 			    matchcol = (colnr_T)STRLEN(sub_firstline); 			    skip_match = TRUE; 			} 			goto skip; 		    } 		    if (got_quit) 			goto skip; 		}  		// Move the cursor to the start of the match, so that we can 		// use ""\=col("".""). 		curwin->w_cursor.col = regmatch.startpos[0].col;  		/* 		 * 3. substitute the string. 		 */ #ifdef FEAT_EVAL 		save_ma = curbuf->b_p_ma; 		if (subflags.do_count) 		{ 		    // prevent accidentally changing the buffer by a function 		    curbuf->b_p_ma = FALSE; 		    sandbox++; 		} 		// Save flags for recursion.  They can change for e.g. 		// :s/^/\=execute(""s#^##gn"") 		subflags_save = subflags; #endif 		// get length of substitution part 		sublen = vim_regsub_multi(&regmatch, 				    sub_firstlnum - regmatch.startpos[0].lnum, 			       sub, sub_firstline, FALSE, magic_isset(), TRUE); #ifdef FEAT_EVAL 		// If getting the substitute string caused an error, don't do 		// the replacement. 		// Don't keep flags set by a recursive call. 		subflags = subflags_save; 		if (aborting() || subflags.do_count) 		{ 		    curbuf->b_p_ma = save_ma; 		    if (sandbox > 0) 			sandbox--; 		    goto skip; 		} #endif  		// When the match included the ""$"" of the last line it may 		// go beyond the last line of the buffer. 		if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1) 		{ 		    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1; 		    skip_match = TRUE; 		}  		// Need room for: 		// - result so far in new_start (not for first sub in line) 		// - original text up to match 		// - length of substituted part 		// - original text after match 		// Adjust text properties here, since we have all information 		// needed. 		if (nmatch == 1) 		{ 		    p1 = sub_firstline; #ifdef FEAT_PROP_POPUP 		    if (curbuf->b_has_textprop) 		    { 			int bytes_added = sublen - 1 - (regmatch.endpos[0].col 						   - regmatch.startpos[0].col);  			// When text properties are changed, need to save for 			// undo first, unless done already. 			if (adjust_prop_columns(lnum, 					total_added + regmatch.startpos[0].col, 						       bytes_added, apc_flags)) 			    apc_flags &= ~APC_SAVE_FOR_UNDO; 			// Offset for column byte number of the text property 			// in the resulting buffer afterwards. 			total_added += bytes_added; 		    } #endif 		} 		else 		{ 		    p1 = ml_get(sub_firstlnum + nmatch - 1); 		    nmatch_tl += nmatch - 1; 		} 		copy_len = regmatch.startpos[0].col - copycol; 		needed_len = copy_len + ((unsigned)STRLEN(p1) 				       - regmatch.endpos[0].col) + sublen + 1; 		if (new_start == NULL) 		{ 		    /* 		     * Get some space for a temporary buffer to do the 		     * substitution into (and some extra space to avoid 		     * too many calls to alloc()/free()). 		     */ 		    new_start_len = needed_len + 50; 		    if ((new_start = alloc(new_start_len)) == NULL) 			goto outofmem; 		    *new_start = NUL; 		    new_end = new_start; 		} 		else 		{ 		    /* 		     * Check if the temporary buffer is long enough to do the 		     * substitution into.  If not, make it larger (with a bit 		     * extra to avoid too many calls to alloc()/free()). 		     */ 		    len = (unsigned)STRLEN(new_start); 		    needed_len += len; 		    if (needed_len > (int)new_start_len) 		    { 			new_start_len = needed_len + 50; 			if ((p1 = alloc(new_start_len)) == NULL) 			{ 			    vim_free(new_start); 			    goto outofmem; 			} 			mch_memmove(p1, new_start, (size_t)(len + 1)); 			vim_free(new_start); 			new_start = p1; 		    } 		    new_end = new_start + len; 		}  		/* 		 * copy the text up to the part that matched 		 */ 		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len); 		new_end += copy_len;  		(void)vim_regsub_multi(&regmatch, 				    sub_firstlnum - regmatch.startpos[0].lnum, 				      sub, new_end, TRUE, magic_isset(), TRUE); 		sub_nsubs++; 		did_sub = TRUE;  		// Move the cursor to the start of the line, to avoid that it 		// is beyond the end of the line after the substitution. 		curwin->w_cursor.col = 0;  		// For a multi-line match, make a copy of the last matched 		// line and continue in that one. 		if (nmatch > 1) 		{ 		    sub_firstlnum += nmatch - 1; 		    vim_free(sub_firstline); 		    sub_firstline = vim_strsave(ml_get(sub_firstlnum)); 		    // When going beyond the last line, stop substituting. 		    if (sub_firstlnum <= line2) 			do_again = TRUE; 		    else 			subflags.do_all = FALSE; 		}  		// Remember next character to be copied. 		copycol = regmatch.endpos[0].col;  		if (skip_match) 		{ 		    // Already hit end of the buffer, sub_firstlnum is one 		    // less than what it ought to be. 		    vim_free(sub_firstline); 		    sub_firstline = vim_strsave((char_u *)""""); 		    copycol = 0; 		}  		/* 		 * Now the trick is to replace CTRL-M chars with a real line 		 * break.  This would make it impossible to insert a CTRL-M in 		 * the text.  The line break can be avoided by preceding the 		 * CTRL-M with a backslash.  To be able to insert a backslash, 		 * they must be doubled in the string and are halved here. 		 * That is Vi compatible. 		 */ 		for (p1 = new_end; *p1; ++p1) 		{ 		    if (p1[0] == '\\' && p1[1] != NUL)  // remove backslash 		    { 			STRMOVE(p1, p1 + 1); #ifdef FEAT_PROP_POPUP 			if (curbuf->b_has_textprop) 			{ 			    // When text properties are changed, need to save 			    // for undo first, unless done already. 			    if (adjust_prop_columns(lnum, 					(colnr_T)(p1 - new_start), -1, 					apc_flags)) 				apc_flags &= ~APC_SAVE_FOR_UNDO; 			} #endif 		    } 		    else if (*p1 == CAR) 		    { 			if (u_inssub(lnum) == OK)   // prepare for undo 			{ 			    colnr_T	plen = (colnr_T)(p1 - new_start + 1);  			    *p1 = NUL;		    // truncate up to the CR 			    ml_append(lnum - 1, new_start, plen, FALSE); 			    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L); 			    if (subflags.do_ask) 				appended_lines(lnum - 1, 1L); 			    else 			    { 				if (first_line == 0) 				    first_line = lnum; 				last_line = lnum + 1; 			    } #ifdef FEAT_PROP_POPUP 			    adjust_props_for_split(lnum + 1, lnum, plen, 1); #endif 			    // all line numbers increase 			    ++sub_firstlnum; 			    ++lnum; 			    ++line2; 			    // move the cursor to the new line, like Vi 			    ++curwin->w_cursor.lnum; 			    // copy the rest 			    STRMOVE(new_start, p1 + 1); 			    p1 = new_start - 1; 			} 		    } 		    else if (has_mbyte) 			p1 += (*mb_ptr2len)(p1) - 1; 		}  		/* 		 * 4. If do_all is set, find next match. 		 * Prevent endless loop with patterns that match empty 		 * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g. 		 * But "":s/\n/#/"" is OK. 		 */ skip: 		// We already know that we did the last subst when we are at 		// the end of the line, except that a pattern like 		// ""bar\|\nfoo"" may match at the NUL.  ""lnum"" can be below 		// ""line2"" when there is a \zs in the pattern after a line 		// break. 		lastone = (skip_match 			|| got_int 			|| got_quit 			|| lnum > line2 			|| !(subflags.do_all || do_again) 			|| (sub_firstline[matchcol] == NUL && nmatch <= 1 					 && !re_multiline(regmatch.regprog))); 		nmatch = -1;  		/* 		 * Replace the line in the buffer when needed.  This is 		 * skipped when there are more matches. 		 * The check for nmatch_tl is needed for when multi-line 		 * matching must replace the lines before trying to do another 		 * match, otherwise ""\@<="" won't work. 		 * When the match starts below where we start searching also 		 * need to replace the line first (using \zs after \n). 		 */ 		if (lastone 			|| nmatch_tl > 0 			|| (nmatch = vim_regexec_multi(&regmatch, curwin, 							curbuf, sub_firstlnum, 						    matchcol, NULL, NULL)) == 0 			|| regmatch.startpos[0].lnum > 0) 		{ 		    if (new_start != NULL) 		    { 			/* 			 * Copy the rest of the line, that didn't match. 			 * ""matchcol"" has to be adjusted, we use the end of 			 * the line as reference, because the substitute may 			 * have changed the number of characters.  Same for 			 * ""prev_matchcol"". 			 */ 			STRCAT(new_start, sub_firstline + copycol); 			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol; 			prev_matchcol = (colnr_T)STRLEN(sub_firstline) 							      - prev_matchcol;  			if (u_savesub(lnum) != OK) 			    break; 			ml_replace(lnum, new_start, TRUE);  			if (nmatch_tl > 0) 			{ 			    /* 			     * Matched lines have now been substituted and are 			     * useless, delete them.  The part after the match 			     * has been appended to new_start, we don't need 			     * it in the buffer. 			     */ 			    ++lnum; 			    if (u_savedel(lnum, nmatch_tl) != OK) 				break; 			    for (i = 0; i < nmatch_tl; ++i) 				ml_delete(lnum); 			    mark_adjust(lnum, lnum + nmatch_tl - 1, 						   (long)MAXLNUM, -nmatch_tl); 			    if (subflags.do_ask) 				deleted_lines(lnum, nmatch_tl); 			    --lnum; 			    line2 -= nmatch_tl; // nr of lines decreases 			    nmatch_tl = 0; 			}  			// When asking, undo is saved each time, must also set 			// changed flag each time. 			if (subflags.do_ask) 			    changed_bytes(lnum, 0); 			else 			{ 			    if (first_line == 0) 				first_line = lnum; 			    last_line = lnum + 1; 			}  			sub_firstlnum = lnum; 			vim_free(sub_firstline);    // free the temp buffer 			sub_firstline = new_start; 			new_start = NULL; 			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol; 			prev_matchcol = (colnr_T)STRLEN(sub_firstline) 							      - prev_matchcol; 			copycol = 0; 		    } 		    if (nmatch == -1 && !lastone) 			nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, 					  sub_firstlnum, matchcol, NULL, NULL);  		    /* 		     * 5. break if there isn't another match in this line 		     */ 		    if (nmatch <= 0) 		    { 			// If the match found didn't start where we were 			// searching, do the next search in the line where we 			// found the match. 			if (nmatch == -1) 			    lnum -= regmatch.startpos[0].lnum; 			break; 		    } 		}  		line_breakcheck(); 	    }  	    if (did_sub) 		++sub_nlines; 	    vim_free(new_start);	// for when substitute was cancelled 	    VIM_CLEAR(sub_firstline);	// free the copy of the original line 	}  	line_breakcheck();     }      if (first_line != 0)     { 	// Need to subtract the number of added lines from ""last_line"" to get 	// the line number before the change (same as adding the number of 	// deleted lines). 	i = curbuf->b_ml.ml_line_count - old_line_count; 	changed_lines(first_line, 0, last_line - i, i);     }  outofmem:     vim_free(sub_firstline); // may have to free allocated copy of the line      // "":s/pat//n"" doesn't move the cursor     if (subflags.do_count) 	curwin->w_cursor = old_cursor;      if (sub_nsubs > start_nsubs)     { 	if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0) 	{ 	    // Set the '[ and '] marks. 	    curbuf->b_op_start.lnum = eap->line1; 	    curbuf->b_op_end.lnum = line2; 	    curbuf->b_op_start.col = curbuf->b_op_end.col = 0; 	}  	if (!global_busy) 	{ 	    // when interactive leave cursor on the match 	    if (!subflags.do_ask) 	    { 		if (endcolumn) 		    coladvance((colnr_T)MAXCOL); 		else 		    beginline(BL_WHITE | BL_FIX); 	    } 	    if (!do_sub_msg(subflags.do_count) && subflags.do_ask) 		msg(""""); 	} 	else 	    global_need_beginline = TRUE; 	if (subflags.do_print) 	    print_line(curwin->w_cursor.lnum, 					 subflags.do_number, subflags.do_list);     }     else if (!global_busy)     { 	if (got_int)		// interrupted 	    emsg(_(e_interrupted)); 	else if (got_match)	// did find something but nothing substituted 	    msg(""""); 	else if (subflags.do_error)	// nothing found 	    semsg(_(e_pattern_not_found_str), get_search_pat());     }  #ifdef FEAT_FOLDING     if (subflags.do_ask && hasAnyFolding(curwin)) 	// Cursor position may require updating 	changed_window_setting(); #endif      vim_regfree(regmatch.regprog);      // Restore the flag values, they can be used for "":&&"".     subflags.do_all = save_do_all;     subflags.do_ask = save_do_ask; }"
"200113_CWE-787.c","CWE-787","static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,   ExceptionInfo *exception) {   typedef struct {     unsigned char Type[4];     unsigned int nRows;     unsigned int nCols;     unsigned int imagf;     unsigned int nameLen;   } MAT4_HDR;    long     ldblk;    EndianType     endian;    Image     *rotated_image;    MagickBooleanType     status;    MAT4_HDR     HDR;    QuantumInfo     *quantum_info;    QuantumFormatType     format_type;    register ssize_t     i;    ssize_t     count,     y;    unsigned char     *pixels;    unsigned int     depth;     quantum_info=(QuantumInfo *) NULL;   (void) SeekBlob(image,0,SEEK_SET);   while (EOFBlob(image) == MagickFalse)   {     /*      Object parser loop.     */     ldblk=ReadBlobLSBLong(image);     if ((ldblk > 9999) || (ldblk < 0))       break;     HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */     HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */     HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */     HDR.Type[0]=ldblk;        /* M digit */     if (HDR.Type[3] != 0)       break;  /* Data format */     if (HDR.Type[2] != 0)       break;  /* Always 0 */     if (HDR.Type[0] == 0)       {         HDR.nRows=ReadBlobLSBLong(image);         HDR.nCols=ReadBlobLSBLong(image);         HDR.imagf=ReadBlobLSBLong(image);         HDR.nameLen=ReadBlobLSBLong(image);         endian=LSBEndian;       }     else       {         HDR.nRows=ReadBlobMSBLong(image);         HDR.nCols=ReadBlobMSBLong(image);         HDR.imagf=ReadBlobMSBLong(image);         HDR.nameLen=ReadBlobMSBLong(image);         endian=MSBEndian;       }     if ((HDR.imagf != 0) && (HDR.imagf != 1))       break;     if (HDR.nameLen > 0xFFFF)       return(DestroyImageList(image));     for (i=0; i < (ssize_t) HDR.nameLen; i++)     {       int         byte;        /*         Skip matrix name.       */       byte=ReadBlobByte(image);       if (byte == EOF)         {           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",             image->filename);           break;         }     }     image->columns=(size_t) HDR.nRows;     image->rows=(size_t) HDR.nCols;     if ((image->columns == 0) || (image->rows == 0))       return(DestroyImageList(image));     if (image_info->ping != MagickFalse)       {         Swap(image->columns,image->rows);         if(HDR.imagf==1) ldblk *= 2;         SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);         if ((image->columns == 0) || (image->rows == 0))           return(image->previous == (Image *) NULL ? DestroyImageList(image)             : image);         goto skip_reading_current;       }     status=SetImageExtent(image,image->columns,image->rows,exception);     if (status == MagickFalse)       return(DestroyImageList(image));     (void) SetImageBackgroundColor(image,exception);     (void) SetImageColorspace(image,GRAYColorspace,exception);     quantum_info=AcquireQuantumInfo(image_info,image);     if (quantum_info == (QuantumInfo *) NULL)       return(DestroyImageList(image));     switch(HDR.Type[1])     {       case 0:         format_type=FloatingPointQuantumFormat;         depth=64;         break;       case 1:         format_type=FloatingPointQuantumFormat;         depth=32;         break;       case 2:         format_type=UnsignedQuantumFormat;         depth=16;         break;       case 3:         format_type=SignedQuantumFormat;         depth=16;         break;       case 4:         format_type=UnsignedQuantumFormat;         depth=8;         break;       default:         format_type=UnsignedQuantumFormat;         depth=8;         break;     }     image->depth=depth;     if (HDR.Type[0] != 0)       SetQuantumEndian(image,quantum_info,MSBEndian);     status=SetQuantumFormat(image,quantum_info,format_type);     status=SetQuantumDepth(image,quantum_info,depth);     status=SetQuantumEndian(image,quantum_info,endian);     SetQuantumScale(quantum_info,1.0);     pixels=(unsigned char *) GetQuantumPixels(quantum_info);     for (y=0; y < (ssize_t) image->rows; y++)     {       register Quantum         *magick_restrict q;        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);       if (count == -1)         break;       q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,         exception);       if (q == (Quantum *) NULL)         break;       (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,         GrayQuantum,pixels,exception);       if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))         FixSignedValues(image,q,(int) image->columns);       if (SyncAuthenticPixels(image,exception) == MagickFalse)         break;       if (image->previous == (Image *) NULL)         {           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,             image->rows);           if (status == MagickFalse)             break;         }     }     if (HDR.imagf == 1)       for (y=0; y < (ssize_t) image->rows; y++)       {         /*           Read complex pixels.         */         count=ReadBlob(image,depth/8*image->columns,(char *) pixels);         if (count == -1)           break;         if (HDR.Type[1] == 0)           InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);         else           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);       }     if (quantum_info != (QuantumInfo *) NULL)       quantum_info=DestroyQuantumInfo(quantum_info);     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }     rotated_image=RotateImage(image,90.0,exception);     if (rotated_image != (Image *) NULL)       {         rotated_image->page.x=0;         rotated_image->page.y=0;         rotated_image->colors = image->colors;         DestroyBlob(rotated_image);         rotated_image->blob=ReferenceBlob(image->blob);         AppendImageToList(&image,rotated_image);         DeleteImageFromList(&image);       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     /*       Allocate next image structure.     */ skip_reading_current:     AcquireNextImage(image_info,image,exception);     if (GetNextImageInList(image) == (Image *) NULL)       {         status=MagickFalse;         break;       }     image=SyncNextImageInList(image);     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),       GetBlobSize(image));     if (status == MagickFalse)       break;   }   (void) CloseBlob(image);   if (status == MagickFalse)     return(DestroyImageList(image));   return(GetFirstImageInList(image)); }"
"200157_CWE-264.c","CWE-264","readconf_main(void) { int sep = 0; struct stat statbuf; uschar *s, *filename; uschar *list = config_main_filelist;  /* Loop through the possible file names */  while((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))        != NULL)   {   /* Cut out all the fancy processing unless specifically wanted */    #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)   uschar *suffix = filename + Ustrlen(filename);    /* Try for the node-specific file if a node name exists */    #ifdef CONFIGURE_FILE_USE_NODE   struct utsname uts;   if (uname(&uts) >= 0)     {     #ifdef CONFIGURE_FILE_USE_EUID     sprintf(CS suffix, "".%ld.%.256s"", (long int)original_euid, uts.nodename);     config_file = Ufopen(filename, ""rb"");     if (config_file == NULL)     #endif  /* CONFIGURE_FILE_USE_EUID */       {       sprintf(CS suffix, "".%.256s"", uts.nodename);       config_file = Ufopen(filename, ""rb"");       }     }   #endif  /* CONFIGURE_FILE_USE_NODE */    /* Otherwise, try the generic name, possibly with the euid added */    #ifdef CONFIGURE_FILE_USE_EUID   if (config_file == NULL)     {     sprintf(CS suffix, "".%ld"", (long int)original_euid);     config_file = Ufopen(filename, ""rb"");     }   #endif  /* CONFIGURE_FILE_USE_EUID */    /* Finally, try the unadorned name */    if (config_file == NULL)     {     *suffix = 0;     config_file = Ufopen(filename, ""rb"");     }   #else  /* if neither defined */    /* This is the common case when the fancy processing is not included. */    config_file = Ufopen(filename, ""rb"");   #endif    /* If the file does not exist, continue to try any others. For any other   error, break out (and die). */    if (config_file != NULL || errno != ENOENT) break;   }  /* On success, save the name for verification; config_filename is used when logging configuration errors (it changes for .included files) whereas config_main_filename is the name shown by -bP. Failure to open a configuration file is a serious disaster. */  if (config_file != NULL)   {   config_filename = config_main_filename = string_copy(filename);   } else   {   if (filename == NULL)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""non-existent configuration file(s): ""       ""%s"", config_main_filelist);   else     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""%s"", string_open_failed(errno,       ""configuration file %s"", filename));   }  /* Check the status of the file we have opened, unless it was specified on the command line, in which case privilege was given away at the start. */  if (!config_changed)   {   if (fstat(fileno(config_file), &statbuf) != 0)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""failed to stat configuration file %s"",       big_buffer);    if ((statbuf.st_uid != root_uid                /* owner not root */        #ifdef CONFIGURE_OWNER        && statbuf.st_uid != config_uid           /* owner not the special one */        #endif          ) ||                                    /* or */       (statbuf.st_gid != root_gid                /* group not root & */        #ifdef CONFIGURE_GROUP        && statbuf.st_gid != config_gid           /* group not the special one */        #endif        && (statbuf.st_mode & 020) != 0) ||       /* group writeable  */                                                  /* or */       ((statbuf.st_mode & 2) != 0))              /* world writeable  */      log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""Exim configuration file %s has the ""       ""wrong owner, group, or mode"", big_buffer);   }  /* Process the main configuration settings. They all begin with a lower case letter. If we see something starting with an upper case letter, it is taken as a macro definition. */  while ((s = get_config_line()) != NULL)   {   if (isupper(s[0])) read_macro_assignment(s);    else if (Ustrncmp(s, ""domainlist"", 10) == 0)     read_named_list(&domainlist_anchor, &domainlist_count,       MAX_NAMED_LIST, s+10, US""domain list"");    else if (Ustrncmp(s, ""hostlist"", 8) == 0)     read_named_list(&hostlist_anchor, &hostlist_count,       MAX_NAMED_LIST, s+8, US""host list"");    else if (Ustrncmp(s, US""addresslist"", 11) == 0)     read_named_list(&addresslist_anchor, &addresslist_count,       MAX_NAMED_LIST, s+11, US""address list"");    else if (Ustrncmp(s, US""localpartlist"", 13) == 0)     read_named_list(&localpartlist_anchor, &localpartlist_count,       MAX_NAMED_LIST, s+13, US""local part list"");    else     (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,       NULL, US""main option \""%s\"" unknown"");   }   /* If local_sender_retain is set, local_from_check must be unset. */  if (local_sender_retain && local_from_check)   log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""both local_from_check and ""     ""local_sender_retain are set; this combination is not allowed"");  /* If the timezone string is empty, set it to NULL, implying no TZ variable wanted. */  if (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;  /* The max retry interval must not be greater than 24 hours. */  if (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;  /* remote_max_parallel must be > 0 */  if (remote_max_parallel <= 0) remote_max_parallel = 1;  /* Save the configured setting of freeze_tell, so we can re-instate it at the start of a new SMTP message. */  freeze_tell_config = freeze_tell;  /* The primary host name may be required for expansion of spool_directory and log_file_path, so make sure it is set asap. It is obtained from uname(), but if that yields an unqualified value, make a FQDN by using gethostbyname to canonize it. Some people like upper case letters in their host names, so we don't force the case. */  if (primary_hostname == NULL)   {   uschar *hostname;   struct utsname uts;   if (uname(&uts) < 0)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""uname() failed to yield host name"");   hostname = US uts.nodename;    if (Ustrchr(hostname, '.') == NULL)     {     int af = AF_INET;     struct hostent *hostdata;      #if HAVE_IPV6     if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||          match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,            TRUE, NULL) != OK))       af = AF_INET6;     #else     af = AF_INET;     #endif      for (;;)       {       #if HAVE_IPV6         #if HAVE_GETIPNODEBYNAME         int error_num;         hostdata = getipnodebyname(CS hostname, af, 0, &error_num);         #else         hostdata = gethostbyname2(CS hostname, af);         #endif       #else       hostdata = gethostbyname(CS hostname);       #endif        if (hostdata != NULL)         {         hostname = US hostdata->h_name;         break;         }        if (af == AF_INET) break;       af = AF_INET;       }     }    primary_hostname = string_copy(hostname);   }  /* Set up default value for smtp_active_hostname */  smtp_active_hostname = primary_hostname;  /* If spool_directory wasn't set in the build-time configuration, it must have got set above. Of course, writing to the log may not work if log_file_path is not set, but it will at least get to syslog or somewhere, with any luck. */  if (*spool_directory == 0)   log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""spool_directory undefined: cannot ""     ""proceed"");  /* Expand the spool directory name; it may, for example, contain the primary host name. Same comment about failure. */  s = expand_string(spool_directory); if (s == NULL)   log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""failed to expand spool_directory ""     ""\""%s\"": %s"", spool_directory, expand_string_message); spool_directory = s;  /* Expand log_file_path, which must contain ""%s"" in any component that isn't the null string or ""syslog"". It is also allowed to contain one instance of %D. However, it must NOT contain % followed by anything else. */  if (*log_file_path != 0)   {   uschar *ss, *sss;   int sep = ':';                       /* Fixed for log file path */   s = expand_string(log_file_path);   if (s == NULL)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""failed to expand log_file_path ""       ""\""%s\"": %s"", log_file_path, expand_string_message);    ss = s;   while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)     {     uschar *t;     if (sss[0] == 0 || Ustrcmp(sss, ""syslog"") == 0) continue;     t = Ustrstr(sss, ""%s"");     if (t == NULL)       log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""log_file_path \""%s\"" does not ""         ""contain \""%%s\"""", sss);     *t = 'X';     t = Ustrchr(sss, '%');     if (t != NULL)       {       if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)         log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""log_file_path \""%s\"" contains ""           ""unexpected \""%%\"" character"", s);       }     }    log_file_path = s;   }  /* Interpret syslog_facility into an integer argument for 'ident' param to openlog(). Default is LOG_MAIL set in globals.c. Allow the user to omit the leading ""log_"". */  if (syslog_facility_str != NULL)   {   int i;   uschar *s = syslog_facility_str;    if ((Ustrlen(syslog_facility_str) >= 4) &&         (strncmpic(syslog_facility_str, US""log_"", 4) == 0))     s += 4;    for (i = 0; i < syslog_list_size; i++)     {     if (strcmpic(s, syslog_list[i].name) == 0)       {       syslog_facility = syslog_list[i].value;       break;       }     }    if (i >= syslog_list_size)     {     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""failed to interpret syslog_facility \""%s\"""", syslog_facility_str);     }   }  /* Expand pid_file_path */  if (*pid_file_path != 0)   {   s = expand_string(pid_file_path);   if (s == NULL)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""failed to expand pid_file_path ""       ""\""%s\"": %s"", pid_file_path, expand_string_message);   pid_file_path = s;   }  /* Compile the regex for matching a UUCP-style ""From_"" line in an incoming message. */  regex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);  /* Unpick the SMTP rate limiting options, if set */  if (smtp_ratelimit_mail != NULL)   {   unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,     &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);   }  if (smtp_ratelimit_rcpt != NULL)   {   unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,     &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);   }  /* The qualify domains default to the primary host name */  if (qualify_domain_sender == NULL)   qualify_domain_sender = primary_hostname; if (qualify_domain_recipient == NULL)   qualify_domain_recipient = qualify_domain_sender;  /* Setting system_filter_user in the configuration sets the gid as well if a name is given, but a numerical value does not. */  if (system_filter_uid_set && !system_filter_gid_set)   {   struct passwd *pw = getpwuid(system_filter_uid);   if (pw == NULL)     log_write(0, LOG_MAIN|LOG_PANIC_DIE, ""Failed to look up uid %ld"",       (long int)system_filter_uid);   system_filter_gid = pw->pw_gid;   system_filter_gid_set = TRUE;   }  /* If the errors_reply_to field is set, check that it is syntactically valid and ensure it contains a domain. */  if (errors_reply_to != NULL)   {   uschar *errmess;   int start, end, domain;   uschar *recipient = parse_extract_address(errors_reply_to, &errmess,     &start, &end, &domain, FALSE);    if (recipient == NULL)     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""error in errors_reply_to (%s): %s"", errors_reply_to, errmess);    if (domain == 0)     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""errors_reply_to (%s) does not contain a domain"", errors_reply_to);   }  /* If smtp_accept_queue or smtp_accept_max_per_host is set, then smtp_accept_max must also be set. */  if (smtp_accept_max == 0 &&     (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,     ""smtp_accept_max must be set if smtp_accept_queue or ""     ""smtp_accept_max_per_host is set"");  /* Set up the host number if anything is specified. It is an expanded string so that it can be computed from the host name, for example. We do this last so as to ensure that everything else is set up before the expansion. */  if (host_number_string != NULL)   {   uschar *end;   uschar *s = expand_string(host_number_string);   long int n = Ustrtol(s, &end, 0);   while (isspace(*end)) end++;   if (*end != 0)     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""localhost_number value is not a number: %s"", s);   if (n > LOCALHOST_MAX)     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""localhost_number is greater than the maximum allowed value (%d)"",         LOCALHOST_MAX);   host_number = n;   }  #ifdef SUPPORT_TLS /* If tls_verify_hosts is set, tls_verify_certificates must also be set */  if ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&      tls_verify_certificates == NULL)   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,     ""tls_%sverify_hosts is set, but tls_verify_certificates is not set"",     (tls_verify_hosts != NULL)? """" : ""try_"");  /* If openssl_options is set, validate it */ if (openssl_options != NULL)   { # ifdef USE_GNUTLS   log_write(0, LOG_PANIC_DIE|LOG_CONFIG,     ""openssl_options is set but we're using GnuTLS""); # else   long dummy;   if (!(tls_openssl_options_parse(openssl_options, &dummy)))     log_write(0, LOG_PANIC_DIE|LOG_CONFIG,       ""openssl_options parse error: %s"", openssl_options); # endif   } #endif }"
"200163_CWE-200.c","CWE-200","static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id) { 	struct elo_priv *priv; 	int ret; 	struct usb_device *udev;  	if (!hid_is_usb(hdev)) 		return -EINVAL;  	priv = kzalloc(sizeof(*priv), GFP_KERNEL); 	if (!priv) 		return -ENOMEM;  	INIT_DELAYED_WORK(&priv->work, elo_work); 	udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent)); 	priv->usbdev = usb_get_dev(udev);  	hid_set_drvdata(hdev, priv);  	ret = hid_parse(hdev); 	if (ret) { 		hid_err(hdev, ""parse failed\n""); 		goto err_free; 	}  	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT); 	if (ret) { 		hid_err(hdev, ""hw start failed\n""); 		goto err_free; 	}  	if (elo_broken_firmware(priv->usbdev)) { 		hid_info(hdev, ""broken firmware found, installing workaround\n""); 		queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL); 	}  	return 0; err_free: 	kfree(priv); 	return ret; }"
"200287_CWE-200.c","CWE-200","static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen) { 	struct sock *sk = sock->sk; 	struct net *net = sock_net(sk); 	struct tipc_sock *tsk = tipc_sk(sk); 	struct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name; 	long timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT); 	struct list_head *clinks = &tsk->cong_links; 	bool syn = !tipc_sk_type_connectionless(sk); 	struct tipc_group *grp = tsk->group; 	struct tipc_msg *hdr = &tsk->phdr; 	struct tipc_socket_addr skaddr; 	struct sk_buff_head pkts; 	int atype, mtu, rc;  	if (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE)) 		return -EMSGSIZE;  	if (ua) { 		if (!tipc_uaddr_valid(ua, m->msg_namelen)) 			return -EINVAL; 		atype = ua->addrtype; 	}  	/* If socket belongs to a communication group follow other paths */ 	if (grp) { 		if (!ua) 			return tipc_send_group_bcast(sock, m, dlen, timeout); 		if (atype == TIPC_SERVICE_ADDR) 			return tipc_send_group_anycast(sock, m, dlen, timeout); 		if (atype == TIPC_SOCKET_ADDR) 			return tipc_send_group_unicast(sock, m, dlen, timeout); 		if (atype == TIPC_SERVICE_RANGE) 			return tipc_send_group_mcast(sock, m, dlen, timeout); 		return -EINVAL; 	}  	if (!ua) { 		ua = (struct tipc_uaddr *)&tsk->peer; 		if (!syn && ua->family != AF_TIPC) 			return -EDESTADDRREQ; 		atype = ua->addrtype; 	}  	if (unlikely(syn)) { 		if (sk->sk_state == TIPC_LISTEN) 			return -EPIPE; 		if (sk->sk_state != TIPC_OPEN) 			return -EISCONN; 		if (tsk->published) 			return -EOPNOTSUPP; 		if (atype == TIPC_SERVICE_ADDR) 			tsk->conn_addrtype = atype; 		msg_set_syn(hdr, 1); 	}  	/* Determine destination */ 	if (atype == TIPC_SERVICE_RANGE) { 		return tipc_sendmcast(sock, ua, m, dlen, timeout); 	} else if (atype == TIPC_SERVICE_ADDR) { 		skaddr.node = ua->lookup_node; 		ua->scope = tipc_node2scope(skaddr.node); 		if (!tipc_nametbl_lookup_anycast(net, ua, &skaddr)) 			return -EHOSTUNREACH; 	} else if (atype == TIPC_SOCKET_ADDR) { 		skaddr = ua->sk; 	} else { 		return -EINVAL; 	}  	/* Block or return if destination link is congested */ 	rc = tipc_wait_for_cond(sock, &timeout, 				!tipc_dest_find(clinks, skaddr.node, 0)); 	if (unlikely(rc)) 		return rc;  	/* Finally build message header */ 	msg_set_destnode(hdr, skaddr.node); 	msg_set_destport(hdr, skaddr.ref); 	if (atype == TIPC_SERVICE_ADDR) { 		msg_set_type(hdr, TIPC_NAMED_MSG); 		msg_set_hdr_sz(hdr, NAMED_H_SIZE); 		msg_set_nametype(hdr, ua->sa.type); 		msg_set_nameinst(hdr, ua->sa.instance); 		msg_set_lookup_scope(hdr, ua->scope); 	} else { /* TIPC_SOCKET_ADDR */ 		msg_set_type(hdr, TIPC_DIRECT_MSG); 		msg_set_lookup_scope(hdr, 0); 		msg_set_hdr_sz(hdr, BASIC_H_SIZE); 	}  	/* Add message body */ 	__skb_queue_head_init(&pkts); 	mtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true); 	rc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts); 	if (unlikely(rc != dlen)) 		return rc; 	if (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) { 		__skb_queue_purge(&pkts); 		return -ENOMEM; 	}  	/* Send message */ 	trace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, "" ""); 	rc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid); 	if (unlikely(rc == -ELINKCONG)) { 		tipc_dest_push(clinks, skaddr.node, 0); 		tsk->cong_link_cnt++; 		rc = 0; 	}  	if (unlikely(syn && !rc)) { 		tipc_set_sk_state(sk, TIPC_CONNECTING); 		if (dlen && timeout) { 			timeout = msecs_to_jiffies(timeout); 			tipc_wait_for_connect(sock, &timeout); 		} 	}  	return rc ? rc : dlen; }"
"200305_CWE-787.c","CWE-787","pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file) {				/*                                  * The PCX format theoretically allows encoding runs of 63                                  * identical bytes, but some readers can't handle repetition                                  * counts greater than 15.                                  */ #define MAX_RUN_COUNT 15     int max_run = step * MAX_RUN_COUNT;      while (from < end) {         byte data = *from;          from += step;         if (data != *from || from == end) {             if (data >= 0xc0)                 gp_fputc(0xc1, file);         } else {             const byte *start = from;              while ((from < end) && (*from == data))                 from += step;             /* Now (from - start) / step + 1 is the run length. */             while (from - start >= max_run) {                 gp_fputc(0xc0 + MAX_RUN_COUNT, file);                 gp_fputc(data, file);                 start += max_run;             }             if (from > start || data >= 0xc0)                 gp_fputc((from - start) / step + 0xc1, file);         }         gp_fputc(data, file);     } #undef MAX_RUN_COUNT }"
"200320_CWE-665.c","CWE-665","static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle, 			      struct files_struct *fsp, 			      TALLOC_CTX *ctx, 			      uint32_t function, 			      uint16_t req_flags, /* Needed for UNICODE ... */ 			      const uint8_t *_in_data, 			      uint32_t in_len, 			      uint8_t **_out_data, 			      uint32_t max_out_len, 			      uint32_t *out_len) { 	const char *in_data = (const char *)_in_data; 	char **out_data = (char **)_out_data;  	switch (function) { 	case FSCTL_SET_SPARSE: 	{ 		bool set_sparse = true; 		NTSTATUS status;  		if (in_len >= 1 && in_data[0] == 0) { 			set_sparse = false; 		}  		status = file_set_sparse(handle->conn, fsp, set_sparse); 		 		DEBUG(NT_STATUS_IS_OK(status) ? 10 : 9, 		      (""FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\n"", 		       smb_fname_str_dbg(fsp->fsp_name), set_sparse,  		       nt_errstr(status)));  		return status; 	}  	case FSCTL_CREATE_OR_GET_OBJECT_ID: 	{ 		unsigned char objid[16]; 		char *return_data = NULL;  		/* This should return the object-id on this file. 		 * I think I'll make this be the inode+dev. JRA. 		 */  		DEBUG(10,(""FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\n"", 			  fsp_fnum_dbg(fsp)));  		*out_len = (max_out_len >= 64) ? 64 : max_out_len; 		/* Hmmm, will this cause problems if less data asked for? */ 		return_data = talloc_array(ctx, char, 64); 		if (return_data == NULL) { 			return NT_STATUS_NO_MEMORY; 		}  		/* For backwards compatibility only store the dev/inode. */ 		push_file_id_16(return_data, &fsp->file_id); 		memcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16); 		push_file_id_16(return_data+32, &fsp->file_id); 		*out_data = return_data; 		return NT_STATUS_OK; 	}  	case FSCTL_GET_REPARSE_POINT: 	{ 		/* Fail it with STATUS_NOT_A_REPARSE_POINT */ 		DEBUG(10, (""FSCTL_GET_REPARSE_POINT: called on %s. "" 			   ""Status: NOT_IMPLEMENTED\n"", fsp_fnum_dbg(fsp))); 		return NT_STATUS_NOT_A_REPARSE_POINT; 	}  	case FSCTL_SET_REPARSE_POINT: 	{ 		/* Fail it with STATUS_NOT_A_REPARSE_POINT */ 		DEBUG(10, (""FSCTL_SET_REPARSE_POINT: called on %s. "" 			   ""Status: NOT_IMPLEMENTED\n"", fsp_fnum_dbg(fsp))); 		return NT_STATUS_NOT_A_REPARSE_POINT; 	}  	case FSCTL_GET_SHADOW_COPY_DATA: 	{ 		/* 		 * This is called to retrieve the number of Shadow Copies (a.k.a. snapshots) 		 * and return their volume names.  If max_data_count is 16, then it is just 		 * asking for the number of volumes and length of the combined names. 		 * 		 * pdata is the data allocated by our caller, but that uses 		 * total_data_count (which is 0 in our case) rather than max_data_count. 		 * Allocate the correct amount and return the pointer to let 		 * it be deallocated when we return. 		 */ 		struct shadow_copy_data *shadow_data = NULL; 		bool labels = False; 		uint32 labels_data_count = 0; 		uint32 i; 		char *cur_pdata = NULL;  		if (max_out_len < 16) { 			DEBUG(0,(""FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\n"", 				max_out_len)); 			return NT_STATUS_INVALID_PARAMETER; 		}  		if (max_out_len > 16) { 			labels = True; 		}  		shadow_data = talloc_zero(ctx, struct shadow_copy_data); 		if (shadow_data == NULL) { 			DEBUG(0,(""TALLOC_ZERO() failed!\n"")); 			return NT_STATUS_NO_MEMORY; 		}  		/* 		 * Call the VFS routine to actually do the work. 		 */ 		if (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) { 			TALLOC_FREE(shadow_data); 			if (errno == ENOSYS) { 				DEBUG(5,(""FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\n"",  					fsp->conn->connectpath)); 				return NT_STATUS_NOT_SUPPORTED; 			} else { 				DEBUG(0,(""FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\n"",  					fsp->conn->connectpath)); 				return NT_STATUS_UNSUCCESSFUL; 			} 		}  		labels_data_count = (shadow_data->num_volumes * 2 *  					sizeof(SHADOW_COPY_LABEL)) + 2;  		if (!labels) { 			*out_len = 16; 		} else { 			*out_len = 12 + labels_data_count + 4; 		}  		if (max_out_len < *out_len) { 			DEBUG(0,(""FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\n"", 				max_out_len, *out_len)); 			TALLOC_FREE(shadow_data); 			return NT_STATUS_BUFFER_TOO_SMALL; 		}  		cur_pdata = talloc_zero_array(ctx, char, *out_len); 		if (cur_pdata == NULL) { 			TALLOC_FREE(shadow_data); 			return NT_STATUS_NO_MEMORY; 		}  		*out_data = cur_pdata;  		/* num_volumes 4 bytes */ 		SIVAL(cur_pdata, 0, shadow_data->num_volumes);  		if (labels) { 			/* num_labels 4 bytes */ 			SIVAL(cur_pdata, 4, shadow_data->num_volumes); 		}  		/* needed_data_count 4 bytes */ 		SIVAL(cur_pdata, 8, labels_data_count + 4);  		cur_pdata += 12;  		DEBUG(10,(""FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\n"", 			  shadow_data->num_volumes, fsp_str_dbg(fsp))); 		if (labels && shadow_data->labels) { 			for (i=0; i<shadow_data->num_volumes; i++) { 				srvstr_push(cur_pdata, req_flags, 					    cur_pdata, shadow_data->labels[i], 					    2 * sizeof(SHADOW_COPY_LABEL), 					    STR_UNICODE|STR_TERMINATE); 				cur_pdata += 2 * sizeof(SHADOW_COPY_LABEL); 				DEBUGADD(10,(""Label[%u]: '%s'\n"",i,shadow_data->labels[i])); 			} 		}  		TALLOC_FREE(shadow_data);  		return NT_STATUS_OK; 	}  	case FSCTL_FIND_FILES_BY_SID: 	{ 		/* pretend this succeeded - 		 * 		 * we have to send back a list with all files owned by this SID 		 * 		 * but I have to check that --metze 		 */ 		struct dom_sid sid; 		uid_t uid; 		size_t sid_len;  		DEBUG(10, (""FSCTL_FIND_FILES_BY_SID: called on %s\n"", 			   fsp_fnum_dbg(fsp)));  		if (in_len < 8) { 			/* NT_STATUS_BUFFER_TOO_SMALL maybe? */ 			return NT_STATUS_INVALID_PARAMETER; 		}  		sid_len = MIN(in_len - 4,SID_MAX_SIZE);  		/* unknown 4 bytes: this is not the length of the sid :-(  */ 		/*unknown = IVAL(pdata,0);*/  		if (!sid_parse(in_data + 4, sid_len, &sid)) { 			return NT_STATUS_INVALID_PARAMETER; 		} 		DEBUGADD(10, (""for SID: %s\n"", sid_string_dbg(&sid)));  		if (!sid_to_uid(&sid, &uid)) { 			DEBUG(0,(""sid_to_uid: failed, sid[%s] sid_len[%lu]\n"", 				 sid_string_dbg(&sid), 				 (unsigned long)sid_len)); 			uid = (-1); 		}  		/* we can take a look at the find source :-) 		 * 		 * find ./ -uid $uid  -name '*'   is what we need here 		 * 		 * 		 * and send 4bytes len and then NULL terminated unicode strings 		 * for each file 		 * 		 * but I don't know how to deal with the paged results 		 * (maybe we can hang the result anywhere in the fsp struct) 		 * 		 * but I don't know how to deal with the paged results 		 * (maybe we can hang the result anywhere in the fsp struct) 		 * 		 * we don't send all files at once 		 * and at the next we should *not* start from the beginning, 		 * so we have to cache the result 		 * 		 * --metze 		 */  		/* this works for now... */ 		return NT_STATUS_OK; 	}  	case FSCTL_QUERY_ALLOCATED_RANGES: 	{ 		/* FIXME: This is just a dummy reply, telling that all of the 		 * file is allocated. MKS cp needs that. 		 * Adding the real allocated ranges via FIEMAP on Linux 		 * and SEEK_DATA/SEEK_HOLE on Solaris is needed to make 		 * this FSCTL correct for sparse files. 		 */ 		NTSTATUS status; 		uint64_t offset, length; 		char *out_data_tmp = NULL;  		if (in_len != 16) { 			DEBUG(0,(""FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\n"", 				in_len)); 			return NT_STATUS_INVALID_PARAMETER; 		}  		if (max_out_len < 16) { 			DEBUG(0,(""FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\n"", 				max_out_len)); 			return NT_STATUS_INVALID_PARAMETER; 		}  		offset = BVAL(in_data,0); 		length = BVAL(in_data,8);  		if (offset + length < offset) { 			/* No 64-bit integer wrap. */ 			return NT_STATUS_INVALID_PARAMETER; 		}  		/* Shouldn't this be SMB_VFS_STAT ... ? */ 		status = vfs_stat_fsp(fsp); 		if (!NT_STATUS_IS_OK(status)) { 			return status; 		}  		*out_len = 16; 		out_data_tmp = talloc_array(ctx, char, *out_len); 		if (out_data_tmp == NULL) { 			DEBUG(10, (""unable to allocate memory for response\n"")); 			return NT_STATUS_NO_MEMORY; 		}  		if (offset > fsp->fsp_name->st.st_ex_size || 				fsp->fsp_name->st.st_ex_size == 0 || 				length == 0) { 			memset(out_data_tmp, 0, *out_len); 		} else { 			uint64_t end = offset + length; 			end = MIN(end, fsp->fsp_name->st.st_ex_size); 			SBVAL(out_data_tmp, 0, 0); 			SBVAL(out_data_tmp, 8, end); 		}  		*out_data = out_data_tmp;  		return NT_STATUS_OK; 	}  	case FSCTL_IS_VOLUME_DIRTY: 	{ 		DEBUG(10,(""FSCTL_IS_VOLUME_DIRTY: called on %s "" 			  ""(but remotely not supported)\n"", fsp_fnum_dbg(fsp))); 		/* 		 * http://msdn.microsoft.com/en-us/library/cc232128%28PROT.10%29.aspx 		 * says we have to respond with NT_STATUS_INVALID_PARAMETER 		 */ 		return NT_STATUS_INVALID_PARAMETER; 	}  	default: 		/*  		 * Only print once ... unfortunately there could be lots of 		 * different FSCTLs that are called. 		 */ 		if (!vfswrap_logged_ioctl_message) { 			vfswrap_logged_ioctl_message = true; 			DEBUG(2, (""%s (0x%x): Currently not implemented.\n"", 			__func__, function)); 		} 	}  	return NT_STATUS_NOT_SUPPORTED; }"
"200323_CWE-787.c","CWE-787","suggest_trie_walk(     suginfo_T	*su,     langp_T	*lp,     char_u	*fword,     int		soundfold) {     char_u	tword[MAXWLEN];	    // good word collected so far     trystate_T	stack[MAXWLEN];     char_u	preword[MAXWLEN * 3]; // word found with proper case; 				      // concatenation of prefix compound 				      // words and split word.  NUL terminated 				      // when going deeper but not when coming 				      // back.     char_u	compflags[MAXWLEN];	// compound flags, one for each word     trystate_T	*sp;     int		newscore;     int		score;     char_u	*byts, *fbyts, *pbyts;     idx_T	*idxs, *fidxs, *pidxs;     int		depth;     int		c, c2, c3;     int		n = 0;     int		flags;     garray_T	*gap;     idx_T	arridx;     int		len;     char_u	*p;     fromto_T	*ftp;     int		fl = 0, tl;     int		repextra = 0;	    // extra bytes in fword[] from REP item     slang_T	*slang = lp->lp_slang;     int		fword_ends;     int		goodword_ends; #ifdef DEBUG_TRIEWALK     // Stores the name of the change made at each level.     char_u	changename[MAXWLEN][80]; #endif     int		breakcheckcount = 1000; #ifdef FEAT_RELTIME     proftime_T	time_limit; #endif     int		compound_ok;      // Go through the whole case-fold tree, try changes at each node.     // ""tword[]"" contains the word collected from nodes in the tree.     // ""fword[]"" the word we are trying to match with (initially the bad     // word).     depth = 0;     sp = &stack[0];     CLEAR_POINTER(sp);     sp->ts_curi = 1;      if (soundfold)     { 	// Going through the soundfold tree. 	byts = fbyts = slang->sl_sbyts; 	idxs = fidxs = slang->sl_sidxs; 	pbyts = NULL; 	pidxs = NULL; 	sp->ts_prefixdepth = PFD_NOPREFIX; 	sp->ts_state = STATE_START;     }     else     { 	// When there are postponed prefixes we need to use these first.  At 	// the end of the prefix we continue in the case-fold tree. 	fbyts = slang->sl_fbyts; 	fidxs = slang->sl_fidxs; 	pbyts = slang->sl_pbyts; 	pidxs = slang->sl_pidxs; 	if (pbyts != NULL) 	{ 	    byts = pbyts; 	    idxs = pidxs; 	    sp->ts_prefixdepth = PFD_PREFIXTREE; 	    sp->ts_state = STATE_NOPREFIX;	// try without prefix first 	} 	else 	{ 	    byts = fbyts; 	    idxs = fidxs; 	    sp->ts_prefixdepth = PFD_NOPREFIX; 	    sp->ts_state = STATE_START; 	}     } #ifdef FEAT_RELTIME     // The loop may take an indefinite amount of time. Break out after some     // time.     if (spell_suggest_timeout > 0) 	profile_setlimit(spell_suggest_timeout, &time_limit); #endif      // Loop to find all suggestions.  At each round we either:     // - For the current state try one operation, advance ""ts_curi"",     //   increase ""depth"".     // - When a state is done go to the next, set ""ts_state"".     // - When all states are tried decrease ""depth"".     while (depth >= 0 && !got_int)     { 	sp = &stack[depth]; 	switch (sp->ts_state) 	{ 	case STATE_START: 	case STATE_NOPREFIX: 	    // Start of node: Deal with NUL bytes, which means 	    // tword[] may end here. 	    arridx = sp->ts_arridx;	    // current node in the tree 	    len = byts[arridx];		    // bytes in this node 	    arridx += sp->ts_curi;	    // index of current byte  	    if (sp->ts_prefixdepth == PFD_PREFIXTREE) 	    { 		// Skip over the NUL bytes, we use them later. 		for (n = 0; n < len && byts[arridx + n] == 0; ++n) 		    ; 		sp->ts_curi += n;  		// Always past NUL bytes now. 		n = (int)sp->ts_state; 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_ENDNUL; 		sp->ts_save_badflags = su->su_badflags;  		// At end of a prefix or at start of prefixtree: check for 		// following word. 		if (depth < MAXWLEN - 1 			    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX)) 		{ 		    // Set su->su_badflags to the caps type at this position. 		    // Use the caps type until here for the prefix itself. 		    if (has_mbyte) 			n = nofold_len(fword, sp->ts_fidx, su->su_badptr); 		    else 			n = sp->ts_fidx; 		    flags = badword_captype(su->su_badptr, su->su_badptr + n); 		    su->su_badflags = badword_captype(su->su_badptr + n, 					       su->su_badptr + su->su_badlen); #ifdef DEBUG_TRIEWALK 		    sprintf(changename[depth], ""prefix""); #endif 		    go_deeper(stack, depth, 0); 		    ++depth; 		    sp = &stack[depth]; 		    sp->ts_prefixdepth = depth - 1; 		    byts = fbyts; 		    idxs = fidxs; 		    sp->ts_arridx = 0;  		    // Move the prefix to preword[] with the right case 		    // and make find_keepcap_word() works. 		    tword[sp->ts_twordlen] = NUL; 		    make_case_word(tword + sp->ts_splitoff, 					  preword + sp->ts_prewordlen, flags); 		    sp->ts_prewordlen = (char_u)STRLEN(preword); 		    sp->ts_splitoff = sp->ts_twordlen; 		} 		break; 	    }  	    if (sp->ts_curi > len || byts[arridx] != 0) 	    { 		// Past bytes in node and/or past NUL bytes. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_ENDNUL; 		sp->ts_save_badflags = su->su_badflags; 		break; 	    }  	    // End of word in tree. 	    ++sp->ts_curi;		// eat one NUL byte  	    flags = (int)idxs[arridx];  	    // Skip words with the NOSUGGEST flag. 	    if (flags & WF_NOSUGGEST) 		break;  	    fword_ends = (fword[sp->ts_fidx] == NUL 			   || (soundfold 			       ? VIM_ISWHITE(fword[sp->ts_fidx]) 			       : !spell_iswordp(fword + sp->ts_fidx, curwin))); 	    tword[sp->ts_twordlen] = NUL;  	    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL 					&& (sp->ts_flags & TSF_PREFIXOK) == 0 					&& pbyts != NULL) 	    { 		// There was a prefix before the word.  Check that the prefix 		// can be used with this word. 		// Count the length of the NULs in the prefix.  If there are 		// none this must be the first try without a prefix. 		n = stack[sp->ts_prefixdepth].ts_arridx; 		len = pbyts[n++]; 		for (c = 0; c < len && pbyts[n + c] == 0; ++c) 		    ; 		if (c > 0) 		{ 		    c = valid_word_prefix(c, n, flags, 				       tword + sp->ts_splitoff, slang, FALSE); 		    if (c == 0) 			break;  		    // Use the WF_RARE flag for a rare prefix. 		    if (c & WF_RAREPFX) 			flags |= WF_RARE;  		    // Tricky: when checking for both prefix and compounding 		    // we run into the prefix flag first. 		    // Remember that it's OK, so that we accept the prefix 		    // when arriving at a compound flag. 		    sp->ts_flags |= TSF_PREFIXOK; 		} 	    }  	    // Check NEEDCOMPOUND: can't use word without compounding.  Do try 	    // appending another compound word below. 	    if (sp->ts_complen == sp->ts_compsplit && fword_ends 						     && (flags & WF_NEEDCOMP)) 		goodword_ends = FALSE; 	    else 		goodword_ends = TRUE;  	    p = NULL; 	    compound_ok = TRUE; 	    if (sp->ts_complen > sp->ts_compsplit) 	    { 		if (slang->sl_nobreak) 		{ 		    // There was a word before this word.  When there was no 		    // change in this word (it was correct) add the first word 		    // as a suggestion.  If this word was corrected too, we 		    // need to check if a correct word follows. 		    if (sp->ts_fidx - sp->ts_splitfidx 					  == sp->ts_twordlen - sp->ts_splitoff 			    && STRNCMP(fword + sp->ts_splitfidx, 					tword + sp->ts_splitoff, 					 sp->ts_fidx - sp->ts_splitfidx) == 0) 		    { 			preword[sp->ts_prewordlen] = NUL; 			newscore = score_wordcount_adj(slang, sp->ts_score, 						 preword + sp->ts_prewordlen, 						 sp->ts_prewordlen > 0); 			// Add the suggestion if the score isn't too bad. 			if (newscore <= su->su_maxscore) 			    add_suggestion(su, &su->su_ga, preword, 				    sp->ts_splitfidx - repextra, 				    newscore, 0, FALSE, 				    lp->lp_sallang, FALSE); 			break; 		    } 		} 		else 		{ 		    // There was a compound word before this word.  If this 		    // word does not support compounding then give up 		    // (splitting is tried for the word without compound 		    // flag). 		    if (((unsigned)flags >> 24) == 0 			    || sp->ts_twordlen - sp->ts_splitoff 						       < slang->sl_compminlen) 			break; 		    // For multi-byte chars check character length against 		    // COMPOUNDMIN. 		    if (has_mbyte 			    && slang->sl_compminlen > 0 			    && mb_charlen(tword + sp->ts_splitoff) 						       < slang->sl_compminlen) 			break;  		    compflags[sp->ts_complen] = ((unsigned)flags >> 24); 		    compflags[sp->ts_complen + 1] = NUL; 		    vim_strncpy(preword + sp->ts_prewordlen, 			    tword + sp->ts_splitoff, 			    sp->ts_twordlen - sp->ts_splitoff);  		    // Verify CHECKCOMPOUNDPATTERN  rules. 		    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen, 							  &slang->sl_comppat)) 			compound_ok = FALSE;  		    if (compound_ok) 		    { 			p = preword; 			while (*skiptowhite(p) != NUL) 			    p = skipwhite(skiptowhite(p)); 			if (fword_ends && !can_compound(slang, p, 						compflags + sp->ts_compsplit)) 			    // Compound is not allowed.  But it may still be 			    // possible if we add another (short) word. 			    compound_ok = FALSE; 		    }  		    // Get pointer to last char of previous word. 		    p = preword + sp->ts_prewordlen; 		    MB_PTR_BACK(preword, p); 		} 	    }  	    // Form the word with proper case in preword. 	    // If there is a word from a previous split, append. 	    // For the soundfold tree don't change the case, simply append. 	    if (soundfold) 		STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff); 	    else if (flags & WF_KEEPCAP) 		// Must find the word in the keep-case tree. 		find_keepcap_word(slang, tword + sp->ts_splitoff, 						 preword + sp->ts_prewordlen); 	    else 	    { 		// Include badflags: If the badword is onecap or allcap 		// use that for the goodword too.  But if the badword is 		// allcap and it's only one char long use onecap. 		c = su->su_badflags; 		if ((c & WF_ALLCAP) 			&& su->su_badlen == (*mb_ptr2len)(su->su_badptr)) 		    c = WF_ONECAP; 		c |= flags;  		// When appending a compound word after a word character don't 		// use Onecap. 		if (p != NULL && spell_iswordp_nmw(p, curwin)) 		    c &= ~WF_ONECAP; 		make_case_word(tword + sp->ts_splitoff, 					      preword + sp->ts_prewordlen, c); 	    }  	    if (!soundfold) 	    { 		// Don't use a banned word.  It may appear again as a good 		// word, thus remember it. 		if (flags & WF_BANNED) 		{ 		    add_banned(su, preword + sp->ts_prewordlen); 		    break; 		} 		if ((sp->ts_complen == sp->ts_compsplit 			    && WAS_BANNED(su, preword + sp->ts_prewordlen)) 						   || WAS_BANNED(su, preword)) 		{ 		    if (slang->sl_compprog == NULL) 			break; 		    // the word so far was banned but we may try compounding 		    goodword_ends = FALSE; 		} 	    }  	    newscore = 0; 	    if (!soundfold)	// soundfold words don't have flags 	    { 		if ((flags & WF_REGION) 			    && (((unsigned)flags >> 16) & lp->lp_region) == 0) 		    newscore += SCORE_REGION; 		if (flags & WF_RARE) 		    newscore += SCORE_RARE;  		if (!spell_valid_case(su->su_badflags, 				  captype(preword + sp->ts_prewordlen, NULL))) 		    newscore += SCORE_ICASE; 	    }  	    // TODO: how about splitting in the soundfold tree? 	    if (fword_ends 		    && goodword_ends 		    && sp->ts_fidx >= sp->ts_fidxtry 		    && compound_ok) 	    { 		// The badword also ends: add suggestions. #ifdef DEBUG_TRIEWALK 		if (soundfold && STRCMP(preword, ""smwrd"") == 0) 		{ 		    int	    j;  		    // print the stack of changes that brought us here 		    smsg(""------ %s -------"", fword); 		    for (j = 0; j < depth; ++j) 			smsg(""%s"", changename[j]); 		} #endif 		if (soundfold) 		{ 		    // For soundfolded words we need to find the original 		    // words, the edit distance and then add them. 		    add_sound_suggest(su, preword, sp->ts_score, lp); 		} 		else if (sp->ts_fidx > 0) 		{ 		    // Give a penalty when changing non-word char to word 		    // char, e.g., ""thes,"" -> ""these"". 		    p = fword + sp->ts_fidx; 		    MB_PTR_BACK(fword, p); 		    if (!spell_iswordp(p, curwin) && *preword != NUL) 		    { 			p = preword + STRLEN(preword); 			MB_PTR_BACK(preword, p); 			if (spell_iswordp(p, curwin)) 			    newscore += SCORE_NONWORD; 		    }  		    // Give a bonus to words seen before. 		    score = score_wordcount_adj(slang, 						sp->ts_score + newscore, 						preword + sp->ts_prewordlen, 						sp->ts_prewordlen > 0);  		    // Add the suggestion if the score isn't too bad. 		    if (score <= su->su_maxscore) 		    { 			add_suggestion(su, &su->su_ga, preword, 				    sp->ts_fidx - repextra, 				    score, 0, FALSE, lp->lp_sallang, FALSE);  			if (su->su_badflags & WF_MIXCAP) 			{ 			    // We really don't know if the word should be 			    // upper or lower case, add both. 			    c = captype(preword, NULL); 			    if (c == 0 || c == WF_ALLCAP) 			    { 				make_case_word(tword + sp->ts_splitoff, 					      preword + sp->ts_prewordlen, 						      c == 0 ? WF_ALLCAP : 0);  				add_suggestion(su, &su->su_ga, preword, 					sp->ts_fidx - repextra, 					score + SCORE_ICASE, 0, FALSE, 					lp->lp_sallang, FALSE); 			    } 			} 		    } 		} 	    }  	    // Try word split and/or compounding. 	    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends) 		    // Don't split halfway a character. 		    && (!has_mbyte || sp->ts_tcharlen == 0)) 	    { 		int	try_compound; 		int	try_split;  		// If past the end of the bad word don't try a split. 		// Otherwise try changing the next word.  E.g., find 		// suggestions for ""the the"" where the second ""the"" is 		// different.  It's done like a split. 		// TODO: word split for soundfold words 		try_split = (sp->ts_fidx - repextra < su->su_badlen) 								&& !soundfold;  		// Get here in several situations: 		// 1. The word in the tree ends: 		//    If the word allows compounding try that.  Otherwise try 		//    a split by inserting a space.  For both check that a 		//    valid words starts at fword[sp->ts_fidx]. 		//    For NOBREAK do like compounding to be able to check if 		//    the next word is valid. 		// 2. The badword does end, but it was due to a change (e.g., 		//    a swap).  No need to split, but do check that the 		//    following word is valid. 		// 3. The badword and the word in the tree end.  It may still 		//    be possible to compound another (short) word. 		try_compound = FALSE; 		if (!soundfold 			&& !slang->sl_nocompoundsugs 			&& slang->sl_compprog != NULL 			&& ((unsigned)flags >> 24) != 0 			&& sp->ts_twordlen - sp->ts_splitoff 						       >= slang->sl_compminlen 			&& (!has_mbyte 			    || slang->sl_compminlen == 0 			    || mb_charlen(tword + sp->ts_splitoff) 						      >= slang->sl_compminlen) 			&& (slang->sl_compsylmax < MAXWLEN 			    || sp->ts_complen + 1 - sp->ts_compsplit 							  < slang->sl_compmax) 			&& (can_be_compound(sp, slang, 					 compflags, ((unsigned)flags >> 24))))  		{ 		    try_compound = TRUE; 		    compflags[sp->ts_complen] = ((unsigned)flags >> 24); 		    compflags[sp->ts_complen + 1] = NUL; 		}  		// For NOBREAK we never try splitting, it won't make any word 		// valid. 		if (slang->sl_nobreak && !slang->sl_nocompoundsugs) 		    try_compound = TRUE;  		// If we could add a compound word, and it's also possible to 		// split at this point, do the split first and set 		// TSF_DIDSPLIT to avoid doing it again. 		else if (!fword_ends 			&& try_compound 			&& (sp->ts_flags & TSF_DIDSPLIT) == 0) 		{ 		    try_compound = FALSE; 		    sp->ts_flags |= TSF_DIDSPLIT; 		    --sp->ts_curi;	    // do the same NUL again 		    compflags[sp->ts_complen] = NUL; 		} 		else 		    sp->ts_flags &= ~TSF_DIDSPLIT;  		if (try_split || try_compound) 		{ 		    if (!try_compound && (!fword_ends || !goodword_ends)) 		    { 			// If we're going to split need to check that the 			// words so far are valid for compounding.  If there 			// is only one word it must not have the NEEDCOMPOUND 			// flag. 			if (sp->ts_complen == sp->ts_compsplit 						     && (flags & WF_NEEDCOMP)) 			    break; 			p = preword; 			while (*skiptowhite(p) != NUL) 			    p = skipwhite(skiptowhite(p)); 			if (sp->ts_complen > sp->ts_compsplit 				&& !can_compound(slang, p, 						compflags + sp->ts_compsplit)) 			    break;  			if (slang->sl_nosplitsugs) 			    newscore += SCORE_SPLIT_NO; 			else 			    newscore += SCORE_SPLIT;  			// Give a bonus to words seen before. 			newscore = score_wordcount_adj(slang, newscore, 					   preword + sp->ts_prewordlen, TRUE); 		    }  		    if (TRY_DEEPER(su, stack, depth, newscore)) 		    { 			go_deeper(stack, depth, newscore); #ifdef DEBUG_TRIEWALK 			if (!try_compound && !fword_ends) 			    sprintf(changename[depth], ""%.*s-%s: split"", 				 sp->ts_twordlen, tword, fword + sp->ts_fidx); 			else 			    sprintf(changename[depth], ""%.*s-%s: compound"", 				 sp->ts_twordlen, tword, fword + sp->ts_fidx); #endif 			// Save things to be restored at STATE_SPLITUNDO. 			sp->ts_save_badflags = su->su_badflags; 			PROF_STORE(sp->ts_state) 			sp->ts_state = STATE_SPLITUNDO;  			++depth; 			sp = &stack[depth];  			// Append a space to preword when splitting. 			if (!try_compound && !fword_ends) 			    STRCAT(preword, "" ""); 			sp->ts_prewordlen = (char_u)STRLEN(preword); 			sp->ts_splitoff = sp->ts_twordlen; 			sp->ts_splitfidx = sp->ts_fidx;  			// If the badword has a non-word character at this 			// position skip it.  That means replacing the 			// non-word character with a space.  Always skip a 			// character when the word ends.  But only when the 			// good word can end. 			if (((!try_compound && !spell_iswordp_nmw(fword 							       + sp->ts_fidx, 							       curwin)) 				    || fword_ends) 				&& fword[sp->ts_fidx] != NUL 				&& goodword_ends) 			{ 			    int	    l;  			    l = mb_ptr2len(fword + sp->ts_fidx); 			    if (fword_ends) 			    { 				// Copy the skipped character to preword. 				mch_memmove(preword + sp->ts_prewordlen, 						      fword + sp->ts_fidx, l); 				sp->ts_prewordlen += l; 				preword[sp->ts_prewordlen] = NUL; 			    } 			    else 				sp->ts_score -= SCORE_SPLIT - SCORE_SUBST; 			    sp->ts_fidx += l; 			}  			// When compounding include compound flag in 			// compflags[] (already set above).  When splitting we 			// may start compounding over again. 			if (try_compound) 			    ++sp->ts_complen; 			else 			    sp->ts_compsplit = sp->ts_complen; 			sp->ts_prefixdepth = PFD_NOPREFIX;  			// set su->su_badflags to the caps type at this 			// position 			if (has_mbyte) 			    n = nofold_len(fword, sp->ts_fidx, su->su_badptr); 			else 			    n = sp->ts_fidx; 			su->su_badflags = badword_captype(su->su_badptr + n, 					       su->su_badptr + su->su_badlen);  			// Restart at top of the tree. 			sp->ts_arridx = 0;  			// If there are postponed prefixes, try these too. 			if (pbyts != NULL) 			{ 			    byts = pbyts; 			    idxs = pidxs; 			    sp->ts_prefixdepth = PFD_PREFIXTREE; 			    PROF_STORE(sp->ts_state) 			    sp->ts_state = STATE_NOPREFIX; 			} 		    } 		} 	    } 	    break;  	case STATE_SPLITUNDO: 	    // Undo the changes done for word split or compound word. 	    su->su_badflags = sp->ts_save_badflags;  	    // Continue looking for NUL bytes. 	    PROF_STORE(sp->ts_state) 	    sp->ts_state = STATE_START;  	    // In case we went into the prefix tree. 	    byts = fbyts; 	    idxs = fidxs; 	    break;  	case STATE_ENDNUL: 	    // Past the NUL bytes in the node. 	    su->su_badflags = sp->ts_save_badflags; 	    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0) 	    { 		// The badword ends, can't use STATE_PLAIN. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_DEL; 		break; 	    } 	    PROF_STORE(sp->ts_state) 	    sp->ts_state = STATE_PLAIN; 	    // FALLTHROUGH  	case STATE_PLAIN: 	    // Go over all possible bytes at this node, add each to tword[] 	    // and use child node.  ""ts_curi"" is the index. 	    arridx = sp->ts_arridx; 	    if (sp->ts_curi > byts[arridx]) 	    { 		// Done all bytes at this node, do next state.  When still at 		// already changed bytes skip the other tricks. 		PROF_STORE(sp->ts_state) 		if (sp->ts_fidx >= sp->ts_fidxtry) 		    sp->ts_state = STATE_DEL; 		else 		    sp->ts_state = STATE_FINAL; 	    } 	    else 	    { 		arridx += sp->ts_curi++; 		c = byts[arridx];  		// Normal byte, go one level deeper.  If it's not equal to the 		// byte in the bad word adjust the score.  But don't even try 		// when the byte was already changed.  And don't try when we 		// just deleted this byte, accepting it is always cheaper than 		// delete + substitute. 		if (c == fword[sp->ts_fidx] 			|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE)) 		    newscore = 0; 		else 		    newscore = SCORE_SUBST; 		if ((newscore == 0 			    || (sp->ts_fidx >= sp->ts_fidxtry 				&& ((sp->ts_flags & TSF_DIDDEL) == 0 				    || c != fword[sp->ts_delidx]))) 			&& TRY_DEEPER(su, stack, depth, newscore)) 		{ 		    go_deeper(stack, depth, newscore); #ifdef DEBUG_TRIEWALK 		    if (newscore > 0) 			sprintf(changename[depth], ""%.*s-%s: subst %c to %c"", 				sp->ts_twordlen, tword, fword + sp->ts_fidx, 				fword[sp->ts_fidx], c); 		    else 			sprintf(changename[depth], ""%.*s-%s: accept %c"", 				sp->ts_twordlen, tword, fword + sp->ts_fidx, 				fword[sp->ts_fidx]); #endif 		    ++depth; 		    sp = &stack[depth]; 		    if (fword[sp->ts_fidx] != NUL) 			++sp->ts_fidx; 		    tword[sp->ts_twordlen++] = c; 		    sp->ts_arridx = idxs[arridx]; 		    if (newscore == SCORE_SUBST) 			sp->ts_isdiff = DIFF_YES; 		    if (has_mbyte) 		    { 			// Multi-byte characters are a bit complicated to 			// handle: They differ when any of the bytes differ 			// and then their length may also differ. 			if (sp->ts_tcharlen == 0) 			{ 			    // First byte. 			    sp->ts_tcharidx = 0; 			    sp->ts_tcharlen = MB_BYTE2LEN(c); 			    sp->ts_fcharstart = sp->ts_fidx - 1; 			    sp->ts_isdiff = (newscore != 0) 						       ? DIFF_YES : DIFF_NONE; 			} 			else if (sp->ts_isdiff == DIFF_INSERT) 			    // When inserting trail bytes don't advance in the 			    // bad word. 			    --sp->ts_fidx; 			if (++sp->ts_tcharidx == sp->ts_tcharlen) 			{ 			    // Last byte of character. 			    if (sp->ts_isdiff == DIFF_YES) 			    { 				// Correct ts_fidx for the byte length of the 				// character (we didn't check that before). 				sp->ts_fidx = sp->ts_fcharstart 					    + mb_ptr2len( 						    fword + sp->ts_fcharstart); 				// For changing a composing character adjust 				// the score from SCORE_SUBST to 				// SCORE_SUBCOMP. 				if (enc_utf8 					&& utf_iscomposing( 					    utf_ptr2char(tword 						+ sp->ts_twordlen 							   - sp->ts_tcharlen)) 					&& utf_iscomposing( 					    utf_ptr2char(fword 							+ sp->ts_fcharstart))) 				    sp->ts_score -= 						  SCORE_SUBST - SCORE_SUBCOMP;  				// For a similar character adjust score from 				// SCORE_SUBST to SCORE_SIMILAR. 				else if (!soundfold 					&& slang->sl_has_map 					&& similar_chars(slang, 					    mb_ptr2char(tword 						+ sp->ts_twordlen 							   - sp->ts_tcharlen), 					    mb_ptr2char(fword 							+ sp->ts_fcharstart))) 				    sp->ts_score -= 						  SCORE_SUBST - SCORE_SIMILAR; 			    } 			    else if (sp->ts_isdiff == DIFF_INSERT 					 && sp->ts_twordlen > sp->ts_tcharlen) 			    { 				p = tword + sp->ts_twordlen - sp->ts_tcharlen; 				c = mb_ptr2char(p); 				if (enc_utf8 && utf_iscomposing(c)) 				{ 				    // Inserting a composing char doesn't 				    // count that much. 				    sp->ts_score -= SCORE_INS - SCORE_INSCOMP; 				} 				else 				{ 				    // If the previous character was the same, 				    // thus doubling a character, give a bonus 				    // to the score.  Also for the soundfold 				    // tree (might seem illogical but does 				    // give better scores). 				    MB_PTR_BACK(tword, p); 				    if (c == mb_ptr2char(p)) 					sp->ts_score -= SCORE_INS 							       - SCORE_INSDUP; 				} 			    }  			    // Starting a new char, reset the length. 			    sp->ts_tcharlen = 0; 			} 		    } 		    else 		    { 			// If we found a similar char adjust the score. 			// We do this after calling go_deeper() because 			// it's slow. 			if (newscore != 0 				&& !soundfold 				&& slang->sl_has_map 				&& similar_chars(slang, 						   c, fword[sp->ts_fidx - 1])) 			    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR; 		    } 		} 	    } 	    break;  	case STATE_DEL: 	    // When past the first byte of a multi-byte char don't try 	    // delete/insert/swap a character. 	    if (has_mbyte && sp->ts_tcharlen > 0) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_FINAL; 		break; 	    } 	    // Try skipping one character in the bad word (delete it). 	    PROF_STORE(sp->ts_state) 	    sp->ts_state = STATE_INS_PREP; 	    sp->ts_curi = 1; 	    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*') 		// Deleting a vowel at the start of a word counts less, see 		// soundalike_score(). 		newscore = 2 * SCORE_DEL / 3; 	    else 		newscore = SCORE_DEL; 	    if (fword[sp->ts_fidx] != NUL 				    && TRY_DEEPER(su, stack, depth, newscore)) 	    { 		go_deeper(stack, depth, newscore); #ifdef DEBUG_TRIEWALK 		sprintf(changename[depth], ""%.*s-%s: delete %c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			fword[sp->ts_fidx]); #endif 		++depth;  		// Remember what character we deleted, so that we can avoid 		// inserting it again. 		stack[depth].ts_flags |= TSF_DIDDEL; 		stack[depth].ts_delidx = sp->ts_fidx;  		// Advance over the character in fword[].  Give a bonus to the 		// score if the same character is following ""nn"" -> ""n"".  It's 		// a bit illogical for soundfold tree but it does give better 		// results. 		if (has_mbyte) 		{ 		    c = mb_ptr2char(fword + sp->ts_fidx); 		    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx); 		    if (enc_utf8 && utf_iscomposing(c)) 			stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP; 		    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx)) 			stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP; 		} 		else 		{ 		    ++stack[depth].ts_fidx; 		    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1]) 			stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP; 		} 		break; 	    } 	    // FALLTHROUGH  	case STATE_INS_PREP: 	    if (sp->ts_flags & TSF_DIDDEL) 	    { 		// If we just deleted a byte then inserting won't make sense, 		// a substitute is always cheaper. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_SWAP; 		break; 	    }  	    // skip over NUL bytes 	    n = sp->ts_arridx; 	    for (;;) 	    { 		if (sp->ts_curi > byts[n]) 		{ 		    // Only NUL bytes at this node, go to next state. 		    PROF_STORE(sp->ts_state) 		    sp->ts_state = STATE_SWAP; 		    break; 		} 		if (byts[n + sp->ts_curi] != NUL) 		{ 		    // Found a byte to insert. 		    PROF_STORE(sp->ts_state) 		    sp->ts_state = STATE_INS; 		    break; 		} 		++sp->ts_curi; 	    } 	    break;  	    // FALLTHROUGH  	case STATE_INS: 	    // Insert one byte.  Repeat this for each possible byte at this 	    // node. 	    n = sp->ts_arridx; 	    if (sp->ts_curi > byts[n]) 	    { 		// Done all bytes at this node, go to next state. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_SWAP; 		break; 	    }  	    // Do one more byte at this node, but: 	    // - Skip NUL bytes. 	    // - Skip the byte if it's equal to the byte in the word, 	    //   accepting that byte is always better. 	    n += sp->ts_curi++; 	    c = byts[n]; 	    if (soundfold && sp->ts_twordlen == 0 && c == '*') 		// Inserting a vowel at the start of a word counts less, 		// see soundalike_score(). 		newscore = 2 * SCORE_INS / 3; 	    else 		newscore = SCORE_INS; 	    if (c != fword[sp->ts_fidx] 				    && TRY_DEEPER(su, stack, depth, newscore)) 	    { 		go_deeper(stack, depth, newscore); #ifdef DEBUG_TRIEWALK 		sprintf(changename[depth], ""%.*s-%s: insert %c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			c); #endif 		++depth; 		sp = &stack[depth]; 		tword[sp->ts_twordlen++] = c; 		sp->ts_arridx = idxs[n]; 		if (has_mbyte) 		{ 		    fl = MB_BYTE2LEN(c); 		    if (fl > 1) 		    { 			// There are following bytes for the same character. 			// We must find all bytes before trying 			// delete/insert/swap/etc. 			sp->ts_tcharlen = fl; 			sp->ts_tcharidx = 1; 			sp->ts_isdiff = DIFF_INSERT; 		    } 		} 		else 		    fl = 1; 		if (fl == 1) 		{ 		    // If the previous character was the same, thus doubling a 		    // character, give a bonus to the score.  Also for 		    // soundfold words (illogical but does give a better 		    // score). 		    if (sp->ts_twordlen >= 2 					   && tword[sp->ts_twordlen - 2] == c) 			sp->ts_score -= SCORE_INS - SCORE_INSDUP; 		} 	    } 	    break;  	case STATE_SWAP: 	    // Swap two bytes in the bad word: ""12"" -> ""21"". 	    // We change ""fword"" here, it's changed back afterwards at 	    // STATE_UNSWAP. 	    p = fword + sp->ts_fidx; 	    c = *p; 	    if (c == NUL) 	    { 		// End of word, can't swap or replace. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_FINAL; 		break; 	    }  	    // Don't swap if the first character is not a word character. 	    // SWAP3 etc. also don't make sense then. 	    if (!soundfold && !spell_iswordp(p, curwin)) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 		break; 	    }  	    if (has_mbyte) 	    { 		n = MB_CPTR2LEN(p); 		c = mb_ptr2char(p); 		if (p[n] == NUL) 		    c2 = NUL; 		else if (!soundfold && !spell_iswordp(p + n, curwin)) 		    c2 = c; // don't swap non-word char 		else 		    c2 = mb_ptr2char(p + n); 	    } 	    else 	    { 		if (p[1] == NUL) 		    c2 = NUL; 		else if (!soundfold && !spell_iswordp(p + 1, curwin)) 		    c2 = c; // don't swap non-word char 		else 		    c2 = p[1]; 	    }  	    // When the second character is NUL we can't swap. 	    if (c2 == NUL) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 		break; 	    }  	    // When characters are identical, swap won't do anything. 	    // Also get here if the second char is not a word character. 	    if (c == c2) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_SWAP3; 		break; 	    } 	    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP)) 	    { 		go_deeper(stack, depth, SCORE_SWAP); #ifdef DEBUG_TRIEWALK 		sprintf(changename[depth], ""%.*s-%s: swap %c and %c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			c, c2); #endif 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_UNSWAP; 		++depth; 		if (has_mbyte) 		{ 		    fl = mb_char2len(c2); 		    mch_memmove(p, p + n, fl); 		    mb_char2bytes(c, p + fl); 		    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl; 		} 		else 		{ 		    p[0] = c2; 		    p[1] = c; 		    stack[depth].ts_fidxtry = sp->ts_fidx + 2; 		} 	    } 	    else 	    { 		// If this swap doesn't work then SWAP3 won't either. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 	    } 	    break;  	case STATE_UNSWAP: 	    // Undo the STATE_SWAP swap: ""21"" -> ""12"". 	    p = fword + sp->ts_fidx; 	    if (has_mbyte) 	    { 		n = mb_ptr2len(p); 		c = mb_ptr2char(p + n); 		mch_memmove(p + mb_ptr2len(p + n), p, n); 		mb_char2bytes(c, p); 	    } 	    else 	    { 		c = *p; 		*p = p[1]; 		p[1] = c; 	    } 	    // FALLTHROUGH  	case STATE_SWAP3: 	    // Swap two bytes, skipping one: ""123"" -> ""321"".  We change 	    // ""fword"" here, it's changed back afterwards at STATE_UNSWAP3. 	    p = fword + sp->ts_fidx; 	    if (has_mbyte) 	    { 		n = MB_CPTR2LEN(p); 		c = mb_ptr2char(p); 		fl = MB_CPTR2LEN(p + n); 		c2 = mb_ptr2char(p + n); 		if (!soundfold && !spell_iswordp(p + n + fl, curwin)) 		    c3 = c;	// don't swap non-word char 		else 		    c3 = mb_ptr2char(p + n + fl); 	    } 	    else 	    { 		c = *p; 		c2 = p[1]; 		if (!soundfold && !spell_iswordp(p + 2, curwin)) 		    c3 = c;	// don't swap non-word char 		else 		    c3 = p[2]; 	    }  	    // When characters are identical: ""121"" then SWAP3 result is 	    // identical, ROT3L result is same as SWAP: ""211"", ROT3L result is 	    // same as SWAP on next char: ""112"".  Thus skip all swapping. 	    // Also skip when c3 is NUL. 	    // Also get here when the third character is not a word character. 	    // Second character may any char: ""a.b"" -> ""b.a"" 	    if (c == c3 || c3 == NUL) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 		break; 	    } 	    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) 	    { 		go_deeper(stack, depth, SCORE_SWAP3); #ifdef DEBUG_TRIEWALK 		sprintf(changename[depth], ""%.*s-%s: swap3 %c and %c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			c, c3); #endif 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_UNSWAP3; 		++depth; 		if (has_mbyte) 		{ 		    tl = mb_char2len(c3); 		    mch_memmove(p, p + n + fl, tl); 		    mb_char2bytes(c2, p + tl); 		    mb_char2bytes(c, p + fl + tl); 		    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl; 		} 		else 		{ 		    p[0] = p[2]; 		    p[2] = c; 		    stack[depth].ts_fidxtry = sp->ts_fidx + 3; 		} 	    } 	    else 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 	    } 	    break;  	case STATE_UNSWAP3: 	    // Undo STATE_SWAP3: ""321"" -> ""123"" 	    p = fword + sp->ts_fidx; 	    if (has_mbyte) 	    { 		n = mb_ptr2len(p); 		c2 = mb_ptr2char(p + n); 		fl = mb_ptr2len(p + n); 		c = mb_ptr2char(p + n + fl); 		tl = mb_ptr2len(p + n + fl); 		mch_memmove(p + fl + tl, p, n); 		mb_char2bytes(c, p); 		mb_char2bytes(c2, p + tl); 		p = p + tl; 	    } 	    else 	    { 		c = *p; 		*p = p[2]; 		p[2] = c; 		++p; 	    }  	    if (!soundfold && !spell_iswordp(p, curwin)) 	    { 		// Middle char is not a word char, skip the rotate.  First and 		// third char were already checked at swap and swap3. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 		break; 	    }  	    // Rotate three characters left: ""123"" -> ""231"".  We change 	    // ""fword"" here, it's changed back afterwards at STATE_UNROT3L. 	    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) 	    { 		go_deeper(stack, depth, SCORE_SWAP3); #ifdef DEBUG_TRIEWALK 		p = fword + sp->ts_fidx; 		sprintf(changename[depth], ""%.*s-%s: rotate left %c%c%c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			p[0], p[1], p[2]); #endif 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_UNROT3L; 		++depth; 		p = fword + sp->ts_fidx; 		if (has_mbyte) 		{ 		    n = MB_CPTR2LEN(p); 		    c = mb_ptr2char(p); 		    fl = MB_CPTR2LEN(p + n); 		    fl += MB_CPTR2LEN(p + n + fl); 		    mch_memmove(p, p + n, fl); 		    mb_char2bytes(c, p + fl); 		    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl; 		} 		else 		{ 		    c = *p; 		    *p = p[1]; 		    p[1] = p[2]; 		    p[2] = c; 		    stack[depth].ts_fidxtry = sp->ts_fidx + 3; 		} 	    } 	    else 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 	    } 	    break;  	case STATE_UNROT3L: 	    // Undo ROT3L: ""231"" -> ""123"" 	    p = fword + sp->ts_fidx; 	    if (has_mbyte) 	    { 		n = mb_ptr2len(p); 		n += mb_ptr2len(p + n); 		c = mb_ptr2char(p + n); 		tl = mb_ptr2len(p + n); 		mch_memmove(p + tl, p, n); 		mb_char2bytes(c, p); 	    } 	    else 	    { 		c = p[2]; 		p[2] = p[1]; 		p[1] = *p; 		*p = c; 	    }  	    // Rotate three bytes right: ""123"" -> ""312"".  We change ""fword"" 	    // here, it's changed back afterwards at STATE_UNROT3R. 	    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) 	    { 		go_deeper(stack, depth, SCORE_SWAP3); #ifdef DEBUG_TRIEWALK 		p = fword + sp->ts_fidx; 		sprintf(changename[depth], ""%.*s-%s: rotate right %c%c%c"", 			sp->ts_twordlen, tword, fword + sp->ts_fidx, 			p[0], p[1], p[2]); #endif 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_UNROT3R; 		++depth; 		p = fword + sp->ts_fidx; 		if (has_mbyte) 		{ 		    n = MB_CPTR2LEN(p); 		    n += MB_CPTR2LEN(p + n); 		    c = mb_ptr2char(p + n); 		    tl = MB_CPTR2LEN(p + n); 		    mch_memmove(p + tl, p, n); 		    mb_char2bytes(c, p); 		    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl; 		} 		else 		{ 		    c = p[2]; 		    p[2] = p[1]; 		    p[1] = *p; 		    *p = c; 		    stack[depth].ts_fidxtry = sp->ts_fidx + 3; 		} 	    } 	    else 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_REP_INI; 	    } 	    break;  	case STATE_UNROT3R: 	    // Undo ROT3R: ""312"" -> ""123"" 	    p = fword + sp->ts_fidx; 	    if (has_mbyte) 	    { 		c = mb_ptr2char(p); 		tl = mb_ptr2len(p); 		n = mb_ptr2len(p + tl); 		n += mb_ptr2len(p + tl + n); 		mch_memmove(p, p + tl, n); 		mb_char2bytes(c, p + n); 	    } 	    else 	    { 		c = *p; 		*p = p[1]; 		p[1] = p[2]; 		p[2] = c; 	    } 	    // FALLTHROUGH  	case STATE_REP_INI: 	    // Check if matching with REP items from the .aff file would work. 	    // Quickly skip if: 	    // - there are no REP items and we are not in the soundfold trie 	    // - the score is going to be too high anyway 	    // - already applied a REP item or swapped here 	    if ((lp->lp_replang == NULL && !soundfold) 		    || sp->ts_score + SCORE_REP >= su->su_maxscore 		    || sp->ts_fidx < sp->ts_fidxtry) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_FINAL; 		break; 	    }  	    // Use the first byte to quickly find the first entry that may 	    // match.  If the index is -1 there is none. 	    if (soundfold) 		sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]]; 	    else 		sp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];  	    if (sp->ts_curi < 0) 	    { 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_FINAL; 		break; 	    }  	    PROF_STORE(sp->ts_state) 	    sp->ts_state = STATE_REP; 	    // FALLTHROUGH  	case STATE_REP: 	    // Try matching with REP items from the .aff file.  For each match 	    // replace the characters and check if the resulting word is 	    // valid. 	    p = fword + sp->ts_fidx;  	    if (soundfold) 		gap = &slang->sl_repsal; 	    else 		gap = &lp->lp_replang->sl_rep; 	    while (sp->ts_curi < gap->ga_len) 	    { 		ftp = (fromto_T *)gap->ga_data + sp->ts_curi++; 		if (*ftp->ft_from != *p) 		{ 		    // past possible matching entries 		    sp->ts_curi = gap->ga_len; 		    break; 		} 		if (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0 			&& TRY_DEEPER(su, stack, depth, SCORE_REP)) 		{ 		    go_deeper(stack, depth, SCORE_REP); #ifdef DEBUG_TRIEWALK 		    sprintf(changename[depth], ""%.*s-%s: replace %s with %s"", 			    sp->ts_twordlen, tword, fword + sp->ts_fidx, 			    ftp->ft_from, ftp->ft_to); #endif 		    // Need to undo this afterwards. 		    PROF_STORE(sp->ts_state) 		    sp->ts_state = STATE_REP_UNDO;  		    // Change the ""from"" to the ""to"" string. 		    ++depth; 		    fl = (int)STRLEN(ftp->ft_from); 		    tl = (int)STRLEN(ftp->ft_to); 		    if (fl != tl) 		    { 			STRMOVE(p + tl, p + fl); 			repextra += tl - fl; 		    } 		    mch_memmove(p, ftp->ft_to, tl); 		    stack[depth].ts_fidxtry = sp->ts_fidx + tl; 		    stack[depth].ts_tcharlen = 0; 		    break; 		} 	    }  	    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP) 	    { 		// No (more) matches. 		PROF_STORE(sp->ts_state) 		sp->ts_state = STATE_FINAL; 	    }  	    break;  	case STATE_REP_UNDO: 	    // Undo a REP replacement and continue with the next one. 	    if (soundfold) 		gap = &slang->sl_repsal; 	    else 		gap = &lp->lp_replang->sl_rep; 	    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1; 	    fl = (int)STRLEN(ftp->ft_from); 	    tl = (int)STRLEN(ftp->ft_to); 	    p = fword + sp->ts_fidx; 	    if (fl != tl) 	    { 		STRMOVE(p + fl, p + tl); 		repextra -= tl - fl; 	    } 	    mch_memmove(p, ftp->ft_from, fl); 	    PROF_STORE(sp->ts_state) 	    sp->ts_state = STATE_REP; 	    break;  	default: 	    // Did all possible states at this level, go up one level. 	    --depth;  	    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE) 	    { 		// Continue in or go back to the prefix tree. 		byts = pbyts; 		idxs = pidxs; 	    }  	    // Don't check for CTRL-C too often, it takes time. 	    if (--breakcheckcount == 0) 	    { 		ui_breakcheck(); 		breakcheckcount = 1000; #ifdef FEAT_RELTIME 		if (spell_suggest_timeout > 0 					  && profile_passed_limit(&time_limit)) 		    got_int = TRUE; #endif 	    } 	}     } }"
"200379_CWE-476.c","CWE-476","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) { 	int i; 	if (!bin) { 		return NULL; 	} 	RList *segments = r_list_newf (free); 	for (i = 0; i < bin->ne_header->SegCount; i++) { 		RBinSection *bs = R_NEW0 (RBinSection); 		if (!bs) { 			return segments; 		} 		NE_image_segment_entry *se = &bin->segment_entries[i]; 		bs->size = se->length; 		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000; 		bs->bits = R_SYS_BITS_16; 		bs->is_data = se->flags & IS_DATA; 		bs->perm = __translate_perms (se->flags); 		bs->paddr = (ut64)se->offset * bin->alignment; 		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr); 		bs->is_segment = true; 		r_list_append (segments, bs); 	} 	bin->segments = segments; 	return segments; }"
"200672_CWE-119.c","CWE-119","static void sdhci_do_adma(SDHCIState *s) {     unsigned int begin, length;     const uint16_t block_size = s->blksize & BLOCK_SIZE_MASK;     ADMADescr dscr = {};     int i;      if (s->trnmod & SDHC_TRNS_BLK_CNT_EN && !s->blkcnt) {         /* Stop Multiple Transfer */         sdhci_end_transfer(s);         return;     }      for (i = 0; i < SDHC_ADMA_DESCS_PER_DELAY; ++i) {         s->admaerr &= ~SDHC_ADMAERR_LENGTH_MISMATCH;          get_adma_description(s, &dscr);         trace_sdhci_adma_loop(dscr.addr, dscr.length, dscr.attr);          if ((dscr.attr & SDHC_ADMA_ATTR_VALID) == 0) {             /* Indicate that error occurred in ST_FDS state */             s->admaerr &= ~SDHC_ADMAERR_STATE_MASK;             s->admaerr |= SDHC_ADMAERR_STATE_ST_FDS;              /* Generate ADMA error interrupt */             if (s->errintstsen & SDHC_EISEN_ADMAERR) {                 s->errintsts |= SDHC_EIS_ADMAERR;                 s->norintsts |= SDHC_NIS_ERR;             }              sdhci_update_irq(s);             return;         }          length = dscr.length ? dscr.length : 64 * KiB;          switch (dscr.attr & SDHC_ADMA_ATTR_ACT_MASK) {         case SDHC_ADMA_ATTR_ACT_TRAN:  /* data transfer */             if (s->trnmod & SDHC_TRNS_READ) {                 while (length) {                     if (s->data_count == 0) {                         sdbus_read_data(&s->sdbus, s->fifo_buffer, block_size);                     }                     begin = s->data_count;                     if ((length + begin) < block_size) {                         s->data_count = length + begin;                         length = 0;                      } else {                         s->data_count = block_size;                         length -= block_size - begin;                     }                     dma_memory_write(s->dma_as, dscr.addr,                                      &s->fifo_buffer[begin],                                      s->data_count - begin);                     dscr.addr += s->data_count - begin;                     if (s->data_count == block_size) {                         s->data_count = 0;                         if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {                             s->blkcnt--;                             if (s->blkcnt == 0) {                                 break;                             }                         }                     }                 }             } else {                 while (length) {                     begin = s->data_count;                     if ((length + begin) < block_size) {                         s->data_count = length + begin;                         length = 0;                      } else {                         s->data_count = block_size;                         length -= block_size - begin;                     }                     dma_memory_read(s->dma_as, dscr.addr,                                     &s->fifo_buffer[begin],                                     s->data_count - begin);                     dscr.addr += s->data_count - begin;                     if (s->data_count == block_size) {                         sdbus_write_data(&s->sdbus, s->fifo_buffer, block_size);                         s->data_count = 0;                         if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {                             s->blkcnt--;                             if (s->blkcnt == 0) {                                 break;                             }                         }                     }                 }             }             s->admasysaddr += dscr.incr;             break;         case SDHC_ADMA_ATTR_ACT_LINK:   /* link to next descriptor table */             s->admasysaddr = dscr.addr;             trace_sdhci_adma(""link"", s->admasysaddr);             break;         default:             s->admasysaddr += dscr.incr;             break;         }          if (dscr.attr & SDHC_ADMA_ATTR_INT) {             trace_sdhci_adma(""interrupt"", s->admasysaddr);             if (s->norintstsen & SDHC_NISEN_DMA) {                 s->norintsts |= SDHC_NIS_DMA;             }              if (sdhci_update_irq(s) && !(dscr.attr & SDHC_ADMA_ATTR_END)) {                 /* IRQ delivered, reschedule current transfer */                 break;             }         }          /* ADMA transfer terminates if blkcnt == 0 or by END attribute */         if (((s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&                     (s->blkcnt == 0)) || (dscr.attr & SDHC_ADMA_ATTR_END)) {             trace_sdhci_adma_transfer_completed();             if (length || ((dscr.attr & SDHC_ADMA_ATTR_END) &&                 (s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&                 s->blkcnt != 0)) {                 trace_sdhci_error(""SD/MMC host ADMA length mismatch"");                 s->admaerr |= SDHC_ADMAERR_LENGTH_MISMATCH |                         SDHC_ADMAERR_STATE_ST_TFR;                 if (s->errintstsen & SDHC_EISEN_ADMAERR) {                     trace_sdhci_error(""Set ADMA error flag"");                     s->errintsts |= SDHC_EIS_ADMAERR;                     s->norintsts |= SDHC_NIS_ERR;                 }                  sdhci_update_irq(s);             }             sdhci_end_transfer(s);             return;         }      }      /* we have unfinished business - reschedule to continue ADMA */     timer_mod(s->transfer_timer,                    qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_TRANSFER_DELAY); }"
"200695_CWE-401.c","CWE-401","static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf, 				  struct dma_buf_attachment *attachment) { 	struct fastrpc_dma_buf_attachment *a; 	struct fastrpc_buf *buffer = dmabuf->priv; 	int ret;  	a = kzalloc(sizeof(*a), GFP_KERNEL); 	if (!a) 		return -ENOMEM;  	ret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt, 			      FASTRPC_PHYS(buffer->phys), buffer->size); 	if (ret < 0) { 		dev_err(buffer->dev, ""failed to get scatterlist from DMA API\n""); 		return -EINVAL; 	}  	a->dev = attachment->dev; 	INIT_LIST_HEAD(&a->node); 	attachment->priv = a;  	mutex_lock(&buffer->lock); 	list_add(&a->node, &buffer->attachments); 	mutex_unlock(&buffer->lock);  	return 0; }"
"200781_CWE-787.c","CWE-787","cvtchar(register const char *sp) /* convert a character to a terminfo push */ {     unsigned char c = 0;     int len;      switch (*sp) {     case '\\': 	switch (*++sp) { 	case '\'': 	case '$': 	case '\\': 	case '%': 	    c = UChar(*sp); 	    len = 2; 	    break; 	case '\0': 	    c = '\\'; 	    len = 1; 	    break; 	case '0': 	case '1': 	case '2': 	case '3': 	    len = 1; 	    while (isdigit(UChar(*sp))) { 		c = UChar(8 * c + (*sp++ - '0')); 		len++; 	    } 	    break; 	default: 	    c = UChar(*sp); 	    len = (c != '\0') ? 2 : 1; 	    break; 	} 	break;     case '^': 	c = UChar(*++sp); 	if (c == '?') 	    c = 127; 	else 	    c &= 0x1f; 	len = 2; 	break;     default: 	c = UChar(*sp); 	len = (c != '\0') ? 1 : 0;     }     if (isgraph(c) && c != ',' && c != '\'' && c != '\\' && c != ':') { 	dp = save_string(dp, ""%\'""); 	dp = save_char(dp, c); 	dp = save_char(dp, '\'');     } else if (c != '\0') { 	dp = save_string(dp, ""%{""); 	if (c > 99) 	    dp = save_char(dp, c / 100 + '0'); 	if (c > 9) 	    dp = save_char(dp, ((int) (c / 10)) % 10 + '0'); 	dp = save_char(dp, c % 10 + '0'); 	dp = save_char(dp, '}');     }     return len; }"
"200831_CWE-264.c","CWE-264","set_routerstatus_from_routerinfo(routerstatus_t *rs,                                  routerinfo_t *ri, time_t now,                                  int naming, int listbadexits,                                  int listbaddirs, int vote_on_hsdirs) {   int unstable_version =     !tor_version_as_new_as(ri->platform,""0.1.1.16-rc-cvs"");   memset(rs, 0, sizeof(routerstatus_t));    rs->is_authority =     router_digest_is_trusted_dir(ri->cache_info.identity_digest);    /* Already set by compute_performance_thresholds. */   rs->is_exit = ri->is_exit;   rs->is_stable = ri->is_stable =     router_is_active(ri, now) &&     !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&     !unstable_version;   rs->is_fast = ri->is_fast =     router_is_active(ri, now) &&     !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);   rs->is_running = ri->is_running; /* computed above */    if (naming) {     uint32_t name_status = dirserv_get_name_status(                          ri->cache_info.identity_digest, ri->nickname);     rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;     rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;   }   rs->is_valid = ri->is_valid;    if (rs->is_fast &&       (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||        router_get_advertised_bandwidth(ri) >=                               MIN(guard_bandwidth_including_exits,                                   guard_bandwidth_excluding_exits))) {     long tk = rep_hist_get_weighted_time_known(                                       ri->cache_info.identity_digest, now);     double wfu = rep_hist_get_weighted_fractional_uptime(                                       ri->cache_info.identity_digest, now);     rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;   } else {     rs->is_possible_guard = 0;   }   rs->is_bad_directory = listbaddirs && ri->is_bad_directory;   rs->is_bad_exit = listbadexits && ri->is_bad_exit;   ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);   rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;   rs->is_v2_dir = ri->dir_port != 0;    if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))     rs->is_named = rs->is_unnamed = 0;    rs->published_on = ri->cache_info.published_on;   memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);   memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,          DIGEST_LEN);   rs->addr = ri->addr;   strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));   rs->or_port = ri->or_port;   rs->dir_port = ri->dir_port; }"
"200895_CWE-703.c","CWE-703","call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx) {     callback_T	*cb = &qftf_cb;     list_T	*qftf_list = NULL;      // If 'quickfixtextfunc' is set, then use the user-supplied function to get     // the text to display. Use the local value of 'quickfixtextfunc' if it is     // set.     if (qfl->qf_qftf_cb.cb_name != NULL) 	cb = &qfl->qf_qftf_cb;     if (cb->cb_name != NULL)     { 	typval_T	args[1]; 	dict_T		*d; 	typval_T	rettv;  	// create the dict argument 	if ((d = dict_alloc_lock(VAR_FIXED)) == NULL) 	    return NULL; 	dict_add_number(d, ""quickfix"", (long)IS_QF_LIST(qfl)); 	dict_add_number(d, ""winid"", (long)qf_winid); 	dict_add_number(d, ""id"", (long)qfl->qf_id); 	dict_add_number(d, ""start_idx"", start_idx); 	dict_add_number(d, ""end_idx"", end_idx); 	++d->dv_refcount; 	args[0].v_type = VAR_DICT; 	args[0].vval.v_dict = d;  	qftf_list = NULL; 	if (call_callback(cb, 0, &rettv, 1, args) != FAIL) 	{ 	    if (rettv.v_type == VAR_LIST) 	    { 		qftf_list = rettv.vval.v_list; 		qftf_list->lv_refcount++; 	    } 	    clear_tv(&rettv); 	} 	dict_unref(d);     }      return qftf_list; }"
"200934_CWE-212.c","CWE-212","testBackingParse(const void *args) {     const struct testBackingParseData *data = args;     g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;     g_autofree char *xml = NULL;     g_autoptr(virStorageSource) src = NULL;     int rc;     int erc = data->rv;      /* expect failure return code with NULL expected data */     if (!data->expect)         erc = -1;      if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {         fprintf(stderr, ""expected return value '%d' actual '%d'\n"", erc, rc);         return -1;     }      if (!src)         return 0;      if (src && !data->expect) {         fprintf(stderr, ""parsing of backing store string '%s' should ""                         ""have failed\n"", data->backing);         return -1;     }      if (virDomainDiskSourceFormat(&buf, src, ""source"", 0, false, 0, true, NULL) < 0 ||         !(xml = virBufferContentAndReset(&buf))) {         fprintf(stderr, ""failed to format disk source xml\n"");         return -1;     }      if (STRNEQ(xml, data->expect)) {         fprintf(stderr, ""\n backing store string '%s'\n""                         ""expected storage source xml:\n%s\n""                         ""actual storage source xml:\n%s\n"",                         data->backing, data->expect, xml);         return -1;     }      return 0; }"
"200976_CWE-787.c","CWE-787","get_visual_text(     cmdarg_T	*cap,     char_u	**pp,	    // return: start of selected text     int		*lenp)	    // return: length of selected text {     if (VIsual_mode != 'V') 	unadjust_for_sel();     if (VIsual.lnum != curwin->w_cursor.lnum)     { 	if (cap != NULL) 	    clearopbeep(cap->oap); 	return FAIL;     }     if (VIsual_mode == 'V')     { 	*pp = ml_get_curline(); 	*lenp = (int)STRLEN(*pp);     }     else     { 	if (LT_POS(curwin->w_cursor, VIsual)) 	{ 	    *pp = ml_get_pos(&curwin->w_cursor); 	    *lenp = VIsual.col - curwin->w_cursor.col + 1; 	} 	else 	{ 	    *pp = ml_get_pos(&VIsual); 	    *lenp = curwin->w_cursor.col - VIsual.col + 1; 	} 	if (**pp == NUL) 	    *lenp = 0; 	if (has_mbyte && *lenp > 0) 	    // Correct the length to include all bytes of the last character. 	    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;     }     reset_VIsual_and_resel();     return OK; }"
"201006_CWE-416.h","CWE-416","static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, 			       pt_element_t __user *ptep_user, unsigned index, 			       pt_element_t orig_pte, pt_element_t new_pte) { 	int npages; 	pt_element_t ret; 	pt_element_t *table; 	struct page *page;  	npages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page); 	if (likely(npages == 1)) { 		table = kmap_atomic(page); 		ret = CMPXCHG(&table[index], orig_pte, new_pte); 		kunmap_atomic(table);  		kvm_release_page_dirty(page); 	} else { 		struct vm_area_struct *vma; 		unsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK; 		unsigned long pfn; 		unsigned long paddr;  		mmap_read_lock(current->mm); 		vma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE); 		if (!vma || !(vma->vm_flags & VM_PFNMAP)) { 			mmap_read_unlock(current->mm); 			return -EFAULT; 		} 		pfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff; 		paddr = pfn << PAGE_SHIFT; 		table = memremap(paddr, PAGE_SIZE, MEMREMAP_WB); 		if (!table) { 			mmap_read_unlock(current->mm); 			return -EFAULT; 		} 		ret = CMPXCHG(&table[index], orig_pte, new_pte); 		memunmap(table); 		mmap_read_unlock(current->mm); 	}  	return (ret != orig_pte); }"
"201007_CWE-787.c","CWE-787","static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len) {     char *p = buf;     char *end = buf+len;     unsigned i;     int printed;      /* check length for the ""m="" line. */     if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) { 	return -1;     }     *p++ = 'm';	    /* m= */     *p++ = '=';     pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);     p += m->desc.media.slen;     *p++ = ' ';     printed = pj_utoa(m->desc.port, p);     p += printed;     if (m->desc.port_count > 1) { 	*p++ = '/'; 	printed = pj_utoa(m->desc.port_count, p); 	p += printed;     }     *p++ = ' ';     pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);     p += m->desc.transport.slen;     for (i=0; i<m->desc.fmt_count; ++i) { 	*p++ = ' '; 	pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen); 	p += m->desc.fmt[i].slen;     }     *p++ = '\r';     *p++ = '\n';      /* print connection info, if present. */     if (m->conn) { 	printed = print_connection_info(m->conn, p, (int)(end-p)); 	if (printed < 0) { 	    return -1; 	} 	p += printed;     }          /* print optional bandwidth info. */     for (i=0; i<m->bandw_count; ++i) { 	printed = (int)print_bandw(m->bandw[i], p, end-p); 	if (printed < 0) { 	    return -1; 	} 	p += printed;     }      /* print attributes. */     for (i=0; i<m->attr_count; ++i) { 	printed = (int)print_attr(m->attr[i], p, end-p); 	if (printed < 0) { 	    return -1; 	} 	p += printed;     }      return (int)(p-buf); }"
"201343_CWE-416.c","CWE-416","static int selinux_ptrace_traceme(struct task_struct *parent) { 	return avc_has_perm(&selinux_state, 			    task_sid_subj(parent), task_sid_obj(current), 			    SECCLASS_PROCESS, PROCESS__PTRACE, NULL); }"
"201353_CWE-415.c","CWE-415","static int rsi_init_usb_interface(struct rsi_hw *adapter, 				  struct usb_interface *pfunction) { 	struct rsi_91x_usbdev *rsi_dev; 	int status;  	rsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL); 	if (!rsi_dev) 		return -ENOMEM;  	adapter->rsi_dev = rsi_dev; 	rsi_dev->usbdev = interface_to_usbdev(pfunction); 	rsi_dev->priv = (void *)adapter;  	if (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) { 		status = -EINVAL; 		goto fail_eps; 	}  	adapter->device = &pfunction->dev; 	usb_set_intfdata(pfunction, adapter);  	rsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL); 	if (!rsi_dev->tx_buffer) { 		status = -ENOMEM; 		goto fail_eps; 	}  	if (rsi_usb_init_rx(adapter)) { 		rsi_dbg(ERR_ZONE, ""Failed to init RX handle\n""); 		status = -ENOMEM; 		goto fail_rx; 	}  	rsi_dev->tx_blk_size = 252; 	adapter->block_size = rsi_dev->tx_blk_size;  	/* Initializing function callbacks */ 	adapter->check_hw_queue_status = rsi_usb_check_queue_status; 	adapter->determine_event_timeout = rsi_usb_event_timeout; 	adapter->rsi_host_intf = RSI_HOST_INTF_USB; 	adapter->host_intf_ops = &usb_host_intf_ops;  #ifdef CONFIG_RSI_DEBUGFS 	/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries is required */ 	adapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1); #endif  	rsi_dbg(INIT_ZONE, ""%s: Enabled the interface\n"", __func__); 	return 0;  fail_rx: 	kfree(rsi_dev->tx_buffer);  fail_eps: 	kfree(rsi_dev);  	return status; }"
"201382_CWE-787.c","CWE-787","drill_parse_T_code(gerb_file_t *fd, drill_state_t *state, 			gerbv_image_t *image, ssize_t file_line) {     int tool_num;     gboolean done = FALSE;     int temp;     double size;     gerbv_drill_stats_t *stats = image->drill_stats;     gerbv_aperture_t *apert;     gchar *tmps;     gchar *string;      dprintf(""---> entering %s()...\n"", __FUNCTION__);      /* Sneak a peek at what's hiding after the 'T'. Ugly fix for        broken headers from Orcad, which is crap */     temp = gerb_fgetc(fd);     dprintf(""  Found a char '%s' (0x%02x) after the T\n"", 	    gerbv_escape_char(temp), temp);          /* might be a tool tool change stop switch on/off*/     if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){     	if(gerb_fgetc(fd) == 'S'){     	    if (gerb_fgetc(fd) == 'T' ){     	  	fd->ptr -= 4;     	  	tmps = get_line(fd++);     	  	gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1, 			_(""Tool change stop switch found \""%s\"" "" 			    ""at line %ld in file \""%s\""""), 			tmps, file_line, fd->filename); 	  	g_free (tmps);  	  	return -1; 	    } 	    gerb_ungetc(fd); 	} 	gerb_ungetc(fd);     }      if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) { 	if(temp != EOF) { 	    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 		   _(""OrCAD bug: Junk text found in place of tool definition"")); 	    tmps = get_line(fd); 	    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1, 		    _(""Junk text \""%s\"" "" 			""at line %ld in file \""%s\""""), 		    tmps, file_line, fd->filename); 	    g_free (tmps); 	    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1, 				  _(""Ignoring junk text"")); 	} 	return -1;     }     gerb_ungetc(fd);      tool_num = (int) gerb_fgetint(fd, NULL);     dprintf (""  Handling tool T%d at line %ld\n"", tool_num, file_line);      if (tool_num == 0)  	return tool_num; /* T00 is a command to unload the drill */      if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) { 	gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 		_(""Out of bounds drill number %d "" 		    ""at line %ld in file \""%s\""""), 		tool_num, file_line, fd->filename);     }      /* Set the current tool to the correct one */     state->current_tool = tool_num;     apert = image->aperture[tool_num];      /* Check for a size definition */     temp = gerb_fgetc(fd);      /* This bit of code looks for a tool definition by scanning for strings      * of form TxxC, TxxF, TxxS.  */     while (!done) { 	switch((char)temp) { 	case 'C': 	    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals); 	    dprintf (""  Read a size of %g\n"", size);  	    if (state->unit == GERBV_UNIT_MM) { 		size /= 25.4; 	    } else if(size >= 4.0) { 		/* If the drill size is >= 4 inches, assume that this 		   must be wrong and that the units are mils. 		   The limit being 4 inches is because the smallest drill 		   I've ever seen used is 0,3mm(about 12mil). Half of that 		   seemed a bit too small a margin, so a third it is */  		gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 			_(""Read a drill of diameter %g inches "" 			    ""at line %ld in file \""%s\""""), 			    size, file_line, fd->filename); 		gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1, 			_(""Assuming units are mils"")); 		size /= 1000.0; 	    }  	    if (size <= 0. || size >= 10000.) { 		gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 			_(""Unreasonable drill size %g found for drill %d "" 			    ""at line %ld in file \""%s\""""), 			    size, tool_num, file_line, fd->filename); 	    } else { 		if (apert != NULL) { 		    /* allow a redefine of a tool only if the new definition is exactly the same. 		     * This avoid lots of spurious complaints with the output of some cad 		     * tools while keeping complaints if there is a true problem 		     */ 		    if (apert->parameter[0] != size 		    ||  apert->type != GERBV_APTYPE_CIRCLE 		    ||  apert->nuf_parameters != 1 		    ||  apert->unit != GERBV_UNIT_INCH) {  			gerbv_stats_printf(stats->error_list, 				GERBV_MESSAGE_ERROR, -1, 				_(""Found redefinition of drill %d "" 				""at line %ld in file \""%s\""""), 				tool_num, file_line, fd->filename); 		    } 		} else { 		    apert = image->aperture[tool_num] = 						g_new0(gerbv_aperture_t, 1); 		    if (apert == NULL) 			GERB_FATAL_ERROR(""malloc tool failed in %s()"", 					__FUNCTION__);  		    /* There's really no way of knowing what unit the tools 		       are defined in without sneaking a peek in the rest of 		       the file first. That's done in drill_guess_format() */ 		    apert->parameter[0] = size; 		    apert->type = GERBV_APTYPE_CIRCLE; 		    apert->nuf_parameters = 1; 		    apert->unit = GERBV_UNIT_INCH; 		} 	    } 	     	    /* Add the tool whose definition we just found into the list 	     * of tools for this layer used to generate statistics. */ 	    stats = image->drill_stats; 	    string = g_strdup_printf(""%s"", (state->unit == GERBV_UNIT_MM ? _(""mm"") : _(""inch""))); 	    drill_stats_add_to_drill_list(stats->drill_list,  					  tool_num,  					  state->unit == GERBV_UNIT_MM ? size*25.4 : size,  					  string); 	    g_free(string); 	    break;  	case 'F': 	case 'S' : 	    /* Silently ignored. They're not important. */ 	    gerb_fgetint(fd, NULL); 	    break;  	default: 	    /* Stop when finding anything but what's expected 	       (and put it back) */ 	    gerb_ungetc(fd); 	    done = TRUE; 	    break; 	}  /* switch((char)temp) */  	temp = gerb_fgetc(fd); 	if (EOF == temp) { 	    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 		    _(""Unexpected EOF encountered in header of "" 			""drill file \""%s\""""), fd->filename);  	/* Restore new line character for processing */ 	if ('\n' == temp || '\r' == temp) 	    gerb_ungetc(fd); 	}     }   /* while(!done) */  /* Done looking at tool definitions */      /* Catch the tools that aren't defined.        This isn't strictly a good thing, but at least something is shown */     if (apert == NULL) {         double dia;  	apert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1); 	if (apert == NULL) 	    GERB_FATAL_ERROR(""malloc tool failed in %s()"", __FUNCTION__);          /* See if we have the tool table */         dia = gerbv_get_tool_diameter(tool_num);         if (dia <= 0) {             /*              * There is no tool. So go out and make some.              * This size calculation is, of course, totally bogus.              */             dia = (double)(16 + 8 * tool_num) / 1000;             /*              * Oooh, this is sooo ugly. But some CAD systems seem to always              * use T00 at the end of the file while others that don't have              * tool definitions inside the file never seem to use T00 at all.              */             if (tool_num != 0) { 		gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1, 			_(""Tool %02d used without being defined "" 			    ""at line %ld in file \""%s\""""), 			tool_num, file_line, fd->filename); 		gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1, 			_(""Setting a default size of %g\""""), dia);             } 	}  	apert->type = GERBV_APTYPE_CIRCLE; 	apert->nuf_parameters = 1; 	apert->parameter[0] = dia;  	/* Add the tool whose definition we just found into the list 	 * of tools for this layer used to generate statistics. */ 	if (tool_num != 0) {  /* Only add non-zero tool nums.   			       * Zero = unload command. */ 	    stats = image->drill_stats; 	    string = g_strdup_printf(""%s"",  				     (state->unit == GERBV_UNIT_MM ? _(""mm"") : _(""inch""))); 	    drill_stats_add_to_drill_list(stats->drill_list,  					  tool_num,  					  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia, 					  string); 	    g_free(string); 	}     } /* if(image->aperture[tool_num] == NULL) */	          dprintf(""<----  ...leaving %s()\n"", __FUNCTION__);      return tool_num; } /* drill_parse_T_code() */"
"201384_CWE-787.c","CWE-787","ga_concat_shorten_esc(garray_T *gap, char_u *str) {     char_u  *p;     char_u  *s;     int	    c;     int	    clen;     char_u  buf[NUMBUFLEN];     int	    same_len;      if (str == NULL)     { 	ga_concat(gap, (char_u *)""NULL""); 	return;     }      for (p = str; *p != NUL; ++p)     { 	same_len = 1; 	s = p; 	c = mb_ptr2char_adv(&s); 	clen = s - p; 	while (*s != NUL && c == mb_ptr2char(s)) 	{ 	    ++same_len; 	    s += clen; 	} 	if (same_len > 20) 	{ 	    ga_concat(gap, (char_u *)""\\[""); 	    ga_concat_esc(gap, p, clen); 	    ga_concat(gap, (char_u *)"" occurs ""); 	    vim_snprintf((char *)buf, NUMBUFLEN, ""%d"", same_len); 	    ga_concat(gap, buf); 	    ga_concat(gap, (char_u *)"" times]""); 	    p = s - 1; 	} 	else 	    ga_concat_esc(gap, p, clen);     } }"
"201451_CWE-787.c","CWE-787","static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define MonoColorType  1 #define RGBColorType  3    char     property[MaxTextExtent];    CINInfo     cin;    Image     *image;    MagickBooleanType     status;    MagickOffsetType     offset;    QuantumInfo     *quantum_info;    QuantumType     quantum_type;    ssize_t     i;    PixelPacket     *q;    size_t     extent,     length;    ssize_t     count,     y;    unsigned char     magick[4],     *pixels;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     File information.   */   offset=0;   count=ReadBlob(image,4,magick);   offset+=count;   if ((count != 4) ||       ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   memset(&cin,0,sizeof(cin));   image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&     (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;   cin.file.image_offset=ReadBlobLong(image);   offset+=4;   cin.file.generic_length=ReadBlobLong(image);   offset+=4;   cin.file.industry_length=ReadBlobLong(image);   offset+=4;   cin.file.user_length=ReadBlobLong(image);   offset+=4;   cin.file.file_size=ReadBlobLong(image);   offset+=4;   offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)     cin.file.version);   (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));   (void) SetImageProperty(image,""dpx:file.version"",property);   offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)     cin.file.filename);   (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));   (void) SetImageProperty(image,""dpx:file.filename"",property);   offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)     cin.file.create_date);   (void) CopyMagickString(property,cin.file.create_date,     sizeof(cin.file.create_date));   (void) SetImageProperty(image,""dpx:file.create_date"",property);   offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)     cin.file.create_time);   (void) CopyMagickString(property,cin.file.create_time,      sizeof(cin.file.create_time));   (void) SetImageProperty(image,""dpx:file.create_time"",property);   offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)     cin.file.reserve);   /*     Image information.   */   cin.image.orientation=(unsigned char) ReadBlobByte(image);   offset++;   if (cin.image.orientation != (unsigned char) (~0))     (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",       cin.image.orientation);   switch (cin.image.orientation)   {     default:     case 0: image->orientation=TopLeftOrientation; break;     case 1: image->orientation=TopRightOrientation; break;     case 2: image->orientation=BottomLeftOrientation; break;     case 3: image->orientation=BottomRightOrientation; break;     case 4: image->orientation=LeftTopOrientation; break;     case 5: image->orientation=RightTopOrientation; break;     case 6: image->orientation=LeftBottomOrientation; break;     case 7: image->orientation=RightBottomOrientation; break;   }   cin.image.number_channels=(unsigned char) ReadBlobByte(image);   offset++;   offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)     cin.image.reserve1);   for (i=0; i < 8; i++)   {     cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].pixels_per_line=ReadBlobLong(image);     offset+=4;     cin.image.channel[i].lines_per_image=ReadBlobLong(image);     offset+=4;     cin.image.channel[i].min_data=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].min_quantity=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].max_data=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].max_quantity=ReadBlobFloat(image);     offset+=4;   }   cin.image.white_point[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)     image->chromaticity.white_point.x=cin.image.white_point[0];   cin.image.white_point[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)     image->chromaticity.white_point.y=cin.image.white_point[1];   cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];   cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];   cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];   cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];   cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];   cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];   offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)     cin.image.label);   (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));   (void) SetImageProperty(image,""dpx:image.label"",property);   offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)     cin.image.reserve);   /*     Image data format information.   */   cin.data_format.interleave=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.packing=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.sign=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.sense=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.line_pad=ReadBlobLong(image);   offset+=4;   cin.data_format.channel_pad=ReadBlobLong(image);   offset+=4;   offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)     cin.data_format.reserve);   /*     Image origination information.   */   cin.origination.x_offset=ReadBlobSignedLong(image);   offset+=4;   if ((size_t) cin.origination.x_offset != ~0UL)     (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",       (double) cin.origination.x_offset);   cin.origination.y_offset=(ssize_t) ReadBlobLong(image);   offset+=4;   if ((size_t) cin.origination.y_offset != ~0UL)     (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",       (double) cin.origination.y_offset);   offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)     cin.origination.filename);   (void) CopyMagickString(property,cin.origination.filename,     sizeof(cin.origination.filename));   (void) SetImageProperty(image,""dpx:origination.filename"",property);   offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)     cin.origination.create_date);   (void) CopyMagickString(property,cin.origination.create_date,     sizeof(cin.origination.create_date));   (void) SetImageProperty(image,""dpx:origination.create_date"",property);   offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)     cin.origination.create_time);   (void) CopyMagickString(property,cin.origination.create_time,     sizeof(cin.origination.create_time));   (void) SetImageProperty(image,""dpx:origination.create_time"",property);   offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)     cin.origination.device);   (void) CopyMagickString(property,cin.origination.device,     sizeof(cin.origination.device));   (void) SetImageProperty(image,""dpx:origination.device"",property);   offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)     cin.origination.model);   (void) CopyMagickString(property,cin.origination.model,     sizeof(cin.origination.model));   (void) SetImageProperty(image,""dpx:origination.model"",property);   (void) memset(cin.origination.serial,0,     sizeof(cin.origination.serial));   offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)     cin.origination.serial);   (void) CopyMagickString(property,cin.origination.serial,     sizeof(cin.origination.serial));   (void) SetImageProperty(image,""dpx:origination.serial"",property);   cin.origination.x_pitch=ReadBlobFloat(image);   offset+=4;   cin.origination.y_pitch=ReadBlobFloat(image);   offset+=4;   cin.origination.gamma=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.origination.gamma) != MagickFalse)     image->gamma=cin.origination.gamma;   offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)     cin.origination.reserve);   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))     {       int         c;        /*         Image film information.       */       cin.film.id=ReadBlobByte(image);       offset++;       c=cin.film.id;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);       cin.film.type=ReadBlobByte(image);       offset++;       c=cin.film.type;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);       cin.film.offset=ReadBlobByte(image);       offset++;       c=cin.film.offset;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",           cin.film.offset);       cin.film.reserve1=ReadBlobByte(image);       offset++;       cin.film.prefix=ReadBlobLong(image);       offset+=4;       if (cin.film.prefix != ~0UL)         (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)           cin.film.prefix);       cin.film.count=ReadBlobLong(image);       offset+=4;       offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)         cin.film.format);       (void) CopyMagickString(property,cin.film.format,         sizeof(cin.film.format));       (void) SetImageProperty(image,""dpx:film.format"",property);       cin.film.frame_position=ReadBlobLong(image);       offset+=4;       if (cin.film.frame_position != ~0UL)         (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",           (double) cin.film.frame_position);       cin.film.frame_rate=ReadBlobFloat(image);       offset+=4;       if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)         (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",           cin.film.frame_rate);       offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)         cin.film.frame_id);       (void) CopyMagickString(property,cin.film.frame_id,         sizeof(cin.film.frame_id));       (void) SetImageProperty(image,""dpx:film.frame_id"",property);       offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)         cin.film.slate_info);       (void) CopyMagickString(property,cin.film.slate_info,         sizeof(cin.film.slate_info));       (void) SetImageProperty(image,""dpx:film.slate_info"",property);       offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)         cin.film.reserve);     }   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))     {       StringInfo         *profile;        /*         User defined data.       */       if (cin.file.user_length > GetBlobSize(image))         ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");       profile=BlobToStringInfo((const void *) NULL,cin.file.user_length);       if (profile == (StringInfo *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       offset+=ReadBlob(image,GetStringInfoLength(profile),         GetStringInfoDatum(profile));       (void) SetImageProfile(image,""dpx:user.data"",profile);       profile=DestroyStringInfo(profile);     }   image->depth=cin.image.channel[0].bits_per_pixel;   image->columns=cin.image.channel[0].pixels_per_line;   image->rows=cin.image.channel[0].lines_per_image;   if (image_info->ping != MagickFalse)     {       (void) CloseBlob(image);       return(image);     }   if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))     ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)   {     int       c;      c=ReadBlobByte(image);     if (c == EOF)       break;   }   if (offset < (MagickOffsetType) cin.file.image_offset)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   status=SetImageExtent(image,image->columns,image->rows);   if (status == MagickFalse)     {       InheritException(exception,&image->exception);       return(DestroyImageList(image));     }   (void) SetImageBackgroundColor(image);   /*     Convert CIN raster image to pixel packets.   */   quantum_info=AcquireQuantumInfo(image_info,image);   if (quantum_info == (QuantumInfo *) NULL)     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");   SetQuantumQuantum(quantum_info,32);   SetQuantumPack(quantum_info,MagickFalse);   quantum_type=RGBQuantum;   extent=GetQuantumExtent(image,quantum_info,quantum_type);   (void) extent;   length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);   if (cin.image.number_channels == 1)     {       quantum_type=GrayQuantum;       length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);     }   status=SetQuantumPad(image,quantum_info,0);   pixels=GetQuantumPixels(quantum_info);   for (y=0; y < (ssize_t) image->rows; y++)   {     const void       *stream;      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);     if (q == (PixelPacket *) NULL)       break;     stream=ReadBlobStream(image,length,pixels,&count);     if (count != (ssize_t) length)       break;     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,       quantum_type,(unsigned char *) stream,exception);     if (SyncAuthenticPixels(image,exception) == MagickFalse)       break;     if (image->previous == (Image *) NULL)       {         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,           image->rows);         if (status == MagickFalse)           break;       }   }   SetQuantumImageType(image,quantum_type);   quantum_info=DestroyQuantumInfo(quantum_info);   if (EOFBlob(image) != MagickFalse)     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",       image->filename);   SetImageColorspace(image,LogColorspace);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"201872_CWE-310.c","CWE-310","_gnutls_server_select_suite(gnutls_session_t session, uint8_t * data, 			    unsigned int datalen) { 	int ret; 	unsigned int i, j, cipher_suites_size; 	size_t pk_algos_size; 	uint8_t cipher_suites[MAX_CIPHERSUITE_SIZE]; 	int retval; 	gnutls_pk_algorithm_t pk_algos[MAX_ALGOS];	/* will hold the pk algorithms 							 * supported by the peer. 							 */  	for (i = 0; i < datalen; i += 2) { 		/* TLS_RENEGO_PROTECTION_REQUEST = { 0x00, 0xff } */ 		if (session->internals.priorities.sr != SR_DISABLED && 		    data[i] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR && 		    data[i + 1] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR) { 			_gnutls_handshake_log 			    (""HSK[%p]: Received safe renegotiation CS\n"", 			     session); 			retval = _gnutls_ext_sr_recv_cs(session); 			if (retval < 0) { 				gnutls_assert(); 				return retval; 			} 		}  		/* TLS_FALLBACK_SCSV */ 		if (data[i] == GNUTLS_FALLBACK_SCSV_MAJOR && 		    data[i + 1] == GNUTLS_FALLBACK_SCSV_MINOR) { 			_gnutls_handshake_log 			    (""HSK[%p]: Received fallback CS\n"", 			     session);  			if (gnutls_protocol_get_version(session) != 			    GNUTLS_TLS_VERSION_MAX) 				return GNUTLS_E_INAPPROPRIATE_FALLBACK; 		} 	}  	pk_algos_size = MAX_ALGOS; 	ret = 	    server_find_pk_algos_in_ciphersuites(data, datalen, pk_algos, 						 &pk_algos_size); 	if (ret < 0) 		return gnutls_assert_val(ret);  	ret = 	    _gnutls_supported_ciphersuites(session, cipher_suites, 					   sizeof(cipher_suites)); 	if (ret < 0) 		return gnutls_assert_val(ret);  	cipher_suites_size = ret;  	/* Here we remove any ciphersuite that does not conform 	 * the certificate requested, or to the 	 * authentication requested (e.g. SRP). 	 */ 	ret = 	    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites, 						 cipher_suites_size, 						 pk_algos, pk_algos_size); 	if (ret <= 0) { 		gnutls_assert(); 		if (ret < 0) 			return ret; 		else 			return GNUTLS_E_UNKNOWN_CIPHER_SUITE; 	}  	cipher_suites_size = ret;  	/* Data length should be zero mod 2 since 	 * every ciphersuite is 2 bytes. (this check is needed 	 * see below). 	 */ 	if (datalen % 2 != 0) { 		gnutls_assert(); 		return GNUTLS_E_UNEXPECTED_PACKET_LENGTH; 	}  	memset(session->security_parameters.cipher_suite, 0, 2);  	retval = GNUTLS_E_UNKNOWN_CIPHER_SUITE;  	_gnutls_handshake_log 	    (""HSK[%p]: Requested cipher suites[size: %d]: \n"", session, 	     (int) datalen);  	if (session->internals.priorities.server_precedence == 0) { 		for (j = 0; j < datalen; j += 2) { 			_gnutls_handshake_log(""\t0x%.2x, 0x%.2x %s\n"", 					      data[j], data[j + 1], 					      _gnutls_cipher_suite_get_name 					      (&data[j])); 			for (i = 0; i < cipher_suites_size; i += 2) { 				if (memcmp(&cipher_suites[i], &data[j], 2) 				    == 0) { 					_gnutls_handshake_log 					    (""HSK[%p]: Selected cipher suite: %s\n"", 					     session, 					     _gnutls_cipher_suite_get_name 					     (&data[j])); 					memcpy(session-> 					       security_parameters. 					       cipher_suite, 					       &cipher_suites[i], 2); 					_gnutls_epoch_set_cipher_suite 					    (session, EPOCH_NEXT, 					     session->security_parameters. 					     cipher_suite);   					retval = 0; 					goto finish; 				} 			} 		} 	} else {		/* server selects */  		for (i = 0; i < cipher_suites_size; i += 2) { 			for (j = 0; j < datalen; j += 2) { 				if (memcmp(&cipher_suites[i], &data[j], 2) 				    == 0) { 					_gnutls_handshake_log 					    (""HSK[%p]: Selected cipher suite: %s\n"", 					     session, 					     _gnutls_cipher_suite_get_name 					     (&data[j])); 					memcpy(session-> 					       security_parameters. 					       cipher_suite, 					       &cipher_suites[i], 2); 					_gnutls_epoch_set_cipher_suite 					    (session, EPOCH_NEXT, 					     session->security_parameters. 					     cipher_suite);   					retval = 0; 					goto finish; 				} 			} 		} 	}       finish:  	if (retval != 0) { 		gnutls_assert(); 		return retval; 	}  	/* check if the credentials (username, public key etc.) are ok 	 */ 	if (_gnutls_get_kx_cred 	    (session, 	     _gnutls_cipher_suite_get_kx_algo(session->security_parameters. 					      cipher_suite)) == NULL) { 		gnutls_assert(); 		return GNUTLS_E_INSUFFICIENT_CREDENTIALS; 	}   	/* set the mod_auth_st to the appropriate struct 	 * according to the KX algorithm. This is needed since all the 	 * handshake functions are read from there; 	 */ 	session->internals.auth_struct = 	    _gnutls_kx_auth_struct(_gnutls_cipher_suite_get_kx_algo 				   (session->security_parameters. 				    cipher_suite)); 	if (session->internals.auth_struct == NULL) {  		_gnutls_handshake_log 		    (""HSK[%p]: Cannot find the appropriate handler for the KX algorithm\n"", 		     session); 		gnutls_assert(); 		return GNUTLS_E_INTERNAL_ERROR; 	}  	return 0;  }"
"201885_CWE-416.c","CWE-416","regmatch(     char_u	*scan,		    // Current node.     proftime_T	*tm UNUSED,	    // timeout limit or NULL     int		*timed_out UNUSED)  // flag set on timeout or NULL {   char_u	*next;		// Next node.   int		op;   int		c;   regitem_T	*rp;   int		no;   int		status;		// one of the RA_ values: #ifdef FEAT_RELTIME   int		tm_count = 0; #endif    // Make ""regstack"" and ""backpos"" empty.  They are allocated and freed in   // bt_regexec_both() to reduce malloc()/free() calls.   regstack.ga_len = 0;   backpos.ga_len = 0;    // Repeat until ""regstack"" is empty.   for (;;)   {     // Some patterns may take a long time to match, e.g., ""\([a-z]\+\)\+Q"".     // Allow interrupting them with CTRL-C.     fast_breakcheck();  #ifdef DEBUG     if (scan != NULL && regnarrate)     { 	mch_errmsg((char *)regprop(scan)); 	mch_errmsg(""(\n"");     } #endif      // Repeat for items that can be matched sequentially, without using the     // regstack.     for (;;)     { 	if (got_int || scan == NULL) 	{ 	    status = RA_FAIL; 	    break; 	} #ifdef FEAT_RELTIME 	// Check for timeout once in a 100 times to avoid overhead. 	if (tm != NULL && ++tm_count == 100) 	{ 	    tm_count = 0; 	    if (profile_passed_limit(tm)) 	    { 		if (timed_out != NULL) 		    *timed_out = TRUE; 		status = RA_FAIL; 		break; 	    } 	} #endif 	status = RA_CONT;  #ifdef DEBUG 	if (regnarrate) 	{ 	    mch_errmsg((char *)regprop(scan)); 	    mch_errmsg(""...\n""); # ifdef FEAT_SYN_HL 	    if (re_extmatch_in != NULL) 	    { 		int i;  		mch_errmsg(_(""External submatches:\n"")); 		for (i = 0; i < NSUBEXP; i++) 		{ 		    mch_errmsg(""    \""""); 		    if (re_extmatch_in->matches[i] != NULL) 			mch_errmsg((char *)re_extmatch_in->matches[i]); 		    mch_errmsg(""\""\n""); 		} 	    } # endif 	} #endif 	next = regnext(scan);  	op = OP(scan); 	// Check for character class with NL added. 	if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI 			     && *rex.input == NUL && rex.lnum <= rex.reg_maxline) 	{ 	    reg_nextline(); 	} 	else if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\n') 	{ 	    ADVANCE_REGINPUT(); 	} 	else 	{ 	  if (WITH_NL(op)) 	      op -= ADD_NL; 	  if (has_mbyte) 	      c = (*mb_ptr2char)(rex.input); 	  else 	      c = *rex.input; 	  switch (op) 	  { 	  case BOL: 	    if (rex.input != rex.line) 		status = RA_NOMATCH; 	    break;  	  case EOL: 	    if (c != NUL) 		status = RA_NOMATCH; 	    break;  	  case RE_BOF: 	    // We're not at the beginning of the file when below the first 	    // line where we started, not at the start of the line or we 	    // didn't start at the first line of the buffer. 	    if (rex.lnum != 0 || rex.input != rex.line 				       || (REG_MULTI && rex.reg_firstlnum > 1)) 		status = RA_NOMATCH; 	    break;  	  case RE_EOF: 	    if (rex.lnum != rex.reg_maxline || c != NUL) 		status = RA_NOMATCH; 	    break;  	  case CURSOR: 	    // Check if the buffer is in a window and compare the 	    // rex.reg_win->w_cursor position to the match position. 	    if (rex.reg_win == NULL 		    || (rex.lnum + rex.reg_firstlnum 						 != rex.reg_win->w_cursor.lnum) 		    || ((colnr_T)(rex.input - rex.line) 						 != rex.reg_win->w_cursor.col)) 		status = RA_NOMATCH; 	    break;  	  case RE_MARK: 	    // Compare the mark position to the match position. 	    { 		int	mark = OPERAND(scan)[0]; 		int	cmp = OPERAND(scan)[1]; 		pos_T	*pos;  		pos = getmark_buf(rex.reg_buf, mark, FALSE); 		if (pos == NULL		     // mark doesn't exist 			|| pos->lnum <= 0)   // mark isn't set in reg_buf 		{ 		    status = RA_NOMATCH; 		} 		else 		{ 		    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum 							  && pos->col == MAXCOL 				      ? (colnr_T)STRLEN(reg_getline( 						pos->lnum - rex.reg_firstlnum)) 				      : pos->col;  		    if ((pos->lnum == rex.lnum + rex.reg_firstlnum 				? (pos_col == (colnr_T)(rex.input - rex.line) 				    ? (cmp == '<' || cmp == '>') 				    : (pos_col < (colnr_T)(rex.input - rex.line) 					? cmp != '>' 					: cmp != '<')) 				: (pos->lnum < rex.lnum + rex.reg_firstlnum 				    ? cmp != '>' 				    : cmp != '<'))) 		    status = RA_NOMATCH; 		} 	    } 	    break;  	  case RE_VISUAL: 	    if (!reg_match_visual()) 		status = RA_NOMATCH; 	    break;  	  case RE_LNUM: 	    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum), 									scan)) 		status = RA_NOMATCH; 	    break;  	  case RE_COL: 	    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan)) 		status = RA_NOMATCH; 	    break;  	  case RE_VCOL: 	    if (!re_num_cmp((long_u)win_linetabsize( 			    rex.reg_win == NULL ? curwin : rex.reg_win, 			    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan)) 		status = RA_NOMATCH; 	    break;  	  case BOW:	// \<word; rex.input points to w 	    if (c == NUL)	// Can't match at end of line 		status = RA_NOMATCH; 	    else if (has_mbyte) 	    { 		int this_class;  		// Get class of current and previous char (if it exists). 		this_class = mb_get_class_buf(rex.input, rex.reg_buf); 		if (this_class <= 1) 		    status = RA_NOMATCH;  // not on a word at all 		else if (reg_prev_class() == this_class) 		    status = RA_NOMATCH;  // previous char is in same word 	    } 	    else 	    { 		if (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line 				&& vim_iswordc_buf(rex.input[-1], rex.reg_buf))) 		    status = RA_NOMATCH; 	    } 	    break;  	  case EOW:	// word\>; rex.input points after d 	    if (rex.input == rex.line)    // Can't match at start of line 		status = RA_NOMATCH; 	    else if (has_mbyte) 	    { 		int this_class, prev_class;  		// Get class of current and previous char (if it exists). 		this_class = mb_get_class_buf(rex.input, rex.reg_buf); 		prev_class = reg_prev_class(); 		if (this_class == prev_class 			|| prev_class == 0 || prev_class == 1) 		    status = RA_NOMATCH; 	    } 	    else 	    { 		if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf) 			|| (rex.input[0] != NUL 					   && vim_iswordc_buf(c, rex.reg_buf))) 		    status = RA_NOMATCH; 	    } 	    break; // Matched with EOW  	  case ANY: 	    // ANY does not match new lines. 	    if (c == NUL) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case IDENT: 	    if (!vim_isIDc(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SIDENT: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case KWORD: 	    if (!vim_iswordp_buf(rex.input, rex.reg_buf)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SKWORD: 	    if (VIM_ISDIGIT(*rex.input) 				    || !vim_iswordp_buf(rex.input, rex.reg_buf)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case FNAME: 	    if (!vim_isfilec(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SFNAME: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case PRINT: 	    if (!vim_isprintc(PTR2CHAR(rex.input))) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SPRINT: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input))) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case WHITE: 	    if (!VIM_ISWHITE(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NWHITE: 	    if (c == NUL || VIM_ISWHITE(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case DIGIT: 	    if (!ri_digit(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NDIGIT: 	    if (c == NUL || ri_digit(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case HEX: 	    if (!ri_hex(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NHEX: 	    if (c == NUL || ri_hex(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case OCTAL: 	    if (!ri_octal(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NOCTAL: 	    if (c == NUL || ri_octal(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case WORD: 	    if (!ri_word(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NWORD: 	    if (c == NUL || ri_word(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case HEAD: 	    if (!ri_head(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NHEAD: 	    if (c == NUL || ri_head(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case ALPHA: 	    if (!ri_alpha(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NALPHA: 	    if (c == NUL || ri_alpha(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case LOWER: 	    if (!ri_lower(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NLOWER: 	    if (c == NUL || ri_lower(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case UPPER: 	    if (!ri_upper(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NUPPER: 	    if (c == NUL || ri_upper(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case EXACTLY: 	    { 		int	len; 		char_u	*opnd;  		opnd = OPERAND(scan); 		// Inline the first byte, for speed. 		if (*opnd != *rex.input 			&& (!rex.reg_ic 			    || (!enc_utf8 			      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input)))) 		    status = RA_NOMATCH; 		else if (*opnd == NUL) 		{ 		    // match empty string always works; happens when ""~"" is 		    // empty. 		} 		else 		{ 		    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic)) 		    { 			len = 1;	// matched a single byte above 		    } 		    else 		    { 			// Need to match first byte again for multi-byte. 			len = (int)STRLEN(opnd); 			if (cstrncmp(opnd, rex.input, &len) != 0) 			    status = RA_NOMATCH; 		    } 		    // Check for following composing character, unless %C 		    // follows (skips over all composing chars). 		    if (status != RA_NOMATCH 			    && enc_utf8 			    && UTF_COMPOSINGLIKE(rex.input, rex.input + len) 			    && !rex.reg_icombine 			    && OP(next) != RE_COMPOSING) 		    { 			// raaron: This code makes a composing character get 			// ignored, which is the correct behavior (sometimes) 			// for voweled Hebrew texts. 			status = RA_NOMATCH; 		    } 		    if (status != RA_NOMATCH) 			rex.input += len; 		} 	    } 	    break;  	  case ANYOF: 	  case ANYBUT: 	    if (c == NUL) 		status = RA_NOMATCH; 	    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case MULTIBYTECODE: 	    if (has_mbyte) 	    { 		int	i, len; 		char_u	*opnd; 		int	opndc = 0, inpc;  		opnd = OPERAND(scan); 		// Safety check (just in case 'encoding' was changed since 		// compiling the program). 		if ((len = (*mb_ptr2len)(opnd)) < 2) 		{ 		    status = RA_NOMATCH; 		    break; 		} 		if (enc_utf8) 		    opndc = utf_ptr2char(opnd); 		if (enc_utf8 && utf_iscomposing(opndc)) 		{ 		    // When only a composing char is given match at any 		    // position where that composing char appears. 		    status = RA_NOMATCH; 		    for (i = 0; rex.input[i] != NUL; 						i += utf_ptr2len(rex.input + i)) 		    { 			inpc = utf_ptr2char(rex.input + i); 			if (!utf_iscomposing(inpc)) 			{ 			    if (i > 0) 				break; 			} 			else if (opndc == inpc) 			{ 			    // Include all following composing chars. 			    len = i + utfc_ptr2len(rex.input + i); 			    status = RA_MATCH; 			    break; 			} 		    } 		} 		else 		    for (i = 0; i < len; ++i) 			if (opnd[i] != rex.input[i]) 			{ 			    status = RA_NOMATCH; 			    break; 			} 		rex.input += len; 	    } 	    else 		status = RA_NOMATCH; 	    break; 	  case RE_COMPOSING: 	    if (enc_utf8) 	    { 		// Skip composing characters. 		while (utf_iscomposing(utf_ptr2char(rex.input))) 		    MB_CPTR_ADV(rex.input); 	    } 	    break;  	  case NOTHING: 	    break;  	  case BACK: 	    { 		int		i; 		backpos_T	*bp;  		// When we run into BACK we need to check if we don't keep 		// looping without matching any input.  The second and later 		// times a BACK is encountered it fails if the input is still 		// at the same position as the previous time. 		// The positions are stored in ""backpos"" and found by the 		// current value of ""scan"", the position in the RE program. 		bp = (backpos_T *)backpos.ga_data; 		for (i = 0; i < backpos.ga_len; ++i) 		    if (bp[i].bp_scan == scan) 			break; 		if (i == backpos.ga_len) 		{ 		    // First time at this BACK, make room to store the pos. 		    if (ga_grow(&backpos, 1) == FAIL) 			status = RA_FAIL; 		    else 		    { 			// get ""ga_data"" again, it may have changed 			bp = (backpos_T *)backpos.ga_data; 			bp[i].bp_scan = scan; 			++backpos.ga_len; 		    } 		} 		else if (reg_save_equal(&bp[i].bp_pos)) 		    // Still at same position as last time, fail. 		    status = RA_NOMATCH;  		if (status != RA_FAIL && status != RA_NOMATCH) 		    reg_save(&bp[i].bp_pos, &backpos); 	    } 	    break;  	  case MOPEN + 0:   // Match start: \zs 	  case MOPEN + 1:   // \( 	  case MOPEN + 2: 	  case MOPEN + 3: 	  case MOPEN + 4: 	  case MOPEN + 5: 	  case MOPEN + 6: 	  case MOPEN + 7: 	  case MOPEN + 8: 	  case MOPEN + 9: 	    { 		no = op - MOPEN; 		cleanup_subexpr(); 		rp = regstack_push(RS_MOPEN, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no], 							  &rex.reg_startp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break;  	  case NOPEN:	    // \%( 	  case NCLOSE:	    // \) after \%( 		if (regstack_push(RS_NOPEN, scan) == NULL) 		    status = RA_FAIL; 		// We simply continue and handle the result when done. 		break;  #ifdef FEAT_SYN_HL 	  case ZOPEN + 1: 	  case ZOPEN + 2: 	  case ZOPEN + 3: 	  case ZOPEN + 4: 	  case ZOPEN + 5: 	  case ZOPEN + 6: 	  case ZOPEN + 7: 	  case ZOPEN + 8: 	  case ZOPEN + 9: 	    { 		no = op - ZOPEN; 		cleanup_zsubexpr(); 		rp = regstack_push(RS_ZOPEN, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &reg_startzpos[no], 							     &reg_startzp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break; #endif  	  case MCLOSE + 0:  // Match end: \ze 	  case MCLOSE + 1:  // \) 	  case MCLOSE + 2: 	  case MCLOSE + 3: 	  case MCLOSE + 4: 	  case MCLOSE + 5: 	  case MCLOSE + 6: 	  case MCLOSE + 7: 	  case MCLOSE + 8: 	  case MCLOSE + 9: 	    { 		no = op - MCLOSE; 		cleanup_subexpr(); 		rp = regstack_push(RS_MCLOSE, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no], 							    &rex.reg_endp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break;  #ifdef FEAT_SYN_HL 	  case ZCLOSE + 1:  // \) after \z( 	  case ZCLOSE + 2: 	  case ZCLOSE + 3: 	  case ZCLOSE + 4: 	  case ZCLOSE + 5: 	  case ZCLOSE + 6: 	  case ZCLOSE + 7: 	  case ZCLOSE + 8: 	  case ZCLOSE + 9: 	    { 		no = op - ZCLOSE; 		cleanup_zsubexpr(); 		rp = regstack_push(RS_ZCLOSE, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &reg_endzpos[no], 							      &reg_endzp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break; #endif  	  case BACKREF + 1: 	  case BACKREF + 2: 	  case BACKREF + 3: 	  case BACKREF + 4: 	  case BACKREF + 5: 	  case BACKREF + 6: 	  case BACKREF + 7: 	  case BACKREF + 8: 	  case BACKREF + 9: 	    { 		int		len;  		no = op - BACKREF; 		cleanup_subexpr(); 		if (!REG_MULTI)		// Single-line regexp 		{ 		    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL) 		    { 			// Backref was not set: Match an empty string. 			len = 0; 		    } 		    else 		    { 			// Compare current input with back-ref in the same 			// line. 			len = (int)(rex.reg_endp[no] - rex.reg_startp[no]); 			if (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0) 			    status = RA_NOMATCH; 		    } 		} 		else				// Multi-line regexp 		{ 		    if (rex.reg_startpos[no].lnum < 0 						|| rex.reg_endpos[no].lnum < 0) 		    { 			// Backref was not set: Match an empty string. 			len = 0; 		    } 		    else 		    { 			if (rex.reg_startpos[no].lnum == rex.lnum 				&& rex.reg_endpos[no].lnum == rex.lnum) 			{ 			    // Compare back-ref within the current line. 			    len = rex.reg_endpos[no].col 						    - rex.reg_startpos[no].col; 			    if (cstrncmp(rex.line + rex.reg_startpos[no].col, 							  rex.input, &len) != 0) 				status = RA_NOMATCH; 			} 			else 			{ 			    // Messy situation: Need to compare between two 			    // lines. 			    int r = match_with_backref( 					    rex.reg_startpos[no].lnum, 					    rex.reg_startpos[no].col, 					    rex.reg_endpos[no].lnum, 					    rex.reg_endpos[no].col, 					    &len);  			    if (r != RA_MATCH) 				status = r; 			} 		    } 		}  		// Matched the backref, skip over it. 		rex.input += len; 	    } 	    break;  #ifdef FEAT_SYN_HL 	  case ZREF + 1: 	  case ZREF + 2: 	  case ZREF + 3: 	  case ZREF + 4: 	  case ZREF + 5: 	  case ZREF + 6: 	  case ZREF + 7: 	  case ZREF + 8: 	  case ZREF + 9: 	    { 		int	len;  		cleanup_zsubexpr(); 		no = op - ZREF; 		if (re_extmatch_in != NULL 			&& re_extmatch_in->matches[no] != NULL) 		{ 		    len = (int)STRLEN(re_extmatch_in->matches[no]); 		    if (cstrncmp(re_extmatch_in->matches[no], 							  rex.input, &len) != 0) 			status = RA_NOMATCH; 		    else 			rex.input += len; 		} 		else 		{ 		    // Backref was not set: Match an empty string. 		} 	    } 	    break; #endif  	  case BRANCH: 	    { 		if (OP(next) != BRANCH) // No choice. 		    next = OPERAND(scan);	// Avoid recursion. 		else 		{ 		    rp = regstack_push(RS_BRANCH, scan); 		    if (rp == NULL) 			status = RA_FAIL; 		    else 			status = RA_BREAK;	// rest is below 		} 	    } 	    break;  	  case BRACE_LIMITS: 	    { 		if (OP(next) == BRACE_SIMPLE) 		{ 		    bl_minval = OPERAND_MIN(scan); 		    bl_maxval = OPERAND_MAX(scan); 		} 		else if (OP(next) >= BRACE_COMPLEX 			&& OP(next) < BRACE_COMPLEX + 10) 		{ 		    no = OP(next) - BRACE_COMPLEX; 		    brace_min[no] = OPERAND_MIN(scan); 		    brace_max[no] = OPERAND_MAX(scan); 		    brace_count[no] = 0; 		} 		else 		{ 		    internal_error(""BRACE_LIMITS""); 		    status = RA_FAIL; 		} 	    } 	    break;  	  case BRACE_COMPLEX + 0: 	  case BRACE_COMPLEX + 1: 	  case BRACE_COMPLEX + 2: 	  case BRACE_COMPLEX + 3: 	  case BRACE_COMPLEX + 4: 	  case BRACE_COMPLEX + 5: 	  case BRACE_COMPLEX + 6: 	  case BRACE_COMPLEX + 7: 	  case BRACE_COMPLEX + 8: 	  case BRACE_COMPLEX + 9: 	    { 		no = op - BRACE_COMPLEX; 		++brace_count[no];  		// If not matched enough times yet, try one more 		if (brace_count[no] <= (brace_min[no] <= brace_max[no] 					     ? brace_min[no] : brace_max[no])) 		{ 		    rp = regstack_push(RS_BRCPLX_MORE, scan); 		    if (rp == NULL) 			status = RA_FAIL; 		    else 		    { 			rp->rs_no = no; 			reg_save(&rp->rs_un.regsave, &backpos); 			next = OPERAND(scan); 			// We continue and handle the result when done. 		    } 		    break; 		}  		// If matched enough times, may try matching some more 		if (brace_min[no] <= brace_max[no]) 		{ 		    // Range is the normal way around, use longest match 		    if (brace_count[no] <= brace_max[no]) 		    { 			rp = regstack_push(RS_BRCPLX_LONG, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    rp->rs_no = no; 			    reg_save(&rp->rs_un.regsave, &backpos); 			    next = OPERAND(scan); 			    // We continue and handle the result when done. 			} 		    } 		} 		else 		{ 		    // Range is backwards, use shortest match first 		    if (brace_count[no] <= brace_min[no]) 		    { 			rp = regstack_push(RS_BRCPLX_SHORT, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    reg_save(&rp->rs_un.regsave, &backpos); 			    // We continue and handle the result when done. 			} 		    } 		} 	    } 	    break;  	  case BRACE_SIMPLE: 	  case STAR: 	  case PLUS: 	    { 		regstar_T	rst;  		// Lookahead to avoid useless match attempts when we know 		// what character comes next. 		if (OP(next) == EXACTLY) 		{ 		    rst.nextb = *OPERAND(next); 		    if (rex.reg_ic) 		    { 			if (MB_ISUPPER(rst.nextb)) 			    rst.nextb_ic = MB_TOLOWER(rst.nextb); 			else 			    rst.nextb_ic = MB_TOUPPER(rst.nextb); 		    } 		    else 			rst.nextb_ic = rst.nextb; 		} 		else 		{ 		    rst.nextb = NUL; 		    rst.nextb_ic = NUL; 		} 		if (op != BRACE_SIMPLE) 		{ 		    rst.minval = (op == STAR) ? 0 : 1; 		    rst.maxval = MAX_LIMIT; 		} 		else 		{ 		    rst.minval = bl_minval; 		    rst.maxval = bl_maxval; 		}  		// When maxval > minval, try matching as much as possible, up 		// to maxval.  When maxval < minval, try matching at least the 		// minimal number (since the range is backwards, that's also 		// maxval!). 		rst.count = regrepeat(OPERAND(scan), rst.maxval); 		if (got_int) 		{ 		    status = RA_FAIL; 		    break; 		} 		if (rst.minval <= rst.maxval 			  ? rst.count >= rst.minval : rst.count >= rst.maxval) 		{ 		    // It could match.  Prepare for trying to match what 		    // follows.  The code is below.  Parameters are stored in 		    // a regstar_T on the regstack. 		    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) 		    { 			emsg(_(e_pattern_uses_more_memory_than_maxmempattern)); 			status = RA_FAIL; 		    } 		    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL) 			status = RA_FAIL; 		    else 		    { 			regstack.ga_len += sizeof(regstar_T); 			rp = regstack_push(rst.minval <= rst.maxval 					? RS_STAR_LONG : RS_STAR_SHORT, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    *(((regstar_T *)rp) - 1) = rst; 			    status = RA_BREAK;	    // skip the restore bits 			} 		    } 		} 		else 		    status = RA_NOMATCH;  	    } 	    break;  	  case NOMATCH: 	  case MATCH: 	  case SUBPAT: 	    rp = regstack_push(RS_NOMATCH, scan); 	    if (rp == NULL) 		status = RA_FAIL; 	    else 	    { 		rp->rs_no = op; 		reg_save(&rp->rs_un.regsave, &backpos); 		next = OPERAND(scan); 		// We continue and handle the result when done. 	    } 	    break;  	  case BEHIND: 	  case NOBEHIND: 	    // Need a bit of room to store extra positions. 	    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) 	    { 		emsg(_(e_pattern_uses_more_memory_than_maxmempattern)); 		status = RA_FAIL; 	    } 	    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL) 		status = RA_FAIL; 	    else 	    { 		regstack.ga_len += sizeof(regbehind_T); 		rp = regstack_push(RS_BEHIND1, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    // Need to save the subexpr to be able to restore them 		    // when there is a match but we don't use it. 		    save_subexpr(((regbehind_T *)rp) - 1);  		    rp->rs_no = op; 		    reg_save(&rp->rs_un.regsave, &backpos); 		    // First try if what follows matches.  If it does then we 		    // check the behind match by looping. 		} 	    } 	    break;  	  case BHPOS: 	    if (REG_MULTI) 	    { 		if (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line) 			|| behind_pos.rs_u.pos.lnum != rex.lnum) 		    status = RA_NOMATCH; 	    } 	    else if (behind_pos.rs_u.ptr != rex.input) 		status = RA_NOMATCH; 	    break;  	  case NEWL: 	    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline 			     || rex.reg_line_lbr) 					   && (c != '\n' || !rex.reg_line_lbr)) 		status = RA_NOMATCH; 	    else if (rex.reg_line_lbr) 		ADVANCE_REGINPUT(); 	    else 		reg_nextline(); 	    break;  	  case END: 	    status = RA_MATCH;	// Success! 	    break;  	  default: 	    iemsg(_(e_corrupted_regexp_program)); #ifdef DEBUG 	    printf(""Illegal op code %d\n"", op); #endif 	    status = RA_FAIL; 	    break; 	  } 	}  	// If we can't continue sequentially, break the inner loop. 	if (status != RA_CONT) 	    break;  	// Continue in inner loop, advance to next item. 	scan = next;      } // end of inner loop      // If there is something on the regstack execute the code for the state.     // If the state is popped then loop and use the older state.     while (regstack.ga_len > 0 && status != RA_FAIL)     { 	rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1; 	switch (rp->rs_state) 	{ 	  case RS_NOPEN: 	    // Result is passed on as-is, simply pop the state. 	    regstack_pop(&scan); 	    break;  	  case RS_MOPEN: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no], 						  &rex.reg_startp[rp->rs_no]); 	    regstack_pop(&scan); 	    break;  #ifdef FEAT_SYN_HL 	  case RS_ZOPEN: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no], 						 &reg_startzp[rp->rs_no]); 	    regstack_pop(&scan); 	    break; #endif  	  case RS_MCLOSE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no], 						    &rex.reg_endp[rp->rs_no]); 	    regstack_pop(&scan); 	    break;  #ifdef FEAT_SYN_HL 	  case RS_ZCLOSE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no], 						   &reg_endzp[rp->rs_no]); 	    regstack_pop(&scan); 	    break; #endif  	  case RS_BRANCH: 	    if (status == RA_MATCH) 		// this branch matched, use it 		regstack_pop(&scan); 	    else 	    { 		if (status != RA_BREAK) 		{ 		    // After a non-matching branch: try next one. 		    reg_restore(&rp->rs_un.regsave, &backpos); 		    scan = rp->rs_scan; 		} 		if (scan == NULL || OP(scan) != BRANCH) 		{ 		    // no more branches, didn't find a match 		    status = RA_NOMATCH; 		    regstack_pop(&scan); 		} 		else 		{ 		    // Prepare to try a branch. 		    rp->rs_scan = regnext(scan); 		    reg_save(&rp->rs_un.regsave, &backpos); 		    scan = OPERAND(scan); 		} 	    } 	    break;  	  case RS_BRCPLX_MORE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 	    { 		reg_restore(&rp->rs_un.regsave, &backpos); 		--brace_count[rp->rs_no];	// decrement match count 	    } 	    regstack_pop(&scan); 	    break;  	  case RS_BRCPLX_LONG: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 	    { 		// There was no match, but we did find enough matches. 		reg_restore(&rp->rs_un.regsave, &backpos); 		--brace_count[rp->rs_no]; 		// continue with the items after ""\{}"" 		status = RA_CONT; 	    } 	    regstack_pop(&scan); 	    if (status == RA_CONT) 		scan = regnext(scan); 	    break;  	  case RS_BRCPLX_SHORT: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		// There was no match, try to match one more item. 		reg_restore(&rp->rs_un.regsave, &backpos); 	    regstack_pop(&scan); 	    if (status == RA_NOMATCH) 	    { 		scan = OPERAND(scan); 		status = RA_CONT; 	    } 	    break;  	  case RS_NOMATCH: 	    // Pop the state.  If the operand matches for NOMATCH or 	    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup, 	    // except for SUBPAT, and continue with the next item. 	    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH)) 		status = RA_NOMATCH; 	    else 	    { 		status = RA_CONT; 		if (rp->rs_no != SUBPAT)	// zero-width 		    reg_restore(&rp->rs_un.regsave, &backpos); 	    } 	    regstack_pop(&scan); 	    if (status == RA_CONT) 		scan = regnext(scan); 	    break;  	  case RS_BEHIND1: 	    if (status == RA_NOMATCH) 	    { 		regstack_pop(&scan); 		regstack.ga_len -= sizeof(regbehind_T); 	    } 	    else 	    { 		// The stuff after BEHIND/NOBEHIND matches.  Now try if 		// the behind part does (not) match before the current 		// position in the input.  This must be done at every 		// position in the input and checking if the match ends at 		// the current position.  		// save the position after the found match for next 		reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);  		// Start looking for a match with operand at the current 		// position.  Go back one character until we find the 		// result, hitting the start of the line or the previous 		// line (for multi-line matching). 		// Set behind_pos to where the match should end, BHPOS 		// will match it.  Save the current value. 		(((regbehind_T *)rp) - 1)->save_behind = behind_pos; 		behind_pos = rp->rs_un.regsave;  		rp->rs_state = RS_BEHIND2;  		reg_restore(&rp->rs_un.regsave, &backpos); 		scan = OPERAND(rp->rs_scan) + 4; 	    } 	    break;  	  case RS_BEHIND2: 	    // Looping for BEHIND / NOBEHIND match. 	    if (status == RA_MATCH && reg_save_equal(&behind_pos)) 	    { 		// found a match that ends where ""next"" started 		behind_pos = (((regbehind_T *)rp) - 1)->save_behind; 		if (rp->rs_no == BEHIND) 		    reg_restore(&(((regbehind_T *)rp) - 1)->save_after, 								    &backpos); 		else 		{ 		    // But we didn't want a match.  Need to restore the 		    // subexpr, because what follows matched, so they have 		    // been set. 		    status = RA_NOMATCH; 		    restore_subexpr(((regbehind_T *)rp) - 1); 		} 		regstack_pop(&scan); 		regstack.ga_len -= sizeof(regbehind_T); 	    } 	    else 	    { 		long limit;  		// No match or a match that doesn't end where we want it: Go 		// back one character.  May go to previous line once. 		no = OK; 		limit = OPERAND_MIN(rp->rs_scan); 		if (REG_MULTI) 		{ 		    if (limit > 0 			    && ((rp->rs_un.regsave.rs_u.pos.lnum 						    < behind_pos.rs_u.pos.lnum 				    ? (colnr_T)STRLEN(rex.line) 				    : behind_pos.rs_u.pos.col) 				- rp->rs_un.regsave.rs_u.pos.col >= limit)) 			no = FAIL; 		    else if (rp->rs_un.regsave.rs_u.pos.col == 0) 		    { 			if (rp->rs_un.regsave.rs_u.pos.lnum 					< behind_pos.rs_u.pos.lnum 				|| reg_getline( 					--rp->rs_un.regsave.rs_u.pos.lnum) 								  == NULL) 			    no = FAIL; 			else 			{ 			    reg_restore(&rp->rs_un.regsave, &backpos); 			    rp->rs_un.regsave.rs_u.pos.col = 						 (colnr_T)STRLEN(rex.line); 			} 		    } 		    else 		    { 			if (has_mbyte) 			{ 			    char_u *line = 				  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);  			    rp->rs_un.regsave.rs_u.pos.col -= 				(*mb_head_off)(line, line 				    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1; 			} 			else 			    --rp->rs_un.regsave.rs_u.pos.col; 		    } 		} 		else 		{ 		    if (rp->rs_un.regsave.rs_u.ptr == rex.line) 			no = FAIL; 		    else 		    { 			MB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr); 			if (limit > 0 && (long)(behind_pos.rs_u.ptr 				     - rp->rs_un.regsave.rs_u.ptr) > limit) 			    no = FAIL; 		    } 		} 		if (no == OK) 		{ 		    // Advanced, prepare for finding match again. 		    reg_restore(&rp->rs_un.regsave, &backpos); 		    scan = OPERAND(rp->rs_scan) + 4; 		    if (status == RA_MATCH) 		    { 			// We did match, so subexpr may have been changed, 			// need to restore them for the next try. 			status = RA_NOMATCH; 			restore_subexpr(((regbehind_T *)rp) - 1); 		    } 		} 		else 		{ 		    // Can't advance.  For NOBEHIND that's a match. 		    behind_pos = (((regbehind_T *)rp) - 1)->save_behind; 		    if (rp->rs_no == NOBEHIND) 		    { 			reg_restore(&(((regbehind_T *)rp) - 1)->save_after, 								    &backpos); 			status = RA_MATCH; 		    } 		    else 		    { 			// We do want a proper match.  Need to restore the 			// subexpr if we had a match, because they may have 			// been set. 			if (status == RA_MATCH) 			{ 			    status = RA_NOMATCH; 			    restore_subexpr(((regbehind_T *)rp) - 1); 			} 		    } 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regbehind_T); 		} 	    } 	    break;  	  case RS_STAR_LONG: 	  case RS_STAR_SHORT: 	    { 		regstar_T	    *rst = ((regstar_T *)rp) - 1;  		if (status == RA_MATCH) 		{ 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regstar_T); 		    break; 		}  		// Tried once already, restore input pointers. 		if (status != RA_BREAK) 		    reg_restore(&rp->rs_un.regsave, &backpos);  		// Repeat until we found a position where it could match. 		for (;;) 		{ 		    if (status != RA_BREAK) 		    { 			// Tried first position already, advance. 			if (rp->rs_state == RS_STAR_LONG) 			{ 			    // Trying for longest match, but couldn't or 			    // didn't match -- back up one char. 			    if (--rst->count < rst->minval) 				break; 			    if (rex.input == rex.line) 			    { 				// backup to last char of previous line 				if (rex.lnum == 0) 				{ 				    status = RA_NOMATCH; 				    break; 				} 				--rex.lnum; 				rex.line = reg_getline(rex.lnum); 				// Just in case regrepeat() didn't count 				// right. 				if (rex.line == NULL) 				    break; 				rex.input = rex.line + STRLEN(rex.line); 				fast_breakcheck(); 			    } 			    else 				MB_PTR_BACK(rex.line, rex.input); 			} 			else 			{ 			    // Range is backwards, use shortest match first. 			    // Careful: maxval and minval are exchanged! 			    // Couldn't or didn't match: try advancing one 			    // char. 			    if (rst->count == rst->minval 				  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0) 				break; 			    ++rst->count; 			} 			if (got_int) 			    break; 		    } 		    else 			status = RA_NOMATCH;  		    // If it could match, try it. 		    if (rst->nextb == NUL || *rex.input == rst->nextb 					     || *rex.input == rst->nextb_ic) 		    { 			reg_save(&rp->rs_un.regsave, &backpos); 			scan = regnext(rp->rs_scan); 			status = RA_CONT; 			break; 		    } 		} 		if (status != RA_CONT) 		{ 		    // Failed. 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regstar_T); 		    status = RA_NOMATCH; 		} 	    } 	    break; 	}  	// If we want to continue the inner loop or didn't pop a state 	// continue matching loop 	if (status == RA_CONT || rp == (regitem_T *) 			     ((char *)regstack.ga_data + regstack.ga_len) - 1) 	    break;     }      // May need to continue with the inner loop, starting at ""scan"".     if (status == RA_CONT) 	continue;      // If the regstack is empty or something failed we are done.     if (regstack.ga_len == 0 || status == RA_FAIL)     { 	if (scan == NULL) 	{ 	    // We get here only if there's trouble -- normally ""case END"" is 	    // the terminating point. 	    iemsg(_(e_corrupted_regexp_program)); #ifdef DEBUG 	    printf(""Premature EOL\n""); #endif 	} 	return (status == RA_MATCH);     }    } // End of loop until the regstack is empty.    // NOTREACHED }"
"201913_CWE-59.cpp","CWE-59","set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,     mode_t mode, unsigned long set, unsigned long clear) { 	int		 ret; 	int		 myfd = fd; 	int newflags, oldflags; 	/* 	 * Linux has no define for the flags that are only settable by 	 * the root user.  This code may seem a little complex, but 	 * there seem to be some Linux systems that lack these 	 * defines. (?)  The code below degrades reasonably gracefully 	 * if sf_mask is incomplete. 	 */ 	const int sf_mask = 0 #if defined(FS_IMMUTABLE_FL) 	    | FS_IMMUTABLE_FL #elif defined(EXT2_IMMUTABLE_FL) 	    | EXT2_IMMUTABLE_FL #endif #if defined(FS_APPEND_FL) 	    | FS_APPEND_FL #elif defined(EXT2_APPEND_FL) 	    | EXT2_APPEND_FL #endif #if defined(FS_JOURNAL_DATA_FL) 	    | FS_JOURNAL_DATA_FL #endif 	;  	if (set == 0 && clear == 0) 		return (ARCHIVE_OK); 	/* Only regular files and dirs can have flags. */ 	if (!S_ISREG(mode) && !S_ISDIR(mode)) 		return (ARCHIVE_OK);  	/* If we weren't given an fd, open it ourselves. */ 	if (myfd < 0) { 		myfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC); 		__archive_ensure_cloexec_flag(myfd); 	} 	if (myfd < 0) 		return (ARCHIVE_OK);  	/* 	 * XXX As above, this would be way simpler if we didn't have 	 * to read the current flags from disk. XXX 	 */ 	ret = ARCHIVE_OK;  	/* Read the current file flags. */ 	if (ioctl(myfd, #ifdef FS_IOC_GETFLAGS 	    FS_IOC_GETFLAGS, #else 	    EXT2_IOC_GETFLAGS, #endif 	    &oldflags) < 0) 		goto fail;  	/* Try setting the flags as given. */ 	newflags = (oldflags & ~clear) | set; 	if (ioctl(myfd, #ifdef FS_IOC_SETFLAGS 	    FS_IOC_SETFLAGS, #else 	    EXT2_IOC_SETFLAGS, #endif 	    &newflags) >= 0) 		goto cleanup; 	if (errno != EPERM) 		goto fail;  	/* If we couldn't set all the flags, try again with a subset. */ 	newflags &= ~sf_mask; 	oldflags &= sf_mask; 	newflags |= oldflags; 	if (ioctl(myfd, #ifdef FS_IOC_SETFLAGS 	    FS_IOC_SETFLAGS, #else 	    EXT2_IOC_SETFLAGS, #endif 	    &newflags) >= 0) 		goto cleanup;  	/* We couldn't set the flags, so report the failure. */ fail: 	archive_set_error(&a->archive, errno, 	    ""Failed to set file flags""); 	ret = ARCHIVE_WARN; cleanup: 	if (fd < 0) 		close(myfd); 	return (ret); }"
"201925_CWE-476.c","CWE-476","*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args) { 	u32 priv_sz = sizeof(struct vidtv_s302m_ctx); 	struct vidtv_s302m_ctx *ctx; 	struct vidtv_encoder *e;  	e = kzalloc(sizeof(*e), GFP_KERNEL); 	if (!e) 		return NULL;  	e->id = S302M;  	if (args.name) 		e->name = kstrdup(args.name, GFP_KERNEL);  	e->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ); 	e->encoder_buf_sz = VIDTV_S302M_BUF_SZ; 	e->encoder_buf_offset = 0;  	e->sample_count = 0;  	e->src_buf = (args.src_buf) ? args.src_buf : NULL; 	e->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0; 	e->src_buf_offset = 0;  	e->is_video_encoder = false;  	ctx = kzalloc(priv_sz, GFP_KERNEL); 	if (!ctx) { 		kfree(e); 		return NULL; 	}  	e->ctx = ctx; 	ctx->last_duration = 0;  	e->encode = vidtv_s302m_encode; 	e->clear = vidtv_s302m_clear;  	e->es_pid = cpu_to_be16(args.es_pid); 	e->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);  	e->sync = args.sync; 	e->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;  	e->last_sample_cb = args.last_sample_cb;  	e->destroy = vidtv_s302m_encoder_destroy;  	if (args.head) { 		while (args.head->next) 			args.head = args.head->next;  		args.head->next = e; 	}  	e->next = NULL;  	return e; }"
"202081_CWE-787.c","CWE-787","do_put(     int		regname,     char_u	*expr_result,	// result for regname ""="" when compiled     int		dir,		// BACKWARD for 'P', FORWARD for 'p'     long	count,     int		flags) {     char_u	*ptr;     char_u	*newp, *oldp;     int		yanklen;     int		totlen = 0;		// init for gcc     linenr_T	lnum;     colnr_T	col;     long	i;			// index in y_array[]     int		y_type;     long	y_size;     int		oldlen;     long	y_width = 0;     colnr_T	vcol;     int		delcount;     int		incr = 0;     long	j;     struct block_def bd;     char_u	**y_array = NULL;     yankreg_T	*y_current_used = NULL;     long	nr_lines = 0;     pos_T	new_cursor;     int		indent;     int		orig_indent = 0;	// init for gcc     int		indent_diff = 0;	// init for gcc     int		first_indent = TRUE;     int		lendiff = 0;     pos_T	old_pos;     char_u	*insert_string = NULL;     int		allocated = FALSE;     long	cnt;     pos_T	orig_start = curbuf->b_op_start;     pos_T	orig_end = curbuf->b_op_end;     unsigned int cur_ve_flags = get_ve_flags();  #ifdef FEAT_CLIPBOARD     // Adjust register name for ""unnamed"" in 'clipboard'.     adjust_clip_reg(&regname);     (void)may_get_selection(regname); #endif      if (flags & PUT_FIXINDENT) 	orig_indent = get_indent();      curbuf->b_op_start = curwin->w_cursor;	// default for '[ mark     curbuf->b_op_end = curwin->w_cursor;	// default for '] mark      // Using inserted text works differently, because the register includes     // special characters (newlines, etc.).     if (regname == '.')     { 	if (VIsual_active) 	    stuffcharReadbuff(VIsual_mode); 	(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') : 				    (count == -1 ? 'O' : 'i')), count, FALSE); 	// Putting the text is done later, so can't really move the cursor to 	// the next character.  Use ""l"" to simulate it. 	if ((flags & PUT_CURSEND) && gchar_cursor() != NUL) 	    stuffcharReadbuff('l'); 	return;     }      // For special registers '%' (file name), '#' (alternate file name) and     // ':' (last command line), etc. we have to create a fake yank register.     // For compiled code ""expr_result"" holds the expression result.     if (regname == '=' && expr_result != NULL) 	insert_string = expr_result;     else if (get_spec_reg(regname, &insert_string, &allocated, TRUE) 		&& insert_string == NULL) 	return;      // Autocommands may be executed when saving lines for undo.  This might     // make ""y_array"" invalid, so we start undo now to avoid that.     if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL) 	goto end;      if (insert_string != NULL)     { 	y_type = MCHAR; #ifdef FEAT_EVAL 	if (regname == '=') 	{ 	    // For the = register we need to split the string at NL 	    // characters. 	    // Loop twice: count the number of lines and save them. 	    for (;;) 	    { 		y_size = 0; 		ptr = insert_string; 		while (ptr != NULL) 		{ 		    if (y_array != NULL) 			y_array[y_size] = ptr; 		    ++y_size; 		    ptr = vim_strchr(ptr, '\n'); 		    if (ptr != NULL) 		    { 			if (y_array != NULL) 			    *ptr = NUL; 			++ptr; 			// A trailing '\n' makes the register linewise. 			if (*ptr == NUL) 			{ 			    y_type = MLINE; 			    break; 			} 		    } 		} 		if (y_array != NULL) 		    break; 		y_array = ALLOC_MULT(char_u *, y_size); 		if (y_array == NULL) 		    goto end; 	    } 	} 	else #endif 	{ 	    y_size = 1;		// use fake one-line yank register 	    y_array = &insert_string; 	}     }     else     { 	get_yank_register(regname, FALSE);  	y_type = y_current->y_type; 	y_width = y_current->y_width; 	y_size = y_current->y_size; 	y_array = y_current->y_array; 	y_current_used = y_current;     }      if (y_type == MLINE)     { 	if (flags & PUT_LINE_SPLIT) 	{ 	    char_u *p;  	    // ""p"" or ""P"" in Visual mode: split the lines to put the text in 	    // between. 	    if (u_save_cursor() == FAIL) 		goto end; 	    p = ml_get_cursor(); 	    if (dir == FORWARD && *p != NUL) 		MB_PTR_ADV(p); 	    ptr = vim_strsave(p); 	    if (ptr == NULL) 		goto end; 	    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE); 	    vim_free(ptr);  	    oldp = ml_get_curline(); 	    p = oldp + curwin->w_cursor.col; 	    if (dir == FORWARD && *p != NUL) 		MB_PTR_ADV(p); 	    ptr = vim_strnsave(oldp, p - oldp); 	    if (ptr == NULL) 		goto end; 	    ml_replace(curwin->w_cursor.lnum, ptr, FALSE); 	    ++nr_lines; 	    dir = FORWARD; 	} 	if (flags & PUT_LINE_FORWARD) 	{ 	    // Must be ""p"" for a Visual block, put lines below the block. 	    curwin->w_cursor = curbuf->b_visual.vi_end; 	    dir = FORWARD; 	} 	curbuf->b_op_start = curwin->w_cursor;	// default for '[ mark 	curbuf->b_op_end = curwin->w_cursor;	// default for '] mark     }      if (flags & PUT_LINE)	// :put command or ""p"" in Visual line mode. 	y_type = MLINE;      if (y_size == 0 || y_array == NULL)     { 	semsg(_(e_nothing_in_register_str), 		  regname == 0 ? (char_u *)""\"""" : transchar(regname)); 	goto end;     }      if (y_type == MBLOCK)     { 	lnum = curwin->w_cursor.lnum + y_size + 1; 	if (lnum > curbuf->b_ml.ml_line_count) 	    lnum = curbuf->b_ml.ml_line_count + 1; 	if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL) 	    goto end;     }     else if (y_type == MLINE)     { 	lnum = curwin->w_cursor.lnum; #ifdef FEAT_FOLDING 	// Correct line number for closed fold.  Don't move the cursor yet, 	// u_save() uses it. 	if (dir == BACKWARD) 	    (void)hasFolding(lnum, &lnum, NULL); 	else 	    (void)hasFolding(lnum, NULL, &lnum); #endif 	if (dir == FORWARD) 	    ++lnum; 	// In an empty buffer the empty line is going to be replaced, include 	// it in the saved lines. 	if ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) 	    goto end; #ifdef FEAT_FOLDING 	if (dir == FORWARD) 	    curwin->w_cursor.lnum = lnum - 1; 	else 	    curwin->w_cursor.lnum = lnum; 	curbuf->b_op_start = curwin->w_cursor;	// for mark_adjust() #endif     }     else if (u_save_cursor() == FAIL) 	goto end;      yanklen = (int)STRLEN(y_array[0]);      if (cur_ve_flags == VE_ALL && y_type == MCHAR)     { 	if (gchar_cursor() == TAB) 	{ 	    int viscol = getviscol(); 	    int ts = curbuf->b_p_ts;  	    // Don't need to insert spaces when ""p"" on the last position of a 	    // tab or ""P"" on the first position. 	    if (dir == FORWARD ? #ifdef FEAT_VARTABS 		    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1 #else 		    ts - (viscol % ts) != 1 #endif 		    : curwin->w_cursor.coladd > 0) 		coladvance_force(viscol); 	    else 		curwin->w_cursor.coladd = 0; 	} 	else if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL) 	    coladvance_force(getviscol() + (dir == FORWARD));     }      lnum = curwin->w_cursor.lnum;     col = curwin->w_cursor.col;      // Block mode     if (y_type == MBLOCK)     { 	int	c = gchar_cursor(); 	colnr_T	endcol2 = 0;  	if (dir == FORWARD && c != NUL) 	{ 	    if (cur_ve_flags == VE_ALL) 		getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2); 	    else 		getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);  	    if (has_mbyte) 		// move to start of next multi-byte character 		curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor()); 	    else 	    if (c != TAB || cur_ve_flags != VE_ALL) 		++curwin->w_cursor.col; 	    ++col; 	} 	else 	    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);  	col += curwin->w_cursor.coladd; 	if (cur_ve_flags == VE_ALL 		&& (curwin->w_cursor.coladd > 0 		    || endcol2 == curwin->w_cursor.col)) 	{ 	    if (dir == FORWARD && c == NUL) 		++col; 	    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0) 		++curwin->w_cursor.col; 	    if (c == TAB) 	    { 		if (dir == BACKWARD && curwin->w_cursor.col) 		    curwin->w_cursor.col--; 		if (dir == FORWARD && col - 1 == endcol2) 		    curwin->w_cursor.col++; 	    } 	} 	curwin->w_cursor.coladd = 0; 	bd.textcol = 0; 	for (i = 0; i < y_size; ++i) 	{ 	    int spaces = 0; 	    char shortline;  	    bd.startspaces = 0; 	    bd.endspaces = 0; 	    vcol = 0; 	    delcount = 0;  	    // add a new line 	    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) 	    { 		if (ml_append(curbuf->b_ml.ml_line_count, (char_u *)"""", 						   (colnr_T)1, FALSE) == FAIL) 		    break; 		++nr_lines; 	    } 	    // get the old line and advance to the position to insert at 	    oldp = ml_get_curline(); 	    oldlen = (int)STRLEN(oldp); 	    for (ptr = oldp; vcol < col && *ptr; ) 	    { 		// Count a tab for what it's worth (if list mode not on) 		incr = lbr_chartabsize_adv(oldp, &ptr, vcol); 		vcol += incr; 	    } 	    bd.textcol = (colnr_T)(ptr - oldp);  	    shortline = (vcol < col) || (vcol == col && !*ptr) ;  	    if (vcol < col) // line too short, padd with spaces 		bd.startspaces = col - vcol; 	    else if (vcol > col) 	    { 		bd.endspaces = vcol - col; 		bd.startspaces = incr - bd.endspaces; 		--bd.textcol; 		delcount = 1; 		if (has_mbyte) 		    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol); 		if (oldp[bd.textcol] != TAB) 		{ 		    // Only a Tab can be split into spaces.  Other 		    // characters will have to be moved to after the 		    // block, causing misalignment. 		    delcount = 0; 		    bd.endspaces = 0; 		} 	    }  	    yanklen = (int)STRLEN(y_array[i]);  	    if ((flags & PUT_BLOCK_INNER) == 0) 	    { 		// calculate number of spaces required to fill right side of 		// block 		spaces = y_width + 1; 		for (j = 0; j < yanklen; j++) 		    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0); 		if (spaces < 0) 		    spaces = 0; 	    }  	    // Insert the new text. 	    // First check for multiplication overflow. 	    if (yanklen + spaces != 0 		     && count > ((INT_MAX - (bd.startspaces + bd.endspaces)) 							/ (yanklen + spaces))) 	    { 		emsg(_(e_resulting_text_too_long)); 		break; 	    }  	    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces; 	    newp = alloc(totlen + oldlen + 1); 	    if (newp == NULL) 		break;  	    // copy part up to cursor to new line 	    ptr = newp; 	    mch_memmove(ptr, oldp, (size_t)bd.textcol); 	    ptr += bd.textcol;  	    // may insert some spaces before the new text 	    vim_memset(ptr, ' ', (size_t)bd.startspaces); 	    ptr += bd.startspaces;  	    // insert the new text 	    for (j = 0; j < count; ++j) 	    { 		mch_memmove(ptr, y_array[i], (size_t)yanklen); 		ptr += yanklen;  		// insert block's trailing spaces only if there's text behind 		if ((j < count - 1 || !shortline) && spaces) 		{ 		    vim_memset(ptr, ' ', (size_t)spaces); 		    ptr += spaces; 		} 	    }  	    // may insert some spaces after the new text 	    vim_memset(ptr, ' ', (size_t)bd.endspaces); 	    ptr += bd.endspaces;  	    // move the text after the cursor to the end of the line. 	    mch_memmove(ptr, oldp + bd.textcol + delcount, 				(size_t)(oldlen - bd.textcol - delcount + 1)); 	    ml_replace(curwin->w_cursor.lnum, newp, FALSE);  	    ++curwin->w_cursor.lnum; 	    if (i == 0) 		curwin->w_cursor.col += bd.startspaces; 	}  	changed_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);  	// Set '[ mark. 	curbuf->b_op_start = curwin->w_cursor; 	curbuf->b_op_start.lnum = lnum;  	// adjust '] mark 	curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1; 	curbuf->b_op_end.col = bd.textcol + totlen - 1; 	curbuf->b_op_end.coladd = 0; 	if (flags & PUT_CURSEND) 	{ 	    colnr_T len;  	    curwin->w_cursor = curbuf->b_op_end; 	    curwin->w_cursor.col++;  	    // in Insert mode we might be after the NUL, correct for that 	    len = (colnr_T)STRLEN(ml_get_curline()); 	    if (curwin->w_cursor.col > len) 		curwin->w_cursor.col = len; 	} 	else 	    curwin->w_cursor.lnum = lnum;     }     else     { 	// Character or Line mode 	if (y_type == MCHAR) 	{ 	    // if type is MCHAR, FORWARD is the same as BACKWARD on the next 	    // char 	    if (dir == FORWARD && gchar_cursor() != NUL) 	    { 		if (has_mbyte) 		{ 		    int bytelen = (*mb_ptr2len)(ml_get_cursor());  		    // put it on the next of the multi-byte character. 		    col += bytelen; 		    if (yanklen) 		    { 			curwin->w_cursor.col += bytelen; 			curbuf->b_op_end.col += bytelen; 		    } 		} 		else 		{ 		    ++col; 		    if (yanklen) 		    { 			++curwin->w_cursor.col; 			++curbuf->b_op_end.col; 		    } 		} 	    } 	    curbuf->b_op_start = curwin->w_cursor; 	} 	// Line mode: BACKWARD is the same as FORWARD on the previous line 	else if (dir == BACKWARD) 	    --lnum; 	new_cursor = curwin->w_cursor;  	// simple case: insert into one line at a time 	if (y_type == MCHAR && y_size == 1) 	{ 	    linenr_T	end_lnum = 0; // init for gcc 	    linenr_T	start_lnum = lnum; 	    int		first_byte_off = 0;  	    if (VIsual_active) 	    { 		end_lnum = curbuf->b_visual.vi_end.lnum; 		if (end_lnum < curbuf->b_visual.vi_start.lnum) 		    end_lnum = curbuf->b_visual.vi_start.lnum; 		if (end_lnum > start_lnum) 		{ 		    pos_T   pos;  		    // ""col"" is valid for the first line, in following lines 		    // the virtual column needs to be used.  Matters for 		    // multi-byte characters. 		    pos.lnum = lnum; 		    pos.col = col; 		    pos.coladd = 0; 		    getvcol(curwin, &pos, NULL, &vcol, NULL); 		} 	    }  	    if (count == 0 || yanklen == 0) 	    { 		if (VIsual_active) 		    lnum = end_lnum; 	    } 	    else if (count > INT_MAX / yanklen) 		// multiplication overflow 		emsg(_(e_resulting_text_too_long)); 	    else 	    { 		totlen = count * yanklen; 		do { 		    oldp = ml_get(lnum); 		    oldlen = (int)STRLEN(oldp); 		    if (lnum > start_lnum) 		    { 			pos_T   pos;  			pos.lnum = lnum; 			if (getvpos(&pos, vcol) == OK) 			    col = pos.col; 			else 			    col = MAXCOL; 		    } 		    if (VIsual_active && col > oldlen) 		    { 			lnum++; 			continue; 		    } 		    newp = alloc(totlen + oldlen + 1); 		    if (newp == NULL) 			goto end;	// alloc() gave an error message 		    mch_memmove(newp, oldp, (size_t)col); 		    ptr = newp + col; 		    for (i = 0; i < count; ++i) 		    { 			mch_memmove(ptr, y_array[0], (size_t)yanklen); 			ptr += yanklen; 		    } 		    STRMOVE(ptr, oldp + col); 		    ml_replace(lnum, newp, FALSE);  		    // compute the byte offset for the last character 		    first_byte_off = mb_head_off(newp, ptr - 1);  		    // Place cursor on last putted char. 		    if (lnum == curwin->w_cursor.lnum) 		    { 			// make sure curwin->w_virtcol is updated 			changed_cline_bef_curs(); 			curwin->w_cursor.col += (colnr_T)(totlen - 1); 		    } 		    if (VIsual_active) 			lnum++; 		} while (VIsual_active && lnum <= end_lnum);  		if (VIsual_active) // reset lnum to the last visual line 		    lnum--; 	    }  	    // put '] at the first byte of the last character 	    curbuf->b_op_end = curwin->w_cursor; 	    curbuf->b_op_end.col -= first_byte_off;  	    // For ""CTRL-O p"" in Insert mode, put cursor after last char 	    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND))) 		++curwin->w_cursor.col; 	    else 		curwin->w_cursor.col -= first_byte_off; 	    changed_bytes(lnum, col); 	} 	else 	{ 	    linenr_T	new_lnum = new_cursor.lnum; 	    size_t	len;  	    // Insert at least one line.  When y_type is MCHAR, break the first 	    // line in two. 	    for (cnt = 1; cnt <= count; ++cnt) 	    { 		i = 0; 		if (y_type == MCHAR) 		{ 		    // Split the current line in two at the insert position. 		    // First insert y_array[size - 1] in front of second line. 		    // Then append y_array[0] to first line. 		    lnum = new_cursor.lnum; 		    ptr = ml_get(lnum) + col; 		    totlen = (int)STRLEN(y_array[y_size - 1]); 		    newp = alloc(STRLEN(ptr) + totlen + 1); 		    if (newp == NULL) 			goto error; 		    STRCPY(newp, y_array[y_size - 1]); 		    STRCAT(newp, ptr); 		    // insert second line 		    ml_append(lnum, newp, (colnr_T)0, FALSE); 		    ++new_lnum; 		    vim_free(newp);  		    oldp = ml_get(lnum); 		    newp = alloc(col + yanklen + 1); 		    if (newp == NULL) 			goto error; 					    // copy first part of line 		    mch_memmove(newp, oldp, (size_t)col); 					    // append to first line 		    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1)); 		    ml_replace(lnum, newp, FALSE);  		    curwin->w_cursor.lnum = lnum; 		    i = 1; 		}  		for (; i < y_size; ++i) 		{ 		    if (y_type != MCHAR || i < y_size - 1) 		    { 			if (ml_append(lnum, y_array[i], (colnr_T)0, FALSE) 								      == FAIL) 			    goto error; 			new_lnum++; 		    } 		    lnum++; 		    ++nr_lines; 		    if (flags & PUT_FIXINDENT) 		    { 			old_pos = curwin->w_cursor; 			curwin->w_cursor.lnum = lnum; 			ptr = ml_get(lnum); 			if (cnt == count && i == y_size - 1) 			    lendiff = (int)STRLEN(ptr); 			if (*ptr == '#' && preprocs_left()) 			    indent = 0;     // Leave # lines at start 			else 			     if (*ptr == NUL) 			    indent = 0;     // Ignore empty lines 			else if (first_indent) 			{ 			    indent_diff = orig_indent - get_indent(); 			    indent = orig_indent; 			    first_indent = FALSE; 			} 			else if ((indent = get_indent() + indent_diff) < 0) 			    indent = 0; 			(void)set_indent(indent, 0); 			curwin->w_cursor = old_pos; 			// remember how many chars were removed 			if (cnt == count && i == y_size - 1) 			    lendiff -= (int)STRLEN(ml_get(lnum)); 		    } 		} 		if (cnt == 1) 		    new_lnum = lnum; 	    }  error: 	    // Adjust marks. 	    if (y_type == MLINE) 	    { 		curbuf->b_op_start.col = 0; 		if (dir == FORWARD) 		    curbuf->b_op_start.lnum++; 	    } 	    // Skip mark_adjust when adding lines after the last one, there 	    // can't be marks there. But still needed in diff mode. 	    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines 						 < curbuf->b_ml.ml_line_count #ifdef FEAT_DIFF 						 || curwin->w_p_diff #endif 						 ) 		mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR), 					     (linenr_T)MAXLNUM, nr_lines, 0L);  	    // note changed text for displaying and folding 	    if (y_type == MCHAR) 		changed_lines(curwin->w_cursor.lnum, col, 					 curwin->w_cursor.lnum + 1, nr_lines); 	    else 		changed_lines(curbuf->b_op_start.lnum, 0, 					   curbuf->b_op_start.lnum, nr_lines); 	    if (y_current_used != NULL && (y_current_used != y_current 					     || y_current->y_array != y_array)) 	    { 		// Something invoked through changed_lines() has changed the 		// yank buffer, e.g. a GUI clipboard callback. 		emsg(_(e_yank_register_changed_while_using_it)); 		goto end; 	    }  	    // Put the '] mark on the first byte of the last inserted character. 	    // Correct the length for change in indent. 	    curbuf->b_op_end.lnum = new_lnum; 	    len = STRLEN(y_array[y_size - 1]); 	    col = (colnr_T)len - lendiff; 	    if (col > 1) 	    { 		curbuf->b_op_end.col = col - 1; 		if (len > 0) 		    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1], 						y_array[y_size - 1] + len - 1); 	    } 	    else 		curbuf->b_op_end.col = 0;  	    if (flags & PUT_CURSLINE) 	    { 		// "":put"": put cursor on last inserted line 		curwin->w_cursor.lnum = lnum; 		beginline(BL_WHITE | BL_FIX); 	    } 	    else if (flags & PUT_CURSEND) 	    { 		// put cursor after inserted text 		if (y_type == MLINE) 		{ 		    if (lnum >= curbuf->b_ml.ml_line_count) 			curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count; 		    else 			curwin->w_cursor.lnum = lnum + 1; 		    curwin->w_cursor.col = 0; 		} 		else 		{ 		    curwin->w_cursor.lnum = new_lnum; 		    curwin->w_cursor.col = col; 		    curbuf->b_op_end = curwin->w_cursor; 		    if (col > 1) 			curbuf->b_op_end.col = col - 1; 		} 	    } 	    else if (y_type == MLINE) 	    { 		// put cursor on first non-blank in first inserted line 		curwin->w_cursor.col = 0; 		if (dir == FORWARD) 		    ++curwin->w_cursor.lnum; 		beginline(BL_WHITE | BL_FIX); 	    } 	    else	// put cursor on first inserted character 		curwin->w_cursor = new_cursor; 	}     }      msgmore(nr_lines);     curwin->w_set_curswant = TRUE;  end:     if (cmdmod.cmod_flags & CMOD_LOCKMARKS)     { 	curbuf->b_op_start = orig_start; 	curbuf->b_op_end = orig_end;     }     if (allocated) 	vim_free(insert_string);     if (regname == '=') 	vim_free(y_array);      VIsual_active = FALSE;      // If the cursor is past the end of the line put it at the end.     adjust_cursor_eol(); }"
"202082_CWE-125.c","CWE-125","R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { 	ut32 i = 0; 	RBinJavaBootStrapMethod *bsm = NULL; 	ut64 offset = 0; 	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); 	offset += 6; 	if (attr) { 		attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR; 		attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free); 		for (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) { 			// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur); 			if (offset >= sz) { 				break; 			} 			bsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset); 			if (bsm) { 				offset += bsm->size; 				r_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm); 			} else { 				// TODO eprintf Failed to read the %d boot strap method. 			} 		} 		attr->size = offset; 	} 	return attr; }"
"202125_CWE-787.c","CWE-787","_inplace_src_spans (void *abstract_renderer, int y, int h, 		    const cairo_half_open_span_t *spans, 		    unsigned num_spans) {     cairo_image_span_renderer_t *r = abstract_renderer;     uint8_t *m;     int x0;      if (num_spans == 0) 	return CAIRO_STATUS_SUCCESS;      x0 = spans[0].x;     m = r->_buf;     do { 	int len = spans[1].x - spans[0].x; 	if (len >= r->u.composite.run_length && spans[0].coverage == 0xff) { 	    if (spans[0].x != x0) { #if PIXMAN_HAS_OP_LERP 		pixman_image_composite32 (PIXMAN_OP_LERP_SRC, 					  r->src, r->mask, r->u.composite.dst, 					  x0 + r->u.composite.src_x, 					  y + r->u.composite.src_y, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); #else 		pixman_image_composite32 (PIXMAN_OP_OUT_REVERSE, 					  r->mask, NULL, r->u.composite.dst, 					  0, 0, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); 		pixman_image_composite32 (PIXMAN_OP_ADD, 					  r->src, r->mask, r->u.composite.dst, 					  x0 + r->u.composite.src_x, 					  y + r->u.composite.src_y, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); #endif 	    }  	    pixman_image_composite32 (PIXMAN_OP_SRC, 				      r->src, NULL, r->u.composite.dst, 				      spans[0].x + r->u.composite.src_x, 				      y + r->u.composite.src_y, 				      0, 0, 				      spans[0].x, y, 				      spans[1].x - spans[0].x, h);  	    m = r->_buf; 	    x0 = spans[1].x; 	} else if (spans[0].coverage == 0x0) { 	    if (spans[0].x != x0) { #if PIXMAN_HAS_OP_LERP 		pixman_image_composite32 (PIXMAN_OP_LERP_SRC, 					  r->src, r->mask, r->u.composite.dst, 					  x0 + r->u.composite.src_x, 					  y + r->u.composite.src_y, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); #else 		pixman_image_composite32 (PIXMAN_OP_OUT_REVERSE, 					  r->mask, NULL, r->u.composite.dst, 					  0, 0, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); 		pixman_image_composite32 (PIXMAN_OP_ADD, 					  r->src, r->mask, r->u.composite.dst, 					  x0 + r->u.composite.src_x, 					  y + r->u.composite.src_y, 					  0, 0, 					  x0, y, 					  spans[0].x - x0, h); #endif 	    }  	    m = r->_buf; 	    x0 = spans[1].x; 	} else { 	    *m++ = spans[0].coverage; 	    if (len > 1) { 		memset (m, spans[0].coverage, --len); 		m += len; 	    } 	} 	spans++;     } while (--num_spans > 1);      if (spans[0].x != x0) { #if PIXMAN_HAS_OP_LERP 	pixman_image_composite32 (PIXMAN_OP_LERP_SRC, 				  r->src, r->mask, r->u.composite.dst, 				  x0 + r->u.composite.src_x, 				  y + r->u.composite.src_y, 				  0, 0, 				  x0, y, 				  spans[0].x - x0, h); #else 	pixman_image_composite32 (PIXMAN_OP_OUT_REVERSE, 				  r->mask, NULL, r->u.composite.dst, 				  0, 0, 				  0, 0, 				  x0, y, 				  spans[0].x - x0, h); 	pixman_image_composite32 (PIXMAN_OP_ADD, 				  r->src, r->mask, r->u.composite.dst, 				  x0 + r->u.composite.src_x, 				  y + r->u.composite.src_y, 				  0, 0, 				  x0, y, 				  spans[0].x - x0, h); #endif     }      return CAIRO_STATUS_SUCCESS; }"
"202256_CWE-787.cpp","CWE-787","void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW     qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif      Q_D(QPaintEngineEx);      if (path.isEmpty())         return;      if (!d->strokeHandler) {         d->strokeHandler = new StrokeHandler(path.elementCount()+4);         d->stroker.setMoveToHook(qpaintengineex_moveTo);         d->stroker.setLineToHook(qpaintengineex_lineTo);         d->stroker.setCubicToHook(qpaintengineex_cubicTo);     }      QRectF clipRect;     QPen pen = inPen;     if (pen.style() > Qt::SolidLine) {         QRectF cpRect = path.controlPointRect();         const QTransform &xf = state()->matrix;         if (pen.isCosmetic()) {             clipRect = d->exDeviceRect;             cpRect.translate(xf.dx(), xf.dy());         } else {             clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));         }         // Check to avoid generating unwieldy amount of dashes that will not be visible anyway         QRectF extentRect = cpRect & clipRect;         qreal extent = qMax(extentRect.width(), extentRect.height());         qreal patternLength = 0;         const QList<qreal> pattern = pen.dashPattern();         const int patternSize = qMin(pattern.size(), 32);         for (int i = 0; i < patternSize; i++)             patternLength += qMax(pattern.at(i), qreal(0));         if (pen.widthF())             patternLength *= pen.widthF();         if (qFuzzyIsNull(patternLength)) {             pen.setStyle(Qt::NoPen);         } else if (extent / patternLength > 10000) {             // approximate stream of tiny dashes with semi-transparent solid line             pen.setStyle(Qt::SolidLine);             QColor color(pen.color());             color.setAlpha(color.alpha() / 2);             pen.setColor(color);         }     }      if (!qpen_fast_equals(pen, d->strokerPen)) {         d->strokerPen = pen;         d->stroker.setJoinStyle(pen.joinStyle());         d->stroker.setCapStyle(pen.capStyle());         d->stroker.setMiterLimit(pen.miterLimit());         qreal penWidth = pen.widthF();         if (penWidth == 0)             d->stroker.setStrokeWidth(1);         else             d->stroker.setStrokeWidth(penWidth);          Qt::PenStyle style = pen.style();         if (style == Qt::SolidLine) {             d->activeStroker = &d->stroker;         } else if (style == Qt::NoPen) {             d->activeStroker = nullptr;         } else {             d->dasher.setDashPattern(pen.dashPattern());             d->dasher.setDashOffset(pen.dashOffset());             d->activeStroker = &d->dasher;         }     }      if (!d->activeStroker) {         return;     }      if (!clipRect.isNull())         d->activeStroker->setClipRect(clipRect);      if (d->activeStroker == &d->stroker)         d->stroker.setForceOpen(path.hasExplicitOpen());      const QPainterPath::ElementType *types = path.elements();     const qreal *points = path.points();     int pointCount = path.elementCount();      const qreal *lastPoint = points + (pointCount<<1);      d->strokeHandler->types.reset();     d->strokeHandler->pts.reset();      // Some engines might decide to optimize for the non-shape hint later on...     uint flags = QVectorPath::WindingFill;      if (path.elementCount() > 2)         flags |= QVectorPath::NonConvexShapeMask;      if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)         flags |= QVectorPath::CurvedShapeMask;      // ### Perspective Xforms are currently not supported...     if (!pen.isCosmetic()) {         // We include cosmetic pens in this case to avoid having to         // change the current transform. Normal transformed,         // non-cosmetic pens will be transformed as part of fill         // later, so they are also covered here..         d->activeStroker->setCurveThresholdFromTransform(state()->matrix);         d->activeStroker->begin(d->strokeHandler);         if (types) {             while (points < lastPoint) {                 switch (*types) {                 case QPainterPath::MoveToElement:                     d->activeStroker->moveTo(points[0], points[1]);                     points += 2;                     ++types;                     break;                 case QPainterPath::LineToElement:                     d->activeStroker->lineTo(points[0], points[1]);                     points += 2;                     ++types;                     break;                 case QPainterPath::CurveToElement:                     d->activeStroker->cubicTo(points[0], points[1],                                               points[2], points[3],                                               points[4], points[5]);                     points += 6;                     types += 3;                     flags |= QVectorPath::CurvedShapeMask;                     break;                 default:                     break;                 }             }             if (path.hasImplicitClose())                 d->activeStroker->lineTo(path.points()[0], path.points()[1]);          } else {             d->activeStroker->moveTo(points[0], points[1]);             points += 2;             while (points < lastPoint) {                 d->activeStroker->lineTo(points[0], points[1]);                 points += 2;             }             if (path.hasImplicitClose())                 d->activeStroker->lineTo(path.points()[0], path.points()[1]);         }         d->activeStroker->end();          if (!d->strokeHandler->types.size()) // an empty path...             return;          QVectorPath strokePath(d->strokeHandler->pts.data(),                                d->strokeHandler->types.size(),                                d->strokeHandler->types.data(),                                flags);         fill(strokePath, pen.brush());     } else {         // For cosmetic pens we need a bit of trickery... We to process xform the input points         if (state()->matrix.type() >= QTransform::TxProject) {             QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());             d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());         } else {             d->activeStroker->setCurveThresholdFromTransform(QTransform());             d->activeStroker->begin(d->strokeHandler);             if (types) {                 while (points < lastPoint) {                     switch (*types) {                     case QPainterPath::MoveToElement: {                         QPointF pt = (*(const QPointF *) points) * state()->matrix;                         d->activeStroker->moveTo(pt.x(), pt.y());                         points += 2;                         ++types;                         break;                     }                     case QPainterPath::LineToElement: {                         QPointF pt = (*(const QPointF *) points) * state()->matrix;                         d->activeStroker->lineTo(pt.x(), pt.y());                         points += 2;                         ++types;                         break;                     }                     case QPainterPath::CurveToElement: {                         QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;                         QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;                         QPointF e =  ((const QPointF *) points)[2] * state()->matrix;                         d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());                         points += 6;                         types += 3;                         flags |= QVectorPath::CurvedShapeMask;                         break;                     }                     default:                         break;                     }                 }                 if (path.hasImplicitClose()) {                     QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;                     d->activeStroker->lineTo(pt.x(), pt.y());                 }              } else {                 QPointF p = ((const QPointF *)points)[0] * state()->matrix;                 d->activeStroker->moveTo(p.x(), p.y());                 points += 2;                 while (points < lastPoint) {                     QPointF p = ((const QPointF *)points)[0] * state()->matrix;                     d->activeStroker->lineTo(p.x(), p.y());                     points += 2;                 }                 if (path.hasImplicitClose())                     d->activeStroker->lineTo(p.x(), p.y());             }             d->activeStroker->end();         }          QVectorPath strokePath(d->strokeHandler->pts.data(),                                d->strokeHandler->types.size(),                                d->strokeHandler->types.data(),                                flags);          QTransform xform = state()->matrix;         state()->matrix = QTransform();         transformChanged();          QBrush brush = pen.brush();         if (qbrush_style(brush) != Qt::SolidPattern)             brush.setTransform(brush.transform() * xform);          fill(strokePath, brush);          state()->matrix = xform;         transformChanged();     } }"
"202276_CWE-787.cpp","CWE-787","block_insert(     oparg_T		*oap,     char_u		*s,     int			b_insert,     struct block_def	*bdp) {     int		ts_val;     int		count = 0;	// extra spaces to replace a cut TAB     int		spaces = 0;	// non-zero if cutting a TAB     colnr_T	offset;		// pointer along new line     colnr_T	startcol;	// column where insert starts     unsigned	s_len;		// STRLEN(s)     char_u	*newp, *oldp;	// new, old lines     linenr_T	lnum;		// loop var     int		oldstate = State;      State = INSERT;		// don't want REPLACE for State     s_len = (unsigned)STRLEN(s);      for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)     { 	block_prep(oap, bdp, lnum, TRUE); 	if (bdp->is_short && b_insert) 	    continue;	// OP_INSERT, line ends before block start  	oldp = ml_get(lnum);  	if (b_insert) 	{ 	    ts_val = bdp->start_char_vcols; 	    spaces = bdp->startspaces; 	    if (spaces != 0) 		count = ts_val - 1; // we're cutting a TAB 	    offset = bdp->textcol; 	} 	else // append 	{ 	    ts_val = bdp->end_char_vcols; 	    if (!bdp->is_short) // spaces = padding after block 	    { 		spaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0); 		if (spaces != 0) 		    count = ts_val - 1; // we're cutting a TAB 		offset = bdp->textcol + bdp->textlen - (spaces != 0); 	    } 	    else // spaces = padding to block edge 	    { 		// if $ used, just append to EOL (ie spaces==0) 		if (!bdp->is_MAX) 		    spaces = (oap->end_vcol - bdp->end_vcol) + 1; 		count = spaces; 		offset = bdp->textcol + bdp->textlen; 	    } 	}  	if (has_mbyte && spaces > 0) 	{ 	    int off;  	    // Avoid starting halfway a multi-byte character. 	    if (b_insert) 	    { 		off = (*mb_head_off)(oldp, oldp + offset + spaces); 		spaces -= off; 		count -= off; 	    } 	    else 	    { 		// spaces fill the gap, the character that's at the edge moves 		// right 		off = (*mb_head_off)(oldp, oldp + offset); 		offset -= off; 	    } 	} 	if (spaces < 0)  // can happen when the cursor was moved 	    spaces = 0;  	// Make sure the allocated size matches what is actually copied below. 	newp = alloc(STRLEN(oldp) + spaces + s_len 		    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0) 								  + count + 1); 	if (newp == NULL) 	    continue;  	// copy up to shifted part 	mch_memmove(newp, oldp, (size_t)offset); 	oldp += offset;  	// insert pre-padding 	vim_memset(newp + offset, ' ', (size_t)spaces); 	startcol = offset + spaces;  	// copy the new text 	mch_memmove(newp + startcol, s, (size_t)s_len); 	offset += s_len;  	if (spaces > 0 && !bdp->is_short) 	{ 	    if (*oldp == TAB) 	    { 		// insert post-padding 		vim_memset(newp + offset + spaces, ' ', 						    (size_t)(ts_val - spaces)); 		// we're splitting a TAB, don't copy it 		oldp++; 		// We allowed for that TAB, remember this now 		count++; 	    } 	    else 		// Not a TAB, no extra spaces 		count = spaces; 	}  	if (spaces > 0) 	    offset += count; 	STRMOVE(newp + offset, oldp);  	ml_replace(lnum, newp, FALSE);  	if (b_insert) 	    // correct any text properties 	    inserted_bytes(lnum, startcol, s_len);  	if (lnum == oap->end.lnum) 	{ 	    // Set ""']"" mark to the end of the block instead of the end of 	    // the insert in the first line. 	    curbuf->b_op_end.lnum = oap->end.lnum; 	    curbuf->b_op_end.col = offset; 	}     } // for all lnum      changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);      State = oldstate; }"
"202304_CWE-122.c","CWE-122","find_match_text(colnr_T startcol, int regstart, char_u *match_text) {     colnr_T col = startcol;     int	    c1, c2;     int	    len1, len2;     int	    match;      for (;;)     { 	match = TRUE; 	len2 = MB_CHAR2LEN(regstart); // skip regstart 	for (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1)) 	{ 	    c1 = PTR2CHAR(match_text + len1); 	    c2 = PTR2CHAR(rex.line + col + len2); 	    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2))) 	    { 		match = FALSE; 		break; 	    } 	    len2 += MB_CHAR2LEN(c2); 	} 	if (match 		// check that no composing char follows 		&& !(enc_utf8 			  && utf_iscomposing(PTR2CHAR(rex.line + col + len2)))) 	{ 	    cleanup_subexpr(); 	    if (REG_MULTI) 	    { 		rex.reg_startpos[0].lnum = rex.lnum; 		rex.reg_startpos[0].col = col; 		rex.reg_endpos[0].lnum = rex.lnum; 		rex.reg_endpos[0].col = col + len2; 	    } 	    else 	    { 		rex.reg_startp[0] = rex.line + col; 		rex.reg_endp[0] = rex.line + col + len2; 	    } 	    return 1L; 	}  	// Try finding regstart after the current match. 	col += MB_CHAR2LEN(regstart); // skip regstart 	if (skip_to_start(regstart, &col) == FAIL) 	    break;     }     return 0L; }"
"202392_CWE-119.c","CWE-119","static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size) { 	unsigned int u = 0; 	LineContribType *res; 	int overflow_error = 0;  	res = (LineContribType *) gdMalloc(sizeof(LineContribType)); 	if (!res) { 		return NULL; 	} 	res->WindowSize = windows_size; 	res->LineLength = line_length; 	if (overflow2(line_length, sizeof(ContributionType))) { 		gdFree(res); 		return NULL; 	} 	res->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType)); 	if (res->ContribRow == NULL) { 		gdFree(res); 		return NULL; 	} 	for (u = 0 ; u < line_length ; u++) { 		if (overflow2(windows_size, sizeof(double))) { 			overflow_error = 1; 		} else { 			res->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double)); 		} 		if (overflow_error == 1 || res->ContribRow[u].Weights == NULL) { 			u--; 			while (u >= 0) { 				gdFree(res->ContribRow[u].Weights); 				u--; 			} 			return NULL; 		} 	} 	return res; }"
"202600_CWE-416.c","CWE-416","append_command(char_u *cmd) {     char_u *s = cmd;     char_u *d;      STRCAT(IObuff, "": "");     d = IObuff + STRLEN(IObuff);     while (*s != NUL && d - IObuff < IOSIZE - 7)     { 	if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0) 	{ 	    s += enc_utf8 ? 2 : 1; 	    STRCPY(d, ""<a0>""); 	    d += 4; 	} 	else 	    MB_COPY_CHAR(s, d);     }     *d = NUL; }"
"202659_CWE-125.c","CWE-125","static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt, 		u8 type, u8 code, int offset, __be32 info) { 	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data; 	__be16 *p = (__be16 *)(skb->data + offset); 	int grehlen = offset + 4; 	struct ip6_tnl *t; 	__be16 flags;  	flags = p[0]; 	if (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) { 		if (flags&(GRE_VERSION|GRE_ROUTING)) 			return; 		if (flags&GRE_KEY) { 			grehlen += 4; 			if (flags&GRE_CSUM) 				grehlen += 4; 		} 	}  	/* If only 8 bytes returned, keyed message will be dropped here */ 	if (!pskb_may_pull(skb, grehlen)) 		return; 	ipv6h = (const struct ipv6hdr *)skb->data; 	p = (__be16 *)(skb->data + offset);  	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr, 				flags & GRE_KEY ? 				*(((__be32 *)p) + (grehlen / 4) - 1) : 0, 				p[1]); 	if (!t) 		return;  	switch (type) { 		__u32 teli; 		struct ipv6_tlv_tnl_enc_lim *tel; 		__u32 mtu; 	case ICMPV6_DEST_UNREACH: 		net_dbg_ratelimited(""%s: Path to destination invalid or inactive!\n"", 				    t->parms.name); 		break; 	case ICMPV6_TIME_EXCEED: 		if (code == ICMPV6_EXC_HOPLIMIT) { 			net_dbg_ratelimited(""%s: Too small hop limit or routing loop in tunnel!\n"", 					    t->parms.name); 		} 		break; 	case ICMPV6_PARAMPROB: 		teli = 0; 		if (code == ICMPV6_HDR_FIELD) 			teli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);  		if (teli && teli == be32_to_cpu(info) - 2) { 			tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli]; 			if (tel->encap_limit == 0) { 				net_dbg_ratelimited(""%s: Too small encapsulation limit or routing loop in tunnel!\n"", 						    t->parms.name); 			} 		} else { 			net_dbg_ratelimited(""%s: Recipient unable to parse tunneled packet!\n"", 					    t->parms.name); 		} 		break; 	case ICMPV6_PKT_TOOBIG: 		mtu = be32_to_cpu(info) - offset; 		if (mtu < IPV6_MIN_MTU) 			mtu = IPV6_MIN_MTU; 		t->dev->mtu = mtu; 		break; 	}  	if (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO)) 		t->err_count++; 	else 		t->err_count = 1; 	t->err_time = jiffies; }"
"202677_CWE-369.c","CWE-369","static int parallels_open(BlockDriverState *bs, QDict *options, int flags,                           Error **errp) {     BDRVParallelsState *s = bs->opaque;     int i;     struct parallels_header ph;     int ret;      bs->read_only = 1; // no write support yet      ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));     if (ret < 0) {         goto fail;     }      if (memcmp(ph.magic, HEADER_MAGIC, 16) ||         (le32_to_cpu(ph.version) != HEADER_VERSION)) {         error_setg(errp, ""Image not in Parallels format"");         ret = -EINVAL;         goto fail;     }      bs->total_sectors = le32_to_cpu(ph.nb_sectors);      s->tracks = le32_to_cpu(ph.tracks);      s->catalog_size = le32_to_cpu(ph.catalog_entries);     if (s->catalog_size > INT_MAX / 4) {         error_setg(errp, ""Catalog too large"");         ret = -EFBIG;         goto fail;     }     s->catalog_bitmap = g_malloc(s->catalog_size * 4);      ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);     if (ret < 0) {         goto fail;     }      for (i = 0; i < s->catalog_size; i++) 	le32_to_cpus(&s->catalog_bitmap[i]);      qemu_co_mutex_init(&s->lock);     return 0;  fail:     g_free(s->catalog_bitmap);     return ret; }"
"202688_CWE-787.c","CWE-787","lprn_is_black(gx_device_printer * pdev, int r, int h, int bx) {     gx_device_lprn *const lprn = (gx_device_lprn *) pdev;      int bh = lprn->nBh;     int bpl = gdev_mem_bytes_per_scan_line(pdev);     int x, y, y0;     byte *p;     int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;      y0 = (r + h - bh) % maxY;     for (y = 0; y < bh; y++) {         p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];         for (x = 0; x < lprn->nBw; x++)             if (p[x] != 0)                 return 1;     }     return 0; }"
"202708_CWE-476.c","CWE-476","fname_match(     regmatch_T	*rmp,     char_u	*name,     int		ignore_case)  // when TRUE ignore case, when FALSE use 'fic' {     char_u	*match = NULL;     char_u	*p;      if (name != NULL)     { 	// Ignore case when 'fileignorecase' or the argument is set. 	rmp->rm_ic = p_fic || ignore_case; 	if (vim_regexec(rmp, name, (colnr_T)0)) 	    match = name; 	else 	{ 	    // Replace $(HOME) with '~' and try matching again. 	    p = home_replace_save(NULL, name); 	    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0)) 		match = name; 	    vim_free(p); 	}     }      return match; }"
"202719_CWE-704.c","CWE-704","struct sctp_chunk *sctp_make_strreset_req( 					const struct sctp_association *asoc, 					__u16 stream_num, __be16 *stream_list, 					bool out, bool in) { 	__u16 stream_len = stream_num * sizeof(__u16); 	struct sctp_strreset_outreq outreq; 	struct sctp_strreset_inreq inreq; 	struct sctp_chunk *retval; 	__u16 outlen, inlen;  	outlen = (sizeof(outreq) + stream_len) * out; 	inlen = (sizeof(inreq) + stream_len) * in;  	retval = sctp_make_reconf(asoc, outlen + inlen); 	if (!retval) 		return NULL;  	if (outlen) { 		outreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST; 		outreq.param_hdr.length = htons(outlen); 		outreq.request_seq = htonl(asoc->strreset_outseq); 		outreq.response_seq = htonl(asoc->strreset_inseq - 1); 		outreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);  		sctp_addto_chunk(retval, sizeof(outreq), &outreq);  		if (stream_len) 			sctp_addto_chunk(retval, stream_len, stream_list); 	}  	if (inlen) { 		inreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST; 		inreq.param_hdr.length = htons(inlen); 		inreq.request_seq = htonl(asoc->strreset_outseq + out);  		sctp_addto_chunk(retval, sizeof(inreq), &inreq);  		if (stream_len) 			sctp_addto_chunk(retval, stream_len, stream_list); 	}  	return retval; }"
"202748_CWE-772.c","CWE-772","static Image *ReadTGAImage(const ImageInfo *image_info,   ExceptionInfo *exception) {   Image     *image;    MagickBooleanType     status;    PixelInfo     pixel;    Quantum     index;    register Quantum     *q;    register ssize_t     i,     x;    size_t     base,     flag,     offset,     real,     skip;    ssize_t     count,     y;    TGAInfo     tga_info;    unsigned char     j,     k,     pixels[4],     runlength;    unsigned int     alpha_bits;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info,exception);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Read TGA header information.   */   count=ReadBlob(image,1,&tga_info.id_length);   tga_info.colormap_type=(unsigned char) ReadBlobByte(image);   tga_info.image_type=(TGAImageType) ReadBlobByte(image);   if ((count != 1) ||       ((tga_info.image_type != TGAColormap) &&        (tga_info.image_type != TGARGB) &&        (tga_info.image_type != TGAMonochrome) &&        (tga_info.image_type != TGARLEColormap) &&        (tga_info.image_type != TGARLERGB) &&        (tga_info.image_type != TGARLEMonochrome)) ||       (((tga_info.image_type == TGAColormap) ||        (tga_info.image_type == TGARLEColormap)) &&        (tga_info.colormap_type == 0)))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   tga_info.colormap_index=ReadBlobLSBShort(image);   tga_info.colormap_length=ReadBlobLSBShort(image);   tga_info.colormap_size=(unsigned char) ReadBlobByte(image);   tga_info.x_origin=ReadBlobLSBShort(image);   tga_info.y_origin=ReadBlobLSBShort(image);   tga_info.width=(unsigned short) ReadBlobLSBShort(image);   tga_info.height=(unsigned short) ReadBlobLSBShort(image);   tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);   tga_info.attributes=(unsigned char) ReadBlobByte(image);   if (EOFBlob(image) != MagickFalse)     ThrowReaderException(CorruptImageError,""UnableToReadImageData"");   if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&        (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   /*     Initialize image structure.   */   image->columns=tga_info.width;   image->rows=tga_info.height;   alpha_bits=(tga_info.attributes & 0x0FU);   image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||     (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;   if ((tga_info.image_type != TGAColormap) &&       (tga_info.image_type != TGARLEColormap))     image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :       (tga_info.bits_per_pixel <= 16) ? 5 : 8);   else     image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :       (tga_info.colormap_size <= 16) ? 5 : 8);   if ((tga_info.image_type == TGAColormap) ||       (tga_info.image_type == TGAMonochrome) ||       (tga_info.image_type == TGARLEColormap) ||       (tga_info.image_type == TGARLEMonochrome))     image->storage_class=PseudoClass;   image->compression=NoCompression;   if ((tga_info.image_type == TGARLEColormap) ||       (tga_info.image_type == TGARLEMonochrome) ||       (tga_info.image_type == TGARLERGB))     image->compression=RLECompression;   if (image->storage_class == PseudoClass)     {       if (tga_info.colormap_type != 0)         image->colors=tga_info.colormap_index+tga_info.colormap_length;       else         {           size_t             one;            one=1;           image->colors=one << tga_info.bits_per_pixel;           if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         }     }   if (tga_info.id_length != 0)     {       char         *comment;        size_t         length;        /*         TGA image comment.       */       length=(size_t) tga_info.id_length;       comment=(char *) NULL;       if (~length >= (MagickPathExtent-1))         comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,           sizeof(*comment));       if (comment == (char *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);       comment[tga_info.id_length]='\0';       (void) SetImageProperty(image,""comment"",comment,exception);       comment=DestroyString(comment);     }   if (tga_info.attributes & (1UL << 4))     {       if (tga_info.attributes & (1UL << 5))         SetImageArtifact(image,""tga:image-origin"",""TopRight"");       else         SetImageArtifact(image,""tga:image-origin"",""BottomRight"");     }   else     {       if (tga_info.attributes & (1UL << 5))         SetImageArtifact(image,""tga:image-origin"",""TopLeft"");       else         SetImageArtifact(image,""tga:image-origin"",""BottomLeft"");     }   if (image_info->ping != MagickFalse)     {       (void) CloseBlob(image);       return(image);     }   status=SetImageExtent(image,image->columns,image->rows,exception);   if (status == MagickFalse)     return(DestroyImageList(image));   (void) ResetMagickMemory(&pixel,0,sizeof(pixel));   pixel.alpha=(MagickRealType) OpaqueAlpha;   if (tga_info.colormap_type != 0)     {       /*         Read TGA raster colormap.       */       if (image->colors < tga_info.colormap_index)         image->colors=tga_info.colormap_index;       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)         image->colormap[i]=pixel;       for ( ; i < (ssize_t) image->colors; i++)       {         switch (tga_info.colormap_size)         {           case 8:           default:           {             /*               Gray scale.             */             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.green=pixel.red;             pixel.blue=pixel.red;             break;           }           case 15:           case 16:           {             QuantumAny               range;              /*               5 bits each of red green and blue.             */             j=(unsigned char) ReadBlobByte(image);             k=(unsigned char) ReadBlobByte(image);             range=GetQuantumRange(5UL);             pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,               range);             pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)               << 3)+(1UL*(j & 0xe0) >> 5),range);             pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);             break;           }           case 24:           {             /*               8 bits each of blue, green and red.             */             pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             break;           }           case 32:           {             /*               8 bits each of blue, green, red, and alpha.             */             pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)               ReadBlobByte(image));             break;           }         }         image->colormap[i]=pixel;       }     }   /*     Convert TGA pixels to pixel packets.   */   base=0;   flag=0;   skip=MagickFalse;   real=0;   index=0;   runlength=0;   offset=0;   for (y=0; y < (ssize_t) image->rows; y++)   {     real=offset;     if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)       real=image->rows-real-1;     q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);     if (q == (Quantum *) NULL)       break;     for (x=0; x < (ssize_t) image->columns; x++)     {       if ((tga_info.image_type == TGARLEColormap) ||           (tga_info.image_type == TGARLERGB) ||           (tga_info.image_type == TGARLEMonochrome))         {           if (runlength != 0)             {               runlength--;               skip=flag != 0;             }           else             {               count=ReadBlob(image,1,&runlength);               if (count != 1)                 ThrowReaderException(CorruptImageError,""UnableToReadImageData"");               flag=runlength & 0x80;               if (flag != 0)                 runlength-=128;               skip=MagickFalse;             }         }       if (skip == MagickFalse)         switch (tga_info.bits_per_pixel)         {           case 8:           default:           {             /*               Gray scale.             */             index=(Quantum) ReadBlobByte(image);             if (tga_info.colormap_type != 0)               pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,                 (ssize_t) index,exception)];             else               {                 pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)                   index);                 pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)                   index);                 pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)                   index);               }             break;           }           case 15:           case 16:           {             QuantumAny               range;              /*               5 bits each of RGB.             */             if (ReadBlob(image,2,pixels) != 2)               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");             j=pixels[0];             k=pixels[1];             range=GetQuantumRange(5UL);             pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,               range);             pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*               (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);             pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);             if (image->alpha_trait != UndefinedPixelTrait)               pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)                 TransparentAlpha : (Quantum) OpaqueAlpha);             if (image->storage_class == PseudoClass)               index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+                 j,exception);             break;           }           case 24:           {             /*               BGR pixels.             */             if (ReadBlob(image,3,pixels) != 3)               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");             pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);             pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);             pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);             break;           }           case 32:           {             /*               BGRA pixels.             */             if (ReadBlob(image,4,pixels) != 4)               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");             pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);             pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);             pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);             pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);             break;           }         }       if (status == MagickFalse)         ThrowReaderException(CorruptImageError,""UnableToReadImageData"");       if (image->storage_class == PseudoClass)         SetPixelIndex(image,index,q);       SetPixelRed(image,ClampToQuantum(pixel.red),q);       SetPixelGreen(image,ClampToQuantum(pixel.green),q);       SetPixelBlue(image,ClampToQuantum(pixel.blue),q);       if (image->alpha_trait != UndefinedPixelTrait)         SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);       q+=GetPixelChannels(image);     }     /*       if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)         offset+=4;       else     */       if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)         offset+=2;       else         offset++;     if (offset >= image->rows)       {         base++;         offset=base;       }     if (SyncAuthenticPixels(image,exception) == MagickFalse)       break;     if (image->previous == (Image *) NULL)       {         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,           image->rows);         if (status == MagickFalse)           break;       }   }   if (EOFBlob(image) != MagickFalse)     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",       image->filename);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"202783_CWE-119.c","CWE-119","static Bigint * Balloc(int k) { 	int x; 	Bigint *rv;  	_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex); 	if ((rv = freelist[k])) { 		freelist[k] = rv->next; 	} else { 		x = 1 << k; 		rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long)); 		rv->k = k; 		rv->maxwds = x; 	} 	_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex); 	rv->sign = rv->wds = 0; 	return rv; }"
"202810_CWE-203.c","CWE-203","_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,                       gcry_mpi_t r, gcry_mpi_t s,                       int flags, int hashalgo) {   gpg_err_code_t rc = 0;   int extraloops = 0;   gcry_mpi_t k, dr, sum, k_1, x;   mpi_point_struct I;   gcry_mpi_t hash;   const void *abuf;   unsigned int abits, qbits;   mpi_ec_t ctx;    if (DBG_CIPHER)     log_mpidump (""ecdsa sign hash  "", input );    qbits = mpi_get_nbits (skey->E.n);    /* Convert the INPUT into an MPI if needed.  */   rc = _gcry_dsa_normalize_hash (input, &hash, qbits);   if (rc)     return rc;    k = NULL;   dr = mpi_alloc (0);   sum = mpi_alloc (0);   k_1 = mpi_alloc (0);   x = mpi_alloc (0);   point_init (&I);    ctx = _gcry_mpi_ec_p_internal_new (skey->E.model, skey->E.dialect, 0,                                      skey->E.p, skey->E.a, skey->E.b);    /* Two loops to avoid R or S are zero.  This is more of a joke than      a real demand because the probability of them being zero is less      than any hardware failure.  Some specs however require it.  */   do     {       do         {           mpi_free (k);           k = NULL;           if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)             {               /* Use Pornin's method for deterministic DSA.  If this                  flag is set, it is expected that HASH is an opaque                  MPI with the to be signed hash.  That hash is also                  used as h1 from 3.2.a.  */               if (!mpi_is_opaque (input))                 {                   rc = GPG_ERR_CONFLICT;                   goto leave;                 }                abuf = mpi_get_opaque (input, &abits);               rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,                                             abuf, (abits+7)/8,                                             hashalgo, extraloops);               if (rc)                 goto leave;               extraloops++;             }           else             k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);            _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);           if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))             {               if (DBG_CIPHER)                 log_debug (""ecc sign: Failed to get affine coordinates\n"");               rc = GPG_ERR_BAD_SIGNATURE;               goto leave;             }           mpi_mod (r, x, skey->E.n);  /* r = x mod n */         }       while (!mpi_cmp_ui (r, 0));        mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */       mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */       mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */       mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */     }   while (!mpi_cmp_ui (s, 0));    if (DBG_CIPHER)     {       log_mpidump (""ecdsa sign result r "", r);       log_mpidump (""ecdsa sign result s "", s);     }   leave:   _gcry_mpi_ec_free (ctx);   point_free (&I);   mpi_free (x);   mpi_free (k_1);   mpi_free (sum);   mpi_free (dr);   mpi_free (k);    if (hash != input)     mpi_free (hash);    return rc; }"
"202822_CWE-787.c","CWE-787","search_impl(i_ctx_t *i_ctx_p, bool forward) {     os_ptr op = osp;     os_ptr op1 = op - 1;     uint size = r_size(op);     uint count;     byte *pat;     byte *ptr;     byte ch;     int incr = forward ? 1 : -1;      check_read_type(*op1, t_string);     check_read_type(*op, t_string);     if (size > r_size(op1)) {	/* can't match */         make_false(op);         return 0;     }     count = r_size(op1) - size;     ptr = op1->value.bytes;     if (size == 0)         goto found;     if (!forward)         ptr += count;     pat = op->value.bytes;     ch = pat[0];     do {         if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))             goto found;         ptr += incr;     }     while (count--);     /* No match */     make_false(op);     return 0; found:     op->tas.type_attrs = op1->tas.type_attrs;     op->value.bytes = ptr;     r_set_size(op, size);     push(2);     op[-1] = *op1;     r_set_size(op - 1, ptr - op[-1].value.bytes);     op1->value.bytes = ptr + size;     r_set_size(op1, count + (!forward ? (size - 1) : 0));     make_true(op);     return 0; }"
"202888_CWE-787.c","CWE-787","int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp) { 	u8 *tail; 	int nfrags; 	int esph_offset; 	struct page *page; 	struct sk_buff *trailer; 	int tailen = esp->tailen;  	/* this is non-NULL only with TCP/UDP Encapsulation */ 	if (x->encap) { 		int err = esp_output_encap(x, skb, esp);  		if (err < 0) 			return err; 	}  	if (!skb_cloned(skb)) { 		if (tailen <= skb_tailroom(skb)) { 			nfrags = 1; 			trailer = skb; 			tail = skb_tail_pointer(trailer);  			goto skip_cow; 		} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS) 			   && !skb_has_frag_list(skb)) { 			int allocsize; 			struct sock *sk = skb->sk; 			struct page_frag *pfrag = &x->xfrag;  			esp->inplace = false;  			allocsize = ALIGN(tailen, L1_CACHE_BYTES);  			spin_lock_bh(&x->lock);  			if (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) { 				spin_unlock_bh(&x->lock); 				goto cow; 			}  			page = pfrag->page; 			get_page(page);  			tail = page_address(page) + pfrag->offset;  			esp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);  			nfrags = skb_shinfo(skb)->nr_frags;  			__skb_fill_page_desc(skb, nfrags, page, pfrag->offset, 					     tailen); 			skb_shinfo(skb)->nr_frags = ++nfrags;  			pfrag->offset = pfrag->offset + allocsize;  			spin_unlock_bh(&x->lock);  			nfrags++;  			skb->len += tailen; 			skb->data_len += tailen; 			skb->truesize += tailen; 			if (sk && sk_fullsock(sk)) 				refcount_add(tailen, &sk->sk_wmem_alloc);  			goto out; 		} 	}  cow: 	esph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);  	nfrags = skb_cow_data(skb, tailen, &trailer); 	if (nfrags < 0) 		goto out; 	tail = skb_tail_pointer(trailer); 	esp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);  skip_cow: 	esp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto); 	pskb_put(skb, trailer, tailen);  out: 	return nfrags; }"
"202889_CWE-787.c","CWE-787","int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp) { 	u8 *tail; 	int nfrags; 	int esph_offset; 	struct page *page; 	struct sk_buff *trailer; 	int tailen = esp->tailen;  	if (x->encap) { 		int err = esp6_output_encap(x, skb, esp);  		if (err < 0) 			return err; 	}  	if (!skb_cloned(skb)) { 		if (tailen <= skb_tailroom(skb)) { 			nfrags = 1; 			trailer = skb; 			tail = skb_tail_pointer(trailer);  			goto skip_cow; 		} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS) 			   && !skb_has_frag_list(skb)) { 			int allocsize; 			struct sock *sk = skb->sk; 			struct page_frag *pfrag = &x->xfrag;  			esp->inplace = false;  			allocsize = ALIGN(tailen, L1_CACHE_BYTES);  			spin_lock_bh(&x->lock);  			if (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) { 				spin_unlock_bh(&x->lock); 				goto cow; 			}  			page = pfrag->page; 			get_page(page);  			tail = page_address(page) + pfrag->offset;  			esp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);  			nfrags = skb_shinfo(skb)->nr_frags;  			__skb_fill_page_desc(skb, nfrags, page, pfrag->offset, 					     tailen); 			skb_shinfo(skb)->nr_frags = ++nfrags;  			pfrag->offset = pfrag->offset + allocsize;  			spin_unlock_bh(&x->lock);  			nfrags++;  			skb->len += tailen; 			skb->data_len += tailen; 			skb->truesize += tailen; 			if (sk && sk_fullsock(sk)) 				refcount_add(tailen, &sk->sk_wmem_alloc);  			goto out; 		} 	}  cow: 	esph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);  	nfrags = skb_cow_data(skb, tailen, &trailer); 	if (nfrags < 0) 		goto out; 	tail = skb_tail_pointer(trailer); 	esp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);  skip_cow: 	esp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto); 	pskb_put(skb, trailer, tailen);  out: 	return nfrags; }"
"202892_CWE-434.c","CWE-434","void dostor(char *name, const int append, const int autorename) {     ULHandler ulhandler;     int f;     const char *ul_name = NULL;     const char *atomic_file = NULL;     off_t filesize = (off_t) 0U;     struct stat st;     double started = 0.0;     signed char overwrite = 0;     int overflow = 0;     int ret = -1;     off_t max_filesize = (off_t) -1; #ifdef QUOTAS     Quota quota; #endif     const char *name2 = NULL;      if (type < 1 || (type == 1 && restartat > (off_t) 1)) {         addreply_noformat(503, MSG_NO_ASCII_RESUME);         goto end;     } #ifndef ANON_CAN_RESUME     if (guest != 0 && anon_noupload != 0) {         addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);         goto end;     } #endif     if (ul_check_free_space(name, -1.0) == 0) {         addreply_noformat(552, MSG_NO_DISK_SPACE);         goto end;     }     if (checknamesanity(name, dot_write_ok) != 0) {         addreply(553, MSG_SANITY_FILE_FAILURE, name);         goto end;     }     if (autorename != 0) {         no_truncate = 1;     }     if (restartat > (off_t) 0 || no_truncate != 0) {         if ((atomic_file = get_atomic_file(name)) == NULL) {             addreply(553, MSG_SANITY_FILE_FAILURE, name);             goto end;         }         if (restartat > (off_t) 0 &&             rename(name, atomic_file) != 0 && errno != ENOENT) {             error(553, MSG_RENAME_FAILURE);             atomic_file = NULL;             goto end;         }     }     if (atomic_file != NULL) {         ul_name = atomic_file;     } else {         ul_name = name;     }     if (atomic_file == NULL &&         (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) {         overwrite++;     } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW,                          (mode_t) 0777 & ~u_mask)) == -1) {         error(553, MSG_OPEN_FAILURE2);         goto end;     }     if (fstat(f, &st) < 0) {         (void) close(f);         error(553, MSG_STAT_FAILURE2);         goto end;     }     if (!S_ISREG(st.st_mode)) {         (void) close(f);         addreply_noformat(550, MSG_NOT_REGULAR_FILE);         goto end;     }     alarm(MAX_SESSION_XFER_IDLE);      /* Anonymous users *CAN* overwrite 0-bytes files - This is the right behavior */     if (st.st_size > (off_t) 0) { #ifndef ANON_CAN_RESUME         if (guest != 0) {             addreply_noformat(550, MSG_ANON_CANT_OVERWRITE);             (void) close(f);             goto end;         } #endif         if (append != 0) {             restartat = st.st_size;         }     } else {         restartat = (off_t) 0;     }     if (restartat > st.st_size) {         restartat = st.st_size;     }     if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) {         (void) close(f);         error(451, ""seek"");         goto end;     }     if (restartat < st.st_size) {         if (ftruncate(f, restartat) < 0) {             (void) close(f);             error(451, ""ftruncate"");             goto end;         } #ifdef QUOTAS         if (restartat != st.st_size) {             (void) quota_update(NULL, 0LL,                                 (long long) (restartat - st.st_size),                                 &overflow);         } #endif     } #ifdef QUOTAS     if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 &&         (overflow > 0 || quota.files >= user_quota_files ||          quota.size > user_quota_size ||          (max_filesize >= (off_t) 0 &&           (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {         overflow = 1;         (void) close(f);         goto afterquota;     } #endif     opendata();     if (xferfd == -1) {         (void) close(f);         goto end;     }     doreply(); # ifdef WITH_TLS     if (data_protection_level == CPL_PRIVATE) {         tls_init_data_session(xferfd, passive);     } # endif     state_needs_update = 1;     setprocessname(""pure-ftpd (UPLOAD)"");     filesize = restartat;  #ifdef FTPWHO     if (shm_data_cur != NULL) {         const size_t sl = strlen(name);          ftpwho_lock();         shm_data_cur->state = FTPWHO_STATE_UPLOAD;         shm_data_cur->download_total_size = (off_t) 0U;         shm_data_cur->download_current_size = (off_t) filesize;         shm_data_cur->restartat = restartat;         (void) time(&shm_data_cur->xfer_date);         if (sl < sizeof shm_data_cur->filename) {             memcpy(shm_data_cur->filename, name, sl);             shm_data_cur->filename[sl] = 0;         } else {             memcpy(shm_data_cur->filename,                    &name[sl - sizeof shm_data_cur->filename - 1U],                    sizeof shm_data_cur->filename);         }         ftpwho_unlock();     } #endif      /* Here starts the real upload code */      started = get_usec_time();      if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx,                 restartat, type == 1, throttling_bandwidth_ul,                 max_filesize) == 0) {         ret = ul_send(&ulhandler);         ul_exit(&ulhandler);     } else {         ret = -1;     }     (void) close(f);     closedata();      /* Here ends the real upload code */  #ifdef SHOW_REAL_DISK_SPACE     if (FSTATFS(f, &statfsbuf) == 0) {         double space;          space = (double) STATFS_BAVAIL(statfsbuf) *             (double) STATFS_FRSIZE(statfsbuf);         if (space > 524288.0) {             addreply(0, MSG_SPACE_FREE_M, space / 1048576.0);         } else {             addreply(0, MSG_SPACE_FREE_K, space / 1024.0);         }     } #endif      uploaded += (unsigned long long) ulhandler.total_uploaded;     {         off_t atomic_file_size;         off_t original_file_size;         int files_count;          if (overwrite == 0) {             files_count = 1;         } else {             files_count = 0;         }         if (autorename != 0 && restartat == (off_t) 0) {             if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {                 goto afterquota;             }             if (tryautorename(atomic_file, name, &name2) != 0) {                 error(553, MSG_RENAME_FAILURE);                 goto afterquota;             } else { #ifdef QUOTAS                 ul_quota_update(name2 ? name2 : name, 1, atomic_file_size); #endif                 atomic_file = NULL;             }         } else if (atomic_file != NULL) {             if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) {                 goto afterquota;             }             if ((original_file_size = get_file_size(name)) < (off_t) 0 ||                 restartat > original_file_size) {                 original_file_size = restartat;             }             if (rename(atomic_file, name) != 0) {                 error(553, MSG_RENAME_FAILURE);                 goto afterquota;             } else { #ifdef QUOTAS                 overflow = ul_quota_update                     (name, files_count, atomic_file_size - original_file_size); #endif                 atomic_file = NULL;             }         } else { #ifdef QUOTAS             overflow = ul_quota_update                 (name, files_count, ulhandler.total_uploaded); #endif         }     }     afterquota:     if (overflow > 0) {         addreply(552, MSG_QUOTA_EXCEEDED, name);     } else {         if (ret == 0) {             addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);         } else {             addreply_noformat(451, MSG_ABORTED);         }         displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started,                     name2 ? name2 : name, 1);     }     end:     restartat = (off_t) 0;     if (atomic_file != NULL) {         unlink(atomic_file);         atomic_file = NULL;     } }"
"202943_CWE-787.c","CWE-787","l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {   CallInfo *ci = L->ci;   const char *msg;   va_list argp;   luaC_checkGC(L);  /* error message uses memory */   va_start(argp, fmt);   msg = luaO_pushvfstring(L, fmt, argp);  /* format message */   va_end(argp);   if (isLua(ci))  /* if Lua function, add source:line information */     luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));   luaG_errormsg(L); }"
"203614_CWE-703.c","CWE-703","pxa3xx_gcu_write(struct file *file, const char *buff, 		 size_t count, loff_t *offp) { 	int ret; 	unsigned long flags; 	struct pxa3xx_gcu_batch	*buffer; 	struct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);  	int words = count / 4;  	/* Does not need to be atomic. There's a lock in user space, 	 * but anyhow, this is just for statistics. */ 	priv->shared->num_writes++; 	priv->shared->num_words += words;  	/* Last word reserved for batch buffer end command */ 	if (words >= PXA3XX_GCU_BATCH_WORDS) 		return -E2BIG;  	/* Wait for a free buffer */ 	if (!priv->free) { 		ret = pxa3xx_gcu_wait_free(priv); 		if (ret < 0) 			return ret; 	}  	/* 	 * Get buffer from free list 	 */ 	spin_lock_irqsave(&priv->spinlock, flags); 	buffer = priv->free; 	priv->free = buffer->next; 	spin_unlock_irqrestore(&priv->spinlock, flags);   	/* Copy data from user into buffer */ 	ret = copy_from_user(buffer->ptr, buff, words * 4); 	if (ret) { 		spin_lock_irqsave(&priv->spinlock, flags); 		buffer->next = priv->free; 		priv->free = buffer; 		spin_unlock_irqrestore(&priv->spinlock, flags); 		return -EFAULT; 	}  	buffer->length = words;  	/* Append batch buffer end command */ 	buffer->ptr[words] = 0x01000000;  	/* 	 * Add buffer to ready list 	 */ 	spin_lock_irqsave(&priv->spinlock, flags);  	buffer->next = NULL;  	if (priv->ready) { 		BUG_ON(priv->ready_last == NULL);  		priv->ready_last->next = buffer; 	} else 		priv->ready = buffer;  	priv->ready_last = buffer;  	if (!priv->shared->hw_running) 		run_ready(priv);  	spin_unlock_irqrestore(&priv->spinlock, flags);  	return words * 4; }"
"203622_CWE-401.c","CWE-401","con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos) { 	int i, n; 	u16 **p1, *p2;  	p1 = p->uni_pgdir[n = unicode >> 11]; 	if (!p1) { 		p1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *), 						     GFP_KERNEL); 		if (!p1) return -ENOMEM; 		for (i = 0; i < 32; i++) 			p1[i] = NULL; 	}  	p2 = p1[n = (unicode >> 6) & 0x1f]; 	if (!p2) { 		p2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL); 		if (!p2) { 			kfree(p1); 			p->uni_pgdir[n] = NULL; 			return -ENOMEM; 		} 		memset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */ 	}  	p2[unicode & 0x3f] = fontpos; 	 	p->sum += (fontpos << 20) + unicode;  	return 0; }"
"203902_CWE-703.c","CWE-703","get_one_sourceline(source_cookie_T *sp) {     garray_T		ga;     int			len;     int			c;     char_u		*buf; #ifdef USE_CRNL     int			has_cr;		// CR-LF found #endif     int			have_read = FALSE;      // use a growarray to store the sourced line     ga_init2(&ga, 1, 250);      // Loop until there is a finished line (or end-of-file).     ++sp->sourcing_lnum;     for (;;)     { 	// make room to read at least 120 (more) characters 	if (ga_grow(&ga, 120) == FAIL) 	    break; 	if (sp->source_from_buf) 	{ 	    if (sp->buf_lnum >= sp->buflines.ga_len) 		break;		    // all the lines are processed 	    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]); 	    sp->buf_lnum++; 	    if (ga_grow(&ga, 1) == FAIL) 		break; 	    buf = (char_u *)ga.ga_data; 	    buf[ga.ga_len++] = NUL; 	} 	else 	{ 	    buf = (char_u *)ga.ga_data; 	    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len, 			sp->fp) == NULL) 		break; 	} 	len = ga.ga_len + (int)STRLEN(buf + ga.ga_len); #ifdef USE_CRNL 	// Ignore a trailing CTRL-Z, when in Dos mode.	Only recognize the 	// CTRL-Z by its own, or after a NL. 	if (	   (len == 1 || (len >= 2 && buf[len - 2] == '\n')) 		&& sp->fileformat == EOL_DOS 		&& buf[len - 1] == Ctrl_Z) 	{ 	    buf[len - 1] = NUL; 	    break; 	} #endif  	have_read = TRUE; 	ga.ga_len = len;  	// If the line was longer than the buffer, read more. 	if (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\n') 	    continue;  	if (len >= 1 && buf[len - 1] == '\n')	// remove trailing NL 	{ #ifdef USE_CRNL 	    has_cr = (len >= 2 && buf[len - 2] == '\r'); 	    if (sp->fileformat == EOL_UNKNOWN) 	    { 		if (has_cr) 		    sp->fileformat = EOL_DOS; 		else 		    sp->fileformat = EOL_UNIX; 	    }  	    if (sp->fileformat == EOL_DOS) 	    { 		if (has_cr)	    // replace trailing CR 		{ 		    buf[len - 2] = '\n'; 		    --len; 		    --ga.ga_len; 		} 		else	    // lines like "":map xx yy^M"" will have failed 		{ 		    if (!sp->error) 		    { 			msg_source(HL_ATTR(HLF_W)); 			emsg(_(""W15: Warning: Wrong line separator, ^M may be missing"")); 		    } 		    sp->error = TRUE; 		    sp->fileformat = EOL_UNIX; 		} 	    } #endif 	    // The '\n' is escaped if there is an odd number of ^V's just 	    // before it, first set ""c"" just before the 'V's and then check 	    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo 	    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--) 		; 	    if ((len & 1) != (c & 1))	// escaped NL, read more 	    { 		++sp->sourcing_lnum; 		continue; 	    }  	    buf[len - 1] = NUL;		// remove the NL 	}  	// Check for ^C here now and then, so recursive :so can be broken. 	line_breakcheck(); 	break;     }      if (have_read) 	return (char_u *)ga.ga_data;      vim_free(ga.ga_data);     return NULL; }"
"203980_CWE-416.c","CWE-416","static void mkiss_close(struct tty_struct *tty) { 	struct mkiss *ax;  	write_lock_irq(&disc_data_lock); 	ax = tty->disc_data; 	tty->disc_data = NULL; 	write_unlock_irq(&disc_data_lock);  	if (!ax) 		return;  	/* 	 * We have now ensured that nobody can start using ap from now on, but 	 * we have to wait for all existing users to finish. 	 */ 	if (!refcount_dec_and_test(&ax->refcnt)) 		wait_for_completion(&ax->dead); 	/* 	 * Halt the transmit queue so that a new transmit cannot scribble 	 * on our buffers 	 */ 	netif_stop_queue(ax->dev);  	/* Free all AX25 frame buffers. */ 	kfree(ax->rbuff); 	kfree(ax->xbuff);  	ax->tty = NULL;  	unregister_netdev(ax->dev); 	free_netdev(ax->dev); }"
"204016_CWE-200.cpp","CWE-200","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	squashfs_dir_header_2 dirh; 	char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; 	long long start; 	int bytes = 0; 	int dir_count, size, res; 	struct dir_ent *ent, *cur_ent = NULL; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		MEM_ERROR();  	dir->dir_count = 0; 	dir->cur_entry = NULL; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 0) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir;  	start = sBlk.s.directory_table_start + (*i)->start; 	offset = (*i)->offset; 	size = (*i)->data + bytes;  	while(bytes < size) { 		if(swap) { 			squashfs_dir_header_2 sdirh; 			res = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh)); 			if(res) 				SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); 		} else 			res = read_directory_data(&dirh, &start, &offset, sizeof(dirh));  		if(res == FALSE) 			goto corrupted;  		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			if(swap) { 				squashfs_dir_entry_2 sdire; 				res = read_directory_data(&sdire, &start, 					&offset, sizeof(sdire)); 				if(res) 					SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); 			} else 				res = read_directory_data(dire, &start, 					&offset, sizeof(*dire));  			if(res == FALSE) 				goto corrupted;  			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			res = read_directory_data(dire->name, &start, &offset, 								dire->size + 1);  			if(res == FALSE) 				goto corrupted;  			dire->name[dire->size + 1] = '\0';  			/* check name for invalid characters (i.e /, ., ..) */ 			if(check_name(dire->name, dire->size + 1) == FALSE) { 				ERROR(""File system corrupted: invalid characters in name\n""); 				goto corrupted; 			}  			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type);  			ent = malloc(sizeof(struct dir_ent)); 			if(ent == NULL) 				MEM_ERROR();  			ent->name = strdup(dire->name); 			ent->start_block = dirh.start_block; 			ent->offset = dire->offset; 			ent->type = dire->type; 			ent->next = NULL; 			if(cur_ent == NULL) 				dir->dirs = ent; 			else 				cur_ent->next = ent; 			cur_ent = ent; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	squashfs_closedir(dir); 	return NULL; }"
"204017_CWE-200.cpp","CWE-200","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	squashfs_dir_header_3 dirh; 	char buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	squashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer; 	long long start; 	int bytes = 0; 	int dir_count, size, res; 	struct dir_ent *ent, *cur_ent = NULL; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		MEM_ERROR();  	dir->dir_count = 0; 	dir->cur_entry = NULL; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 3) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir;  	start = sBlk.s.directory_table_start + (*i)->start; 	offset = (*i)->offset; 	size = (*i)->data + bytes - 3;  	while(bytes < size) {			 		if(swap) { 			squashfs_dir_header_3 sdirh; 			res = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh)); 			if(res) 				SQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh); 		} else 			res = read_directory_data(&dirh, &start, &offset, sizeof(dirh)); 	 		if(res == FALSE) 			goto corrupted;  		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			if(swap) { 				squashfs_dir_entry_3 sdire; 				res = read_directory_data(&sdire, &start, 					&offset, sizeof(sdire)); 				if(res) 					SQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire); 			} else 				res = read_directory_data(dire, &start, 					&offset, sizeof(*dire));  			if(res == FALSE) 				goto corrupted;  			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			res = read_directory_data(dire->name, &start, &offset, 								dire->size + 1);  			if(res == FALSE) 				goto corrupted;  			dire->name[dire->size + 1] = '\0';  			/* check name for invalid characters (i.e /, ., ..) */ 			if(check_name(dire->name, dire->size + 1) == FALSE) { 				ERROR(""File system corrupted: invalid characters in name\n""); 				goto corrupted; 			}  			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type);  			ent = malloc(sizeof(struct dir_ent)); 			if(ent == NULL) 				MEM_ERROR();  			ent->name = strdup(dire->name); 			ent->start_block = dirh.start_block; 			ent->offset = dire->offset; 			ent->type = dire->type; 			ent->next = NULL; 			if(cur_ent == NULL) 				dir->dirs = ent; 			else 				cur_ent->next = ent; 			cur_ent = ent; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	squashfs_closedir(dir); 	return NULL; }"
"204019_CWE-200.cpp","CWE-200","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	struct squashfs_dir_header dirh; 	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer; 	long long start; 	int bytes = 0, dir_count, size, res; 	struct dir_ent *ent, *cur_ent = NULL; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		MEM_ERROR();  	dir->dir_count = 0; 	dir->cur_entry = NULL; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 3) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir;  	start = sBlk.s.directory_table_start + (*i)->start; 	offset = (*i)->offset; 	size = (*i)->data + bytes - 3;  	while(bytes < size) {			 		res = read_directory_data(&dirh, &start, &offset, sizeof(dirh)); 		if(res == FALSE) 			goto corrupted;  		SQUASHFS_INSWAP_DIR_HEADER(&dirh); 	 		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			res = read_directory_data(dire, &start, &offset, sizeof(*dire)); 			if(res == FALSE) 				goto corrupted;  			SQUASHFS_INSWAP_DIR_ENTRY(dire);  			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			res = read_directory_data(dire->name, &start, &offset, 								dire->size + 1); 			if(res == FALSE) 				goto corrupted;  			dire->name[dire->size + 1] = '\0';  			/* check name for invalid characters (i.e /, ., ..) */ 			if(check_name(dire->name, dire->size + 1) == FALSE) { 				ERROR(""File system corrupted: invalid characters in name\n""); 				goto corrupted; 			}  			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type);  			ent = malloc(sizeof(struct dir_ent)); 			if(ent == NULL) 				MEM_ERROR();  			ent->name = strdup(dire->name); 			ent->start_block = dirh.start_block; 			ent->offset = dire->offset; 			ent->type = dire->type; 			ent->next = NULL; 			if(cur_ent == NULL) 				dir->dirs = ent; 			else 				cur_ent->next = ent; 			cur_ent = ent; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	squashfs_closedir(dir); 	return NULL; }"
"204032_CWE-772.c","CWE-772","static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb) { 	__u8 pkt_type;  	pkt_type = *((__u8 *) skb->data); 	skb_pull(skb, 1);  	switch (pkt_type) { 	case HCI_EVENT_PKT: 	case HCI_ACLDATA_PKT: 	case HCI_SCODATA_PKT: 	case HCI_ISODATA_PKT: 		hci_skb_pkt_type(skb) = pkt_type; 		hci_recv_frame(vbt->hdev, skb); 		break; 	} }"
"204036_CWE-787.c","CWE-787","int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self, 			     struct hw_atl_utils_fw_rpc **rpc) { 	struct aq_hw_atl_utils_fw_rpc_tid_s sw; 	struct aq_hw_atl_utils_fw_rpc_tid_s fw; 	int err = 0;  	do { 		sw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);  		self->rpc_tid = sw.tid;  		err = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get, 						self, fw.val, 						sw.tid == fw.tid, 						1000U, 100000U); 		if (err < 0) 			goto err_exit;  		err = aq_hw_err_from_flags(self); 		if (err < 0) 			goto err_exit;  		if (fw.len == 0xFFFFU) { 			err = hw_atl_utils_fw_rpc_call(self, sw.len); 			if (err < 0) 				goto err_exit; 		} 	} while (sw.tid != fw.tid || 0xFFFFU == fw.len);  	if (rpc) { 		if (fw.len) { 			err = 			hw_atl_utils_fw_downld_dwords(self, 						      self->rpc_addr, 						      (u32 *)(void *) 						      &self->rpc, 						      (fw.len + sizeof(u32) - 						       sizeof(u8)) / 						      sizeof(u32)); 			if (err < 0) 				goto err_exit; 		}  		*rpc = &self->rpc; 	}  err_exit: 	return err; }"
"204069_CWE-416.c","CWE-416","do_window(     int		nchar,     long	Prenum,     int		xchar)	    // extra char from "":wincmd gx"" or NUL {     long	Prenum1;     win_T	*wp; #if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)     char_u	*ptr;     linenr_T    lnum = -1; #endif #ifdef FEAT_FIND_ID     int		type = FIND_DEFINE;     int		len; #endif     char_u	cbuf[40];      if (ERROR_IF_ANY_POPUP_WINDOW) 	return;  #ifdef FEAT_CMDWIN # define CHECK_CMDWIN \     do { \ 	if (cmdwin_type != 0) \ 	{ \ 	    emsg(_(e_invalid_in_cmdline_window)); \ 	    return; \ 	} \     } while (0) #else # define CHECK_CMDWIN do { /**/ } while (0) #endif      Prenum1 = Prenum == 0 ? 1 : Prenum;      switch (nchar)     { // split current window in two parts, horizontally     case 'S':     case Ctrl_S:     case 's': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode #ifdef FEAT_QUICKFIX 		// When splitting the quickfix window open a new buffer in it, 		// don't replicate the quickfix buffer. 		if (bt_quickfix(curbuf)) 		    goto newwindow; #endif #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		(void)win_split((int)Prenum, 0); 		break;  // split current window in two parts, vertically     case Ctrl_V:     case 'v': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode #ifdef FEAT_QUICKFIX 		// When splitting the quickfix window open a new buffer in it, 		// don't replicate the quickfix buffer. 		if (bt_quickfix(curbuf)) 		    goto newwindow; #endif #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		(void)win_split((int)Prenum, WSP_VERT); 		break;  // split current window and edit alternate file     case Ctrl_HAT:     case '^': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode  		if (buflist_findnr(Prenum == 0 					? curwin->w_alt_fnum : Prenum) == NULL) 		{ 		    if (Prenum == 0) 			emsg(_(e_no_alternate_file)); 		    else 			semsg(_(e_buffer_nr_not_found), Prenum); 		    break; 		}  		if (!curbuf_locked() && win_split(0, 0) == OK) 		    (void)buflist_getfile( 			    Prenum == 0 ? curwin->w_alt_fnum : Prenum, 			    (linenr_T)0, GETF_ALT, FALSE); 		break;  // open new window     case Ctrl_N:     case 'n': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode #ifdef FEAT_QUICKFIX newwindow: #endif 		if (Prenum) 		    // window height 		    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, ""%ld"", Prenum); 		else 		    cbuf[0] = NUL; #if defined(FEAT_QUICKFIX) 		if (nchar == 'v' || nchar == Ctrl_V) 		    STRCAT(cbuf, ""v""); #endif 		STRCAT(cbuf, ""new""); 		do_cmdline_cmd(cbuf); 		break;  // quit current window     case Ctrl_Q:     case 'q': 		reset_VIsual_and_resel();	// stop Visual mode 		cmd_with_count(""quit"", cbuf, sizeof(cbuf), Prenum); 		do_cmdline_cmd(cbuf); 		break;  // close current window     case Ctrl_C:     case 'c': 		reset_VIsual_and_resel();	// stop Visual mode 		cmd_with_count(""close"", cbuf, sizeof(cbuf), Prenum); 		do_cmdline_cmd(cbuf); 		break;  #if defined(FEAT_QUICKFIX) // close preview window     case Ctrl_Z:     case 'z': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode 		do_cmdline_cmd((char_u *)""pclose""); 		break;  // cursor to preview window     case 'P': 		FOR_ALL_WINDOWS(wp) 		    if (wp->w_p_pvw) 			break; 		if (wp == NULL) 		    emsg(_(e_there_is_no_preview_window)); 		else 		    win_goto(wp); 		break; #endif  // close all but current window     case Ctrl_O:     case 'o': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode 		cmd_with_count(""only"", cbuf, sizeof(cbuf), Prenum); 		do_cmdline_cmd(cbuf); 		break;  // cursor to next window with wrap around     case Ctrl_W:     case 'w': // cursor to previous window with wrap around     case 'W': 		CHECK_CMDWIN; 		if (ONE_WINDOW && Prenum != 1)	// just one window 		    beep_flush(); 		else 		{ 		    if (Prenum)			// go to specified window 		    { 			for (wp = firstwin; --Prenum > 0; ) 			{ 			    if (wp->w_next == NULL) 				break; 			    else 				wp = wp->w_next; 			} 		    } 		    else 		    { 			if (nchar == 'W')	    // go to previous window 			{ 			    wp = curwin->w_prev; 			    if (wp == NULL) 				wp = lastwin;	    // wrap around 			} 			else			    // go to next window 			{ 			    wp = curwin->w_next; 			    if (wp == NULL) 				wp = firstwin;	    // wrap around 			} 		    } 		    win_goto(wp); 		} 		break;  // cursor to window below     case 'j':     case K_DOWN:     case Ctrl_J: 		CHECK_CMDWIN; 		win_goto_ver(FALSE, Prenum1); 		break;  // cursor to window above     case 'k':     case K_UP:     case Ctrl_K: 		CHECK_CMDWIN; 		win_goto_ver(TRUE, Prenum1); 		break;  // cursor to left window     case 'h':     case K_LEFT:     case Ctrl_H:     case K_BS: 		CHECK_CMDWIN; 		win_goto_hor(TRUE, Prenum1); 		break;  // cursor to right window     case 'l':     case K_RIGHT:     case Ctrl_L: 		CHECK_CMDWIN; 		win_goto_hor(FALSE, Prenum1); 		break;  // move window to new tab page     case 'T': 		CHECK_CMDWIN; 		if (one_window()) 		    msg(_(m_onlyone)); 		else 		{ 		    tabpage_T	*oldtab = curtab; 		    tabpage_T	*newtab;  		    // First create a new tab with the window, then go back to 		    // the old tab and close the window there. 		    wp = curwin; 		    if (win_new_tabpage((int)Prenum) == OK 						     && valid_tabpage(oldtab)) 		    { 			newtab = curtab; 			goto_tabpage_tp(oldtab, TRUE, TRUE); 			if (curwin == wp) 			    win_close(curwin, FALSE); 			if (valid_tabpage(newtab)) 			    goto_tabpage_tp(newtab, TRUE, TRUE); 		    } 		} 		break;  // cursor to top-left window     case 't':     case Ctrl_T: 		win_goto(firstwin); 		break;  // cursor to bottom-right window     case 'b':     case Ctrl_B: 		win_goto(lastwin); 		break;  // cursor to last accessed (previous) window     case 'p':     case Ctrl_P: 		if (!win_valid(prevwin)) 		    beep_flush(); 		else 		    win_goto(prevwin); 		break;  // exchange current and next window     case 'x':     case Ctrl_X: 		CHECK_CMDWIN; 		win_exchange(Prenum); 		break;  // rotate windows downwards     case Ctrl_R:     case 'r': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode 		win_rotate(FALSE, (int)Prenum1);    // downwards 		break;  // rotate windows upwards     case 'R': 		CHECK_CMDWIN; 		reset_VIsual_and_resel();	// stop Visual mode 		win_rotate(TRUE, (int)Prenum1);	    // upwards 		break;  // move window to the very top/bottom/left/right     case 'K':     case 'J':     case 'H':     case 'L': 		CHECK_CMDWIN; 		win_totop((int)Prenum, 			((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0) 			| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT)); 		break;  // make all windows the same height     case '=': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_equal(NULL, FALSE, 'b'); 		break;  // increase current window height     case '+': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setheight(curwin->w_height + (int)Prenum1); 		break;  // decrease current window height     case '-': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setheight(curwin->w_height - (int)Prenum1); 		break;  // set current window height     case Ctrl__:     case '_': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setheight(Prenum ? (int)Prenum : 9999); 		break;  // increase current window width     case '>': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setwidth(curwin->w_width + (int)Prenum1); 		break;  // decrease current window width     case '<': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setwidth(curwin->w_width - (int)Prenum1); 		break;  // set current window width     case '|': #ifdef FEAT_GUI 		need_mouse_correct = TRUE; #endif 		win_setwidth(Prenum != 0 ? (int)Prenum : 9999); 		break;  // jump to tag and split window if tag exists (in preview window) #if defined(FEAT_QUICKFIX)     case '}': 		CHECK_CMDWIN; 		if (Prenum) 		    g_do_tagpreview = Prenum; 		else 		    g_do_tagpreview = p_pvh; #endif 		// FALLTHROUGH     case ']':     case Ctrl_RSB: 		CHECK_CMDWIN; 		// keep Visual mode, can select words to use as a tag 		if (Prenum) 		    postponed_split = Prenum; 		else 		    postponed_split = -1; #ifdef FEAT_QUICKFIX 		if (nchar != '}') 		    g_do_tagpreview = 0; #endif  		// Execute the command right here, required when ""wincmd ]"" 		// was used in a function. 		do_nv_ident(Ctrl_RSB, NUL); 		break;  #ifdef FEAT_SEARCHPATH // edit file name under cursor in a new window     case 'f':     case 'F':     case Ctrl_F: wingotofile: 		CHECK_CMDWIN;  		ptr = grab_file_name(Prenum1, &lnum); 		if (ptr != NULL) 		{ 		    tabpage_T	*oldtab = curtab; 		    win_T	*oldwin = curwin; # ifdef FEAT_GUI 		    need_mouse_correct = TRUE; # endif 		    setpcmark(); 		    if (win_split(0, 0) == OK) 		    { 			RESET_BINDING(curwin); 			if (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, 						   ECMD_HIDE, NULL) == FAIL) 			{ 			    // Failed to open the file, close the window 			    // opened for it. 			    win_close(curwin, FALSE); 			    goto_tabpage_win(oldtab, oldwin); 			} 			else if (nchar == 'F' && lnum >= 0) 			{ 			    curwin->w_cursor.lnum = lnum; 			    check_cursor_lnum(); 			    beginline(BL_SOL | BL_FIX); 			} 		    } 		    vim_free(ptr); 		} 		break; #endif  #ifdef FEAT_FIND_ID // Go to the first occurrence of the identifier under cursor along path in a // new window -- webb     case 'i':			    // Go to any match     case Ctrl_I: 		type = FIND_ANY; 		// FALLTHROUGH     case 'd':			    // Go to definition, using 'define'     case Ctrl_D: 		CHECK_CMDWIN; 		if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0) 		    break; 		find_pattern_in_path(ptr, 0, len, TRUE, 			Prenum == 0 ? TRUE : FALSE, type, 			Prenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM); 		curwin->w_set_curswant = TRUE; 		break; #endif  // Quickfix window only: view the result under the cursor in a new split. #if defined(FEAT_QUICKFIX)     case K_KENTER:     case CAR: 		if (bt_quickfix(curbuf)) 		    qf_view_result(TRUE); 		break; #endif  // CTRL-W g  extended commands     case 'g':     case Ctrl_G: 		CHECK_CMDWIN; #ifdef USE_ON_FLY_SCROLL 		dont_scroll = TRUE;		// disallow scrolling here #endif 		++no_mapping; 		++allow_keys;   // no mapping for xchar, but allow key codes 		if (xchar == NUL) 		    xchar = plain_vgetc(); 		LANGMAP_ADJUST(xchar, TRUE); 		--no_mapping; 		--allow_keys; #ifdef FEAT_CMDL_INFO 		(void)add_to_showcmd(xchar); #endif 		switch (xchar) 		{ #if defined(FEAT_QUICKFIX) 		    case '}': 			xchar = Ctrl_RSB; 			if (Prenum) 			    g_do_tagpreview = Prenum; 			else 			    g_do_tagpreview = p_pvh; #endif 			// FALLTHROUGH 		    case ']': 		    case Ctrl_RSB: 			// keep Visual mode, can select words to use as a tag 			if (Prenum) 			    postponed_split = Prenum; 			else 			    postponed_split = -1;  			// Execute the command right here, required when 			// ""wincmd g}"" was used in a function. 			do_nv_ident('g', xchar); 			break;  #ifdef FEAT_SEARCHPATH 		    case 'f':	    // CTRL-W gf: ""gf"" in a new tab page 		    case 'F':	    // CTRL-W gF: ""gF"" in a new tab page 			cmdmod.cmod_tab = tabpage_index(curtab) + 1; 			nchar = xchar; 			goto wingotofile; #endif 		    case 't':	    // CTRL-W gt: go to next tab page 			goto_tabpage((int)Prenum); 			break;  		    case 'T':	    // CTRL-W gT: go to previous tab page 			goto_tabpage(-(int)Prenum1); 			break;  		    case TAB:	    // CTRL-W g<Tab>: go to last used tab page 			if (goto_tabpage_lastused() == FAIL) 			    beep_flush(); 			break;  		    default: 			beep_flush(); 			break; 		} 		break;      default:	beep_flush(); 		break;     } }"
"204073_CWE-415.c","CWE-415","static char ** split(const char *arg, const char *delim) {   char *copy = dupstr(arg);   char **result = NULL;   int i = 0;    for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {     char **tmp = realloc (result, sizeof *result * (i + 1));     if (!tmp && result) {       while (i > 0) { 	free(result[--i]);       }       free(result);       free(copy);       return NULL;     }     result = tmp;     result[i++] = dupstr(cptr);   }    free(copy);    if (i) {     char **tmp = realloc(result, sizeof *result * (i + 1));     if (!tmp) {       while (i > 0) { 	free(result[--i]);       }       free(result);       free(copy);       return NULL;     }     result = tmp;     result[i++] = NULL;   }    return result; }"
"204101_CWE-125.c","CWE-125","R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { 	ut64 offset = 6; 	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); 	if (attr) { 		attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR; 		attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		attr->size = offset; 	} 	// IFDBG r_bin_java_print_constant_value_attr_summary(attr); 	return attr; }"
"204115_CWE-617.c","CWE-617","issuerAndThisUpdateCheck( 	struct berval *in, 	struct berval *is, 	struct berval *tu, 	void *ctx ) { 	int numdquotes = 0; 	struct berval x = *in; 	struct berval ni = BER_BVNULL; 	/* Parse GSER format */  	enum { 		HAVE_NONE = 0x0, 		HAVE_ISSUER = 0x1, 		HAVE_THISUPDATE = 0x2, 		HAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE ) 	} have = HAVE_NONE;   	if ( in->bv_len < STRLENOF( ""{issuer \""\"",thisUpdate \""YYMMDDhhmmssZ\""}"" ) ) return LDAP_INVALID_SYNTAX;  	if ( in->bv_val[0] != '{' || in->bv_val[in->bv_len-1] != '}' ) { 		return LDAP_INVALID_SYNTAX; 	}  	x.bv_val++; 	x.bv_len -= STRLENOF(""{}"");  	do { 		/* eat leading spaces */ 		for ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) { 			/* empty */; 		}  		/* should be at issuer or thisUpdate */ 		if ( strncasecmp( x.bv_val, ""issuer"", STRLENOF(""issuer"") ) == 0 ) { 			if ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX;  			/* parse issuer */ 			x.bv_val += STRLENOF(""issuer""); 			x.bv_len -= STRLENOF(""issuer"");  			if ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX; 			x.bv_val++; 			x.bv_len--;  			/* eat leading spaces */ 			for ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) { 				/* empty */; 			}  			/* For backward compatibility, this part is optional */ 			if ( strncasecmp( x.bv_val, ""rdnSequence:"", STRLENOF(""rdnSequence:"") ) != 0 ) { 				return LDAP_INVALID_SYNTAX; 			} 			x.bv_val += STRLENOF(""rdnSequence:""); 			x.bv_len -= STRLENOF(""rdnSequence:"");  			if ( x.bv_val[0] != '""' ) return LDAP_INVALID_SYNTAX; 			x.bv_val++; 			x.bv_len--;  			is->bv_val = x.bv_val; 			is->bv_len = 0;  			for ( ; is->bv_len < x.bv_len; ) { 				if ( is->bv_val[is->bv_len] != '""' ) { 					is->bv_len++; 					continue; 				} 				if ( is->bv_val[is->bv_len+1] == '""' ) { 					/* double dquote */ 					numdquotes++; 					is->bv_len += 2; 					continue; 				} 				break; 			} 			x.bv_val += is->bv_len + 1; 			x.bv_len -= is->bv_len + 1;  			have |= HAVE_ISSUER;  		} else if ( strncasecmp( x.bv_val, ""thisUpdate"", STRLENOF(""thisUpdate"") ) == 0 ) 		{ 			if ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX;  			/* parse thisUpdate */ 			x.bv_val += STRLENOF(""thisUpdate""); 			x.bv_len -= STRLENOF(""thisUpdate"");  			if ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX; 			x.bv_val++; 			x.bv_len--;  			/* eat leading spaces */ 			for ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) { 				/* empty */; 			}  			if ( !x.bv_len || x.bv_val[0] != '""' ) return LDAP_INVALID_SYNTAX; 			x.bv_val++; 			x.bv_len--;  			tu->bv_val = x.bv_val; 			tu->bv_len = 0;  			for ( ; tu->bv_len < x.bv_len; tu->bv_len++ ) { 				if ( tu->bv_val[tu->bv_len] == '""' ) { 					break; 				} 			} 			x.bv_val += tu->bv_len + 1; 			x.bv_len -= tu->bv_len + 1;  			have |= HAVE_THISUPDATE;  		} else { 			return LDAP_INVALID_SYNTAX; 		}  		/* eat leading spaces */ 		for ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) { 			/* empty */; 		}  		if ( have == HAVE_ALL ) { 			break; 		}  		if ( x.bv_val[0] != ',' ) { 			return LDAP_INVALID_SYNTAX; 		}  		x.bv_val++; 		x.bv_len--; 	} while ( 1 );  	/* should have no characters left... */ 	if ( x.bv_len ) return LDAP_INVALID_SYNTAX;  	if ( numdquotes == 0 ) { 		ber_dupbv_x( &ni, is, ctx );  	} else { 		ber_len_t src, dst;  		ni.bv_len = is->bv_len - numdquotes; 		ni.bv_val = slap_sl_malloc( ni.bv_len + 1, ctx ); 		for ( src = 0, dst = 0; src < is->bv_len; src++, dst++ ) { 			if ( is->bv_val[src] == '""' ) { 				src++; 			} 			ni.bv_val[dst] = is->bv_val[src]; 		} 		ni.bv_val[dst] = '\0'; 	} 		 	*is = ni;  	return 0; }"
"204137_CWE-369.cpp","CWE-369","bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str, 					const double *ptm, int paintType, int /*tilingType*/, Dict *resDict, 					const double *mat, const double *bbox, 					int x0, int y0, int x1, int y1, 					double xStep, double yStep) {   PDFRectangle box;   Gfx *gfx;   Splash *formerSplash = splash;   SplashBitmap *formerBitmap = bitmap;   double width, height;   int surface_width, surface_height, result_width, result_height, i;   int repeatX, repeatY;   SplashCoord matc[6];   Matrix m1;   const double *ctm;   double savedCTM[6];   double kx, ky, sx, sy;   bool retValue = false;    width = bbox[2] - bbox[0];   height = bbox[3] - bbox[1];    if (xStep != width || yStep != height)     return false;    // calculate offsets   ctm = state->getCTM();   for (i = 0; i < 6; ++i) {     savedCTM[i] = ctm[i];   }   state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);   state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);   ctm = state->getCTM();   for (i = 0; i < 6; ++i) {     if (!std::isfinite(ctm[i])) {       state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);       return false;     }   }   matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];   matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];   if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {     kx = -ctm[1];     ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];   } else {     kx = ctm[0];     ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];   }   result_width = (int) ceil(fabs(kx * width * (x1 - x0)));   result_height = (int) ceil(fabs(ky * height * (y1 - y0)));   kx = state->getHDPI() / 72.0;   ky = state->getVDPI() / 72.0;   m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;   m1.m[1] = 0;   m1.m[2] = 0;   m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;   m1.m[4] = 0;   m1.m[5] = 0;   m1.transform(width, height, &kx, &ky);   surface_width = (int) ceil (fabs(kx));   surface_height = (int) ceil (fabs(ky));    sx = (double) result_width / (surface_width * (x1 - x0));   sy = (double) result_height / (surface_height * (y1 - y0));   m1.m[0] *= sx;   m1.m[3] *= sy;   m1.transform(width, height, &kx, &ky);    if(fabs(kx) < 1 && fabs(ky) < 1) {     kx = std::min<double>(kx, ky);     ky = 2 / kx;     m1.m[0] *= ky;     m1.m[3] *= ky;     m1.transform(width, height, &kx, &ky);     surface_width = (int) ceil (fabs(kx));     surface_height = (int) ceil (fabs(ky));     repeatX = x1 - x0;     repeatY = y1 - y0;   } else {     if ((unsigned long) surface_width * surface_height > 0x800000L) {       state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);       return false;     }     while(fabs(kx) > 16384 || fabs(ky) > 16384) {       // limit pattern bitmap size       m1.m[0] /= 2;       m1.m[3] /= 2;       m1.transform(width, height, &kx, &ky);     }     surface_width = (int) ceil (fabs(kx));     surface_height = (int) ceil (fabs(ky));     // adjust repeat values to completely fill region     repeatX = result_width / surface_width;     repeatY = result_height / surface_height;     if (surface_width * repeatX < result_width)       repeatX++;     if (surface_height * repeatY < result_height)       repeatY++;     if (x1 - x0 > repeatX)       repeatX = x1 - x0;     if (y1 - y0 > repeatY)       repeatY = y1 - y0;   }   // restore CTM and calculate rotate and scale with rounded matrix   state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);   state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);   state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);   ctm = state->getCTM();   matc[0] = ctm[0];   matc[1] = ctm[1];   matc[2] = ctm[2];   matc[3] = ctm[3];    if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {     state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);     return false;   }   m1.transform(bbox[0], bbox[1], &kx, &ky);   m1.m[4] = -kx;   m1.m[5] = -ky;    bitmap = new SplashBitmap(surface_width, surface_height, 1,                             (paintType == 1) ? colorMode : splashModeMono8, true);   if (bitmap->getDataPtr() == nullptr) {     SplashBitmap *tBitmap = bitmap;     bitmap = formerBitmap;     delete tBitmap;     state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);     return false;   }   splash = new Splash(bitmap, true);   if (paintType == 2) {     SplashColor clearColor; #ifdef SPLASH_CMYK     clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF; #else     clearColor[0] = 0xFF; #endif     splash->clear(clearColor, 0);   } else {     splash->clear(paperColor, 0);   }   splash->setThinLineMode(formerSplash->getThinLineMode());   splash->setMinLineWidth(s_minLineWidth);    box.x1 = bbox[0]; box.y1 = bbox[1];   box.x2 = bbox[2]; box.y2 = bbox[3];   gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);   // set pattern transformation matrix   gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);   updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);   gfx->display(str);   delete splash;   splash = formerSplash;   TilingSplashOutBitmap imgData;   imgData.bitmap = bitmap;   imgData.paintType = paintType;   imgData.pattern = splash->getFillPattern();   imgData.colorMode = colorMode;   imgData.y = 0;   imgData.repeatX = repeatX;   imgData.repeatY = repeatY;   SplashBitmap *tBitmap = bitmap;   bitmap = formerBitmap;   result_width = tBitmap->getWidth() * imgData.repeatX;   result_height = tBitmap->getHeight() * imgData.repeatY;    if (splashAbs(matc[1]) > splashAbs(matc[0])) {     kx = -matc[1];     ky = matc[2] - (matc[0] * matc[3]) / matc[1];   } else {     kx = matc[0];     ky = matc[3] - (matc[1] * matc[2]) / matc[0];   }   kx = result_width / (fabs(kx) + 1);   ky = result_height / (fabs(ky) + 1);   state->concatCTM(kx, 0, 0, ky, 0, 0);   ctm = state->getCTM();   matc[0] = ctm[0];   matc[1] = ctm[1];   matc[2] = ctm[2];   matc[3] = ctm[3];   bool minorAxisZero = matc[1] == 0 && matc[2] == 0;   if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {     // draw the tiles     for (int y = 0; y < imgData.repeatY; ++y) {       for (int x = 0; x < imgData.repeatX; ++x) {         x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();         y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();         splash->blitImage(tBitmap, true, x0, y0);       }     }     retValue = true;   } else {     retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;   }   delete tBitmap;   delete gfx;   return retValue; }"
"204138_CWE-476.c","CWE-476","static void write_response(ESPState *s) {     uint32_t n;      trace_esp_write_response(s->status);      fifo8_reset(&s->fifo);     esp_fifo_push(s, s->status);     esp_fifo_push(s, 0);      if (s->dma) {         if (s->dma_memory_write) {             s->dma_memory_write(s->dma_opaque,                                 (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);             s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;             s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;             s->rregs[ESP_RSEQ] = SEQ_CD;         } else {             s->pdma_cb = write_response_pdma_cb;             esp_raise_drq(s);             return;         }     } else {         s->ti_size = 2;         s->rregs[ESP_RFLAGS] = 2;     }     esp_raise_irq(s); }"
"204195_CWE-125.c","CWE-125","static void parse_rtcp_bye(pjmedia_rtcp_session *sess, 			   const void *pkt, 			   pj_size_t size) {     pj_str_t reason = {""-"", 1};      /* Check and get BYE reason */     if (size > 8) { 	reason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),                              *((pj_uint8_t*)pkt+8)); 	pj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9), 		  reason.slen); 	reason.ptr = sess->stat.peer_sdes_buf_;     }      /* Just print RTCP BYE log */     PJ_LOG(5, (sess->name, ""Received RTCP BYE, reason: %.*s"", 	       reason.slen, reason.ptr)); }"
"204243_CWE-787.c","CWE-787","eval7(     char_u	**arg,     typval_T	*rettv,     evalarg_T	*evalarg,     int		want_string)	// after ""."" operator {     int		evaluate = evalarg != NULL 				      && (evalarg->eval_flags & EVAL_EVALUATE);     int		len;     char_u	*s;     char_u	*name_start = NULL;     char_u	*start_leader, *end_leader;     int		ret = OK;     char_u	*alias;      /*      * Initialise variable so that clear_tv() can't mistake this for a      * string and free a string that isn't there.      */     rettv->v_type = VAR_UNKNOWN;      /*      * Skip '!', '-' and '+' characters.  They are handled later.      */     start_leader = *arg;     if (eval_leader(arg, in_vim9script()) == FAIL) 	return FAIL;     end_leader = *arg;      if (**arg == '.' && (!isdigit(*(*arg + 1)) #ifdef FEAT_FLOAT 	    || in_old_script(2) #endif 	    ))     { 	semsg(_(e_invalid_expression_str), *arg); 	++*arg; 	return FAIL;     }      switch (**arg)     {     /*      * Number constant.      */     case '0':     case '1':     case '2':     case '3':     case '4':     case '5':     case '6':     case '7':     case '8':     case '9':     case '.':	ret = eval_number(arg, rettv, evaluate, want_string);  		// Apply prefixed ""-"" and ""+"" now.  Matters especially when 		// ""->"" follows. 		if (ret == OK && evaluate && end_leader > start_leader 						  && rettv->v_type != VAR_BLOB) 		    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader); 		break;      /*      * String constant: ""string"".      */     case '""':	ret = eval_string(arg, rettv, evaluate); 		break;      /*      * Literal string constant: 'str''ing'.      */     case '\'':	ret = eval_lit_string(arg, rettv, evaluate); 		break;      /*      * List: [expr, expr]      */     case '[':	ret = eval_list(arg, rettv, evalarg, TRUE); 		break;      /*      * Dictionary: #{key: val, key: val}      */     case '#':	if (in_vim9script()) 		{ 		    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE; 		} 		else if ((*arg)[1] == '{') 		{ 		    ++*arg; 		    ret = eval_dict(arg, rettv, evalarg, TRUE); 		} 		else 		    ret = NOTDONE; 		break;      /*      * Lambda: {arg, arg -> expr}      * Dictionary: {'key': val, 'key': val}      */     case '{':	if (in_vim9script()) 		    ret = NOTDONE; 		else 		    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg); 		if (ret == NOTDONE) 		    ret = eval_dict(arg, rettv, evalarg, FALSE); 		break;      /*      * Option value: &name      */     case '&':	ret = eval_option(arg, rettv, evaluate); 		break;      /*      * Environment variable: $VAR.      */     case '$':	ret = eval_env_var(arg, rettv, evaluate); 		break;      /*      * Register contents: @r.      */     case '@':	++*arg; 		if (evaluate) 		{ 		    if (in_vim9script() && IS_WHITE_OR_NUL(**arg)) 			semsg(_(e_syntax_error_at_str), *arg); 		    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE)) 			emsg_invreg(**arg); 		    else 		    { 			rettv->v_type = VAR_STRING; 			rettv->vval.v_string = get_reg_contents(**arg, 								GREG_EXPR_SRC); 		    } 		} 		if (**arg != NUL) 		    ++*arg; 		break;      /*      * nested expression: (expression).      * or lambda: (arg) => expr      */     case '(':	ret = NOTDONE; 		if (in_vim9script()) 		{ 		    ret = get_lambda_tv(arg, rettv, TRUE, evalarg); 		    if (ret == OK && evaluate) 		    { 			ufunc_T *ufunc = rettv->vval.v_partial->pt_func;  			// Compile it here to get the return type.  The return 			// type is optional, when it's missing use t_unknown. 			// This is recognized in compile_return(). 			if (ufunc->uf_ret_type->tt_type == VAR_VOID) 			    ufunc->uf_ret_type = &t_unknown; 			if (compile_def_function(ufunc, 				     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL) 			{ 			    clear_tv(rettv); 			    ret = FAIL; 			} 		    } 		} 		if (ret == NOTDONE) 		{ 		    *arg = skipwhite_and_linebreak(*arg + 1, evalarg); 		    ret = eval1(arg, rettv, evalarg);	// recursive!  		    *arg = skipwhite_and_linebreak(*arg, evalarg); 		    if (**arg == ')') 			++*arg; 		    else if (ret == OK) 		    { 			emsg(_(e_missing_closing_paren)); 			clear_tv(rettv); 			ret = FAIL; 		    } 		} 		break;      default:	ret = NOTDONE; 		break;     }      if (ret == NOTDONE)     { 	/* 	 * Must be a variable or function name. 	 * Can also be a curly-braces kind of name: {expr}. 	 */ 	s = *arg; 	len = get_name_len(arg, &alias, evaluate, TRUE); 	if (alias != NULL) 	    s = alias;  	if (len <= 0) 	    ret = FAIL; 	else 	{ 	    int	    flags = evalarg == NULL ? 0 : evalarg->eval_flags;  	    if (evaluate && in_vim9script() && len == 1 && *s == '_') 	    { 		emsg(_(e_cannot_use_underscore_here)); 		ret = FAIL; 	    } 	    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(') 	    { 		// ""name(...""  recursive! 		*arg = skipwhite(*arg); 		ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL); 	    } 	    else if (flags & EVAL_CONSTANT) 		ret = FAIL; 	    else if (evaluate) 	    { 		// get the value of ""true"", ""false"" or a variable 		if (len == 4 && in_vim9script() && STRNCMP(s, ""true"", 4) == 0) 		{ 		    rettv->v_type = VAR_BOOL; 		    rettv->vval.v_number = VVAL_TRUE; 		    ret = OK; 		} 		else if (len == 5 && in_vim9script() 						&& STRNCMP(s, ""false"", 5) == 0) 		{ 		    rettv->v_type = VAR_BOOL; 		    rettv->vval.v_number = VVAL_FALSE; 		    ret = OK; 		} 		else if (len == 4 && in_vim9script() 						&& STRNCMP(s, ""null"", 4) == 0) 		{ 		    rettv->v_type = VAR_SPECIAL; 		    rettv->vval.v_number = VVAL_NULL; 		    ret = OK; 		} 		else 		{ 		    name_start = s; 		    ret = eval_variable(s, len, 0, rettv, NULL, 					   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT); 		} 	    } 	    else 	    { 		// skip the name 		check_vars(s, len); 		ret = OK; 	    } 	} 	vim_free(alias);     }      // Handle following '[', '(' and '.' for expr[expr], expr.name,     // expr(expr), expr->name(expr)     if (ret == OK) 	ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);      /*      * Apply logical NOT and unary '-', from right to left, ignore '+'.      */     if (ret == OK && evaluate && end_leader > start_leader) 	ret = eval7_leader(rettv, FALSE, start_leader, &end_leader);     return ret; }"
"204278_CWE-94.cpp","CWE-94","static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) { 	char *p = src + src_prefix_len + 1; 	char *q = dst + dst_prefix_len + 1; 	char *r = dst + dst_prefix_len; 	struct stat s; 	bool last = false; 	*r = '\0'; 	for (; !last; p++, q++) { 		if (*p == '\0') { 			last = true; 		} 		if (*p == '\0' || (*p == '/' && *(p - 1) != '/')) { 			// We found a new component of our src path. 			// Null-terminate it temporarily here so that we can work 			// with it. 			*p = '\0'; 			if (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) { 				// Null-terminate the dst path and undo its previous 				// termination. 				*q = '\0'; 				*r = '/'; 				r = q; 				mkdir_attr(dst, s.st_mode, 0, 0); 			} 			if (!last) { 				// If we're not at the final terminating null, restore 				// the slash so that we can continue our traversal. 				*p = '/'; 			} 		} 	} }"
"204351_CWE-125.cpp","CWE-125","bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic) {     SQObjectPtr temp;     bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;     if(_locked && !belongs_to_static_table)         return false; //the class already has an instance so cannot be modified     if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value     {         _defaultvalues[_member_idx(temp)].val = val;         return true;     }     if(belongs_to_static_table) {         SQInteger mmidx;         if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&             (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {             _metamethods[mmidx] = val;         }         else {             SQObjectPtr theval = val;             if(_base && sq_type(val) == OT_CLOSURE) {                 theval = _closure(val)->Clone();                 _closure(theval)->_base = _base;                 __ObjAddRef(_base); //ref for the closure             }             if(sq_type(temp) == OT_NULL) {                 bool isconstructor;                 SQVM::IsEqual(ss->_constructoridx, key, isconstructor);                 if(isconstructor) {                     _constructoridx = (SQInteger)_methods.size();                 }                 SQClassMember m;                 m.val = theval;                 _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));                 _methods.push_back(m);             }             else {                 _methods[_member_idx(temp)].val = theval;             }         }         return true;     }     SQClassMember m;     m.val = val;     _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));     _defaultvalues.push_back(m);     return true; }"
"204412_CWE-787.c","CWE-787","static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size) { 	unsigned long cons_pos, prod_pos, new_prod_pos, flags; 	u32 len, pg_off; 	struct bpf_ringbuf_hdr *hdr;  	if (unlikely(size > RINGBUF_MAX_RECORD_SZ)) 		return NULL;  	len = round_up(size + BPF_RINGBUF_HDR_SZ, 8); 	cons_pos = smp_load_acquire(&rb->consumer_pos);  	if (in_nmi()) { 		if (!spin_trylock_irqsave(&rb->spinlock, flags)) 			return NULL; 	} else { 		spin_lock_irqsave(&rb->spinlock, flags); 	}  	prod_pos = rb->producer_pos; 	new_prod_pos = prod_pos + len;  	/* check for out of ringbuf space by ensuring producer position 	 * doesn't advance more than (ringbuf_size - 1) ahead 	 */ 	if (new_prod_pos - cons_pos > rb->mask) { 		spin_unlock_irqrestore(&rb->spinlock, flags); 		return NULL; 	}  	hdr = (void *)rb->data + (prod_pos & rb->mask); 	pg_off = bpf_ringbuf_rec_pg_off(rb, hdr); 	hdr->len = size | BPF_RINGBUF_BUSY_BIT; 	hdr->pg_off = pg_off;  	/* pairs with consumer's smp_load_acquire() */ 	smp_store_release(&rb->producer_pos, new_prod_pos);  	spin_unlock_irqrestore(&rb->spinlock, flags);  	return (void *)hdr + BPF_RINGBUF_HDR_SZ; }"
"204425_CWE-125.c","CWE-125","bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length) {   u_char *end;   struct capability cap;   u_char action;   struct bgp *bgp;   afi_t afi;   safi_t safi;    bgp = peer->bgp;   end = pnt + length;    while (pnt < end)     {       /* We need at least action, capability code and capability length. */       if (pnt + 3 > end)         {           zlog_info (""%s Capability length error"", peer->host);           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);           return -1;         }        action = *pnt;        /* Fetch structure to the byte stream. */       memcpy (&cap, pnt + 1, sizeof (struct capability));        /* Action value check.  */       if (action != CAPABILITY_ACTION_SET 	  && action != CAPABILITY_ACTION_UNSET)         {           zlog_info (""%s Capability Action Value error %d"", 		     peer->host, action);           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);           return -1;         }        if (BGP_DEBUG (normal, NORMAL)) 	zlog_debug (""%s CAPABILITY has action: %d, code: %u, length %u"", 		   peer->host, action, cap.code, cap.length);        /* Capability length check. */       if (pnt + (cap.length + 3) > end)         {           zlog_info (""%s Capability length error"", peer->host);           bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);           return -1;         }        /* We know MP Capability Code. */       if (cap.code == CAPABILITY_CODE_MP)         { 	  afi = ntohs (cap.mpc.afi); 	  safi = cap.mpc.safi;            /* Ignore capability when override-capability is set. */           if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY)) 	    continue;  	  /* Address family check.  */ 	  if ((afi == AFI_IP  	       || afi == AFI_IP6) 	      && (safi == SAFI_UNICAST  		  || safi == SAFI_MULTICAST  		  || safi == BGP_SAFI_VPNV4)) 	    { 	      if (BGP_DEBUG (normal, NORMAL)) 		zlog_debug (""%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u"", 			   peer->host, 			   action == CAPABILITY_ACTION_SET  			   ? ""Advertising"" : ""Removing"", 			   ntohs(cap.mpc.afi) , cap.mpc.safi); 		   	      /* Adjust safi code. */ 	      if (safi == BGP_SAFI_VPNV4) 		safi = SAFI_MPLS_VPN; 	       	      if (action == CAPABILITY_ACTION_SET) 		{ 		  peer->afc_recv[afi][safi] = 1; 		  if (peer->afc[afi][safi]) 		    { 		      peer->afc_nego[afi][safi] = 1; 		      bgp_announce_route (peer, afi, safi); 		    } 		} 	      else 		{ 		  peer->afc_recv[afi][safi] = 0; 		  peer->afc_nego[afi][safi] = 0;  		  if (peer_active_nego (peer)) 		    bgp_clear_route (peer, afi, safi); 		  else 		    BGP_EVENT_ADD (peer, BGP_Stop); 		}  	    }         }       else         {           zlog_warn (""%s unrecognized capability code: %d - ignored"",                      peer->host, cap.code);         }       pnt += cap.length + 3;     }   return 0; }"
"204438_CWE-617.c","CWE-617","WandPrivate void CLINoImageOperator(MagickCLI *cli_wand,   const char *option,const char *arg1n,const char *arg2n) {   const char    /* percent escaped versions of the args */     *arg1,     *arg2;  #define _image_info     (cli_wand->wand.image_info) #define _images         (cli_wand->wand.images) #define _exception      (cli_wand->wand.exception) #define _process_flags  (cli_wand->process_flags) #define _option_type    ((CommandOptionFlags) cli_wand->command->flags) #define IfNormalOp      (*option=='-') #define IfPlusOp        (*option!='-')    assert(cli_wand != (MagickCLI *) NULL);   assert(cli_wand->signature == MagickWandSignature);   assert(cli_wand->wand.signature == MagickWandSignature);    if (cli_wand->wand.debug != MagickFalse)     (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),       ""- NoImage Operator: %s \""%s\"" \""%s\"""", option,       arg1n != (char *) NULL ? arg1n : """",       arg2n != (char *) NULL ? arg2n : """");    arg1 = arg1n;   arg2 = arg2n;    /* Interpret Percent Escapes in Arguments - using first image */   if ( (((_process_flags & ProcessInterpretProperities) != 0 )         || ((_option_type & AlwaysInterpretArgsFlag) != 0)        )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {     /* Interpret Percent escapes in argument 1 */     if (arg1n != (char *) NULL) {       arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);       if (arg1 == (char *) NULL) {         CLIWandException(OptionWarning,""InterpretPropertyFailure"",option);         arg1=arg1n;  /* use the given argument as is */       }     }     if (arg2n != (char *) NULL) {       arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);       if (arg2 == (char *) NULL) {         CLIWandException(OptionWarning,""InterpretPropertyFailure"",option);         arg2=arg2n;  /* use the given argument as is */       }     }   } #undef _process_flags #undef _option_type    do {  /* break to exit code */     /*       No-op options  (ignore these)     */     if (LocaleCompare(""noop"",option+1) == 0)   /* zero argument */       break;     if (LocaleCompare(""sans"",option+1) == 0)   /* one argument */       break;     if (LocaleCompare(""sans0"",option+1) == 0)  /* zero argument */       break;     if (LocaleCompare(""sans1"",option+1) == 0)  /* one argument */       break;     if (LocaleCompare(""sans2"",option+1) == 0)  /* two arguments */       break;     /*       Image Reading     */     if ( ( LocaleCompare(""read"",option+1) == 0 ) ||       ( LocaleCompare(""--"",option) == 0 ) ) {       /* Do Glob filename Expansion for 'arg1' then read all images.       *       * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring       * (but attaching to the filenames in the generated argument list) any       * [...] read modifiers that may be present.       *       * For example: It will expand '*.gif[20x20]' into a list such as       * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'       *       * NOTE: In IMv6 this was done globally across all images. This       * meant you could include IM options in '@filename' lists, but you       * could not include comments.   Doing it only for image read makes       * it far more secure.       *       * Note: arguments do not have percent escapes expanded for security       * reasons.       */       int      argc;       char     **argv;       ssize_t  i;        argc = 1;       argv = (char **) &arg1;        /* Expand 'glob' expressions in the given filename.         Expansion handles any 'coder:' prefix, or read modifiers attached         to the filename, including them in the resulting expanded list.       */       if (ExpandFilenames(&argc,&argv) == MagickFalse)         CLIWandExceptArgBreak(ResourceLimitError,""MemoryAllocationFailed"",             option,GetExceptionMessage(errno));        /* loop over expanded filename list, and read then all in */       for (i=0; i < (ssize_t) argc; i++) {         Image *           new_images;         if (_image_info->ping != MagickFalse)           new_images=PingImages(_image_info,argv[i],_exception);         else           new_images=ReadImages(_image_info,argv[i],_exception);         AppendImageToList(&_images, new_images);         argv[i]=DestroyString(argv[i]);       }       argv=(char **) RelinquishMagickMemory(argv);       break;     }     /*       Image Writing       Note: Writing a empty image list is valid in specific cases     */     if (LocaleCompare(""write"",option+1) == 0) {       /* Note: arguments do not have percent escapes expanded */       char         key[MagickPathExtent];        Image         *write_images;        ImageInfo         *write_info;        /* Need images, unless a ""null:"" output coder is used */       if ( _images == (Image *) NULL ) {         if ( LocaleCompare(arg1,""null:"") == 0 )           break;         CLIWandExceptArgBreak(OptionError,""NoImagesForWrite"",option,arg1);       }        (void) FormatLocaleString(key,MagickPathExtent,""cache:%s"",arg1);       (void) DeleteImageRegistry(key);       write_images=CloneImageList(_images,_exception);       write_info=CloneImageInfo(_image_info);       (void) WriteImages(write_info,write_images,arg1,_exception);       write_info=DestroyImageInfo(write_info);       write_images=DestroyImageList(write_images);       break;     }     /*       Parenthesis and Brace operations     */     if (LocaleCompare(""("",option) == 0) {       /* stack 'push' images */       Stack         *node;        size_t         size;        size=0;       node=cli_wand->image_list_stack;       for ( ; node != (Stack *) NULL; node=node->next)         size++;       if ( size >= MAX_STACK_DEPTH )         CLIWandExceptionBreak(OptionError,""ParenthesisNestedTooDeeply"",option);       node=(Stack *) AcquireMagickMemory(sizeof(*node));       if (node == (Stack *) NULL)         CLIWandExceptionBreak(ResourceLimitFatalError,             ""MemoryAllocationFailed"",option);       node->data = (void *)cli_wand->wand.images;       node->next = cli_wand->image_list_stack;       cli_wand->image_list_stack = node;       cli_wand->wand.images = NewImageList();        /* handle respect-parenthesis */       if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,                     ""respect-parenthesis"")) != MagickFalse)         option=""{""; /* fall-thru so as to push image settings too */       else         break;       /* fall thru to operation */     }     if (LocaleCompare(""{"",option) == 0) {       /* stack 'push' of image_info settings */       Stack         *node;        size_t         size;        size=0;       node=cli_wand->image_info_stack;       for ( ; node != (Stack *) NULL; node=node->next)         size++;       if ( size >= MAX_STACK_DEPTH )         CLIWandExceptionBreak(OptionError,""CurlyBracesNestedTooDeeply"",option);       node=(Stack *) AcquireMagickMemory(sizeof(*node));       if (node == (Stack *) NULL)         CLIWandExceptionBreak(ResourceLimitFatalError,             ""MemoryAllocationFailed"",option);        node->data = (void *)cli_wand->wand.image_info;       node->next = cli_wand->image_info_stack;        cli_wand->image_info_stack = node;       cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);       if (cli_wand->wand.image_info == (ImageInfo *) NULL) {         CLIWandException(ResourceLimitFatalError,""MemoryAllocationFailed"",             option);         cli_wand->wand.image_info = (ImageInfo *)node->data;         node = (Stack *)RelinquishMagickMemory(node);         break;       }        break;     }     if (LocaleCompare("")"",option) == 0) {       /* pop images from stack */       Stack         *node;        node = (Stack *)cli_wand->image_list_stack;       if ( node == (Stack *) NULL)         CLIWandExceptionBreak(OptionError,""UnbalancedParenthesis"",option);       cli_wand->image_list_stack = node->next;        AppendImageToList((Image **)&node->data,cli_wand->wand.images);       cli_wand->wand.images= (Image *)node->data;       node = (Stack *)RelinquishMagickMemory(node);        /* handle respect-parenthesis - of the previous 'pushed' settings */       node = cli_wand->image_info_stack;       if ( node != (Stack *) NULL)         {           if (IsStringTrue(GetImageOption(                 cli_wand->wand.image_info,""respect-parenthesis"")) != MagickFalse)             option=""}""; /* fall-thru so as to pop image settings too */           else             break;         }       else         break;       /* fall thru to next if */     }     if (LocaleCompare(""}"",option) == 0) {       /* pop image_info settings from stack */       Stack         *node;        node = (Stack *)cli_wand->image_info_stack;       if ( node == (Stack *) NULL)         CLIWandExceptionBreak(OptionError,""UnbalancedCurlyBraces"",option);       cli_wand->image_info_stack = node->next;        (void) DestroyImageInfo(cli_wand->wand.image_info);       cli_wand->wand.image_info = (ImageInfo *)node->data;       node = (Stack *)RelinquishMagickMemory(node);        GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);       cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);       cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);        break;     }       if (LocaleCompare(""print"",option+1) == 0)         {           (void) FormatLocaleFile(stdout,""%s"",arg1);           break;         }     if (LocaleCompare(""set"",option+1) == 0)       {         /* Settings are applied to each image in memory in turn (if any).            While a option: only need to be applied once globally.             NOTE: rguments have not been automatically percent expaneded         */          /* escape the 'key' once only, using first image. */         arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);         if (arg1 == (char *) NULL)           CLIWandExceptionBreak(OptionWarning,""InterpretPropertyFailure"",                 option);          if (LocaleNCompare(arg1,""registry:"",9) == 0)           {             if (IfPlusOp)               {                 (void) DeleteImageRegistry(arg1+9);                 arg1=DestroyString((char *)arg1);                 break;               }             arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);             if (arg2 == (char *) NULL) {               arg1=DestroyString((char *)arg1);               CLIWandExceptionBreak(OptionWarning,""InterpretPropertyFailure"",                     option);             }             (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);             arg1=DestroyString((char *)arg1);             arg2=DestroyString((char *)arg2);             break;           }         if (LocaleNCompare(arg1,""option:"",7) == 0)           {             /* delete equivelent artifact from all images (if any) */             if (_images != (Image *) NULL)               {                 MagickResetIterator(&cli_wand->wand);                 while (MagickNextImage(&cli_wand->wand) != MagickFalse)                   (void) DeleteImageArtifact(_images,arg1+7);                 MagickResetIterator(&cli_wand->wand);               }             /* now set/delete the global option as needed */             /* FUTURE: make escapes in a global 'option:' delayed */             arg2=(char *) NULL;             if (IfNormalOp)               {                 arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);                 if (arg2 == (char *) NULL)                   CLIWandExceptionBreak(OptionWarning,                        ""InterpretPropertyFailure"",option);               }             (void) SetImageOption(_image_info,arg1+7,arg2);             arg1=DestroyString((char *)arg1);             arg2=DestroyString((char *)arg2);             break;           }         /* Set Artifacts/Properties/Attributes all images (required) */         if ( _images == (Image *) NULL )           CLIWandExceptArgBreak(OptionWarning,""NoImageForProperty"",option,arg1);          MagickResetIterator(&cli_wand->wand);         while (MagickNextImage(&cli_wand->wand) != MagickFalse)           {             arg2=(char *) NULL;             if (IfNormalOp)               {                 arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);                 if (arg2 == (char *) NULL)                   CLIWandExceptionBreak(OptionWarning,                        ""InterpretPropertyFailure"",option);               }             if (LocaleNCompare(arg1,""artifact:"",9) == 0)               (void) SetImageArtifact(_images,arg1+9,arg2);             else if (LocaleNCompare(arg1,""property:"",9) == 0)               (void) SetImageProperty(_images,arg1+9,arg2,_exception);             else               (void) SetImageProperty(_images,arg1,arg2,_exception);             arg2=DestroyString((char *)arg2);           }         MagickResetIterator(&cli_wand->wand);         arg1=DestroyString((char *)arg1);         break;      }     if (LocaleCompare(""clone"",option+1) == 0) {         Image           *new_images;          if (*option == '+')           arg1=AcquireString(""-1"");         if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)           CLIWandExceptionBreak(OptionError,""InvalidArgument"",option);         if ( cli_wand->image_list_stack == (Stack *) NULL)           CLIWandExceptionBreak(OptionError,""UnableToCloneImage"",option);         new_images = (Image *)cli_wand->image_list_stack->data;         if (new_images == (Image *) NULL)           CLIWandExceptionBreak(OptionError,""UnableToCloneImage"",option);         new_images=CloneImages(new_images,arg1,_exception);         if (new_images == (Image *) NULL)           CLIWandExceptionBreak(OptionError,""NoSuchImage"",option);         AppendImageToList(&_images,new_images);         break;       }     /*        Informational Operations.         Note that these do not require either a cli-wand or images!        Though currently a cli-wand much be provided regardless.     */     if (LocaleCompare(""version"",option+1) == 0)       {         ListMagickVersion(stdout);         break;       }     if (LocaleCompare(""list"",option+1) == 0) {       /*          FUTURE: This 'switch' should really be part of MagickCore       */       ssize_t         list;        list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);       if ( list < 0 ) {         CLIWandExceptionArg(OptionError,""UnrecognizedListType"",option,arg1);         break;       }       switch (list)       {         case MagickCoderOptions:         {           (void) ListCoderInfo((FILE *) NULL,_exception);           break;         }         case MagickColorOptions:         {           (void) ListColorInfo((FILE *) NULL,_exception);           break;         }         case MagickConfigureOptions:         {           (void) ListConfigureInfo((FILE *) NULL,_exception);           break;         }         case MagickDelegateOptions:         {           (void) ListDelegateInfo((FILE *) NULL,_exception);           break;         }         case MagickFontOptions:         {           (void) ListTypeInfo((FILE *) NULL,_exception);           break;         }         case MagickFormatOptions:           (void) ListMagickInfo((FILE *) NULL,_exception);           break;         case MagickLocaleOptions:           (void) ListLocaleInfo((FILE *) NULL,_exception);           break;         case MagickLogOptions:           (void) ListLogInfo((FILE *) NULL,_exception);           break;         case MagickMagicOptions:           (void) ListMagicInfo((FILE *) NULL,_exception);           break;         case MagickMimeOptions:           (void) ListMimeInfo((FILE *) NULL,_exception);           break;         case MagickModuleOptions:           (void) ListModuleInfo((FILE *) NULL,_exception);           break;         case MagickPolicyOptions:           (void) ListPolicyInfo((FILE *) NULL,_exception);           break;         case MagickResourceOptions:           (void) ListMagickResourceInfo((FILE *) NULL,_exception);           break;         case MagickThresholdOptions:           (void) ListThresholdMaps((FILE *) NULL,_exception);           break;         default:           (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,             _exception);           break;       }       break;     }      CLIWandException(OptionError,""UnrecognizedOption"",option);  DisableMSCWarning(4127)   } while (0);  /* break to exit code. */ RestoreMSCWarning    /* clean up percent escape interpreted strings */   if (arg1 != arg1n )     arg1=DestroyString((char *)arg1);   if (arg2 != arg2n )     arg2=DestroyString((char *)arg2);  #undef _image_info #undef _images #undef _exception #undef IfNormalOp #undef IfPlusOp }"
"204495_CWE-193.c","CWE-193","static int __io_sync_cancel(struct io_uring_task *tctx, 			    struct io_cancel_data *cd, int fd) { 	struct io_ring_ctx *ctx = cd->ctx;  	/* fixed must be grabbed every time since we drop the uring_lock */ 	if ((cd->flags & IORING_ASYNC_CANCEL_FD) && 	    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) { 		unsigned long file_ptr;  		if (unlikely(fd > ctx->nr_user_files)) 			return -EBADF; 		fd = array_index_nospec(fd, ctx->nr_user_files); 		file_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr; 		cd->file = (struct file *) (file_ptr & FFS_MASK); 		if (!cd->file) 			return -EBADF; 	}  	return __io_async_cancel(cd, tctx, 0); }"
"204534_CWE-125.c","CWE-125","stl_remove_degenerate(stl_file *stl, int facet) {   int edge1;   int edge2;   int edge3;   int neighbor1;   int neighbor2;   int neighbor3;   int vnot1;   int vnot2;   int vnot3;    if (stl->error) return;    if(   !memcmp(&stl->facet_start[facet].vertex[0],                 &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))         && !memcmp(&stl->facet_start[facet].vertex[1],                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {     /* all 3 vertices are equal.  Just remove the facet.  I don't think*/     /* this is really possible, but just in case... */     printf(""removing a facet in stl_remove_degenerate\n"");      stl_remove_facet(stl, facet);     return;   }    if(!memcmp(&stl->facet_start[facet].vertex[0],              &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {     edge1 = 1;     edge2 = 2;     edge3 = 0;   } else if(!memcmp(&stl->facet_start[facet].vertex[1],                     &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {     edge1 = 0;     edge2 = 2;     edge3 = 1;   } else if(!memcmp(&stl->facet_start[facet].vertex[2],                     &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {     edge1 = 0;     edge2 = 1;     edge3 = 2;   } else {     /* No degenerate. Function shouldn't have been called. */     return;   }   neighbor1 = stl->neighbors_start[facet].neighbor[edge1];   neighbor2 = stl->neighbors_start[facet].neighbor[edge2];    if(neighbor1 == -1) {     stl_update_connects_remove_1(stl, neighbor2);   }   if(neighbor2 == -1) {     stl_update_connects_remove_1(stl, neighbor1);   }     neighbor3 = stl->neighbors_start[facet].neighbor[edge3];   vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];   vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];   vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];    if(neighbor1 != -1){     stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;     stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;   }   if(neighbor2 != -1){     stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;     stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;   }    stl_remove_facet(stl, facet);    if(neighbor3 != -1) {     stl_update_connects_remove_1(stl, neighbor3);     stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;   } }"
"204535_CWE-125.c","CWE-125","stl_update_connects_remove_1(stl_file *stl, int facet_num) {   int j;    if (stl->error) return;   /* Update list of connected edges */   j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +        (stl->neighbors_start[facet_num].neighbor[1] == -1) +        (stl->neighbors_start[facet_num].neighbor[2] == -1));   if(j == 0) {		       /* Facet has 3 neighbors */     stl->stats.connected_facets_3_edge -= 1;   } else if(j == 1) {	     /* Facet has 2 neighbors */     stl->stats.connected_facets_2_edge -= 1;   } else if(j == 2) {	     /* Facet has 1 neighbor  */     stl->stats.connected_facets_1_edge -= 1;   } }"
"204544_CWE-416.c","CWE-416","static int em28xx_usb_probe(struct usb_interface *intf, 			    const struct usb_device_id *id) { 	struct usb_device *udev; 	struct em28xx *dev = NULL; 	int retval; 	bool has_vendor_audio = false, has_video = false, has_dvb = false; 	int i, nr, try_bulk; 	const int ifnum = intf->altsetting[0].desc.bInterfaceNumber; 	char *speed;  	udev = usb_get_dev(interface_to_usbdev(intf));  	/* Check to see next free device and mark as used */ 	do { 		nr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS); 		if (nr >= EM28XX_MAXBOARDS) { 			/* No free device slots */ 			dev_err(&intf->dev, 				""Driver supports up to %i em28xx boards.\n"", 			       EM28XX_MAXBOARDS); 			retval = -ENOMEM; 			goto err_no_slot; 		} 	} while (test_and_set_bit(nr, em28xx_devused));  	/* Don't register audio interfaces */ 	if (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) { 		dev_info(&intf->dev, 			""audio device (%04x:%04x): interface %i, class %i\n"", 			le16_to_cpu(udev->descriptor.idVendor), 			le16_to_cpu(udev->descriptor.idProduct), 			ifnum, 			intf->altsetting[0].desc.bInterfaceClass);  		retval = -ENODEV; 		goto err; 	}  	/* allocate memory for our device state and initialize it */ 	dev = kzalloc(sizeof(*dev), GFP_KERNEL); 	if (!dev) { 		retval = -ENOMEM; 		goto err; 	}  	/* compute alternate max packet sizes */ 	dev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting, 					     sizeof(dev->alt_max_pkt_size_isoc[0]), 					     GFP_KERNEL); 	if (!dev->alt_max_pkt_size_isoc) { 		kfree(dev); 		retval = -ENOMEM; 		goto err; 	}  	/* Get endpoints */ 	for (i = 0; i < intf->num_altsetting; i++) { 		int ep;  		for (ep = 0; 		     ep < intf->altsetting[i].desc.bNumEndpoints; 		     ep++) 			em28xx_check_usb_descriptor(dev, udev, intf, 						    i, ep, 						    &has_vendor_audio, 						    &has_video, 						    &has_dvb); 	}  	if (!(has_vendor_audio || has_video || has_dvb)) { 		retval = -ENODEV; 		goto err_free; 	}  	switch (udev->speed) { 	case USB_SPEED_LOW: 		speed = ""1.5""; 		break; 	case USB_SPEED_UNKNOWN: 	case USB_SPEED_FULL: 		speed = ""12""; 		break; 	case USB_SPEED_HIGH: 		speed = ""480""; 		break; 	default: 		speed = ""unknown""; 	}  	dev_info(&intf->dev, 		""New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\n"", 		udev->manufacturer ? udev->manufacturer : """", 		udev->product ? udev->product : """", 		speed, 		le16_to_cpu(udev->descriptor.idVendor), 		le16_to_cpu(udev->descriptor.idProduct), 		ifnum, 		intf->altsetting->desc.bInterfaceNumber);  	/* 	 * Make sure we have 480 Mbps of bandwidth, otherwise things like 	 * video stream wouldn't likely work, since 12 Mbps is generally 	 * not enough even for most Digital TV streams. 	 */ 	if (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) { 		dev_err(&intf->dev, ""Device initialization failed.\n""); 		dev_err(&intf->dev, 			""Device must be connected to a high-speed USB 2.0 port.\n""); 		retval = -ENODEV; 		goto err_free; 	}  	dev->devno = nr; 	dev->model = id->driver_info; 	dev->alt   = -1; 	dev->is_audio_only = has_vendor_audio && !(has_video || has_dvb); 	dev->has_video = has_video; 	dev->ifnum = ifnum;  	dev->ts = PRIMARY_TS; 	snprintf(dev->name, 28, ""em28xx""); 	dev->dev_next = NULL;  	if (has_vendor_audio) { 		dev_info(&intf->dev, 			""Audio interface %i found (Vendor Class)\n"", ifnum); 		dev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR; 	} 	/* Checks if audio is provided by a USB Audio Class intf */ 	for (i = 0; i < udev->config->desc.bNumInterfaces; i++) { 		struct usb_interface *uif = udev->config->interface[i];  		if (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) { 			if (has_vendor_audio) 				dev_err(&intf->dev, 					""em28xx: device seems to have vendor AND usb audio class interfaces !\n"" 					""\t\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\n""); 			dev->usb_audio_type = EM28XX_USB_AUDIO_CLASS; 			break; 		} 	}  	if (has_video) 		dev_info(&intf->dev, ""Video interface %i found:%s%s\n"", 			ifnum, 			dev->analog_ep_bulk ? "" bulk"" : """", 			dev->analog_ep_isoc ? "" isoc"" : """"); 	if (has_dvb) 		dev_info(&intf->dev, ""DVB interface %i found:%s%s\n"", 			ifnum, 			dev->dvb_ep_bulk ? "" bulk"" : """", 			dev->dvb_ep_isoc ? "" isoc"" : """");  	dev->num_alt = intf->num_altsetting;  	if ((unsigned int)card[nr] < em28xx_bcount) 		dev->model = card[nr];  	/* save our data pointer in this intf device */ 	usb_set_intfdata(intf, dev);  	/* allocate device struct and check if the device is a webcam */ 	mutex_init(&dev->lock); 	retval = em28xx_init_dev(dev, udev, intf, nr); 	if (retval) 		goto err_free;  	if (usb_xfer_mode < 0) { 		if (dev->is_webcam) 			try_bulk = 1; 		else 			try_bulk = 0; 	} else { 		try_bulk = usb_xfer_mode > 0; 	}  	/* Disable V4L2 if the device doesn't have a decoder or image sensor */ 	if (has_video && 	    dev->board.decoder == EM28XX_NODECODER && 	    dev->em28xx_sensor == EM28XX_NOSENSOR) { 		dev_err(&intf->dev, 			""Currently, V4L2 is not supported on this model\n""); 		has_video = false; 		dev->has_video = false; 	}  	if (dev->board.has_dual_ts && 	    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) { 		/* 		 * The logic with sets alternate is not ready for dual-tuners 		 * which analog modes. 		 */ 		dev_err(&intf->dev, 			""We currently don't support analog TV or stream capture on dual tuners.\n""); 		has_video = false; 	}  	/* Select USB transfer types to use */ 	if (has_video) { 		if (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk)) 			dev->analog_xfer_bulk = 1; 		dev_info(&intf->dev, ""analog set to %s mode.\n"", 			dev->analog_xfer_bulk ? ""bulk"" : ""isoc""); 	} 	if (has_dvb) { 		if (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk)) 			dev->dvb_xfer_bulk = 1; 		dev_info(&intf->dev, ""dvb set to %s mode.\n"", 			dev->dvb_xfer_bulk ? ""bulk"" : ""isoc""); 	}  	if (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) { 		dev->dev_next->ts = SECONDARY_TS; 		dev->dev_next->alt   = -1; 		dev->dev_next->is_audio_only = has_vendor_audio && 						!(has_video || has_dvb); 		dev->dev_next->has_video = false; 		dev->dev_next->ifnum = ifnum; 		dev->dev_next->model = id->driver_info;  		mutex_init(&dev->dev_next->lock); 		retval = em28xx_init_dev(dev->dev_next, udev, intf, 					 dev->dev_next->devno); 		if (retval) 			goto err_free;  		dev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */ 		dev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */  		if (usb_xfer_mode < 0) { 			if (dev->dev_next->is_webcam) 				try_bulk = 1; 			else 				try_bulk = 0; 		} else { 			try_bulk = usb_xfer_mode > 0; 		}  		/* Select USB transfer types to use */ 		if (has_dvb) { 			if (!dev->dvb_ep_isoc_ts2 || 			    (try_bulk && dev->dvb_ep_bulk_ts2)) 				dev->dev_next->dvb_xfer_bulk = 1; 			dev_info(&dev->intf->dev, ""dvb ts2 set to %s mode.\n"", 				 dev->dev_next->dvb_xfer_bulk ? ""bulk"" : ""isoc""); 		}  		dev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2; 		dev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2; 		dev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2; 		dev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;  		/* Configure hardware to support TS2*/ 		if (dev->dvb_xfer_bulk) { 			/* The ep4 and ep5 are configured for BULK */ 			em28xx_write_reg(dev, 0x0b, 0x96); 			mdelay(100); 			em28xx_write_reg(dev, 0x0b, 0x80); 			mdelay(100); 		} else { 			/* The ep4 and ep5 are configured for ISO */ 			em28xx_write_reg(dev, 0x0b, 0x96); 			mdelay(100); 			em28xx_write_reg(dev, 0x0b, 0x82); 			mdelay(100); 		}  		kref_init(&dev->dev_next->ref); 	}  	kref_init(&dev->ref);  	request_modules(dev);  	/* 	 * Do it at the end, to reduce dynamic configuration changes during 	 * the device init. Yet, as request_modules() can be async, the 	 * topology will likely change after the load of the em28xx subdrivers. 	 */ #ifdef CONFIG_MEDIA_CONTROLLER 	retval = media_device_register(dev->media_dev); #endif  	return 0;  err_free: 	kfree(dev->alt_max_pkt_size_isoc); 	kfree(dev);  err: 	clear_bit(nr, em28xx_devused);  err_no_slot: 	usb_put_dev(udev); 	return retval; }"
"204711_CWE-125.c","CWE-125","static int ldb_wildcard_compare(struct ldb_context *ldb, 				const struct ldb_parse_tree *tree, 				const struct ldb_val value, bool *matched) { 	const struct ldb_schema_attribute *a; 	struct ldb_val val; 	struct ldb_val cnk; 	struct ldb_val *chunk; 	uint8_t *save_p = NULL; 	unsigned int c = 0;  	a = ldb_schema_attribute_by_name(ldb, tree->u.substring.attr); 	if (!a) { 		return LDB_ERR_INVALID_ATTRIBUTE_SYNTAX; 	}  	if (tree->u.substring.chunks == NULL) { 		*matched = false; 		return LDB_SUCCESS; 	}  	if (a->syntax->canonicalise_fn(ldb, ldb, &value, &val) != 0) { 		return LDB_ERR_INVALID_ATTRIBUTE_SYNTAX; 	}  	save_p = val.data; 	cnk.data = NULL;  	if ( ! tree->u.substring.start_with_wildcard ) {  		chunk = tree->u.substring.chunks[c]; 		if (a->syntax->canonicalise_fn(ldb, ldb, chunk, &cnk) != 0) goto mismatch;  		/* This deals with wildcard prefix searches on binary attributes (eg objectGUID) */ 		if (cnk.length > val.length) { 			goto mismatch; 		} 		/* 		 * Empty strings are returned as length 0. Ensure 		 * we can cope with this. 		 */ 		if (cnk.length == 0) { 			goto mismatch; 		}  		if (memcmp((char *)val.data, (char *)cnk.data, cnk.length) != 0) goto mismatch; 		val.length -= cnk.length; 		val.data += cnk.length; 		c++; 		talloc_free(cnk.data); 		cnk.data = NULL; 	}  	while (tree->u.substring.chunks[c]) { 		uint8_t *p;  		chunk = tree->u.substring.chunks[c]; 		if(a->syntax->canonicalise_fn(ldb, ldb, chunk, &cnk) != 0) goto mismatch;  		/* 		 * Empty strings are returned as length 0. Ensure 		 * we can cope with this. 		 */ 		if (cnk.length == 0) { 			goto mismatch; 		} 		/* 		 * Values might be binary blobs. Don't use string 		 * search, but memory search instead. 		 */ 		p = memmem((const void *)val.data,val.length, 			   (const void *)cnk.data, cnk.length); 		if (p == NULL) goto mismatch;  		/* 		 * At this point we know cnk.length <= val.length as 		 * otherwise there could be no match 		 */  		if ( (! tree->u.substring.chunks[c + 1]) && (! tree->u.substring.end_with_wildcard) ) { 			uint8_t *g; 			uint8_t *end = val.data + val.length; 			do { /* greedy */  				/* 				 * haystack is a valid pointer in val 				 * because the memmem() can only 				 * succeed if the needle (cnk.length) 				 * is <= haystacklen 				 * 				 * p will be a pointer at least 				 * cnk.length from the end of haystack 				 */ 				uint8_t *haystack 					= p + cnk.length; 				size_t haystacklen 					= end - (haystack);  				g = memmem(haystack, 					   haystacklen, 					   (const uint8_t *)cnk.data, 					   cnk.length); 				if (g) { 					p = g; 				} 			} while(g); 		} 		val.length = val.length - (p - (uint8_t *)(val.data)) - cnk.length; 		val.data = (uint8_t *)(p + cnk.length); 		c++; 		talloc_free(cnk.data); 		cnk.data = NULL; 	}  	/* last chunk may not have reached end of string */ 	if ( (! tree->u.substring.end_with_wildcard) && (*(val.data) != 0) ) goto mismatch; 	talloc_free(save_p); 	*matched = true; 	return LDB_SUCCESS;  mismatch: 	*matched = false; 	talloc_free(save_p); 	talloc_free(cnk.data); 	return LDB_SUCCESS; }"
"204751_CWE-416.c","CWE-416","do_tag(     char_u	*tag,		// tag (pattern) to jump to     int		type,     int		count,     int		forceit,	// :ta with !     int		verbose)	// print ""tag not found"" message {     taggy_T	*tagstack = curwin->w_tagstack;     int		tagstackidx = curwin->w_tagstackidx;     int		tagstacklen = curwin->w_tagstacklen;     int		cur_match = 0;     int		cur_fnum = curbuf->b_fnum;     int		oldtagstackidx = tagstackidx;     int		prevtagstackidx = tagstackidx;     int		prev_num_matches;     int		new_tag = FALSE;     int		i;     int		ic;     int		no_regexp = FALSE;     int		error_cur_match = 0;     int		save_pos = FALSE;     fmark_T	saved_fmark; #ifdef FEAT_CSCOPE     int		jumped_to_tag = FALSE; #endif     int		new_num_matches;     char_u	**new_matches;     int		use_tagstack;     int		skip_msg = FALSE;     char_u	*buf_ffname = curbuf->b_ffname;	    // name to use for 						    // priority computation     int		use_tfu = 1;      // remember the matches for the last used tag     static int		num_matches = 0;     static int		max_num_matches = 0;  // limit used for match search     static char_u	**matches = NULL;     static int		flags;  #ifdef FEAT_EVAL     if (tfu_in_use)     { 	emsg(_(e_cannot_modify_tag_stack_within_tagfunc)); 	return FALSE;     } #endif  #ifdef EXITFREE     if (type == DT_FREE)     { 	// remove the list of matches 	FreeWild(num_matches, matches); # ifdef FEAT_CSCOPE 	cs_free_tags(); # endif 	num_matches = 0; 	return FALSE;     } #endif      if (type == DT_HELP)     { 	type = DT_TAG; 	no_regexp = TRUE; 	use_tfu = 0;     }      prev_num_matches = num_matches;     free_string_option(nofile_fname);     nofile_fname = NULL;      CLEAR_POS(&saved_fmark.mark);	// shutup gcc 4.0     saved_fmark.fnum = 0;      /*      * Don't add a tag to the tagstack if 'tagstack' has been reset.      */     if ((!p_tgst && *tag != NUL))     { 	use_tagstack = FALSE; 	new_tag = TRUE; #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	{ 	    tagstack_clear_entry(&ptag_entry); 	    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL) 		goto end_do_tag; 	} #endif     }     else     { #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	    use_tagstack = FALSE; 	else #endif 	    use_tagstack = TRUE;  	// new pattern, add to the tag stack 	if (*tag != NUL 		&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP #ifdef FEAT_QUICKFIX 		    || type == DT_LTAG #endif #ifdef FEAT_CSCOPE 		    || type == DT_CSCOPE #endif 		    )) 	{ #if defined(FEAT_QUICKFIX) 	    if (g_do_tagpreview != 0) 	    { 		if (ptag_entry.tagname != NULL 			&& STRCMP(ptag_entry.tagname, tag) == 0) 		{ 		    // Jumping to same tag: keep the current match, so that 		    // the CursorHold autocommand example works. 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else 		{ 		    tagstack_clear_entry(&ptag_entry); 		    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL) 			goto end_do_tag; 		} 	    } 	    else #endif 	    { 		/* 		 * If the last used entry is not at the top, delete all tag 		 * stack entries above it. 		 */ 		while (tagstackidx < tagstacklen) 		    tagstack_clear_entry(&tagstack[--tagstacklen]);  		// if the tagstack is full: remove oldest entry 		if (++tagstacklen > TAGSTACKSIZE) 		{ 		    tagstacklen = TAGSTACKSIZE; 		    tagstack_clear_entry(&tagstack[0]); 		    for (i = 1; i < tagstacklen; ++i) 			tagstack[i - 1] = tagstack[i]; 		    --tagstackidx; 		}  		/* 		 * put the tag name in the tag stack 		 */ 		if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL) 		{ 		    curwin->w_tagstacklen = tagstacklen - 1; 		    goto end_do_tag; 		} 		curwin->w_tagstacklen = tagstacklen;  		save_pos = TRUE;	// save the cursor position below 	    }  	    new_tag = TRUE; 	} 	else 	{ 	    if ( #if defined(FEAT_QUICKFIX) 		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL : #endif 		    tagstacklen == 0) 	    { 		// empty stack 		emsg(_(e_tag_stack_empty)); 		goto end_do_tag; 	    }  	    if (type == DT_POP)		// go to older position 	    { #ifdef FEAT_FOLDING 		int	old_KeyTyped = KeyTyped; #endif 		if ((tagstackidx -= count) < 0) 		{ 		    emsg(_(e_at_bottom_of_tag_stack)); 		    if (tagstackidx + count == 0) 		    { 			// We did [num]^T from the bottom of the stack 			tagstackidx = 0; 			goto end_do_tag; 		    } 		    // We weren't at the bottom of the stack, so jump all the 		    // way to the bottom now. 		    tagstackidx = 0; 		} 		else if (tagstackidx >= tagstacklen)    // count == 0? 		{ 		    emsg(_(e_at_top_of_tag_stack)); 		    goto end_do_tag; 		}  		// Make a copy of the fmark, autocommands may invalidate the 		// tagstack before it's used. 		saved_fmark = tagstack[tagstackidx].fmark; 		if (saved_fmark.fnum != curbuf->b_fnum) 		{ 		    /* 		     * Jump to other file. If this fails (e.g. because the 		     * file was changed) keep original position in tag stack. 		     */ 		    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum, 					       GETF_SETMARK, forceit) == FAIL) 		    { 			tagstackidx = oldtagstackidx;  // back to old posn 			goto end_do_tag; 		    } 		    // An BufReadPost autocommand may jump to the '"" mark, but 		    // we don't what that here. 		    curwin->w_cursor.lnum = saved_fmark.mark.lnum; 		} 		else 		{ 		    setpcmark(); 		    curwin->w_cursor.lnum = saved_fmark.mark.lnum; 		} 		curwin->w_cursor.col = saved_fmark.mark.col; 		curwin->w_set_curswant = TRUE; 		check_cursor(); #ifdef FEAT_FOLDING 		if ((fdo_flags & FDO_TAG) && old_KeyTyped) 		    foldOpenCursor(); #endif  		// remove the old list of matches 		FreeWild(num_matches, matches); #ifdef FEAT_CSCOPE 		cs_free_tags(); #endif 		num_matches = 0; 		tag_freematch(); 		goto end_do_tag; 	    }  	    if (type == DT_TAG #if defined(FEAT_QUICKFIX) 		    || type == DT_LTAG #endif 	       ) 	    { #if defined(FEAT_QUICKFIX) 		if (g_do_tagpreview != 0) 		{ 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else #endif 		{ 		    // "":tag"" (no argument): go to newer pattern 		    save_pos = TRUE;	// save the cursor position below 		    if ((tagstackidx += count - 1) >= tagstacklen) 		    { 			/* 			 * Beyond the last one, just give an error message and 			 * go to the last one.  Don't store the cursor 			 * position. 			 */ 			tagstackidx = tagstacklen - 1; 			emsg(_(e_at_top_of_tag_stack)); 			save_pos = FALSE; 		    } 		    else if (tagstackidx < 0)	// must have been count == 0 		    { 			emsg(_(e_at_bottom_of_tag_stack)); 			tagstackidx = 0; 			goto end_do_tag; 		    } 		    cur_match = tagstack[tagstackidx].cur_match; 		    cur_fnum = tagstack[tagstackidx].cur_fnum; 		} 		new_tag = TRUE; 	    } 	    else				// go to other matching tag 	    { 		// Save index for when selection is cancelled. 		prevtagstackidx = tagstackidx;  #if defined(FEAT_QUICKFIX) 		if (g_do_tagpreview != 0) 		{ 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else #endif 		{ 		    if (--tagstackidx < 0) 			tagstackidx = 0; 		    cur_match = tagstack[tagstackidx].cur_match; 		    cur_fnum = tagstack[tagstackidx].cur_fnum; 		} 		switch (type) 		{ 		    case DT_FIRST: cur_match = count - 1; break; 		    case DT_SELECT: 		    case DT_JUMP: #ifdef FEAT_CSCOPE 		    case DT_CSCOPE: #endif 		    case DT_LAST:  cur_match = MAXCOL - 1; break; 		    case DT_NEXT:  cur_match += count; break; 		    case DT_PREV:  cur_match -= count; break; 		} 		if (cur_match >= MAXCOL) 		    cur_match = MAXCOL - 1; 		else if (cur_match < 0) 		{ 		    emsg(_(e_cannot_go_before_first_matching_tag)); 		    skip_msg = TRUE; 		    cur_match = 0; 		    cur_fnum = curbuf->b_fnum; 		} 	    } 	}  #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	{ 	    if (type != DT_SELECT && type != DT_JUMP) 	    { 		ptag_entry.cur_match = cur_match; 		ptag_entry.cur_fnum = cur_fnum; 	    } 	} 	else #endif 	{ 	    /* 	     * For "":tag [arg]"" or "":tselect"" remember position before the jump. 	     */ 	    saved_fmark = tagstack[tagstackidx].fmark; 	    if (save_pos) 	    { 		tagstack[tagstackidx].fmark.mark = curwin->w_cursor; 		tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum; 	    }  	    // Curwin will change in the call to jumpto_tag() if "":stag"" was 	    // used or an autocommand jumps to another window; store value of 	    // tagstackidx now. 	    curwin->w_tagstackidx = tagstackidx; 	    if (type != DT_SELECT && type != DT_JUMP) 	    { 		curwin->w_tagstack[tagstackidx].cur_match = cur_match; 		curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum; 	    } 	}     }      // When not using the current buffer get the name of buffer ""cur_fnum"".     // Makes sure that the tag order doesn't change when using a remembered     // position for ""cur_match"".     if (cur_fnum != curbuf->b_fnum)     { 	buf_T *buf = buflist_findnr(cur_fnum);  	if (buf != NULL) 	    buf_ffname = buf->b_ffname;     }      /*      * Repeat searching for tags, when a file has not been found.      */     for (;;)     { 	int	other_name; 	char_u	*name;  	/* 	 * When desired match not found yet, try to find it (and others). 	 */ 	if (use_tagstack) 	    name = tagstack[tagstackidx].tagname; #if defined(FEAT_QUICKFIX) 	else if (g_do_tagpreview != 0) 	    name = ptag_entry.tagname; #endif 	else 	    name = tag; 	other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0); 	if (new_tag 		|| (cur_match >= num_matches && max_num_matches != MAXCOL) 		|| other_name) 	{ 	    if (other_name) 	    { 		vim_free(tagmatchname); 		tagmatchname = vim_strsave(name); 	    }  	    if (type == DT_SELECT || type == DT_JUMP #if defined(FEAT_QUICKFIX) 		|| type == DT_LTAG #endif 		) 		cur_match = MAXCOL - 1; 	    if (type == DT_TAG) 		max_num_matches = MAXCOL; 	    else 		max_num_matches = cur_match + 1;  	    // when the argument starts with '/', use it as a regexp 	    if (!no_regexp && *name == '/') 	    { 		flags = TAG_REGEXP; 		++name; 	    } 	    else 		flags = TAG_NOIC;  #ifdef FEAT_CSCOPE 	    if (type == DT_CSCOPE) 		flags = TAG_CSCOPE; #endif 	    if (verbose) 		flags |= TAG_VERBOSE;  	    if (!use_tfu) 		flags |= TAG_NO_TAGFUNC;  	    if (find_tags(name, &new_num_matches, &new_matches, flags, 					    max_num_matches, buf_ffname) == OK 		    && new_num_matches < max_num_matches) 		max_num_matches = MAXCOL; // If less than max_num_matches 					  // found: all matches found.  	    // If there already were some matches for the same name, move them 	    // to the start.  Avoids that the order changes when using 	    // "":tnext"" and jumping to another file. 	    if (!new_tag && !other_name) 	    { 		int	    j, k; 		int	    idx = 0; 		tagptrs_T   tagp, tagp2;  		// Find the position of each old match in the new list.  Need 		// to use parse_match() to find the tag line. 		for (j = 0; j < num_matches; ++j) 		{ 		    parse_match(matches[j], &tagp); 		    for (i = idx; i < new_num_matches; ++i) 		    { 			parse_match(new_matches[i], &tagp2); 			if (STRCMP(tagp.tagname, tagp2.tagname) == 0) 			{ 			    char_u *p = new_matches[i]; 			    for (k = i; k > idx; --k) 				new_matches[k] = new_matches[k - 1]; 			    new_matches[idx++] = p; 			    break; 			} 		    } 		} 	    } 	    FreeWild(num_matches, matches); 	    num_matches = new_num_matches; 	    matches = new_matches; 	}  	if (num_matches <= 0) 	{ 	    if (verbose) 		semsg(_(e_tag_not_found_str), name); #if defined(FEAT_QUICKFIX) 	    g_do_tagpreview = 0; #endif 	} 	else 	{ 	    int ask_for_selection = FALSE;  #ifdef FEAT_CSCOPE 	    if (type == DT_CSCOPE && num_matches > 1) 	    { 		cs_print_tags(); 		ask_for_selection = TRUE; 	    } 	    else #endif 	    if (type == DT_TAG && *tag != NUL) 		// If a count is supplied to the "":tag <name>"" command, then 		// jump to count'th matching tag. 		cur_match = count > 0 ? count - 1 : 0; 	    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1)) 	    { 		print_tag_list(new_tag, use_tagstack, num_matches, matches); 		ask_for_selection = TRUE; 	    } #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL) 	    else if (type == DT_LTAG) 	    { 		if (add_llist_tags(tag, num_matches, matches) == FAIL) 		    goto end_do_tag; 		cur_match = 0;		// Jump to the first tag 	    } #endif  	    if (ask_for_selection == TRUE) 	    { 		/* 		 * Ask to select a tag from the list. 		 */ 		i = prompt_for_number(NULL); 		if (i <= 0 || i > num_matches || got_int) 		{ 		    // no valid choice: don't change anything 		    if (use_tagstack) 		    { 			tagstack[tagstackidx].fmark = saved_fmark; 			tagstackidx = prevtagstackidx; 		    } #ifdef FEAT_CSCOPE 		    cs_free_tags(); 		    jumped_to_tag = TRUE; #endif 		    break; 		} 		cur_match = i - 1; 	    }  	    if (cur_match >= num_matches) 	    { 		// Avoid giving this error when a file wasn't found and we're 		// looking for a match in another file, which wasn't found. 		// There will be an emsg(""file doesn't exist"") below then. 		if ((type == DT_NEXT || type == DT_FIRST) 						      && nofile_fname == NULL) 		{ 		    if (num_matches == 1) 			emsg(_(e_there_is_only_one_matching_tag)); 		    else 			emsg(_(e_cannot_go_beyond_last_matching_tag)); 		    skip_msg = TRUE; 		} 		cur_match = num_matches - 1; 	    } 	    if (use_tagstack) 	    { 		tagptrs_T   tagp;  		tagstack[tagstackidx].cur_match = cur_match; 		tagstack[tagstackidx].cur_fnum = cur_fnum;  		// store user-provided data originating from tagfunc 		if (use_tfu && parse_match(matches[cur_match], &tagp) == OK 			&& tagp.user_data) 		{ 		    VIM_CLEAR(tagstack[tagstackidx].user_data); 		    tagstack[tagstackidx].user_data = vim_strnsave( 			  tagp.user_data, tagp.user_data_end - tagp.user_data); 		}  		++tagstackidx; 	    } #if defined(FEAT_QUICKFIX) 	    else if (g_do_tagpreview != 0) 	    { 		ptag_entry.cur_match = cur_match; 		ptag_entry.cur_fnum = cur_fnum; 	    } #endif  	    /* 	     * Only when going to try the next match, report that the previous 	     * file didn't exist.  Otherwise an emsg() is given below. 	     */ 	    if (nofile_fname != NULL && error_cur_match != cur_match) 		smsg(_(""File \""%s\"" does not exist""), nofile_fname);   	    ic = (matches[cur_match][0] & MT_IC_OFF); 	    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP #ifdef FEAT_CSCOPE 		&& type != DT_CSCOPE #endif 		&& (num_matches > 1 || ic) 		&& !skip_msg) 	    { 		// Give an indication of the number of matching tags 		sprintf((char *)IObuff, _(""tag %d of %d%s""), 				cur_match + 1, 				num_matches, 				max_num_matches != MAXCOL ? _("" or more"") : """"); 		if (ic) 		    STRCAT(IObuff, _(""  Using tag with different case!"")); 		if ((num_matches > prev_num_matches || new_tag) 							   && num_matches > 1) 		{ 		    if (ic) 			msg_attr((char *)IObuff, HL_ATTR(HLF_W)); 		    else 			msg((char *)IObuff); 		    msg_scroll = TRUE;	// don't overwrite this message 		} 		else 		    give_warning(IObuff, ic); 		if (ic && !msg_scrolled && msg_silent == 0) 		{ 		    out_flush(); 		    ui_delay(1007L, TRUE); 		} 	    }  #if defined(FEAT_EVAL) 	    // Let the SwapExists event know what tag we are jumping to. 	    vim_snprintf((char *)IObuff, IOSIZE, "":ta %s\r"", name); 	    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1); #endif  	    /* 	     * Jump to the desired match. 	     */ 	    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);  #if defined(FEAT_EVAL) 	    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1); #endif  	    if (i == NOTAGFILE) 	    { 		// File not found: try again with another matching tag 		if ((type == DT_PREV && cur_match > 0) 			|| ((type == DT_TAG || type == DT_NEXT 							  || type == DT_FIRST) 			    && (max_num_matches != MAXCOL 					     || cur_match < num_matches - 1))) 		{ 		    error_cur_match = cur_match; 		    if (use_tagstack) 			--tagstackidx; 		    if (type == DT_PREV) 			--cur_match; 		    else 		    { 			type = DT_NEXT; 			++cur_match; 		    } 		    continue; 		} 		semsg(_(e_file_str_does_not_exist), nofile_fname); 	    } 	    else 	    { 		// We may have jumped to another window, check that 		// tagstackidx is still valid. 		if (use_tagstack && tagstackidx > curwin->w_tagstacklen) 		    tagstackidx = curwin->w_tagstackidx; #ifdef FEAT_CSCOPE 		jumped_to_tag = TRUE; #endif 	    } 	} 	break;     }  end_do_tag:     // Only store the new index when using the tagstack and it's valid.     if (use_tagstack && tagstackidx <= curwin->w_tagstacklen) 	curwin->w_tagstackidx = tagstackidx;     postponed_split = 0;	// don't split next time # ifdef FEAT_QUICKFIX     g_do_tagpreview = 0;	// don't do tag preview next time # endif  #ifdef FEAT_CSCOPE     return jumped_to_tag; #else     return FALSE; #endif }"
"204814_CWE-703.c","CWE-703","static void sixpack_close(struct tty_struct *tty) { 	struct sixpack *sp;  	write_lock_irq(&disc_data_lock); 	sp = tty->disc_data; 	tty->disc_data = NULL; 	write_unlock_irq(&disc_data_lock); 	if (!sp) 		return;  	/* 	 * We have now ensured that nobody can start using ap from now on, but 	 * we have to wait for all existing users to finish. 	 */ 	if (!refcount_dec_and_test(&sp->refcnt)) 		wait_for_completion(&sp->dead);  	/* We must stop the queue to avoid potentially scribbling 	 * on the free buffers. The sp->dead completion is not sufficient 	 * to protect us from sp->xbuff access. 	 */ 	netif_stop_queue(sp->dev);  	del_timer_sync(&sp->tx_t); 	del_timer_sync(&sp->resync_t);  	unregister_netdev(sp->dev);  	/* Free all 6pack frame buffers after unreg. */ 	kfree(sp->rbuff); 	kfree(sp->xbuff);  	free_netdev(sp->dev); }"
"204830_CWE-200.c","CWE-200","struct vfsmount *clone_private_mount(const struct path *path) { 	struct mount *old_mnt = real_mount(path->mnt); 	struct mount *new_mnt;  	if (IS_MNT_UNBINDABLE(old_mnt)) 		return ERR_PTR(-EINVAL);  	new_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE); 	if (IS_ERR(new_mnt)) 		return ERR_CAST(new_mnt);  	/* Longterm mount to be removed by kern_unmount*() */ 	new_mnt->mnt_ns = MNT_NS_INTERNAL;  	return &new_mnt->mnt; }"
"205570_CWE-125.c","CWE-125","RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) { 	RList *segments = bin->segments; 	if (!segments) { 		return NULL; 	} 	RList *entries = bin->entries; 	if (!entries) { 		return NULL; 	} 	RList *symbols = bin->symbols; 	if (!symbols) { 		return NULL; 	}  	ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16)); 	if (!modref) { 		return NULL; 	} 	r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));  	RList *relocs = r_list_newf (free); 	if (!relocs) { 		free (modref); 		return NULL; 	}  	RListIter *it; 	RBinSection *seg; 	int index = -1; 	r_list_foreach (segments, it, seg) { 		index++; 		if (!(bin->segment_entries[index].flags & RELOCINFO)) { 			continue; 		} 		ut32 off = seg->paddr + seg->size; 		ut32 start = off; 		ut16 length = r_buf_read_le16_at (bin->buf, off); 		if (!length) { 			continue; 		} 		off += 2; 		// size_t buf_size = r_buf_size (bin->buf); 		while (off < start + length * sizeof (NE_image_reloc_item)) { 			// && off + sizeof (NE_image_reloc_item) < buf_size) 			NE_image_reloc_item rel = {0}; 			if (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) { 				return NULL; 			} 			RBinReloc *reloc = R_NEW0 (RBinReloc); 			if (!reloc) { 				return NULL; 			} 			reloc->paddr = seg->paddr + rel.offset; 			switch (rel.type) { 			case LOBYTE: 				reloc->type = R_BIN_RELOC_8; 				break; 			case SEL_16: 			case OFF_16: 				reloc->type = R_BIN_RELOC_16; 				break; 			case POI_32: 			case OFF_32: 				reloc->type = R_BIN_RELOC_32; 				break; 			case POI_48: 				reloc->type = R_BIN_RELOC_64; 				break; 			} 			 			ut32 offset; 			if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) { 				RBinImport *imp = R_NEW0 (RBinImport); 				if (!imp) { 					free (reloc); 					break; 				} 				char *name; #if NE_BUG 				if (rel.index > 0 && rel.index < bin->ne_header->ModRefs) { 					offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; 					name = __read_nonnull_str_at (bin->buf, offset); 				} else { 					name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ???? 				} #else 				if (rel.index > bin->ne_header->ModRefs) { 					name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ???? 				} else { 					offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; 					name = __read_nonnull_str_at (bin->buf, offset); 				} #endif 				if (rel.flags & IMPORTED_ORD) { 					imp->ordinal = rel.func_ord; 					imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord)); 				} else { 					offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off; 					char *func = __read_nonnull_str_at (bin->buf, offset); 					imp->name = r_str_newf (""%s.%s"", name, func); 					free (func); 				} 				free (name); 				reloc->import = imp; 			} else if (rel.flags & OSFIXUP) { 				// TODO 			} else { 				if (strstr (seg->name, ""FIXED"")) { 					RBinSection *s = r_list_get_n (segments, rel.segnum - 1); 					if (s) { 						offset = s->paddr + rel.segoff; 					} else { 						offset = -1; 					} 				} else { 					RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1); 					if (entry) { 						offset = entry->paddr; 					} else { 						offset = -1; 					} 				} 				reloc->addend = offset; 				RBinSymbol *sym = NULL; 				RListIter *sit; 				r_list_foreach (symbols, sit, sym) { 					if (sym->paddr == reloc->addend) { 						reloc->symbol = sym; 						break; 					} 				} 			}  			if (rel.flags & ADDITIVE) { 				reloc->additive = 1; 				r_list_append (relocs, reloc); 			} else { 				do { #if NE_BUG 					if (reloc->paddr + 4 < r_buf_size (bin->buf)) { 						break; 					} #endif 					r_list_append (relocs, reloc); 					offset = r_buf_read_le16_at (bin->buf, reloc->paddr); 					RBinReloc *tmp = reloc; 					reloc = R_NEW0 (RBinReloc); 					if (!reloc) { 						break; 					} 					*reloc = *tmp; 					reloc->paddr = seg->paddr + offset; 				} while (offset != 0xFFFF); 				free (reloc); 			}  			off += sizeof (NE_image_reloc_item); 		} 	} 	free (modref); 	return relocs; }"
"205630_CWE-94.c","CWE-94","static int io_rw_init_file(struct io_kiocb *req, fmode_t mode) { 	struct kiocb *kiocb = &req->rw.kiocb; 	struct io_ring_ctx *ctx = req->ctx; 	struct file *file = req->file; 	int ret;  	if (unlikely(!file || !(file->f_mode & mode))) 		return -EBADF;  	if (!io_req_ffs_set(req)) 		req->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;  	kiocb->ki_flags = iocb_flags(file); 	ret = kiocb_set_rw_flags(kiocb, req->rw.flags); 	if (unlikely(ret)) 		return ret;  	/* 	 * If the file is marked O_NONBLOCK, still allow retry for it if it 	 * supports async. Otherwise it's impossible to use O_NONBLOCK files 	 * reliably. If not, or it IOCB_NOWAIT is set, don't retry. 	 */ 	if ((kiocb->ki_flags & IOCB_NOWAIT) || 	    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req))) 		req->flags |= REQ_F_NOWAIT;  	if (ctx->flags & IORING_SETUP_IOPOLL) { 		if (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll) 			return -EOPNOTSUPP;  		kiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE; 		kiocb->ki_complete = io_complete_rw_iopoll; 		req->iopoll_completed = 0; 	} else { 		if (kiocb->ki_flags & IOCB_HIPRI) 			return -EINVAL; 		kiocb->ki_complete = io_complete_rw; 	}  	return 0; }"
"205734_CWE-787.c","CWE-787","static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) { 	pyc_object *ret = NULL; 	bool error = false; 	ut32 size = 0; 	ut32 n1 = 0; 	ut32 n2 = 0;  	ret = RZ_NEW0(pyc_object); 	if (!ret) { 		return NULL; 	}  	if ((pyc->magic_int & 0xffff) <= 62061) { 		n1 = get_ut8(buffer, &error); 	} else { 		n1 = get_st32(buffer, &error); 	} 	if (error) { 		free(ret); 		return NULL; 	} 	ut8 *s1 = malloc(n1 + 1); 	if (!s1) { 		return NULL; 	} 	/* object contain string representation of the number */ 	size = rz_buf_read(buffer, s1, n1); 	if (size != n1) { 		RZ_FREE(s1); 		RZ_FREE(ret); 		return NULL; 	} 	s1[n1] = '\0';  	if ((pyc->magic_int & 0xffff) <= 62061) { 		n2 = get_ut8(buffer, &error); 	} else 		n2 = get_st32(buffer, &error); 	if (error) { 		return NULL; 	} 	ut8 *s2 = malloc(n2 + 1); 	if (!s2) { 		return NULL; 	} 	/* object contain string representation of the number */ 	size = rz_buf_read(buffer, s2, n2); 	if (size != n2) { 		RZ_FREE(s1); 		RZ_FREE(s2); 		RZ_FREE(ret); 		return NULL; 	} 	s2[n2] = '\0';  	ret->type = TYPE_COMPLEX; 	ret->data = rz_str_newf(""%s+%sj"", s1, s2); 	RZ_FREE(s1); 	RZ_FREE(s2); 	if (!ret->data) { 		RZ_FREE(ret); 		return NULL; 	} 	return ret; }"
"205736_CWE-834.h","CWE-834","static inline void fuse_make_bad(struct inode *inode) { 	set_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state); }"
"205747_CWE-416.c","CWE-416","static void sixpack_close(struct tty_struct *tty) { 	struct sixpack *sp;  	write_lock_irq(&disc_data_lock); 	sp = tty->disc_data; 	tty->disc_data = NULL; 	write_unlock_irq(&disc_data_lock); 	if (!sp) 		return;  	/* 	 * We have now ensured that nobody can start using ap from now on, but 	 * we have to wait for all existing users to finish. 	 */ 	if (!refcount_dec_and_test(&sp->refcnt)) 		wait_for_completion(&sp->dead);  	/* We must stop the queue to avoid potentially scribbling 	 * on the free buffers. The sp->dead completion is not sufficient 	 * to protect us from sp->xbuff access. 	 */ 	netif_stop_queue(sp->dev);  	del_timer_sync(&sp->tx_t); 	del_timer_sync(&sp->resync_t);  	/* Free all 6pack frame buffers. */ 	kfree(sp->rbuff); 	kfree(sp->xbuff);  	unregister_netdev(sp->dev); }"
"205806_CWE-269.c","CWE-269","void sdb_edit(procinfo *pi) {   char * filename = omStrDup(""/tmp/sd000000"");   sprintf(filename+7,""%d"",getpid());   FILE *fp=fopen(filename,""w"");   if (fp==NULL)   {     Print(""cannot open %s\n"",filename);     omFree(filename);     return;   }   if (pi->language!= LANG_SINGULAR)   {     Print(""cannot edit type %d\n"",pi->language);     fclose(fp);     fp=NULL;   }   else   {     const char *editor=getenv(""EDITOR"");     if (editor==NULL)       editor=getenv(""VISUAL"");     if (editor==NULL)       editor=""vi"";     editor=omStrDup(editor);      if (pi->data.s.body==NULL)     {       iiGetLibProcBuffer(pi);       if (pi->data.s.body==NULL)       {         PrintS(""cannot get the procedure body\n"");         fclose(fp);         si_unlink(filename);         omFree(filename);         return;       }     }      fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);     fclose(fp);      int pid=fork();     if (pid!=0)     {       si_wait(&pid);     }     else if(pid==0)     {       if (strchr(editor,' ')==NULL)       {         execlp(editor,editor,filename,NULL);         Print(""cannot exec %s\n"",editor);       }       else       {         char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);         sprintf(p,""%s %s"",editor,filename);         system(p);       }       exit(0);     }     else     {       PrintS(""cannot fork\n"");     }      fp=fopen(filename,""r"");     if (fp==NULL)     {       Print(""cannot read from %s\n"",filename);     }     else     {       fseek(fp,0L,SEEK_END);       long len=ftell(fp);       fseek(fp,0L,SEEK_SET);        omFree((ADDRESS)pi->data.s.body);       pi->data.s.body=(char *)omAlloc((int)len+1);       myfread( pi->data.s.body, len, 1, fp);       pi->data.s.body[len]='\0';       fclose(fp);     }   }   si_unlink(filename);   omFree(filename); }"
"205823_CWE-401.c","CWE-401","ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,                              ovs_be16 dl_type, uint16_t zone, long long now,                              uint32_t hash_basis) {     const size_t pb_cnt = dp_packet_batch_size(pb);     int pb_idx; /* Index in a packet batch. */     struct dp_packet *pkt;      DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {         if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&                           ipf_is_valid_v4_frag(ipf, pkt))                           ||                           (dl_type == htons(ETH_TYPE_IPV6) &&                           ipf_is_valid_v6_frag(ipf, pkt)))) {              ovs_mutex_lock(&ipf->ipf_lock);             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {                 dp_packet_batch_refill(pb, pkt, pb_idx);             }             ovs_mutex_unlock(&ipf->ipf_lock);         } else {             dp_packet_batch_refill(pb, pkt, pb_idx);         }     } }"
"205838_CWE-122.c","CWE-122","get_one_sourceline(source_cookie_T *sp) {     garray_T		ga;     int			len;     int			c;     char_u		*buf; #ifdef USE_CRNL     int			has_cr;		// CR-LF found #endif     int			have_read = FALSE;      // use a growarray to store the sourced line     ga_init2(&ga, 1, 250);      // Loop until there is a finished line (or end-of-file).     ++sp->sourcing_lnum;     for (;;)     { 	// make room to read at least 120 (more) characters 	if (ga_grow(&ga, 120) == FAIL) 	    break; 	if (sp->source_from_buf) 	{ 	    if (sp->buf_lnum >= sp->buflines.ga_len) 		break;		    // all the lines are processed 	    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]); 	    sp->buf_lnum++; 	    buf = (char_u *)ga.ga_data; 	} 	else 	{ 	    buf = (char_u *)ga.ga_data; 	    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len, 			sp->fp) == NULL) 		break; 	} 	len = ga.ga_len + (int)STRLEN(buf + ga.ga_len); #ifdef USE_CRNL 	// Ignore a trailing CTRL-Z, when in Dos mode.	Only recognize the 	// CTRL-Z by its own, or after a NL. 	if (	   (len == 1 || (len >= 2 && buf[len - 2] == '\n')) 		&& sp->fileformat == EOL_DOS 		&& buf[len - 1] == Ctrl_Z) 	{ 	    buf[len - 1] = NUL; 	    break; 	} #endif  	have_read = TRUE; 	ga.ga_len = len;  	// If the line was longer than the buffer, read more. 	if (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\n') 	    continue;  	if (len >= 1 && buf[len - 1] == '\n')	// remove trailing NL 	{ #ifdef USE_CRNL 	    has_cr = (len >= 2 && buf[len - 2] == '\r'); 	    if (sp->fileformat == EOL_UNKNOWN) 	    { 		if (has_cr) 		    sp->fileformat = EOL_DOS; 		else 		    sp->fileformat = EOL_UNIX; 	    }  	    if (sp->fileformat == EOL_DOS) 	    { 		if (has_cr)	    // replace trailing CR 		{ 		    buf[len - 2] = '\n'; 		    --len; 		    --ga.ga_len; 		} 		else	    // lines like "":map xx yy^M"" will have failed 		{ 		    if (!sp->error) 		    { 			msg_source(HL_ATTR(HLF_W)); 			emsg(_(""W15: Warning: Wrong line separator, ^M may be missing"")); 		    } 		    sp->error = TRUE; 		    sp->fileformat = EOL_UNIX; 		} 	    } #endif 	    // The '\n' is escaped if there is an odd number of ^V's just 	    // before it, first set ""c"" just before the 'V's and then check 	    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo 	    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--) 		; 	    if ((len & 1) != (c & 1))	// escaped NL, read more 	    { 		++sp->sourcing_lnum; 		continue; 	    }  	    buf[len - 1] = NUL;		// remove the NL 	}  	// Check for ^C here now and then, so recursive :so can be broken. 	line_breakcheck(); 	break;     }      if (have_read) 	return (char_u *)ga.ga_data;      vim_free(ga.ga_data);     return NULL; }"
"205870_CWE-476.c","CWE-476","static RList *symbols(RBinFile *bf) { 	RList *res = r_list_newf ((RListFree)r_bin_symbol_free); 	r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res); 	RCoreSymCacheElement *element = bf->o->bin_obj; 	size_t i; 	HtUU *hash = ht_uu_new0 (); 	if (!hash) { 		return res; 	} 	bool found = false; 	for (i = 0; i < element->hdr->n_lined_symbols; i++) { 		RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i]; 		ht_uu_find (hash, sym->paddr, &found); 		if (found) { 			continue; 		} 		RBinSymbol *s = bin_symbol_from_symbol (element, sym); 		if (s) { 			r_list_append (res, s); 			ht_uu_insert (hash, sym->paddr, 1); 		} 	} 	if (element->symbols) { 		for (i = 0; i < element->hdr->n_symbols; i++) { 			RCoreSymCacheElementSymbol *sym = &element->symbols[i]; 			ht_uu_find (hash, sym->paddr, &found); 			if (found) { 				continue; 			} 			RBinSymbol *s = bin_symbol_from_symbol (element, sym); 			if (s) { 				r_list_append (res, s); 			} 		} 	} 	ht_uu_free (hash); 	return res; }"
"206025_CWE-200.c","CWE-200","gpg_ctx_add_recipient (struct _GpgCtx *gpg,                        const gchar *keyid) { 	if (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT) 		return;  	if (!gpg->recipients) 		gpg->recipients = g_ptr_array_new ();  	g_ptr_array_add (gpg->recipients, g_strdup (keyid)); }"
"206043_CWE-125.c","CWE-125","load_image (const gchar  *filename,             GError      **error) {   gchar             *name;   gint               fd;   BrushHeader        bh;   guchar            *brush_buf = NULL;   gint32             image_ID;   gint32             layer_ID;   GimpParasite      *parasite;   GimpDrawable      *drawable;   GimpPixelRgn       pixel_rgn;   gint               bn_size;   GimpImageBaseType  base_type;   GimpImageType      image_type;   gsize              size;    fd = g_open (filename, O_RDONLY | _O_BINARY, 0);    if (fd == -1)     {       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),                    _(""Could not open '%s' for reading: %s""),                    gimp_filename_to_utf8 (filename), g_strerror (errno));       return -1;     }    gimp_progress_init_printf (_(""Opening '%s'""),                              gimp_filename_to_utf8 (filename));    if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))     {       close (fd);       return -1;     }    /*  rearrange the bytes in each unsigned int  */   bh.header_size  = g_ntohl (bh.header_size);   bh.version      = g_ntohl (bh.version);   bh.width        = g_ntohl (bh.width);   bh.height       = g_ntohl (bh.height);   bh.bytes        = g_ntohl (bh.bytes);   bh.magic_number = g_ntohl (bh.magic_number);   bh.spacing      = g_ntohl (bh.spacing);    /* Sanitize values */   if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||       (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||       ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&        (bh.bytes != 18)) ||       (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))     {       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,                    _(""Invalid header data in '%s': width=%lu, height=%lu, ""                      ""bytes=%lu""), gimp_filename_to_utf8 (filename),                    (unsigned long int)bh.width, (unsigned long int)bh.height,                    (unsigned long int)bh.bytes);       return -1;     }    switch (bh.version)     {     case 1:       /* Version 1 didn't have a magic number and had no spacing  */       bh.spacing = 25;       /* And we need to rewind the handle, 4 due spacing and 4 due magic */       lseek (fd, -8, SEEK_CUR);       bh.header_size += 8;       break;      case 3: /*  cinepaint brush  */       if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)         {           bh.bytes = 2;         }       else         {           g_message (_(""Unsupported brush format""));           close (fd);           return -1;         }       /*  fallthrough  */      case 2:       if (bh.magic_number == GBRUSH_MAGIC &&           bh.header_size  >  sizeof (BrushHeader))         break;      default:       g_message (_(""Unsupported brush format""));       close (fd);       return -1;     }    if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)     {       gchar *temp = g_new (gchar, bn_size);        if ((read (fd, temp, bn_size)) < bn_size)         {           g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,                        _(""Error in GIMP brush file '%s'""),                        gimp_filename_to_utf8 (filename));           close (fd);           g_free (temp);           return -1;         }        name = gimp_any_to_utf8 (temp, -1,                                _(""Invalid UTF-8 string in brush file '%s'.""),                                gimp_filename_to_utf8 (filename));       g_free (temp);     }   else     {       name = g_strdup (_(""Unnamed""));     }    /* Now there's just raw data left. */    size = bh.width * bh.height * bh.bytes;   brush_buf = g_malloc (size);    if (read (fd, brush_buf, size) != size)     {       close (fd);       g_free (brush_buf);       g_free (name);       return -1;     }    switch (bh.bytes)     {     case 1:       {         PatternHeader ph;          /*  For backwards-compatibility, check if a pattern follows.             The obsolete .gpb format did it this way.  */          if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))           {             /*  rearrange the bytes in each unsigned int  */             ph.header_size  = g_ntohl (ph.header_size);             ph.version      = g_ntohl (ph.version);             ph.width        = g_ntohl (ph.width);             ph.height       = g_ntohl (ph.height);             ph.bytes        = g_ntohl (ph.bytes);             ph.magic_number = g_ntohl (ph.magic_number);              if (ph.magic_number == GPATTERN_MAGIC        &&                 ph.version      == 1                     &&                 ph.header_size  > sizeof (PatternHeader) &&                 ph.bytes        == 3                     &&                 ph.width        == bh.width              &&                 ph.height       == bh.height             &&                 lseek (fd, ph.header_size - sizeof (PatternHeader),                        SEEK_CUR) > 0)               {                 guchar *plain_brush = brush_buf;                 gint    i;                  bh.bytes = 4;                 brush_buf = g_malloc (4 * bh.width * bh.height);                  for (i = 0; i < ph.width * ph.height; i++)                   {                     if (read (fd, brush_buf + i * 4, 3) != 3)                       {                         close (fd);                         g_free (name);                         g_free (plain_brush);                         g_free (brush_buf);                         return -1;                       }                     brush_buf[i * 4 + 3] = plain_brush[i];                   }                 g_free (plain_brush);               }           }       }       break;      case 2:       {         guint16 *buf = (guint16 *) brush_buf;         gint     i;          for (i = 0; i < bh.width * bh.height; i++, buf++)           {             union             {               guint16 u[2];               gfloat  f;             } short_float;  #if G_BYTE_ORDER == G_LITTLE_ENDIAN             short_float.u[0] = 0;             short_float.u[1] = GUINT16_FROM_BE (*buf); #else             short_float.u[0] = GUINT16_FROM_BE (*buf);             short_float.u[1] = 0; #endif              brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);           }          bh.bytes = 1;       }       break;      default:       break;     }    /*    * Create a new image of the proper size and    * associate the filename with it.    */    switch (bh.bytes)     {     case 1:       base_type = GIMP_GRAY;       image_type = GIMP_GRAY_IMAGE;       break;      case 4:       base_type = GIMP_RGB;       image_type = GIMP_RGBA_IMAGE;       break;      default:       g_message (""Unsupported brush depth: %d\n""                  ""GIMP Brushes must be GRAY or RGBA\n"",                  bh.bytes);       g_free (name);       return -1;     }    image_ID = gimp_image_new (bh.width, bh.height, base_type);   gimp_image_set_filename (image_ID, filename);    parasite = gimp_parasite_new (""gimp-brush-name"",                                 GIMP_PARASITE_PERSISTENT,                                 strlen (name) + 1, name);   gimp_image_attach_parasite (image_ID, parasite);   gimp_parasite_free (parasite);    layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,                              image_type, 100, GIMP_NORMAL_MODE);   gimp_image_insert_layer (image_ID, layer_ID, -1, 0);    g_free (name);    drawable = gimp_drawable_get (layer_ID);   gimp_pixel_rgn_init (&pixel_rgn, drawable,                        0, 0, drawable->width, drawable->height,                        TRUE, FALSE);    gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,                            0, 0, bh.width, bh.height);   g_free (brush_buf);    if (image_type == GIMP_GRAY_IMAGE)     gimp_invert (layer_ID);    close (fd);    gimp_drawable_flush (drawable);   gimp_progress_update (1.0);    return image_ID; }"
"206044_CWE-672.cpp","CWE-672","void ZRLE_DECODE (const Rect& r, rdr::InStream* is,                   rdr::ZlibInStream* zis,                   const PixelFormat& pf, ModifiablePixelBuffer* pb) {   int length = is->readU32();   zis->setUnderlying(is, length);   Rect t;   PIXEL_T buf[64 * 64];    for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {      t.br.y = __rfbmin(r.br.y, t.tl.y + 64);      for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {        t.br.x = __rfbmin(r.br.x, t.tl.x + 64);        int mode = zis->readU8();       bool rle = mode & 128;       int palSize = mode & 127;       PIXEL_T palette[128];        for (int i = 0; i < palSize; i++) {         palette[i] = READ_PIXEL(zis);       }        if (palSize == 1) {         PIXEL_T pix = palette[0];         pb->fillRect(pf, t, &pix);         continue;       }        if (!rle) {         if (palSize == 0) {            // raw  #ifdef CPIXEL           for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {             *ptr = READ_PIXEL(zis);           } #else           zis->readBytes(buf, t.area() * (BPP / 8)); #endif          } else {            // packed pixels           int bppp = ((palSize > 16) ? 8 :                       ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));            PIXEL_T* ptr = buf;            for (int i = 0; i < t.height(); i++) {             PIXEL_T* eol = ptr + t.width();             rdr::U8 byte = 0;             rdr::U8 nbits = 0;              while (ptr < eol) {               if (nbits == 0) {                 byte = zis->readU8();                 nbits = 8;               }               nbits -= bppp;               rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;               *ptr++ = palette[index];             }           }         }        } else {          if (palSize == 0) {            // plain RLE            PIXEL_T* ptr = buf;           PIXEL_T* end = ptr + t.area();           while (ptr < end) {             PIXEL_T pix = READ_PIXEL(zis);             int len = 1;             int b;             do {               b = zis->readU8();               len += b;             } while (b == 255);              if (end - ptr < len) {               throw Exception (""ZRLE decode error"");             }              while (len-- > 0) *ptr++ = pix;            }         } else {            // palette RLE            PIXEL_T* ptr = buf;           PIXEL_T* end = ptr + t.area();           while (ptr < end) {             int index = zis->readU8();             int len = 1;             if (index & 128) {               int b;               do {                 b = zis->readU8();                 len += b;               } while (b == 255);                if (end - ptr < len) {                 throw Exception (""ZRLE decode error"");               }             }              index &= 127;              PIXEL_T pix = palette[index];              while (len-- > 0) *ptr++ = pix;           }         }       }        pb->imageRect(pf, t, buf);     }   }    zis->removeUnderlying(); }"
"206123_CWE-787.c","CWE-787","RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) { 	RCoreSymCacheElement *result = NULL; 	ut8 *b = NULL; 	RCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits); 	if (!hdr) { 		return NULL; 	} 	if (hdr->version != 1) { 		eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", hdr->version); 		goto beach; 	} 	if (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) { 		eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", hdr->size); 		goto beach; 	} 	result = R_NEW0 (RCoreSymCacheElement); 	if (!result) { 		goto beach; 	} 	result->hdr = hdr; 	b = malloc (hdr->size); 	if (!b) { 		goto beach; 	} 	if (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) { 		goto beach; 	} 	ut8 *end = b + hdr->size; 	if (file_name) { 		result->file_name = file_name; 	} else if (hdr->file_name_off) { 		result->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end); 	} 	if (hdr->version_off) { 		result->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end); 	} 	const size_t word_size = bits / 8; 	const ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS; 	const ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64; 	const ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size; 	const ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM; 	const ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM; 	const ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO; 	const ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;  	ut64 page_zero_size = 0; 	size_t page_zero_idx = 0; 	if (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) { 		goto beach; 	} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) { 		goto beach; 	} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) { 		goto beach; 	} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) { 		goto beach; 	} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) { 		goto beach; 	} 	if (hdr->n_segments > 0) { 		result->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments); 		if (!result->segments) { 			goto beach; 		} 		size_t i; 		ut8 *cursor = b + R_CS_EL_OFF_SEGS; 		for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) { 			RCoreSymCacheElementSegment *seg = &result->segments[i]; 			seg->paddr = seg->vaddr = r_read_le64 (cursor); 			cursor += 8; 			if (cursor >= end) { 				break; 			} 			seg->size = seg->vsize = r_read_le64 (cursor); 			cursor += 8; 			if (cursor >= end) { 				break; 			} 			seg->name = str_dup_safe_fixed (b, cursor, 16, end); 			cursor += 16; 			if (!seg->name) { 				continue; 			}  			if (!strcmp (seg->name, ""__PAGEZERO"")) { 				page_zero_size = seg->size; 				page_zero_idx = i; 				seg->paddr = seg->vaddr = 0; 				seg->size = 0; 			} 		} 		for (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) { 			if (i == page_zero_idx) { 				continue; 			} 			RCoreSymCacheElementSegment *seg = &result->segments[i]; 			if (seg->vaddr < page_zero_size) { 				seg->vaddr += page_zero_size; 			} 		} 	} 	bool relative_to_strings = false; 	ut8* string_origin; 	if (hdr->n_sections > 0) { 		result->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections); 		if (!result->sections) { 			goto beach; 		} 		size_t i; 		ut8 *cursor = b + start_of_sections; 		for (i = 0; i < hdr->n_sections && cursor < end; i++) { 			ut8 *sect_start = cursor; 			RCoreSymCacheElementSection *sect = &result->sections[i]; 			sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits); 			if (sect->vaddr < page_zero_size) { 				sect->vaddr += page_zero_size; 			} 			cursor += word_size; 			if (cursor >= end) { 				break; 			} 			sect->size = r_read_ble (cursor, false, bits); 			cursor += word_size; 			if (cursor >= end) { 				break; 			} 			ut64 sect_name_off = r_read_ble (cursor, false, bits); 			if (!i && !sect_name_off) { 				relative_to_strings = true; 			} 			cursor += word_size; 			if (bits == 32) { 				cursor += word_size; 			} 			string_origin = relative_to_strings? b + start_of_strings : sect_start; 			sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end); 		} 	} 	if (hdr->n_symbols) { 		result->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols); 		if (!result->symbols) { 			goto beach; 		} 		size_t i; 		ut8 *cursor = b + start_of_symbols; 		for (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) { 			RCoreSymCacheElementSymbol *sym = &result->symbols[i]; 			sym->paddr = r_read_le32 (cursor); 			sym->size = r_read_le32 (cursor + 0x4); 			sym->unk1 = r_read_le32 (cursor + 0x8); 			size_t name_off = r_read_le32 (cursor + 0xc); 			size_t mangled_name_off = r_read_le32 (cursor + 0x10); 			sym->unk2 = (st32)r_read_le32 (cursor + 0x14); 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			sym->name = str_dup_safe (b, string_origin + name_off, end); 			if (!sym->name) { 				cursor += R_CS_EL_SIZE_SYM; 				continue; 			} 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			sym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end); 			if (!sym->mangled_name) { 				cursor += R_CS_EL_SIZE_SYM; 				continue; 			} 			cursor += R_CS_EL_SIZE_SYM; 		} 	} 	if (hdr->n_lined_symbols) { 		result->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols); 		if (!result->lined_symbols) { 			goto beach; 		} 		size_t i; 		ut8 *cursor = b + start_of_lined_symbols; 		for (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) { 			RCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i]; 			lsym->sym.paddr = r_read_le32 (cursor); 			lsym->sym.size = r_read_le32 (cursor + 0x4); 			lsym->sym.unk1 = r_read_le32 (cursor + 0x8); 			size_t name_off = r_read_le32 (cursor + 0xc); 			size_t mangled_name_off = r_read_le32 (cursor + 0x10); 			lsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14); 			size_t file_name_off = r_read_le32 (cursor + 0x18); 			lsym->flc.line = r_read_le32 (cursor + 0x1c); 			lsym->flc.col = r_read_le32 (cursor + 0x20); 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			lsym->sym.name = str_dup_safe (b, string_origin + name_off, end); 			if (!lsym->sym.name) { 				cursor += R_CS_EL_SIZE_LSYM; 				continue; 			} 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			lsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end); 			if (!lsym->sym.mangled_name) { 				cursor += R_CS_EL_SIZE_LSYM; 				continue; 			} 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end); 			if (!lsym->flc.file) { 				cursor += R_CS_EL_SIZE_LSYM; 				continue; 			} 			cursor += R_CS_EL_SIZE_LSYM; 			meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc); 		} 	} 	if (hdr->n_line_info) { 		result->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info); 		if (!result->line_info) { 			goto beach; 		} 		size_t i; 		ut8 *cursor = b + start_of_line_info; 		for (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) { 			RCoreSymCacheElementLineInfo *info = &result->line_info[i]; 			info->paddr = r_read_le32 (cursor); 			info->size = r_read_le32 (cursor + 4); 			size_t file_name_off = r_read_le32 (cursor + 8); 			info->flc.line = r_read_le32 (cursor + 0xc); 			info->flc.col = r_read_le32 (cursor + 0x10); 			string_origin = relative_to_strings? b + start_of_strings : cursor; 			info->flc.file = str_dup_safe (b, string_origin + file_name_off, end); 			if (!info->flc.file) { 				break; 			} 			cursor += R_CS_EL_SIZE_LINFO; 			meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc); 		} 	}  	/* 	 * TODO: 	 * Figure out the meaning of the 2 arrays of hdr->n_symbols 	 * 32-bit integers located at the end of line info. 	 * Those are the last info before the strings at the end. 	 */  beach: 	free (b); 	return result; }"
"206210_CWE-122.cpp","CWE-122","parse_command_modifiers( 	exarg_T	    *eap, 	char	    **errormsg, 	cmdmod_T    *cmod, 	int	    skip_only) {     char_u  *cmd_start = NULL;     char_u  *p;     int	    starts_with_colon = FALSE;     int	    vim9script = in_vim9script();     int	    has_visual_range = FALSE;      CLEAR_POINTER(cmod);     cmod->cmod_flags = sticky_cmdmod_flags;      if (STRNCMP(eap->cmd, ""'<,'>"", 5) == 0)     { 	// The automatically inserted Visual area range is skipped, so that 	// typing "":cmdmod cmd"" in Visual mode works without having to move the 	// range to after the modififiers. 	eap->cmd += 5; 	cmd_start = eap->cmd; 	has_visual_range = TRUE;     }      // Repeat until no more command modifiers are found.     for (;;)     { 	while (*eap->cmd == ' ' || *eap->cmd == '\t' || *eap->cmd == ':') 	{ 	    if (*eap->cmd == ':') 		starts_with_colon = TRUE; 	    ++eap->cmd; 	}  	// in ex mode, an empty line works like :+ 	if (*eap->cmd == NUL && exmode_active 		   && (getline_equal(eap->getline, eap->cookie, getexmodeline) 		       || getline_equal(eap->getline, eap->cookie, getexline)) 			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) 	{ 	    eap->cmd = (char_u *)""+""; 	    if (!skip_only) 		ex_pressedreturn = TRUE; 	}  	// ignore comment and empty lines 	if (comment_start(eap->cmd, starts_with_colon)) 	{ 	    // a comment ends at a NL 	    if (eap->nextcmd == NULL) 	    { 		eap->nextcmd = vim_strchr(eap->cmd, '\n'); 		if (eap->nextcmd != NULL) 		    ++eap->nextcmd; 	    } 	    if (vim9script && has_cmdmod(cmod, FALSE)) 		*errormsg = _(e_command_modifier_without_command); 	    return FAIL; 	} 	if (*eap->cmd == NUL) 	{ 	    if (!skip_only) 	    { 		ex_pressedreturn = TRUE; 		if (vim9script && has_cmdmod(cmod, FALSE)) 		    *errormsg = _(e_command_modifier_without_command); 	    } 	    return FAIL; 	}  	p = skip_range(eap->cmd, TRUE, NULL);  	// In Vim9 script a variable can shadow a command modifier: 	//   verbose = 123 	//   verbose += 123 	//   silent! verbose = func() 	//   verbose.member = 2 	//   verbose[expr] = 2 	// But not: 	//   verbose [a, b] = list 	if (vim9script) 	{ 	    char_u *s, *n;  	    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s) 		; 	    n = skipwhite(s); 	    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=') 		    || *s == '[') 		break; 	}  	switch (*p) 	{ 	    // When adding an entry, also modify cmd_exists(). 	    case 'a':	if (!checkforcmd_noparen(&eap->cmd, ""aboveleft"", 3)) 			    break; 			cmod->cmod_split |= WSP_ABOVE; 			continue;  	    case 'b':	if (checkforcmd_noparen(&eap->cmd, ""belowright"", 3)) 			{ 			    cmod->cmod_split |= WSP_BELOW; 			    continue; 			} 			if (checkforcmd_opt(&eap->cmd, ""browse"", 3, TRUE)) 			{ #ifdef FEAT_BROWSE_CMD 			    cmod->cmod_flags |= CMOD_BROWSE; #endif 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""botright"", 2)) 			    break; 			cmod->cmod_split |= WSP_BOT; 			continue;  	    case 'c':	if (!checkforcmd_opt(&eap->cmd, ""confirm"", 4, TRUE)) 			    break; #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) 			cmod->cmod_flags |= CMOD_CONFIRM; #endif 			continue;  	    case 'k':	if (checkforcmd_noparen(&eap->cmd, ""keepmarks"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPMARKS; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""keepalt"", 5)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPALT; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""keeppatterns"", 5)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPPATTERNS; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""keepjumps"", 5)) 			    break; 			cmod->cmod_flags |= CMOD_KEEPJUMPS; 			continue;  	    case 'f':	// only accept "":filter {pat} cmd"" 			{ 			    char_u  *reg_pat; 			    char_u  *nulp = NULL; 			    int	    c = 0;  			    if (!checkforcmd_noparen(&p, ""filter"", 4) 				    || *p == NUL 				    || (ends_excmd(*p) #ifdef FEAT_EVAL 					// in "":filter #pat# cmd"" # does not 					// start a comment 				     && (!vim9script || VIM_ISWHITE(p[1])) #endif 				     )) 				break; 			    if (*p == '!') 			    { 				cmod->cmod_filter_force = TRUE; 				p = skipwhite(p + 1); 				if (*p == NUL || ends_excmd(*p)) 				    break; 			    } #ifdef FEAT_EVAL 			    // Avoid that ""filter(arg)"" is recognized. 			    if (vim9script && !VIM_ISWHITE(p[-1])) 				break; #endif 			    if (skip_only) 				p = skip_vimgrep_pat(p, NULL, NULL); 			    else 				// NOTE: This puts a NUL after the pattern. 				p = skip_vimgrep_pat_ext(p, &reg_pat, NULL, 								    &nulp, &c); 			    if (p == NULL || *p == NUL) 				break; 			    if (!skip_only) 			    { 				cmod->cmod_filter_regmatch.regprog = 						vim_regcomp(reg_pat, RE_MAGIC); 				if (cmod->cmod_filter_regmatch.regprog == NULL) 				    break; 				// restore the character overwritten by NUL 				if (nulp != NULL) 				    *nulp = c; 			    } 			    eap->cmd = p; 			    continue; 			}  			// "":hide"" and "":hide | cmd"" are not modifiers 	    case 'h':	if (p != eap->cmd || !checkforcmd_noparen(&p, ""hide"", 3) 					       || *p == NUL || ends_excmd(*p)) 			    break; 			eap->cmd = p; 			cmod->cmod_flags |= CMOD_HIDE; 			continue;  	    case 'l':	if (checkforcmd_noparen(&eap->cmd, ""lockmarks"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_LOCKMARKS; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""legacy"", 3)) 			{ 			    if (ends_excmd2(p, eap->cmd)) 			    { 				*errormsg = 				      _(e_legacy_must_be_followed_by_command); 				return FAIL; 			    } 			    cmod->cmod_flags |= CMOD_LEGACY; 			    continue; 			}  			if (!checkforcmd_noparen(&eap->cmd, ""leftabove"", 5)) 			    break; 			cmod->cmod_split |= WSP_ABOVE; 			continue;  	    case 'n':	if (checkforcmd_noparen(&eap->cmd, ""noautocmd"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_NOAUTOCMD; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""noswapfile"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_NOSWAPFILE; 			continue;  	    case 'r':	if (!checkforcmd_noparen(&eap->cmd, ""rightbelow"", 6)) 			    break; 			cmod->cmod_split |= WSP_BELOW; 			continue;  	    case 's':	if (checkforcmd_noparen(&eap->cmd, ""sandbox"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_SANDBOX; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""silent"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_SILENT; 			if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1])) 			{ 			    // "":silent!"", but not ""silent !cmd"" 			    eap->cmd = skipwhite(eap->cmd + 1); 			    cmod->cmod_flags |= CMOD_ERRSILENT; 			} 			continue;  	    case 't':	if (checkforcmd_noparen(&p, ""tab"", 3)) 			{ 			    if (!skip_only) 			    { 				long tabnr = get_address(eap, &eap->cmd, 						    ADDR_TABS, eap->skip, 						    skip_only, FALSE, 1); 				if (tabnr == MAXLNUM) 				    cmod->cmod_tab = tabpage_index(curtab) + 1; 				else 				{ 				    if (tabnr < 0 || tabnr > LAST_TAB_NR) 				    { 					*errormsg = _(e_invalid_range); 					return FAIL; 				    } 				    cmod->cmod_tab = tabnr + 1; 				} 			    } 			    eap->cmd = p; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""topleft"", 2)) 			    break; 			cmod->cmod_split |= WSP_TOP; 			continue;  	    case 'u':	if (!checkforcmd_noparen(&eap->cmd, ""unsilent"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_UNSILENT; 			continue;  	    case 'v':	if (checkforcmd_noparen(&eap->cmd, ""vertical"", 4)) 			{ 			    cmod->cmod_split |= WSP_VERT; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""vim9cmd"", 4)) 			{ 			    if (ends_excmd2(p, eap->cmd)) 			    { 				*errormsg = 				      _(e_vim9cmd_must_be_followed_by_command); 				return FAIL; 			    } 			    cmod->cmod_flags |= CMOD_VIM9CMD; 			    continue; 			} 			if (!checkforcmd_noparen(&p, ""verbose"", 4)) 			    break; 			if (vim_isdigit(*eap->cmd)) 			{ 			    cmod->cmod_verbose = atoi((char *)eap->cmd); 			    if (cmod->cmod_verbose == 0) 				cmod->cmod_verbose = -1; 			} 			else 			    cmod->cmod_verbose = 1; 			eap->cmd = p; 			continue; 	} 	break;     }      if (has_visual_range)     { 	if (eap->cmd > cmd_start) 	{ 	    // Move the '<,'> range to after the modifiers and insert a colon. 	    // Since the modifiers have been parsed put the colon on top of the 	    // space: ""'<,'>mod cmd"" -> ""mod:'<,'>cmd 	    // Put eap->cmd after the colon. 	    mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start); 	    eap->cmd -= 5; 	    mch_memmove(eap->cmd - 1, "":'<,'>"", 6); 	} 	else 	    // no modifiers, move the pointer back 	    eap->cmd -= 5;     }      return OK; }"
"206262_CWE-787.c","CWE-787","parse_command_modifiers( 	exarg_T	    *eap, 	char	    **errormsg, 	cmdmod_T    *cmod, 	int	    skip_only) {     char_u  *orig_cmd = eap->cmd;     char_u  *cmd_start = NULL;     int	    use_plus_cmd = FALSE;     int	    starts_with_colon = FALSE;     int	    vim9script = in_vim9script();     int	    has_visual_range = FALSE;      CLEAR_POINTER(cmod);     cmod->cmod_flags = sticky_cmdmod_flags;      if (STRNCMP(eap->cmd, ""'<,'>"", 5) == 0)     { 	// The automatically inserted Visual area range is skipped, so that 	// typing "":cmdmod cmd"" in Visual mode works without having to move the 	// range to after the modififiers. The command will be 	// ""'<,'>cmdmod cmd"", parse ""cmdmod cmd"" and then put back ""'<,'>"" 	// before ""cmd"" below. 	eap->cmd += 5; 	cmd_start = eap->cmd; 	has_visual_range = TRUE;     }      // Repeat until no more command modifiers are found.     for (;;)     { 	char_u  *p;  	while (*eap->cmd == ' ' || *eap->cmd == '\t' || *eap->cmd == ':') 	{ 	    if (*eap->cmd == ':') 		starts_with_colon = TRUE; 	    ++eap->cmd; 	}  	// in ex mode, an empty command (after modifiers) works like :+ 	if (*eap->cmd == NUL && exmode_active 		   && (getline_equal(eap->getline, eap->cookie, getexmodeline) 		       || getline_equal(eap->getline, eap->cookie, getexline)) 			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) 	{ 	    use_plus_cmd = TRUE; 	    if (!skip_only) 		ex_pressedreturn = TRUE; 	    break;  // no modifiers following 	}  	// ignore comment and empty lines 	if (comment_start(eap->cmd, starts_with_colon)) 	{ 	    // a comment ends at a NL 	    if (eap->nextcmd == NULL) 	    { 		eap->nextcmd = vim_strchr(eap->cmd, '\n'); 		if (eap->nextcmd != NULL) 		    ++eap->nextcmd; 	    } 	    if (vim9script && has_cmdmod(cmod, FALSE)) 		*errormsg = _(e_command_modifier_without_command); 	    return FAIL; 	} 	if (*eap->cmd == NUL) 	{ 	    if (!skip_only) 	    { 		ex_pressedreturn = TRUE; 		if (vim9script && has_cmdmod(cmod, FALSE)) 		    *errormsg = _(e_command_modifier_without_command); 	    } 	    return FAIL; 	}  	p = skip_range(eap->cmd, TRUE, NULL);  	// In Vim9 script a variable can shadow a command modifier: 	//   verbose = 123 	//   verbose += 123 	//   silent! verbose = func() 	//   verbose.member = 2 	//   verbose[expr] = 2 	// But not: 	//   verbose [a, b] = list 	if (vim9script) 	{ 	    char_u *s, *n;  	    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s) 		; 	    n = skipwhite(s); 	    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=') 		    || *s == '[') 		break; 	}  	switch (*p) 	{ 	    // When adding an entry, also modify cmd_exists(). 	    case 'a':	if (!checkforcmd_noparen(&eap->cmd, ""aboveleft"", 3)) 			    break; 			cmod->cmod_split |= WSP_ABOVE; 			continue;  	    case 'b':	if (checkforcmd_noparen(&eap->cmd, ""belowright"", 3)) 			{ 			    cmod->cmod_split |= WSP_BELOW; 			    continue; 			} 			if (checkforcmd_opt(&eap->cmd, ""browse"", 3, TRUE)) 			{ #ifdef FEAT_BROWSE_CMD 			    cmod->cmod_flags |= CMOD_BROWSE; #endif 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""botright"", 2)) 			    break; 			cmod->cmod_split |= WSP_BOT; 			continue;  	    case 'c':	if (!checkforcmd_opt(&eap->cmd, ""confirm"", 4, TRUE)) 			    break; #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) 			cmod->cmod_flags |= CMOD_CONFIRM; #endif 			continue;  	    case 'k':	if (checkforcmd_noparen(&eap->cmd, ""keepmarks"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPMARKS; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""keepalt"", 5)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPALT; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""keeppatterns"", 5)) 			{ 			    cmod->cmod_flags |= CMOD_KEEPPATTERNS; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""keepjumps"", 5)) 			    break; 			cmod->cmod_flags |= CMOD_KEEPJUMPS; 			continue;  	    case 'f':	// only accept "":filter {pat} cmd"" 			{ 			    char_u  *reg_pat; 			    char_u  *nulp = NULL; 			    int	    c = 0;  			    if (!checkforcmd_noparen(&p, ""filter"", 4) 				    || *p == NUL 				    || (ends_excmd(*p) #ifdef FEAT_EVAL 					// in "":filter #pat# cmd"" # does not 					// start a comment 				     && (!vim9script || VIM_ISWHITE(p[1])) #endif 				     )) 				break; 			    if (*p == '!') 			    { 				cmod->cmod_filter_force = TRUE; 				p = skipwhite(p + 1); 				if (*p == NUL || ends_excmd(*p)) 				    break; 			    } #ifdef FEAT_EVAL 			    // Avoid that ""filter(arg)"" is recognized. 			    if (vim9script && !VIM_ISWHITE(p[-1])) 				break; #endif 			    if (skip_only) 				p = skip_vimgrep_pat(p, NULL, NULL); 			    else 				// NOTE: This puts a NUL after the pattern. 				p = skip_vimgrep_pat_ext(p, &reg_pat, NULL, 								    &nulp, &c); 			    if (p == NULL || *p == NUL) 				break; 			    if (!skip_only) 			    { 				cmod->cmod_filter_regmatch.regprog = 						vim_regcomp(reg_pat, RE_MAGIC); 				if (cmod->cmod_filter_regmatch.regprog == NULL) 				    break; 				// restore the character overwritten by NUL 				if (nulp != NULL) 				    *nulp = c; 			    } 			    eap->cmd = p; 			    continue; 			}  			// "":hide"" and "":hide | cmd"" are not modifiers 	    case 'h':	if (p != eap->cmd || !checkforcmd_noparen(&p, ""hide"", 3) 					       || *p == NUL || ends_excmd(*p)) 			    break; 			eap->cmd = p; 			cmod->cmod_flags |= CMOD_HIDE; 			continue;  	    case 'l':	if (checkforcmd_noparen(&eap->cmd, ""lockmarks"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_LOCKMARKS; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""legacy"", 3)) 			{ 			    if (ends_excmd2(p, eap->cmd)) 			    { 				*errormsg = 				      _(e_legacy_must_be_followed_by_command); 				return FAIL; 			    } 			    cmod->cmod_flags |= CMOD_LEGACY; 			    continue; 			}  			if (!checkforcmd_noparen(&eap->cmd, ""leftabove"", 5)) 			    break; 			cmod->cmod_split |= WSP_ABOVE; 			continue;  	    case 'n':	if (checkforcmd_noparen(&eap->cmd, ""noautocmd"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_NOAUTOCMD; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""noswapfile"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_NOSWAPFILE; 			continue;  	    case 'r':	if (!checkforcmd_noparen(&eap->cmd, ""rightbelow"", 6)) 			    break; 			cmod->cmod_split |= WSP_BELOW; 			continue;  	    case 's':	if (checkforcmd_noparen(&eap->cmd, ""sandbox"", 3)) 			{ 			    cmod->cmod_flags |= CMOD_SANDBOX; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""silent"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_SILENT; 			if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1])) 			{ 			    // "":silent!"", but not ""silent !cmd"" 			    eap->cmd = skipwhite(eap->cmd + 1); 			    cmod->cmod_flags |= CMOD_ERRSILENT; 			} 			continue;  	    case 't':	if (checkforcmd_noparen(&p, ""tab"", 3)) 			{ 			    if (!skip_only) 			    { 				long tabnr = get_address(eap, &eap->cmd, 						    ADDR_TABS, eap->skip, 						    skip_only, FALSE, 1); 				if (tabnr == MAXLNUM) 				    cmod->cmod_tab = tabpage_index(curtab) + 1; 				else 				{ 				    if (tabnr < 0 || tabnr > LAST_TAB_NR) 				    { 					*errormsg = _(e_invalid_range); 					return FAIL; 				    } 				    cmod->cmod_tab = tabnr + 1; 				} 			    } 			    eap->cmd = p; 			    continue; 			} 			if (!checkforcmd_noparen(&eap->cmd, ""topleft"", 2)) 			    break; 			cmod->cmod_split |= WSP_TOP; 			continue;  	    case 'u':	if (!checkforcmd_noparen(&eap->cmd, ""unsilent"", 3)) 			    break; 			cmod->cmod_flags |= CMOD_UNSILENT; 			continue;  	    case 'v':	if (checkforcmd_noparen(&eap->cmd, ""vertical"", 4)) 			{ 			    cmod->cmod_split |= WSP_VERT; 			    continue; 			} 			if (checkforcmd_noparen(&eap->cmd, ""vim9cmd"", 4)) 			{ 			    if (ends_excmd2(p, eap->cmd)) 			    { 				*errormsg = 				      _(e_vim9cmd_must_be_followed_by_command); 				return FAIL; 			    } 			    cmod->cmod_flags |= CMOD_VIM9CMD; 			    continue; 			} 			if (!checkforcmd_noparen(&p, ""verbose"", 4)) 			    break; 			if (vim_isdigit(*eap->cmd)) 			{ 			    // zero means not set, one is verbose == 0, etc. 			    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1; 			} 			else 			    cmod->cmod_verbose = 2;  // default: verbose == 1 			eap->cmd = p; 			continue; 	} 	break;     }      if (has_visual_range)     { 	if (eap->cmd > cmd_start) 	{ 	    // Move the '<,'> range to after the modifiers and insert a colon. 	    // Since the modifiers have been parsed put the colon on top of the 	    // space: ""'<,'>mod cmd"" -> ""mod:'<,'>cmd 	    // Put eap->cmd after the colon. 	    if (use_plus_cmd) 	    { 		size_t len = STRLEN(cmd_start);  		// Special case: empty command uses ""+"": 		//  ""'<,'>mods"" -> ""mods'<,'>+ 		mch_memmove(orig_cmd, cmd_start, len); 		STRCPY(orig_cmd + len, ""'<,'>+""); 	    } 	    else 	    { 		mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start); 		eap->cmd -= 5; 		mch_memmove(eap->cmd - 1, "":'<,'>"", 6); 	    } 	} 	else 	    // No modifiers, move the pointer back. 	    // Special case: change empty command to ""+"". 	    if (use_plus_cmd) 		eap->cmd = (char_u *)""'<,'>+""; 	    else 		eap->cmd = orig_cmd;     }     else if (use_plus_cmd) 	eap->cmd = (char_u *)""+"";      return OK; }"
"206273_CWE-416.c","CWE-416","static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) { 	st64 ptr = 0; 	char *addr, *esil_buf = NULL; 	const st64 maxstackframe = 1024 * 8;   	r_return_if_fail (anal && fcn && op && reg);  	size_t i; 	for (i = 0; i < R_ARRAY_SIZE (op->src); i++) { 		if (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) { 			if (!strcmp (reg, op->src[i]->reg->name)) { 				st64 delta = op->src[i]->delta; 				if ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) { 					ptr = R_ABS (op->src[i]->delta); 					break; 				} 			} 		} 	}  	if (!ptr) { 		const char *op_esil = r_strbuf_get (&op->esil); 		if (!op_esil) { 			return; 		} 		esil_buf = strdup (op_esil); 		if (!esil_buf) { 			return; 		} 		r_strf_var (esilexpr, 64, "",%s,%s,"", reg, sign); 		char *ptr_end = strstr (esil_buf, esilexpr); 		if (!ptr_end) { 			free (esil_buf); 			return; 		} 		*ptr_end = 0; 		addr = ptr_end; 		while ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') { 			addr--; 		} 		if (strncmp (addr, ""0x"", 2)) { 			//XXX: This is a workaround for inconsistent esil 			if (!op->stackop && op->dst) { 				const char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP); 				const char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP); 				const char *rn = op->dst->reg ? op->dst->reg->name : NULL; 				if (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) { 					if (anal->verbose) { 						eprintf (""Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%"" PFMT64x "".\n"", op->addr); 					} 					goto beach; 				} 			} 			if (*addr == ',') { 				addr++; 			} 			if (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP 				&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) { 				ptr = (st64)r_num_get (NULL, addr); 				if (ptr && op->src[0] && ptr == op->src[0]->imm) { 					goto beach; 				} 			} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) { 				if (op->ptr % 4) { 					goto beach; 				} 				ptr = R_ABS (op->ptr); 			} else { 				goto beach; 			} 		} else { 			ptr = (st64)r_num_get (NULL, addr); 		} 	}  	if (anal->verbose && (!op->src[0] || !op->dst)) { 		eprintf (""Warning: Analysis didn't fill op->src/dst at 0x%"" PFMT64x "".\n"", op->addr); 	}  	int rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ; 	if (*sign == '+') { 		const bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off; 		const char *pfx = isarg ? ARGPREFIX : VARPREFIX; 		st64 frame_off; 		if (type == R_ANAL_VAR_KIND_SPV) { 			frame_off = ptr - fcn->stack; 		} else { 			frame_off = ptr - fcn->bp_off; 		} 		if (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) { 			goto beach; 		} 		RAnalVar *var = get_stack_var (fcn, frame_off); 		if (var) { 			r_anal_var_set_access (var, reg, op->addr, rw, ptr); 			goto beach; 		} 		char *varname = NULL, *vartype = NULL; 		if (isarg) { 			const char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL; 			bool stack_rev = place ? !strcmp (place, ""stack_rev"") : false; 			char *fname = r_type_func_guess (anal->sdb_types, fcn->name); 			if (fname) { 				ut64 sum_sz = 0; 				size_t from, to, i; 				if (stack_rev) { 					const size_t cnt = r_type_func_args_count (anal->sdb_types, fname); 					from = cnt ? cnt - 1 : cnt; 					to = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0; 				} else { 					from = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0; 					to = r_type_func_args_count (anal->sdb_types, fname); 				} 				const int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8; 				for (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) { 					char *tp = r_type_func_args_type (anal->sdb_types, fname, i); 					if (!tp) { 						break; 					} 					if (sum_sz == frame_off) { 						vartype = tp; 						varname = strdup (r_type_func_args_name (anal->sdb_types, fname, i)); 						break; 					} 					ut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp); 					sum_sz += bit_sz ? bit_sz / 8 : bytes; 					sum_sz = R_ROUND (sum_sz, bytes); 					free (tp); 				} 				free (fname); 			} 		} 		if (!varname) { 			if (anal->opt.varname_stack) { 				varname = r_str_newf (""%s_%"" PFMT64x ""h"", pfx, R_ABS (frame_off)); 			} else { 				varname = r_anal_function_autoname_var (fcn, type, pfx, ptr); 			} 		} 		if (varname) { #if 0 			if (isarg && frame_off > 48) { 				free (varname); 				goto beach; 			} #endif 			RAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname); 			if (var) { 				r_anal_var_set_access (var, reg, op->addr, rw, ptr); 			} 			free (varname); 		} 		free (vartype); 	} else { 		st64 frame_off = -(ptr + fcn->bp_off); 		if (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) { 			goto beach; 		} 		RAnalVar *var = get_stack_var (fcn, frame_off); 		if (var) { 			r_anal_var_set_access (var, reg, op->addr, rw, -ptr); 			goto beach; 		} 		char *varname = anal->opt.varname_stack 			? r_str_newf (""%s_%"" PFMT64x ""h"", VARPREFIX, R_ABS (frame_off)) 			: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr); 		if (varname) { 			RAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname); 			if (var) { 				r_anal_var_set_access (var, reg, op->addr, rw, -ptr); 			} 			free (varname); 		} 	} beach: 	free (esil_buf); }"
"206417_CWE-787.c","CWE-787","ins_bs(     int		c,     int		mode,     int		*inserted_space_p) {     linenr_T	lnum;     int		cc;     int		temp = 0;	    // init for GCC     colnr_T	save_col;     colnr_T	mincol;     int		did_backspace = FALSE;     int		in_indent;     int		oldState;     int		cpc[MAX_MCO];	    // composing characters     int		call_fix_indent = FALSE;      /*      * can't delete anything in an empty file      * can't backup past first character in buffer      * can't backup past starting point unless 'backspace' > 1      * can backup to a previous line if 'backspace' == 0      */     if (       BUFEMPTY() 	    || ( #ifdef FEAT_RIGHTLEFT 		!revins_on && #endif 		((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0) 		    || (!can_bs(BS_START) 			&& ((arrow_used #ifdef FEAT_JOB_CHANNEL 				&& !bt_prompt(curbuf) #endif 			) || (curwin->w_cursor.lnum == Insstart_orig.lnum 				&& curwin->w_cursor.col <= Insstart_orig.col))) 		    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0 					 && curwin->w_cursor.col <= ai_col) 		    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))     { 	vim_beep(BO_BS); 	return FALSE;     }      if (stop_arrow() == FAIL) 	return FALSE;     in_indent = inindent(0);     if (in_indent) 	can_cindent = FALSE;     end_comment_pending = NUL;	// After BS, don't auto-end comment #ifdef FEAT_RIGHTLEFT     if (revins_on)	    // put cursor after last inserted char 	inc_cursor(); #endif      // Virtualedit:     //	BACKSPACE_CHAR eats a virtual space     //	BACKSPACE_WORD eats all coladd     //	BACKSPACE_LINE eats all coladd and keeps going     if (curwin->w_cursor.coladd > 0)     { 	if (mode == BACKSPACE_CHAR) 	{ 	    --curwin->w_cursor.coladd; 	    return TRUE; 	} 	if (mode == BACKSPACE_WORD) 	{ 	    curwin->w_cursor.coladd = 0; 	    return TRUE; 	} 	curwin->w_cursor.coladd = 0;     }      /*      * Delete newline!      */     if (curwin->w_cursor.col == 0)     { 	lnum = Insstart.lnum; 	if (curwin->w_cursor.lnum == lnum #ifdef FEAT_RIGHTLEFT 			|| revins_on #endif 				    ) 	{ 	    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2), 			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL) 		return FALSE; 	    --Insstart.lnum; 	    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum)); 	} 	/* 	 * In replace mode: 	 * cc < 0: NL was inserted, delete it 	 * cc >= 0: NL was replaced, put original characters back 	 */ 	cc = -1; 	if (State & REPLACE_FLAG) 	    cc = replace_pop();	    // returns -1 if NL was inserted 	/* 	 * In replace mode, in the line we started replacing, we only move the 	 * cursor. 	 */ 	if ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum) 	{ 	    dec_cursor(); 	} 	else 	{ 	    if (!(State & VREPLACE_FLAG) 				   || curwin->w_cursor.lnum > orig_line_count) 	    { 		temp = gchar_cursor();	// remember current char 		--curwin->w_cursor.lnum;  		// When ""aw"" is in 'formatoptions' we must delete the space at 		// the end of the line, otherwise the line will be broken 		// again when auto-formatting. 		if (has_format_option(FO_AUTO) 					   && has_format_option(FO_WHITE_PAR)) 		{ 		    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, 									TRUE); 		    int	    len;  		    len = (int)STRLEN(ptr); 		    if (len > 0 && ptr[len - 1] == ' ') 			ptr[len - 1] = NUL; 		}  		(void)do_join(2, FALSE, FALSE, FALSE, FALSE); 		if (temp == NUL && gchar_cursor() != NUL) 		    inc_cursor(); 	    } 	    else 		dec_cursor();  	    /* 	     * In MODE_REPLACE mode we have to put back the text that was 	     * replaced by the NL. On the replace stack is first a 	     * NUL-terminated sequence of characters that were deleted and then 	     * the characters that NL replaced. 	     */ 	    if (State & REPLACE_FLAG) 	    { 		/* 		 * Do the next ins_char() in MODE_NORMAL state, to 		 * prevent ins_char() from replacing characters and 		 * avoiding showmatch(). 		 */ 		oldState = State; 		State = MODE_NORMAL; 		/* 		 * restore characters (blanks) deleted after cursor 		 */ 		while (cc > 0) 		{ 		    save_col = curwin->w_cursor.col; 		    mb_replace_pop_ins(cc); 		    curwin->w_cursor.col = save_col; 		    cc = replace_pop(); 		} 		// restore the characters that NL replaced 		replace_pop_ins(); 		State = oldState; 	    } 	} 	did_ai = FALSE;     }     else     { 	/* 	 * Delete character(s) before the cursor. 	 */ #ifdef FEAT_RIGHTLEFT 	if (revins_on)		// put cursor on last inserted char 	    dec_cursor(); #endif 	mincol = 0; 						// keep indent 	if (mode == BACKSPACE_LINE 		&& (curbuf->b_p_ai || cindent_on()) #ifdef FEAT_RIGHTLEFT 		&& !revins_on #endif 			    ) 	{ 	    save_col = curwin->w_cursor.col; 	    beginline(BL_WHITE); 	    if (curwin->w_cursor.col < save_col) 	    { 		mincol = curwin->w_cursor.col; 		// should now fix the indent to match with the previous line 		call_fix_indent = TRUE; 	    } 	    curwin->w_cursor.col = save_col; 	}  	/* 	 * Handle deleting one 'shiftwidth' or 'softtabstop'. 	 */ 	if (	   mode == BACKSPACE_CHAR 		&& ((p_sta && in_indent) 		    || ((get_sts_value() != 0 #ifdef FEAT_VARTABS 			|| tabstop_count(curbuf->b_p_vsts_array) #endif 			) 			&& curwin->w_cursor.col > 0 			&& (*(ml_get_cursor() - 1) == TAB 			    || (*(ml_get_cursor() - 1) == ' ' 				&& (!*inserted_space_p 				    || arrow_used)))))) 	{ 	    int		ts; 	    colnr_T	vcol; 	    colnr_T	want_vcol; 	    colnr_T	start_vcol;  	    *inserted_space_p = FALSE; 	    // Compute the virtual column where we want to be.  Since 	    // 'showbreak' may get in the way, need to get the last column of 	    // the previous character. 	    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL); 	    start_vcol = vcol; 	    dec_cursor(); 	    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol); 	    inc_cursor(); #ifdef FEAT_VARTABS 	    if (p_sta && in_indent) 	    { 		ts = (int)get_sw_value(curbuf); 		want_vcol = (want_vcol / ts) * ts; 	    } 	    else 		want_vcol = tabstop_start(want_vcol, get_sts_value(), 						       curbuf->b_p_vsts_array); #else 	    if (p_sta && in_indent) 		ts = (int)get_sw_value(curbuf); 	    else 		ts = (int)get_sts_value(); 	    want_vcol = (want_vcol / ts) * ts; #endif  	    // delete characters until we are at or before want_vcol 	    while (vcol > want_vcol 		    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc))) 		ins_bs_one(&vcol);  	    // insert extra spaces until we are at want_vcol 	    while (vcol < want_vcol) 	    { 		// Remember the first char we inserted 		if (curwin->w_cursor.lnum == Insstart_orig.lnum 				   && curwin->w_cursor.col < Insstart_orig.col) 		    Insstart_orig.col = curwin->w_cursor.col;  		if (State & VREPLACE_FLAG) 		    ins_char(' '); 		else 		{ 		    ins_str((char_u *)"" ""); 		    if ((State & REPLACE_FLAG)) 			replace_push(NUL); 		} 		getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL); 	    }  	    // If we are now back where we started delete one character.  Can 	    // happen when using 'sts' and 'linebreak'. 	    if (vcol >= start_vcol) 		ins_bs_one(&vcol); 	}  	/* 	 * Delete up to starting point, start of line or previous word. 	 */ 	else 	{ 	    int cclass = 0, prev_cclass = 0;  	    if (has_mbyte) 		cclass = mb_get_class(ml_get_cursor()); 	    do 	    { #ifdef FEAT_RIGHTLEFT 		if (!revins_on) // put cursor on char to be deleted #endif 		    dec_cursor();  		cc = gchar_cursor(); 		// look multi-byte character class 		if (has_mbyte) 		{ 		    prev_cclass = cclass; 		    cclass = mb_get_class(ml_get_cursor()); 		}  		// start of word? 		if (mode == BACKSPACE_WORD && !vim_isspace(cc)) 		{ 		    mode = BACKSPACE_WORD_NOT_SPACE; 		    temp = vim_iswordc(cc); 		} 		// end of word? 		else if (mode == BACKSPACE_WORD_NOT_SPACE 			&& ((vim_isspace(cc) || vim_iswordc(cc) != temp) 			|| prev_cclass != cclass)) 		{ #ifdef FEAT_RIGHTLEFT 		    if (!revins_on) #endif 			inc_cursor(); #ifdef FEAT_RIGHTLEFT 		    else if (State & REPLACE_FLAG) 			dec_cursor(); #endif 		    break; 		} 		if (State & REPLACE_FLAG) 		    replace_do_bs(-1); 		else 		{ 		    if (enc_utf8 && p_deco) 			(void)utfc_ptr2char(ml_get_cursor(), cpc); 		    (void)del_char(FALSE); 		    /* 		     * If there are combining characters and 'delcombine' is set 		     * move the cursor back.  Don't back up before the base 		     * character. 		     */ 		    if (enc_utf8 && p_deco && cpc[0] != NUL) 			inc_cursor(); #ifdef FEAT_RIGHTLEFT 		    if (revins_chars) 		    { 			revins_chars--; 			revins_legal++; 		    } 		    if (revins_on && gchar_cursor() == NUL) 			break; #endif 		} 		// Just a single backspace?: 		if (mode == BACKSPACE_CHAR) 		    break; 	    } while ( #ifdef FEAT_RIGHTLEFT 		    revins_on || #endif 		    (curwin->w_cursor.col > mincol 		    &&  (can_bs(BS_NOSTOP) 			|| (curwin->w_cursor.lnum != Insstart_orig.lnum 			|| curwin->w_cursor.col != Insstart_orig.col) 		    ))); 	} 	did_backspace = TRUE;     }     did_si = FALSE;     can_si = FALSE;     can_si_back = FALSE;     if (curwin->w_cursor.col <= 1) 	did_ai = FALSE;      if (call_fix_indent) 	fix_indent();      /*      * It's a little strange to put backspaces into the redo      * buffer, but it makes auto-indent a lot easier to deal      * with.      */     AppendCharToRedobuff(c);      // If deleted before the insertion point, adjust it     if (curwin->w_cursor.lnum == Insstart_orig.lnum 				  && curwin->w_cursor.col < Insstart_orig.col) 	Insstart_orig.col = curwin->w_cursor.col;      // vi behaviour: the cursor moves backward but the character that     //		     was there remains visible     // Vim behaviour: the cursor moves backward and the character that     //		      was there is erased from the screen.     // We can emulate the vi behaviour by pretending there is a dollar     // displayed even when there isn't.     //  --pkv Sun Jan 19 01:56:40 EST 2003     if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1) 	dollar_vcol = curwin->w_virtcol;  #ifdef FEAT_FOLDING     // When deleting a char the cursor line must never be in a closed fold.     // E.g., when 'foldmethod' is indent and deleting the first non-white     // char before a Tab.     if (did_backspace) 	foldOpenCursor(); #endif      return did_backspace; }"
"206510_CWE-476.c","CWE-476","int udf_expand_file_adinicb(struct inode *inode) { 	struct page *page; 	char *kaddr; 	struct udf_inode_info *iinfo = UDF_I(inode); 	int err; 	struct writeback_control udf_wbc = { 		.sync_mode = WB_SYNC_NONE, 		.nr_to_write = 1, 	};  	WARN_ON_ONCE(!inode_is_locked(inode)); 	if (!iinfo->i_lenAlloc) { 		if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD)) 			iinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT; 		else 			iinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG; 		/* from now on we have normal address_space methods */ 		inode->i_data.a_ops = &udf_aops; 		up_write(&iinfo->i_data_sem); 		mark_inode_dirty(inode); 		return 0; 	} 	/* 	 * Release i_data_sem so that we can lock a page - page lock ranks 	 * above i_data_sem. i_mutex still protects us against file changes. 	 */ 	up_write(&iinfo->i_data_sem);  	page = find_or_create_page(inode->i_mapping, 0, GFP_NOFS); 	if (!page) 		return -ENOMEM;  	if (!PageUptodate(page)) { 		kaddr = kmap_atomic(page); 		memset(kaddr + iinfo->i_lenAlloc, 0x00, 		       PAGE_SIZE - iinfo->i_lenAlloc); 		memcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr, 			iinfo->i_lenAlloc); 		flush_dcache_page(page); 		SetPageUptodate(page); 		kunmap_atomic(kaddr); 	} 	down_write(&iinfo->i_data_sem); 	memset(iinfo->i_data + iinfo->i_lenEAttr, 0x00, 	       iinfo->i_lenAlloc); 	iinfo->i_lenAlloc = 0; 	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD)) 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT; 	else 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG; 	/* from now on we have normal address_space methods */ 	inode->i_data.a_ops = &udf_aops; 	up_write(&iinfo->i_data_sem); 	err = inode->i_data.a_ops->writepage(page, &udf_wbc); 	if (err) { 		/* Restore everything back so that we don't lose data... */ 		lock_page(page); 		down_write(&iinfo->i_data_sem); 		kaddr = kmap_atomic(page); 		memcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size); 		kunmap_atomic(kaddr); 		unlock_page(page); 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB; 		inode->i_data.a_ops = &udf_adinicb_aops; 		up_write(&iinfo->i_data_sem); 	} 	put_page(page); 	mark_inode_dirty(inode);  	return err; }"
"206555_CWE-119.c","CWE-119","static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len) { 	int rlen, remain; 	dpIOCtxPtr dctx; 	dynamicPtr *dp;  	dctx = (dpIOCtxPtr) ctx; 	dp = dctx->dp;  	remain = dp->logicalSize - dp->pos; 	if (remain >= len) { 		rlen = len; 	} else { 		if (remain == 0) { 			return EOF; 		} 		rlen = remain; 	}  	memcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen); 	dp->pos += rlen;  	return rlen; }"
"206588_CWE-119.c","CWE-119","gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color) {   int lastBorder;   /* Seek left */   int leftLimit, rightLimit;   int i;   leftLimit = (-1);   if (border < 0)     {       /* Refuse to fill to a non-solid border */       return;     }   for (i = x; (i >= 0); i--)     {       if (gdImageGetPixel (im, i, y) == border) 	{ 	  break; 	}       gdImageSetPixel (im, i, y, color);       leftLimit = i;     }   if (leftLimit == (-1))     {       return;     }   /* Seek right */   rightLimit = x;   for (i = (x + 1); (i < im->sx); i++)     {       if (gdImageGetPixel (im, i, y) == border) 	{ 	  break; 	}       gdImageSetPixel (im, i, y, color);       rightLimit = i;     }   /* Look at lines above and below and start paints */   /* Above */   if (y > 0)     {       lastBorder = 1;       for (i = leftLimit; (i <= rightLimit); i++) 	{ 	  int c; 	  c = gdImageGetPixel (im, i, y - 1); 	  if (lastBorder) 	    { 	      if ((c != border) && (c != color)) 		{ 		  gdImageFillToBorder (im, i, y - 1, 				       border, color); 		  lastBorder = 0; 		} 	    } 	  else if ((c == border) || (c == color)) 	    { 	      lastBorder = 1; 	    } 	}     }   /* Below */   if (y < ((im->sy) - 1))     {       lastBorder = 1;       for (i = leftLimit; (i <= rightLimit); i++) 	{ 	  int c; 	  c = gdImageGetPixel (im, i, y + 1); 	  if (lastBorder) 	    { 	      if ((c != border) && (c != color)) 		{ 		  gdImageFillToBorder (im, i, y + 1, 				       border, color); 		  lastBorder = 0; 		} 	    } 	  else if ((c == border) || (c == color)) 	    { 	      lastBorder = 1; 	    } 	}     } }"
"206625_CWE-787.c","CWE-787","raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer,                                        raptor_xml_element* element,                                        int auto_empty) {   raptor_iostream* iostr = xml_writer->iostr;   raptor_namespace_stack *nstack = xml_writer->nstack;   int depth = xml_writer->depth;   int auto_indent = XML_WRITER_AUTO_INDENT(xml_writer);   struct nsd *nspace_declarations = NULL;   size_t nspace_declarations_count = 0;     unsigned int i;    /* max is 1 per element and 1 for each attribute + size of declared */   if(nstack) {     int nspace_max_count = element->attribute_count+1;     if(element->declared_nspaces)       nspace_max_count += raptor_sequence_size(element->declared_nspaces);     if(element->xml_language)       nspace_max_count++;      nspace_declarations = RAPTOR_CALLOC(struct nsd*, nspace_max_count,                                         sizeof(struct nsd));     if(!nspace_declarations)       return 1;   }    if(element->name->nspace) {     if(nstack && !raptor_namespaces_namespace_in_scope(nstack, element->name->nspace)) {       nspace_declarations[0].declaration=         raptor_namespace_format_as_xml(element->name->nspace,                                        &nspace_declarations[0].length);       if(!nspace_declarations[0].declaration)         goto error;       nspace_declarations[0].nspace = element->name->nspace;       nspace_declarations_count++;     }   }    if(nstack && element->attributes) {     for(i = 0; i < element->attribute_count; i++) {       /* qname */       if(element->attributes[i]->nspace) {         /* Check if we need a namespace declaration attribute */         if(nstack &&             !raptor_namespaces_namespace_in_scope(nstack, element->attributes[i]->nspace) && element->attributes[i]->nspace != element->name->nspace) {           /* not in scope and not same as element (so already going to be declared)*/           unsigned int j;           int declare_me = 1;                      /* check it wasn't an earlier declaration too */           for(j = 0; j < nspace_declarations_count; j++)             if(nspace_declarations[j].nspace == element->attributes[j]->nspace) {               declare_me = 0;               break;             }                        if(declare_me) {             nspace_declarations[nspace_declarations_count].declaration=               raptor_namespace_format_as_xml(element->attributes[i]->nspace,                                              &nspace_declarations[nspace_declarations_count].length);             if(!nspace_declarations[nspace_declarations_count].declaration)               goto error;             nspace_declarations[nspace_declarations_count].nspace = element->attributes[i]->nspace;             nspace_declarations_count++;           }         }       }        /* Add the attribute + value */       nspace_declarations[nspace_declarations_count].declaration=         raptor_qname_format_as_xml(element->attributes[i],                                    &nspace_declarations[nspace_declarations_count].length);       if(!nspace_declarations[nspace_declarations_count].declaration)         goto error;       nspace_declarations[nspace_declarations_count].nspace = NULL;       nspace_declarations_count++;      }   }    if(nstack && element->declared_nspaces &&      raptor_sequence_size(element->declared_nspaces) > 0) {     for(i = 0; i< (unsigned int)raptor_sequence_size(element->declared_nspaces); i++) {       raptor_namespace* nspace = (raptor_namespace*)raptor_sequence_get_at(element->declared_nspaces, i);       unsigned int j;       int declare_me = 1;              /* check it wasn't an earlier declaration too */       for(j = 0; j < nspace_declarations_count; j++)         if(nspace_declarations[j].nspace == nspace) {           declare_me = 0;           break;         }              if(declare_me) {         nspace_declarations[nspace_declarations_count].declaration=           raptor_namespace_format_as_xml(nspace,                                          &nspace_declarations[nspace_declarations_count].length);         if(!nspace_declarations[nspace_declarations_count].declaration)           goto error;         nspace_declarations[nspace_declarations_count].nspace = nspace;         nspace_declarations_count++;       }      }   }    if(nstack && element->xml_language) {     size_t lang_len = strlen(RAPTOR_GOOD_CAST(char*, element->xml_language)); #define XML_LANG_PREFIX_LEN 10     size_t buf_length = XML_LANG_PREFIX_LEN + lang_len + 1;     unsigned char* buffer = RAPTOR_MALLOC(unsigned char*, buf_length + 1);     const char quote = '\""';     unsigned char* p;      memcpy(buffer, ""xml:lang=\"""", XML_LANG_PREFIX_LEN);     p = buffer + XML_LANG_PREFIX_LEN;     p += raptor_xml_escape_string(xml_writer->world,                                   element->xml_language, lang_len,                                   p, buf_length, quote);     *p++ = quote;     *p = '\0';      nspace_declarations[nspace_declarations_count].declaration = buffer;     nspace_declarations[nspace_declarations_count].length = buf_length;     nspace_declarations[nspace_declarations_count].nspace = NULL;     nspace_declarations_count++;   }       raptor_iostream_write_byte('<', iostr);    if(element->name->nspace && element->name->nspace->prefix_length > 0) {     raptor_iostream_counted_string_write((const char*)element->name->nspace->prefix,                                           element->name->nspace->prefix_length,                                          iostr);     raptor_iostream_write_byte(':', iostr);   }   raptor_iostream_counted_string_write((const char*)element->name->local_name,                                        element->name->local_name_length,                                        iostr);    /* declare namespaces and attributes */   if(nspace_declarations_count) {     int need_indent = 0;          /* sort them into the canonical order */     qsort((void*)nspace_declarations,            nspace_declarations_count, sizeof(struct nsd),           raptor_xml_writer_nsd_compare);      /* declare namespaces first */     for(i = 0; i < nspace_declarations_count; i++) {       if(!nspace_declarations[i].nspace)         continue;        if(auto_indent && need_indent) {         /* indent attributes */         raptor_xml_writer_newline(xml_writer);         xml_writer->depth++;         raptor_xml_writer_indent(xml_writer);         xml_writer->depth--;       }       raptor_iostream_write_byte(' ', iostr);       raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,                                            nspace_declarations[i].length,                                            iostr);       RAPTOR_FREE(char*, nspace_declarations[i].declaration);       nspace_declarations[i].declaration = NULL;       need_indent = 1;              if(raptor_namespace_stack_start_namespace(nstack,                                                 (raptor_namespace*)nspace_declarations[i].nspace,                                                 depth))         goto error;     }      /* declare attributes */     for(i = 0; i < nspace_declarations_count; i++) {       if(nspace_declarations[i].nspace)         continue;        if(auto_indent && need_indent) {         /* indent attributes */         raptor_xml_writer_newline(xml_writer);         xml_writer->depth++;         raptor_xml_writer_indent(xml_writer);         xml_writer->depth--;       }       raptor_iostream_write_byte(' ', iostr);       raptor_iostream_counted_string_write((const char*)nspace_declarations[i].declaration,                                            nspace_declarations[i].length,                                            iostr);       need_indent = 1;        RAPTOR_FREE(char*, nspace_declarations[i].declaration);       nspace_declarations[i].declaration = NULL;     }   }    if(!auto_empty)     raptor_iostream_write_byte('>', iostr);    if(nstack)     RAPTOR_FREE(stringarray, nspace_declarations);    return 0;    /* Clean up nspace_declarations on error */   error:    for(i = 0; i < nspace_declarations_count; i++) {     if(nspace_declarations[i].declaration)       RAPTOR_FREE(char*, nspace_declarations[i].declaration);   }    RAPTOR_FREE(stringarray, nspace_declarations);    return 1; }"
"206639_CWE-703.c","CWE-703","static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data, 			    struct nft_data_desc *desc, const struct nlattr *nla) { 	u8 genmask = nft_genmask_next(ctx->net); 	struct nlattr *tb[NFTA_VERDICT_MAX + 1]; 	struct nft_chain *chain; 	int err;  	err = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla, 					  nft_verdict_policy, NULL); 	if (err < 0) 		return err;  	if (!tb[NFTA_VERDICT_CODE]) 		return -EINVAL; 	data->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));  	switch (data->verdict.code) { 	default: 		switch (data->verdict.code & NF_VERDICT_MASK) { 		case NF_ACCEPT: 		case NF_DROP: 		case NF_QUEUE: 			break; 		default: 			return -EINVAL; 		} 		fallthrough; 	case NFT_CONTINUE: 	case NFT_BREAK: 	case NFT_RETURN: 		break; 	case NFT_JUMP: 	case NFT_GOTO: 		if (tb[NFTA_VERDICT_CHAIN]) { 			chain = nft_chain_lookup(ctx->net, ctx->table, 						 tb[NFTA_VERDICT_CHAIN], 						 genmask); 		} else if (tb[NFTA_VERDICT_CHAIN_ID]) { 			chain = nft_chain_lookup_byid(ctx->net, ctx->table, 						      tb[NFTA_VERDICT_CHAIN_ID]); 			if (IS_ERR(chain)) 				return PTR_ERR(chain); 		} else { 			return -EINVAL; 		}  		if (IS_ERR(chain)) 			return PTR_ERR(chain); 		if (nft_is_base_chain(chain)) 			return -EOPNOTSUPP; 		if (desc->flags & NFT_DATA_DESC_SETELEM && 		    chain->flags & NFT_CHAIN_BINDING) 			return -EINVAL;  		chain->use++; 		data->verdict.chain = chain; 		break; 	}  	desc->len = sizeof(data->verdict);  	return 0; }"
"206665_CWE-787.c","CWE-787","static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) { 	if (!num || !offset || (st32)num < 0) { 		return; 	}  	ut64 total_size = num * sizeof (struct relocation_info); 	if (offset > bin->size) { 		return; 	} 	if (total_size > bin->size) { 		total_size = bin->size - offset; 		num = total_size /= sizeof (struct relocation_info); 	} 	struct relocation_info *info = calloc (num, sizeof (struct relocation_info)); 	if (!info) { 		return; 	}  	if (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) { 		free (info); 		return; 	}  	size_t i; 	for (i = 0; i < num; i++) { 		struct relocation_info a_info = info[i]; 		ut32 sym_num = a_info.r_symbolnum; 		if (sym_num > bin->nsymtab) { 			continue; 		}  		ut32 stridx = bin->symtab[sym_num].n_strx; 		char *sym_name = get_name (bin, stridx, false); 		if (!sym_name) { 			continue; 		}  		struct reloc_t *reloc = R_NEW0 (struct reloc_t); 		if (!reloc) { 			free (info); 			free (sym_name); 			return; 		}  		reloc->addr = offset_to_vaddr (bin, a_info.r_address); 		reloc->offset = a_info.r_address; 		reloc->ord = sym_num; 		reloc->type = a_info.r_type; // enum RelocationInfoType 		reloc->external = a_info.r_extern; 		reloc->pc_relative = a_info.r_pcrel; 		reloc->size = a_info.r_length; 		r_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1); 		r_skiplist_insert (relocs, reloc); 		free (sym_name); 	} 	free (info); }"
"206670_CWE-924.c","CWE-924","negotiate_handshake_newstyle_options (void) {   GET_CONN;   struct nbd_new_option new_option;   size_t nr_options;   bool list_seen = false;   uint64_t version;   uint32_t option;   uint32_t optlen;   struct nbd_export_name_option_reply handshake_finish;   const char *optname;   uint64_t exportsize;   struct backend *b;    for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {     CLEANUP_FREE char *data = NULL;      if (conn_recv_full (&new_option, sizeof new_option,                         ""reading option: conn->recv: %m"") == -1)       return -1;      version = be64toh (new_option.version);     if (version != NBD_NEW_VERSION) {       nbdkit_error (""unknown option version %"" PRIx64                     "", expecting %"" PRIx64,                     version, NBD_NEW_VERSION);       return -1;     }      /* There is a maximum option length we will accept, regardless      * of the option type.      */     optlen = be32toh (new_option.optlen);     if (optlen > MAX_REQUEST_SIZE) {       nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);       return -1;     }     data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */     if (data == NULL) {       nbdkit_error (""malloc: %m"");       return -1;     }      option = be32toh (new_option.option);     optname = name_of_nbd_opt (option);      /* If the client lacks fixed newstyle support, it should only send      * NBD_OPT_EXPORT_NAME.      */     if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&         option != NBD_OPT_EXPORT_NAME) {       if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))         return -1;       continue;     }      /* In --tls=require / FORCEDTLS mode the only options allowed      * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.      */     if (tls == 2 && !conn->using_tls &&         !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {       if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))         return -1;       continue;     }      switch (option) {     case NBD_OPT_EXPORT_NAME:       if (conn_recv_full (data, optlen,                           ""read: %s: %m"", name_of_nbd_opt (option)) == -1)         return -1;       if (check_export_name (option, data, optlen, optlen) == -1)         return -1;        /* We have to finish the handshake by sending handshake_finish.        * On failure, we have to disconnect.        */       if (finish_newstyle_options (&exportsize, data, optlen) == -1)         return -1;        memset (&handshake_finish, 0, sizeof handshake_finish);       handshake_finish.exportsize = htobe64 (exportsize);       handshake_finish.eflags = htobe16 (conn->eflags);        if (conn->send (&handshake_finish,                       (conn->cflags & NBD_FLAG_NO_ZEROES)                       ? offsetof (struct nbd_export_name_option_reply, zeroes)                       : sizeof handshake_finish, 0) == -1) {         nbdkit_error (""write: %s: %m"", optname);         return -1;       }       break;      case NBD_OPT_ABORT:       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;       debug (""client sent %s to abort the connection"",              name_of_nbd_opt (option));       return -1;      case NBD_OPT_LIST:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        if (list_seen) {         debug (""newstyle negotiation: %s: export list already advertised"",                name_of_nbd_opt (option));         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)           return -1;         continue;       }       else {         /* Send back the exportname list. */         debug (""newstyle negotiation: %s: advertising exports"",                name_of_nbd_opt (option));         if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)           return -1;         list_seen = true;       }       break;      case NBD_OPT_STARTTLS:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        if (tls == 0) {           /* --tls=off (NOTLS mode). */ #ifdef HAVE_GNUTLS #define NO_TLS_REPLY NBD_REP_ERR_POLICY #else #define NO_TLS_REPLY NBD_REP_ERR_UNSUP #endif         if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)           return -1;       }       else /* --tls=on or --tls=require */ {         /* We can't upgrade to TLS twice on the same connection. */         if (conn->using_tls) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)             return -1;           continue;         }          /* We have to send the (unencrypted) reply before starting          * the handshake.          */         if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)           return -1;          /* Upgrade the connection to TLS.  Also performs access control. */         if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)           return -1;         conn->using_tls = true;         debug (""using TLS on this connection"");         /* Wipe out any cached state. */         conn->structured_replies = false;         for_each_backend (b) {           free (conn->default_exportname[b->i]);           conn->default_exportname[b->i] = NULL;         }       }       break;      case NBD_OPT_INFO:     case NBD_OPT_GO:       if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)         return -1;        if (optlen < 6) { /* 32 bit export length + 16 bit nr info */         debug (""newstyle negotiation: %s option length < 6"", optname);          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         continue;       }        {         uint32_t exportnamelen;         uint16_t nrinfos;         uint16_t info;         size_t i;          /* Validate the name length and number of INFO requests. */         memcpy (&exportnamelen, &data[0], 4);         exportnamelen = be32toh (exportnamelen);         if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {           debug (""newstyle negotiation: %s: export name too long"", optname);           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }         memcpy (&nrinfos, &data[exportnamelen+4], 2);         nrinfos = be16toh (nrinfos);         if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {           debug (""newstyle negotiation: %s: ""                  ""number of information requests incorrect"", optname);           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* As with NBD_OPT_EXPORT_NAME we print the export name and          * save it in the connection.  If an earlier          * NBD_OPT_SET_META_CONTEXT used an export name, it must match          * or else we drop the support for that context.          */         if (check_export_name (option, &data[4], exportnamelen,                                optlen - 6) == -1) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* The spec is confusing, but it is required that we send back          * NBD_INFO_EXPORT, even if the client did not request it!          * qemu client in particular does not request this, but will          * fail if we don't send it.  Note that if .open fails, but we          * succeed at .close, then we merely return an error to the          * client and let them try another NBD_OPT, rather than          * disconnecting.          */         if (finish_newstyle_options (&exportsize,                                      &data[4], exportnamelen) == -1) {           if (conn->top_context) {             if (backend_finalize (conn->top_context) == -1)               return -1;             backend_close (conn->top_context);             conn->top_context = NULL;           }           if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)             return -1;           continue;         }          if (send_newstyle_option_reply_info_export (option,                                                     NBD_REP_INFO,                                                     NBD_INFO_EXPORT,                                                     exportsize) == -1)           return -1;          /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if          * requested, and ignore all other info requests (including          * NBD_INFO_EXPORT if it was requested, because we replied          * already above).          */         for (i = 0; i < nrinfos; ++i) {           memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);           info = be16toh (info);           switch (info) {           case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;           case NBD_INFO_NAME:             {               const char *name = &data[4];               size_t namelen = exportnamelen;                if (exportnamelen == 0) {                 name = backend_default_export (top, read_only);                 if (!name) {                   debug (""newstyle negotiation: %s: ""                          ""NBD_INFO_NAME: no name to send"", optname);                   break;                 }                 namelen = -1;               }               if (send_newstyle_option_reply_info_str (option,                                                        NBD_REP_INFO,                                                        NBD_INFO_NAME,                                                        name, namelen) == -1)                 return -1;             }             break;           case NBD_INFO_DESCRIPTION:             {               const char *desc = backend_export_description (conn->top_context);                if (!desc) {                 debug (""newstyle negotiation: %s: ""                        ""NBD_INFO_DESCRIPTION: no description to send"",                        optname);                 break;               }               if (send_newstyle_option_reply_info_str (option,                                                        NBD_REP_INFO,                                                        NBD_INFO_DESCRIPTION,                                                        desc, -1) == -1)                 return -1;             }             break;           default:             debug (""newstyle negotiation: %s: ""                    ""ignoring NBD_INFO_* request %u (%s)"",                    optname, (unsigned) info, name_of_nbd_info (info));             break;           }         }       }        /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK        * or ERROR packet.  If this was NBD_OPT_LIST, call .close.        */       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;        if (option == NBD_OPT_INFO) {         if (backend_finalize (conn->top_context) == -1)           return -1;         backend_close (conn->top_context);         conn->top_context = NULL;       }        break;      case NBD_OPT_STRUCTURED_REPLY:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        debug (""newstyle negotiation: %s: client requested structured replies"",              name_of_nbd_opt (option));        if (no_sr) {         /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;          * but failing with ERR_POLICY would have been nicer.          */         if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)           return -1;         debug (""newstyle negotiation: %s: structured replies are disabled"",                name_of_nbd_opt (option));         break;       }        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;        conn->structured_replies = true;       break;      case NBD_OPT_LIST_META_CONTEXT:     case NBD_OPT_SET_META_CONTEXT:       {         uint32_t opt_index;         uint32_t exportnamelen;         uint32_t nr_queries;         uint32_t querylen;         const char *what;          if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)           return -1;          /* Note that we support base:allocation whether or not the plugin          * supports can_extents.          */         if (!conn->structured_replies) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* Minimum length of the option payload is:          *   32 bit export name length followed by empty export name          * + 32 bit number of queries followed by no queries          * = 8 bytes.          */         what = ""optlen < 8"";         if (optlen < 8) {         opt_meta_invalid_option_len:           debug (""newstyle negotiation: %s: invalid option length: %s"",                  optname, what);            if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          memcpy (&exportnamelen, &data[0], 4);         exportnamelen = be32toh (exportnamelen);         what = ""validating export name"";         if (check_export_name (option, &data[4], exportnamelen,                                optlen - 8) == -1)           goto opt_meta_invalid_option_len;          /* Remember the export name: the NBD spec says that if the client          * later uses NBD_OPT_GO on a different export, then the context          * returned here is not usable.          */         if (option == NBD_OPT_SET_META_CONTEXT) {           conn->exportname_from_set_meta_context =             strndup (&data[4], exportnamelen);           if (conn->exportname_from_set_meta_context == NULL) {             nbdkit_error (""malloc: %m"");             return -1;           }         }          opt_index = 4 + exportnamelen;          /* Read the number of queries. */         what = ""reading number of queries"";         if (opt_index+4 > optlen)           goto opt_meta_invalid_option_len;         memcpy (&nr_queries, &data[opt_index], 4);         nr_queries = be32toh (nr_queries);         opt_index += 4;          /* for LIST: nr_queries == 0 means return all meta contexts          * for SET: nr_queries == 0 means reset all contexts          */         debug (""newstyle negotiation: %s: %s count: %d"", optname,                option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",                nr_queries);         if (option == NBD_OPT_SET_META_CONTEXT)           conn->meta_context_base_allocation = false;         if (nr_queries == 0) {           if (option == NBD_OPT_LIST_META_CONTEXT) {             if (send_newstyle_option_reply_meta_context (option,                                                          NBD_REP_META_CONTEXT,                                                          0, ""base:allocation"")                 == -1)               return -1;           }            if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)             return -1;         }         else {           /* Read and answer each query. */           while (nr_queries > 0) {             what = ""reading query string length"";             if (opt_index+4 > optlen)               goto opt_meta_invalid_option_len;             memcpy (&querylen, &data[opt_index], 4);             querylen = be32toh (querylen);             opt_index += 4;             what = ""reading query string"";             if (check_string (option, &data[opt_index], querylen,                               optlen - opt_index, ""meta context query"") == -1)               goto opt_meta_invalid_option_len;              debug (""newstyle negotiation: %s: %s %.*s"",                    optname,                    option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",                    (int) querylen, &data[opt_index]);              /* For LIST, ""base:"" returns all supported contexts in the              * base namespace.  We only support ""base:allocation"".              */             if (option == NBD_OPT_LIST_META_CONTEXT &&                 querylen == 5 &&                 strncmp (&data[opt_index], ""base:"", 5) == 0) {               if (send_newstyle_option_reply_meta_context                   (option, NBD_REP_META_CONTEXT,                    0, ""base:allocation"") == -1)                 return -1;             }             /* ""base:allocation"" requested by name. */             else if (querylen == 15 &&                      strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {               if (send_newstyle_option_reply_meta_context                   (option, NBD_REP_META_CONTEXT,                    option == NBD_OPT_SET_META_CONTEXT                    ? base_allocation_id : 0,                    ""base:allocation"") == -1)                 return -1;               if (option == NBD_OPT_SET_META_CONTEXT)                 conn->meta_context_base_allocation = true;             }             /* Every other query must be ignored. */              opt_index += querylen;             nr_queries--;           }           if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)             return -1;         }         debug (""newstyle negotiation: %s: reply complete"", optname);       }       break;      default:       /* Unknown option. */       if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)         return -1;       if (conn_recv_full (data, optlen,                           ""reading unknown option data: conn->recv: %m"") == -1)         return -1;     }      /* Note, since it's not very clear from the protocol doc, that the      * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and      * that ends option negotiation.      */     if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)       break;   }    if (nr_options == 0) {     nbdkit_error (""client spent too much time negotiating without selecting ""                   ""an export"");     return -1;   }    /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS    * by the time we finish option negotiation.  If not, give up.    */   if (tls == 2 && !conn->using_tls) {     nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");     return -1;   }    return 0; }"
"206676_CWE-122.c","CWE-122","update_topline(void) {     long	line_count;     int		halfheight;     int		n;     linenr_T	old_topline; #ifdef FEAT_DIFF     int		old_topfill; #endif #ifdef FEAT_FOLDING     linenr_T	lnum; #endif     int		check_topline = FALSE;     int		check_botline = FALSE;     long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;     int		save_so = *so_ptr;      // If there is no valid screen and when the window height is zero just use     // the cursor line.     if (!screen_valid(TRUE) || curwin->w_height == 0)     { 	check_cursor_lnum(); 	curwin->w_topline = curwin->w_cursor.lnum; 	curwin->w_botline = curwin->w_topline; 	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP; 	curwin->w_scbind_pos = 1; 	return;     }      check_cursor_moved(curwin);     if (curwin->w_valid & VALID_TOPLINE) 	return;      // When dragging with the mouse, don't scroll that quickly     if (mouse_dragging > 0) 	*so_ptr = mouse_dragging - 1;      old_topline = curwin->w_topline; #ifdef FEAT_DIFF     old_topfill = curwin->w_topfill; #endif      /*      * If the buffer is empty, always set topline to 1.      */     if (BUFEMPTY())		// special case - file is empty     { 	if (curwin->w_topline != 1) 	    redraw_later(NOT_VALID); 	curwin->w_topline = 1; 	curwin->w_botline = 2; 	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP; 	curwin->w_scbind_pos = 1;     }      /*      * If the cursor is above or near the top of the window, scroll the window      * to show the line the cursor is in, with 'scrolloff' context.      */     else     { 	if (curwin->w_topline > 1) 	{ 	    // If the cursor is above topline, scrolling is always needed. 	    // If the cursor is far below topline and there is no folding, 	    // scrolling down is never needed. 	    if (curwin->w_cursor.lnum < curwin->w_topline) 		check_topline = TRUE; 	    else if (check_top_offset()) 		check_topline = TRUE; 	} #ifdef FEAT_DIFF 	    // Check if there are more filler lines than allowed. 	if (!check_topline && curwin->w_topfill > diff_check_fill(curwin, 							   curwin->w_topline)) 	    check_topline = TRUE; #endif  	if (check_topline) 	{ 	    halfheight = curwin->w_height / 2 - 1; 	    if (halfheight < 2) 		halfheight = 2;  #ifdef FEAT_FOLDING 	    if (hasAnyFolding(curwin)) 	    { 		// Count the number of logical lines between the cursor and 		// topline + scrolloff (approximation of how much will be 		// scrolled). 		n = 0; 		for (lnum = curwin->w_cursor.lnum; 				    lnum < curwin->w_topline + *so_ptr; ++lnum) 		{ 		    ++n; 		    // stop at end of file or when we know we are far off 		    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight) 			break; 		    (void)hasFolding(lnum, NULL, &lnum); 		} 	    } 	    else #endif 		n = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;  	    // If we weren't very close to begin with, we scroll to put the 	    // cursor in the middle of the window.  Otherwise put the cursor 	    // near the top of the window. 	    if (n >= halfheight) 		scroll_cursor_halfway(FALSE); 	    else 	    { 		scroll_cursor_top(scrolljump_value(), FALSE); 		check_botline = TRUE; 	    } 	}  	else 	{ #ifdef FEAT_FOLDING 	    // Make sure topline is the first line of a fold. 	    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL); #endif 	    check_botline = TRUE; 	}     }      /*      * If the cursor is below the bottom of the window, scroll the window      * to put the cursor on the window.      * When w_botline is invalid, recompute it first, to avoid a redraw later.      * If w_botline was approximated, we might need a redraw later in a few      * cases, but we don't want to spend (a lot of) time recomputing w_botline      * for every small change.      */     if (check_botline)     { 	if (!(curwin->w_valid & VALID_BOTLINE_AP)) 	    validate_botline();  	if (curwin->w_botline <= curbuf->b_ml.ml_line_count) 	{ 	    if (curwin->w_cursor.lnum < curwin->w_botline) 	    { 	      if (((long)curwin->w_cursor.lnum 					     >= (long)curwin->w_botline - *so_ptr #ifdef FEAT_FOLDING 			|| hasAnyFolding(curwin) #endif 			)) 	      { 		lineoff_T	loff;  		// Cursor is (a few lines) above botline, check if there are 		// 'scrolloff' window lines below the cursor.  If not, need to 		// scroll. 		n = curwin->w_empty_rows; 		loff.lnum = curwin->w_cursor.lnum; #ifdef FEAT_FOLDING 		// In a fold go to its last line. 		(void)hasFolding(loff.lnum, NULL, &loff.lnum); #endif #ifdef FEAT_DIFF 		loff.fill = 0; 		n += curwin->w_filler_rows; #endif 		loff.height = 0; 		while (loff.lnum < curwin->w_botline #ifdef FEAT_DIFF 			&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0) #endif 			) 		{ 		    n += loff.height; 		    if (n >= *so_ptr) 			break; 		    botline_forw(&loff); 		} 		if (n >= *so_ptr) 		    // sufficient context, no need to scroll 		    check_botline = FALSE; 	      } 	      else 		  // sufficient context, no need to scroll 		  check_botline = FALSE; 	    } 	    if (check_botline) 	    { #ifdef FEAT_FOLDING 		if (hasAnyFolding(curwin)) 		{ 		    // Count the number of logical lines between the cursor and 		    // botline - scrolloff (approximation of how much will be 		    // scrolled). 		    line_count = 0; 		    for (lnum = curwin->w_cursor.lnum; 				   lnum >= curwin->w_botline - *so_ptr; --lnum) 		    { 			++line_count; 			// stop at end of file or when we know we are far off 			if (lnum <= 0 || line_count > curwin->w_height + 1) 			    break; 			(void)hasFolding(lnum, &lnum, NULL); 		    } 		} 		else #endif 		    line_count = curwin->w_cursor.lnum - curwin->w_botline 								   + 1 + *so_ptr; 		if (line_count <= curwin->w_height + 1) 		    scroll_cursor_bot(scrolljump_value(), FALSE); 		else 		    scroll_cursor_halfway(FALSE); 	    } 	}     }     curwin->w_valid |= VALID_TOPLINE;      /*      * Need to redraw when topline changed.      */     if (curwin->w_topline != old_topline #ifdef FEAT_DIFF 	    || curwin->w_topfill != old_topfill #endif 	    )     { 	dollar_vcol = -1; 	if (curwin->w_skipcol != 0) 	{ 	    curwin->w_skipcol = 0; 	    redraw_later(NOT_VALID); 	} 	else 	    redraw_later(VALID); 	// May need to set w_skipcol when cursor in w_topline. 	if (curwin->w_cursor.lnum == curwin->w_topline) 	    validate_cursor();     }      *so_ptr = save_so; }"
"206677_CWE-703.c","CWE-703","unix_expandpath(     garray_T	*gap,     char_u	*path,     int		wildoff,     int		flags,		// EW_* flags     int		didstar)	// expanded ""**"" once already {     char_u	*buf;     char_u	*path_end;     char_u	*p, *s, *e;     int		start_len = gap->ga_len;     char_u	*pat;     regmatch_T	regmatch;     int		starts_with_dot;     int		matches;     int		len;     int		starstar = FALSE;     static int	stardepth = 0;	    // depth for ""**"" expansion      DIR		*dirp;     struct dirent *dp;      // Expanding ""**"" may take a long time, check for CTRL-C.     if (stardepth > 0)     { 	ui_breakcheck(); 	if (got_int) 	    return 0;     }      // make room for file name     buf = alloc(STRLEN(path) + BASENAMELEN + 5);     if (buf == NULL) 	return 0;      /*      * Find the first part in the path name that contains a wildcard.      * When EW_ICASE is set every letter is considered to be a wildcard.      * Copy it into ""buf"", including the preceding characters.      */     p = buf;     s = buf;     e = NULL;     path_end = path;     while (*path_end != NUL)     { 	// May ignore a wildcard that has a backslash before it; it will 	// be removed by rem_backslash() or file_pat_to_reg_pat() below. 	if (path_end >= path + wildoff && rem_backslash(path_end)) 	    *p++ = *path_end++; 	else if (*path_end == '/') 	{ 	    if (e != NULL) 		break; 	    s = p + 1; 	} 	else if (path_end >= path + wildoff 			 && (vim_strchr((char_u *)""*?[{~$"", *path_end) != NULL 			     || (!p_fic && (flags & EW_ICASE) 					     && isalpha(PTR2CHAR(path_end))))) 	    e = p; 	if (has_mbyte) 	{ 	    len = (*mb_ptr2len)(path_end); 	    STRNCPY(p, path_end, len); 	    p += len; 	    path_end += len; 	} 	else 	    *p++ = *path_end++;     }     e = p;     *e = NUL;      // Now we have one wildcard component between ""s"" and ""e"".     // Remove backslashes between ""wildoff"" and the start of the wildcard     // component.     for (p = buf + wildoff; p < s; ++p) 	if (rem_backslash(p)) 	{ 	    STRMOVE(p, p + 1); 	    --e; 	    --s; 	}      // Check for ""**"" between ""s"" and ""e"".     for (p = s; p < e; ++p) 	if (p[0] == '*' && p[1] == '*') 	    starstar = TRUE;      // convert the file pattern to a regexp pattern     starts_with_dot = *s == '.';     pat = file_pat_to_reg_pat(s, e, NULL, FALSE);     if (pat == NULL)     { 	vim_free(buf); 	return 0;     }      // compile the regexp into a program     if (flags & EW_ICASE) 	regmatch.rm_ic = TRUE;		// 'wildignorecase' set     else 	regmatch.rm_ic = p_fic;	// ignore case when 'fileignorecase' is set     if (flags & (EW_NOERROR | EW_NOTWILD)) 	++emsg_silent;     regmatch.regprog = vim_regcomp(pat, RE_MAGIC);     if (flags & (EW_NOERROR | EW_NOTWILD)) 	--emsg_silent;     vim_free(pat);      if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)     { 	vim_free(buf); 	return 0;     }      // If ""**"" is by itself, this is the first time we encounter it and more     // is following then find matches without any directory.     if (!didstar && stardepth < 100 && starstar && e - s == 2 							  && *path_end == '/')     { 	STRCPY(s, path_end + 1); 	++stardepth; 	(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE); 	--stardepth;     }      // open the directory for scanning     *s = NUL;     dirp = opendir(*buf == NUL ? ""."" : (char *)buf);      // Find all matching entries     if (dirp != NULL)     { 	for (;;) 	{ 	    dp = readdir(dirp); 	    if (dp == NULL) 		break; 	    if ((dp->d_name[0] != '.' || starts_with_dot 			|| ((flags & EW_DODOT) 			    && dp->d_name[1] != NUL 			    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL))) 		 && ((regmatch.regprog != NULL && vim_regexec(&regmatch, 					     (char_u *)dp->d_name, (colnr_T)0)) 		   || ((flags & EW_NOTWILD) 		     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0))) 	    { 		STRCPY(s, dp->d_name); 		len = STRLEN(buf);  		if (starstar && stardepth < 100) 		{ 		    // For ""**"" in the pattern first go deeper in the tree to 		    // find matches. 		    STRCPY(buf + len, ""/**""); 		    STRCPY(buf + len + 3, path_end); 		    ++stardepth; 		    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE); 		    --stardepth; 		}  		STRCPY(buf + len, path_end); 		if (mch_has_exp_wildcard(path_end)) // handle more wildcards 		{ 		    // need to expand another component of the path 		    // remove backslashes for the remaining components only 		    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE); 		} 		else 		{ 		    stat_T  sb;  		    // no more wildcards, check if there is a match 		    // remove backslashes for the remaining components only 		    if (*path_end != NUL) 			backslash_halve(buf + len + 1); 		    // add existing file or symbolic link 		    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0 						      : mch_getperm(buf) >= 0) 		    { #ifdef MACOS_CONVERT 			size_t precomp_len = STRLEN(buf)+1; 			char_u *precomp_buf = 			    mac_precompose_path(buf, precomp_len, &precomp_len);  			if (precomp_buf) 			{ 			    mch_memmove(buf, precomp_buf, precomp_len); 			    vim_free(precomp_buf); 			} #endif 			addfile(gap, buf, flags); 		    } 		} 	    } 	}  	closedir(dirp);     }      vim_free(buf);     vim_regfree(regmatch.regprog);      matches = gap->ga_len - start_len;     if (matches > 0) 	qsort(((char_u **)gap->ga_data) + start_len, matches, 						   sizeof(char_u *), pstrcmp);     return matches; }"
"206736_CWE-189.c","CWE-189","ftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC) { 	php_stream	*tmpstream = NULL; 	databuf_t	*data = NULL; 	char		*ptr; 	int		ch, lastch; 	int		size, rcvd; 	int		lines; 	char		**ret = NULL; 	char		**entry; 	char		*text;   	if ((tmpstream = php_stream_fopen_tmpfile()) == NULL) { 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create temporary file.  Check permissions in temporary files directory.""); 		return NULL; 	}  	if (!ftp_type(ftp, FTPTYPE_ASCII)) { 		goto bail; 	}  	if ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) { 		goto bail; 	} 	ftp->data = data;	  	if (!ftp_putcmd(ftp, cmd, path)) { 		goto bail; 	} 	if (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) { 		goto bail; 	}  	/* some servers don't open a ftp-data connection if the directory is empty */ 	if (ftp->resp == 226) { 		ftp->data = data_close(ftp, data); 		php_stream_close(tmpstream); 		return ecalloc(1, sizeof(char*)); 	}  	/* pull data buffer into tmpfile */ 	if ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) { 		goto bail; 	} 	size = 0; 	lines = 0; 	lastch = 0; 	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) { 		if (rcvd == -1) { 			goto bail; 		}  		php_stream_write(tmpstream, data->buf, rcvd);  		size += rcvd; 		for (ptr = data->buf; rcvd; rcvd--, ptr++) { 			if (*ptr == '\n' && lastch == '\r') { 				lines++; 			} else { 				size++; 			} 			lastch = *ptr; 		} 	}  	ftp->data = data_close(ftp, data);  	php_stream_rewind(tmpstream);  	ret = safe_emalloc((lines + 1), sizeof(char*), size * sizeof(char*));  	entry = ret; 	text = (char*) (ret + lines + 1); 	*entry = text; 	lastch = 0; 	while ((ch = php_stream_getc(tmpstream)) != EOF) { 		if (ch == '\n' && lastch == '\r') { 			*(text - 1) = 0; 			*++entry = text; 		} else { 			*text++ = ch; 		} 		lastch = ch; 	} 	*entry = NULL;  	php_stream_close(tmpstream);  	if (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) { 		efree(ret); 		return NULL; 	}  	return ret; bail: 	ftp->data = data_close(ftp, data); 	php_stream_close(tmpstream); 	if (ret) 		efree(ret); 	return NULL; }"
"206771_CWE-191.cpp","CWE-191","bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* /*creationInterface*/) {     // Allocate LWPolyline vertices (group code 90):     if (groupCode==90) {         maxVertices = toInt(groupValue);         if (maxVertices>0) {             if (vertices!=NULL) {                 delete[] vertices;             }             vertices = new double[4*maxVertices];             for (int i=0; i<maxVertices; ++i) {                 vertices[i*4] = 0.0;                 vertices[i*4+1] = 0.0;                 vertices[i*4+2] = 0.0;                 vertices[i*4+3] = 0.0;             }         }         vertexIndex=-1;         return true;     }      // Process LWPolylines vertices (group codes 10/20/30/42):     else if (groupCode==10 || groupCode==20 ||              groupCode==30 || groupCode==42) {          if (vertexIndex<maxVertices-1 && groupCode==10) {             vertexIndex++;         }          if (groupCode<=30) {             if (vertexIndex>=0 && vertexIndex<maxVertices) {                 vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);             }         } else if (groupCode==42 && vertexIndex<maxVertices) {             vertices[4*vertexIndex + 3] = toReal(groupValue);         }         return true;     }     return false; }"
"206781_CWE-476.c","CWE-476","int udf_expand_file_adinicb(struct inode *inode) { 	struct page *page; 	char *kaddr; 	struct udf_inode_info *iinfo = UDF_I(inode); 	int err;  	WARN_ON_ONCE(!inode_is_locked(inode)); 	if (!iinfo->i_lenAlloc) { 		if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD)) 			iinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT; 		else 			iinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG; 		/* from now on we have normal address_space methods */ 		inode->i_data.a_ops = &udf_aops; 		up_write(&iinfo->i_data_sem); 		mark_inode_dirty(inode); 		return 0; 	} 	/* 	 * Release i_data_sem so that we can lock a page - page lock ranks 	 * above i_data_sem. i_mutex still protects us against file changes. 	 */ 	up_write(&iinfo->i_data_sem);  	page = find_or_create_page(inode->i_mapping, 0, GFP_NOFS); 	if (!page) 		return -ENOMEM;  	if (!PageUptodate(page)) { 		kaddr = kmap_atomic(page); 		memset(kaddr + iinfo->i_lenAlloc, 0x00, 		       PAGE_SIZE - iinfo->i_lenAlloc); 		memcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr, 			iinfo->i_lenAlloc); 		flush_dcache_page(page); 		SetPageUptodate(page); 		kunmap_atomic(kaddr); 	} 	down_write(&iinfo->i_data_sem); 	memset(iinfo->i_data + iinfo->i_lenEAttr, 0x00, 	       iinfo->i_lenAlloc); 	iinfo->i_lenAlloc = 0; 	if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD)) 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT; 	else 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG; 	/* from now on we have normal address_space methods */ 	inode->i_data.a_ops = &udf_aops; 	set_page_dirty(page); 	unlock_page(page); 	up_write(&iinfo->i_data_sem); 	err = filemap_fdatawrite(inode->i_mapping); 	if (err) { 		/* Restore everything back so that we don't lose data... */ 		lock_page(page); 		down_write(&iinfo->i_data_sem); 		kaddr = kmap_atomic(page); 		memcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size); 		kunmap_atomic(kaddr); 		unlock_page(page); 		iinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB; 		inode->i_data.a_ops = &udf_adinicb_aops; 		up_write(&iinfo->i_data_sem); 	} 	put_page(page); 	mark_inode_dirty(inode);  	return err; }"
"206815_CWE-125.c","CWE-125","static MagickBooleanType SetGrayscaleImage(Image *image,   ExceptionInfo *exception) {   CacheView     *image_view;    MagickBooleanType     status;    PixelInfo     *colormap;    register ssize_t     i;    ssize_t     *colormap_index,     j,     y;    assert(image != (Image *) NULL);   assert(image->signature == MagickCoreSignature);   if (image->type != GrayscaleType)     (void) TransformImageColorspace(image,GRAYColorspace,exception);   if (image->storage_class == PseudoClass)     colormap_index=(ssize_t *) AcquireQuantumMemory(image->colors+1,       sizeof(*colormap_index));   else     colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize+1,       sizeof(*colormap_index));   if (colormap_index == (ssize_t *) NULL)     ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",       image->filename);   if (image->storage_class != PseudoClass)     {       (void) memset(colormap_index,(-1),MaxColormapSize*         sizeof(*colormap_index));       if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)         {           colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);           ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",             image->filename);         }       image->colors=0;       status=MagickTrue;       image_view=AcquireAuthenticCacheView(image,exception); #if defined(MAGICKCORE_OPENMP_SUPPORT)       #pragma omp parallel for schedule(static) shared(status) \         magick_number_threads(image,image,image->rows,1) #endif       for (y=0; y < (ssize_t) image->rows; y++)       {         register Quantum           *magick_restrict q;          register ssize_t           x;          if (status == MagickFalse)           continue;         q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,           exception);         if (q == (Quantum *) NULL)           {             status=MagickFalse;             continue;           }         for (x=0; x < (ssize_t) image->columns; x++)         {           register size_t             intensity;            intensity=ScaleQuantumToMap(GetPixelRed(image,q));           if (colormap_index[intensity] < 0)             { #if defined(MAGICKCORE_OPENMP_SUPPORT)               #pragma omp critical (MagickCore_SetGrayscaleImage) #endif               if (colormap_index[intensity] < 0)                 {                   colormap_index[intensity]=(ssize_t) image->colors;                   image->colormap[image->colors].red=(double)                     GetPixelRed(image,q);                   image->colormap[image->colors].green=(double)                     GetPixelGreen(image,q);                   image->colormap[image->colors].blue=(double)                     GetPixelBlue(image,q);                   image->colors++;                }             }           SetPixelIndex(image,(Quantum) colormap_index[intensity],q);           q+=GetPixelChannels(image);         }         if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)           status=MagickFalse;       }       image_view=DestroyCacheView(image_view);     }   for (i=0; i < (ssize_t) image->colors; i++)     image->colormap[i].alpha=(double) i;   qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),     IntensityCompare);   colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));   if (colormap == (PixelInfo *) NULL)     {       colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);       ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",         image->filename);     }   j=0;   colormap[j]=image->colormap[0];   for (i=0; i < (ssize_t) image->colors; i++)   {     if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)       {         j++;         colormap[j]=image->colormap[i];       }     colormap_index[(ssize_t) image->colormap[i].alpha]=j;   }   image->colors=(size_t) (j+1);   image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);   image->colormap=colormap;   status=MagickTrue;   image_view=AcquireAuthenticCacheView(image,exception); #if defined(MAGICKCORE_OPENMP_SUPPORT)   #pragma omp parallel for schedule(static) shared(status) \     magick_number_threads(image,image,image->rows,1) #endif   for (y=0; y < (ssize_t) image->rows; y++)   {     register Quantum       *magick_restrict q;      register ssize_t       x;      if (status == MagickFalse)       continue;     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);     if (q == (Quantum *) NULL)       {         status=MagickFalse;         continue;       }     for (x=0; x < (ssize_t) image->columns; x++)     {       SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(         GetPixelIndex(image,q))],q);       q+=GetPixelChannels(image);     }     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)       status=MagickFalse;   }   image_view=DestroyCacheView(image_view);   colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);   image->type=GrayscaleType;   if (SetImageMonochrome(image,exception) != MagickFalse)     image->type=BilevelType;   return(status); }"
"206845_CWE-125.c","CWE-125","static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id) { 	int i; 	unsigned long h;  	h = id->iface; 	h = MULTIPLIER * h + id->device; 	h = MULTIPLIER * h + id->subdevice; 	for (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++) 		h = MULTIPLIER * h + id->name[i]; 	h = MULTIPLIER * h + id->index; 	h &= LONG_MAX; 	return h; }"
"206921_CWE-703.c","CWE-703","regmatch(     char_u	*scan,		    // Current node.     proftime_T	*tm UNUSED,	    // timeout limit or NULL     int		*timed_out UNUSED)  // flag set on timeout or NULL {   char_u	*next;		// Next node.   int		op;   int		c;   regitem_T	*rp;   int		no;   int		status;		// one of the RA_ values: #ifdef FEAT_RELTIME   int		tm_count = 0; #endif    // Make ""regstack"" and ""backpos"" empty.  They are allocated and freed in   // bt_regexec_both() to reduce malloc()/free() calls.   regstack.ga_len = 0;   backpos.ga_len = 0;    // Repeat until ""regstack"" is empty.   for (;;)   {     // Some patterns may take a long time to match, e.g., ""\([a-z]\+\)\+Q"".     // Allow interrupting them with CTRL-C.     fast_breakcheck();  #ifdef DEBUG     if (scan != NULL && regnarrate)     { 	mch_errmsg((char *)regprop(scan)); 	mch_errmsg(""(\n"");     } #endif      // Repeat for items that can be matched sequentially, without using the     // regstack.     for (;;)     { 	if (got_int || scan == NULL) 	{ 	    status = RA_FAIL; 	    break; 	} #ifdef FEAT_RELTIME 	// Check for timeout once in a 100 times to avoid overhead. 	if (tm != NULL && ++tm_count == 100) 	{ 	    tm_count = 0; 	    if (profile_passed_limit(tm)) 	    { 		if (timed_out != NULL) 		    *timed_out = TRUE; 		status = RA_FAIL; 		break; 	    } 	} #endif 	status = RA_CONT;  #ifdef DEBUG 	if (regnarrate) 	{ 	    mch_errmsg((char *)regprop(scan)); 	    mch_errmsg(""...\n""); # ifdef FEAT_SYN_HL 	    if (re_extmatch_in != NULL) 	    { 		int i;  		mch_errmsg(_(""External submatches:\n"")); 		for (i = 0; i < NSUBEXP; i++) 		{ 		    mch_errmsg(""    \""""); 		    if (re_extmatch_in->matches[i] != NULL) 			mch_errmsg((char *)re_extmatch_in->matches[i]); 		    mch_errmsg(""\""\n""); 		} 	    } # endif 	} #endif 	next = regnext(scan);  	op = OP(scan); 	// Check for character class with NL added. 	if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI 			     && *rex.input == NUL && rex.lnum <= rex.reg_maxline) 	{ 	    reg_nextline(); 	} 	else if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\n') 	{ 	    ADVANCE_REGINPUT(); 	} 	else 	{ 	  if (WITH_NL(op)) 	      op -= ADD_NL; 	  if (has_mbyte) 	      c = (*mb_ptr2char)(rex.input); 	  else 	      c = *rex.input; 	  switch (op) 	  { 	  case BOL: 	    if (rex.input != rex.line) 		status = RA_NOMATCH; 	    break;  	  case EOL: 	    if (c != NUL) 		status = RA_NOMATCH; 	    break;  	  case RE_BOF: 	    // We're not at the beginning of the file when below the first 	    // line where we started, not at the start of the line or we 	    // didn't start at the first line of the buffer. 	    if (rex.lnum != 0 || rex.input != rex.line 				       || (REG_MULTI && rex.reg_firstlnum > 1)) 		status = RA_NOMATCH; 	    break;  	  case RE_EOF: 	    if (rex.lnum != rex.reg_maxline || c != NUL) 		status = RA_NOMATCH; 	    break;  	  case CURSOR: 	    // Check if the buffer is in a window and compare the 	    // rex.reg_win->w_cursor position to the match position. 	    if (rex.reg_win == NULL 		    || (rex.lnum + rex.reg_firstlnum 						 != rex.reg_win->w_cursor.lnum) 		    || ((colnr_T)(rex.input - rex.line) 						 != rex.reg_win->w_cursor.col)) 		status = RA_NOMATCH; 	    break;  	  case RE_MARK: 	    // Compare the mark position to the match position. 	    { 		int	mark = OPERAND(scan)[0]; 		int	cmp = OPERAND(scan)[1]; 		pos_T	*pos;  		pos = getmark_buf(rex.reg_buf, mark, FALSE); 		if (pos == NULL		     // mark doesn't exist 			|| pos->lnum <= 0)   // mark isn't set in reg_buf 		{ 		    status = RA_NOMATCH; 		} 		else 		{ 		    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum 							  && pos->col == MAXCOL 				      ? (colnr_T)STRLEN(reg_getline( 						pos->lnum - rex.reg_firstlnum)) 				      : pos->col;  		    if ((pos->lnum == rex.lnum + rex.reg_firstlnum 				? (pos_col == (colnr_T)(rex.input - rex.line) 				    ? (cmp == '<' || cmp == '>') 				    : (pos_col < (colnr_T)(rex.input - rex.line) 					? cmp != '>' 					: cmp != '<')) 				: (pos->lnum < rex.lnum + rex.reg_firstlnum 				    ? cmp != '>' 				    : cmp != '<'))) 		    status = RA_NOMATCH; 		} 	    } 	    break;  	  case RE_VISUAL: 	    if (!reg_match_visual()) 		status = RA_NOMATCH; 	    break;  	  case RE_LNUM: 	    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum), 									scan)) 		status = RA_NOMATCH; 	    break;  	  case RE_COL: 	    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan)) 		status = RA_NOMATCH; 	    break;  	  case RE_VCOL: 	    if (!re_num_cmp((long_u)win_linetabsize( 			    rex.reg_win == NULL ? curwin : rex.reg_win, 			    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan)) 		status = RA_NOMATCH; 	    break;  	  case BOW:	// \<word; rex.input points to w 	    if (c == NUL)	// Can't match at end of line 		status = RA_NOMATCH; 	    else if (has_mbyte) 	    { 		int this_class;  		// Get class of current and previous char (if it exists). 		this_class = mb_get_class_buf(rex.input, rex.reg_buf); 		if (this_class <= 1) 		    status = RA_NOMATCH;  // not on a word at all 		else if (reg_prev_class() == this_class) 		    status = RA_NOMATCH;  // previous char is in same word 	    } 	    else 	    { 		if (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line 				&& vim_iswordc_buf(rex.input[-1], rex.reg_buf))) 		    status = RA_NOMATCH; 	    } 	    break;  	  case EOW:	// word\>; rex.input points after d 	    if (rex.input == rex.line)    // Can't match at start of line 		status = RA_NOMATCH; 	    else if (has_mbyte) 	    { 		int this_class, prev_class;  		// Get class of current and previous char (if it exists). 		this_class = mb_get_class_buf(rex.input, rex.reg_buf); 		prev_class = reg_prev_class(); 		if (this_class == prev_class 			|| prev_class == 0 || prev_class == 1) 		    status = RA_NOMATCH; 	    } 	    else 	    { 		if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf) 			|| (rex.input[0] != NUL 					   && vim_iswordc_buf(c, rex.reg_buf))) 		    status = RA_NOMATCH; 	    } 	    break; // Matched with EOW  	  case ANY: 	    // ANY does not match new lines. 	    if (c == NUL) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case IDENT: 	    if (!vim_isIDc(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SIDENT: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case KWORD: 	    if (!vim_iswordp_buf(rex.input, rex.reg_buf)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SKWORD: 	    if (VIM_ISDIGIT(*rex.input) 				    || !vim_iswordp_buf(rex.input, rex.reg_buf)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case FNAME: 	    if (!vim_isfilec(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SFNAME: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case PRINT: 	    if (!vim_isprintc(PTR2CHAR(rex.input))) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case SPRINT: 	    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input))) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case WHITE: 	    if (!VIM_ISWHITE(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NWHITE: 	    if (c == NUL || VIM_ISWHITE(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case DIGIT: 	    if (!ri_digit(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NDIGIT: 	    if (c == NUL || ri_digit(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case HEX: 	    if (!ri_hex(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NHEX: 	    if (c == NUL || ri_hex(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case OCTAL: 	    if (!ri_octal(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NOCTAL: 	    if (c == NUL || ri_octal(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case WORD: 	    if (!ri_word(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NWORD: 	    if (c == NUL || ri_word(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case HEAD: 	    if (!ri_head(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NHEAD: 	    if (c == NUL || ri_head(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case ALPHA: 	    if (!ri_alpha(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NALPHA: 	    if (c == NUL || ri_alpha(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case LOWER: 	    if (!ri_lower(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NLOWER: 	    if (c == NUL || ri_lower(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case UPPER: 	    if (!ri_upper(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case NUPPER: 	    if (c == NUL || ri_upper(c)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case EXACTLY: 	    { 		int	len; 		char_u	*opnd;  		opnd = OPERAND(scan); 		// Inline the first byte, for speed. 		if (*opnd != *rex.input 			&& (!rex.reg_ic 			    || (!enc_utf8 			      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input)))) 		    status = RA_NOMATCH; 		else if (*opnd == NUL) 		{ 		    // match empty string always works; happens when ""~"" is 		    // empty. 		} 		else 		{ 		    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic)) 		    { 			len = 1;	// matched a single byte above 		    } 		    else 		    { 			// Need to match first byte again for multi-byte. 			len = (int)STRLEN(opnd); 			if (cstrncmp(opnd, rex.input, &len) != 0) 			    status = RA_NOMATCH; 		    } 		    // Check for following composing character, unless %C 		    // follows (skips over all composing chars). 		    if (status != RA_NOMATCH 			    && enc_utf8 			    && UTF_COMPOSINGLIKE(rex.input, rex.input + len) 			    && !rex.reg_icombine 			    && OP(next) != RE_COMPOSING) 		    { 			// raaron: This code makes a composing character get 			// ignored, which is the correct behavior (sometimes) 			// for voweled Hebrew texts. 			status = RA_NOMATCH; 		    } 		    if (status != RA_NOMATCH) 			rex.input += len; 		} 	    } 	    break;  	  case ANYOF: 	  case ANYBUT: 	    if (c == NUL) 		status = RA_NOMATCH; 	    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF)) 		status = RA_NOMATCH; 	    else 		ADVANCE_REGINPUT(); 	    break;  	  case MULTIBYTECODE: 	    if (has_mbyte) 	    { 		int	i, len; 		char_u	*opnd; 		int	opndc = 0, inpc;  		opnd = OPERAND(scan); 		// Safety check (just in case 'encoding' was changed since 		// compiling the program). 		if ((len = (*mb_ptr2len)(opnd)) < 2) 		{ 		    status = RA_NOMATCH; 		    break; 		} 		if (enc_utf8) 		    opndc = utf_ptr2char(opnd); 		if (enc_utf8 && utf_iscomposing(opndc)) 		{ 		    // When only a composing char is given match at any 		    // position where that composing char appears. 		    status = RA_NOMATCH; 		    for (i = 0; rex.input[i] != NUL; 						i += utf_ptr2len(rex.input + i)) 		    { 			inpc = utf_ptr2char(rex.input + i); 			if (!utf_iscomposing(inpc)) 			{ 			    if (i > 0) 				break; 			} 			else if (opndc == inpc) 			{ 			    // Include all following composing chars. 			    len = i + utfc_ptr2len(rex.input + i); 			    status = RA_MATCH; 			    break; 			} 		    } 		} 		else 		    for (i = 0; i < len; ++i) 			if (opnd[i] != rex.input[i]) 			{ 			    status = RA_NOMATCH; 			    break; 			} 		rex.input += len; 	    } 	    else 		status = RA_NOMATCH; 	    break; 	  case RE_COMPOSING: 	    if (enc_utf8) 	    { 		// Skip composing characters. 		while (utf_iscomposing(utf_ptr2char(rex.input))) 		    MB_CPTR_ADV(rex.input); 	    } 	    break;  	  case NOTHING: 	    break;  	  case BACK: 	    { 		int		i; 		backpos_T	*bp;  		// When we run into BACK we need to check if we don't keep 		// looping without matching any input.  The second and later 		// times a BACK is encountered it fails if the input is still 		// at the same position as the previous time. 		// The positions are stored in ""backpos"" and found by the 		// current value of ""scan"", the position in the RE program. 		bp = (backpos_T *)backpos.ga_data; 		for (i = 0; i < backpos.ga_len; ++i) 		    if (bp[i].bp_scan == scan) 			break; 		if (i == backpos.ga_len) 		{ 		    // First time at this BACK, make room to store the pos. 		    if (ga_grow(&backpos, 1) == FAIL) 			status = RA_FAIL; 		    else 		    { 			// get ""ga_data"" again, it may have changed 			bp = (backpos_T *)backpos.ga_data; 			bp[i].bp_scan = scan; 			++backpos.ga_len; 		    } 		} 		else if (reg_save_equal(&bp[i].bp_pos)) 		    // Still at same position as last time, fail. 		    status = RA_NOMATCH;  		if (status != RA_FAIL && status != RA_NOMATCH) 		    reg_save(&bp[i].bp_pos, &backpos); 	    } 	    break;  	  case MOPEN + 0:   // Match start: \zs 	  case MOPEN + 1:   // \( 	  case MOPEN + 2: 	  case MOPEN + 3: 	  case MOPEN + 4: 	  case MOPEN + 5: 	  case MOPEN + 6: 	  case MOPEN + 7: 	  case MOPEN + 8: 	  case MOPEN + 9: 	    { 		no = op - MOPEN; 		cleanup_subexpr(); 		rp = regstack_push(RS_MOPEN, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no], 							  &rex.reg_startp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break;  	  case NOPEN:	    // \%( 	  case NCLOSE:	    // \) after \%( 		if (regstack_push(RS_NOPEN, scan) == NULL) 		    status = RA_FAIL; 		// We simply continue and handle the result when done. 		break;  #ifdef FEAT_SYN_HL 	  case ZOPEN + 1: 	  case ZOPEN + 2: 	  case ZOPEN + 3: 	  case ZOPEN + 4: 	  case ZOPEN + 5: 	  case ZOPEN + 6: 	  case ZOPEN + 7: 	  case ZOPEN + 8: 	  case ZOPEN + 9: 	    { 		no = op - ZOPEN; 		cleanup_zsubexpr(); 		rp = regstack_push(RS_ZOPEN, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &reg_startzpos[no], 							     &reg_startzp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break; #endif  	  case MCLOSE + 0:  // Match end: \ze 	  case MCLOSE + 1:  // \) 	  case MCLOSE + 2: 	  case MCLOSE + 3: 	  case MCLOSE + 4: 	  case MCLOSE + 5: 	  case MCLOSE + 6: 	  case MCLOSE + 7: 	  case MCLOSE + 8: 	  case MCLOSE + 9: 	    { 		no = op - MCLOSE; 		cleanup_subexpr(); 		rp = regstack_push(RS_MCLOSE, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no], 							    &rex.reg_endp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break;  #ifdef FEAT_SYN_HL 	  case ZCLOSE + 1:  // \) after \z( 	  case ZCLOSE + 2: 	  case ZCLOSE + 3: 	  case ZCLOSE + 4: 	  case ZCLOSE + 5: 	  case ZCLOSE + 6: 	  case ZCLOSE + 7: 	  case ZCLOSE + 8: 	  case ZCLOSE + 9: 	    { 		no = op - ZCLOSE; 		cleanup_zsubexpr(); 		rp = regstack_push(RS_ZCLOSE, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    rp->rs_no = no; 		    save_se(&rp->rs_un.sesave, &reg_endzpos[no], 							      &reg_endzp[no]); 		    // We simply continue and handle the result when done. 		} 	    } 	    break; #endif  	  case BACKREF + 1: 	  case BACKREF + 2: 	  case BACKREF + 3: 	  case BACKREF + 4: 	  case BACKREF + 5: 	  case BACKREF + 6: 	  case BACKREF + 7: 	  case BACKREF + 8: 	  case BACKREF + 9: 	    { 		int		len;  		no = op - BACKREF; 		cleanup_subexpr(); 		if (!REG_MULTI)		// Single-line regexp 		{ 		    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL) 		    { 			// Backref was not set: Match an empty string. 			len = 0; 		    } 		    else 		    { 			// Compare current input with back-ref in the same 			// line. 			len = (int)(rex.reg_endp[no] - rex.reg_startp[no]); 			if (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0) 			    status = RA_NOMATCH; 		    } 		} 		else				// Multi-line regexp 		{ 		    if (rex.reg_startpos[no].lnum < 0 						|| rex.reg_endpos[no].lnum < 0) 		    { 			// Backref was not set: Match an empty string. 			len = 0; 		    } 		    else 		    { 			if (rex.reg_startpos[no].lnum == rex.lnum 				&& rex.reg_endpos[no].lnum == rex.lnum) 			{ 			    // Compare back-ref within the current line. 			    len = rex.reg_endpos[no].col 						    - rex.reg_startpos[no].col; 			    if (cstrncmp(rex.line + rex.reg_startpos[no].col, 							  rex.input, &len) != 0) 				status = RA_NOMATCH; 			} 			else 			{ 			    // Messy situation: Need to compare between two 			    // lines. 			    int r = match_with_backref( 					    rex.reg_startpos[no].lnum, 					    rex.reg_startpos[no].col, 					    rex.reg_endpos[no].lnum, 					    rex.reg_endpos[no].col, 					    &len);  			    if (r != RA_MATCH) 				status = r; 			} 		    } 		}  		// Matched the backref, skip over it. 		rex.input += len; 	    } 	    break;  #ifdef FEAT_SYN_HL 	  case ZREF + 1: 	  case ZREF + 2: 	  case ZREF + 3: 	  case ZREF + 4: 	  case ZREF + 5: 	  case ZREF + 6: 	  case ZREF + 7: 	  case ZREF + 8: 	  case ZREF + 9: 	    { 		int	len;  		cleanup_zsubexpr(); 		no = op - ZREF; 		if (re_extmatch_in != NULL 			&& re_extmatch_in->matches[no] != NULL) 		{ 		    len = (int)STRLEN(re_extmatch_in->matches[no]); 		    if (cstrncmp(re_extmatch_in->matches[no], 							  rex.input, &len) != 0) 			status = RA_NOMATCH; 		    else 			rex.input += len; 		} 		else 		{ 		    // Backref was not set: Match an empty string. 		} 	    } 	    break; #endif  	  case BRANCH: 	    { 		if (OP(next) != BRANCH) // No choice. 		    next = OPERAND(scan);	// Avoid recursion. 		else 		{ 		    rp = regstack_push(RS_BRANCH, scan); 		    if (rp == NULL) 			status = RA_FAIL; 		    else 			status = RA_BREAK;	// rest is below 		} 	    } 	    break;  	  case BRACE_LIMITS: 	    { 		if (OP(next) == BRACE_SIMPLE) 		{ 		    bl_minval = OPERAND_MIN(scan); 		    bl_maxval = OPERAND_MAX(scan); 		} 		else if (OP(next) >= BRACE_COMPLEX 			&& OP(next) < BRACE_COMPLEX + 10) 		{ 		    no = OP(next) - BRACE_COMPLEX; 		    brace_min[no] = OPERAND_MIN(scan); 		    brace_max[no] = OPERAND_MAX(scan); 		    brace_count[no] = 0; 		} 		else 		{ 		    internal_error(""BRACE_LIMITS""); 		    status = RA_FAIL; 		} 	    } 	    break;  	  case BRACE_COMPLEX + 0: 	  case BRACE_COMPLEX + 1: 	  case BRACE_COMPLEX + 2: 	  case BRACE_COMPLEX + 3: 	  case BRACE_COMPLEX + 4: 	  case BRACE_COMPLEX + 5: 	  case BRACE_COMPLEX + 6: 	  case BRACE_COMPLEX + 7: 	  case BRACE_COMPLEX + 8: 	  case BRACE_COMPLEX + 9: 	    { 		no = op - BRACE_COMPLEX; 		++brace_count[no];  		// If not matched enough times yet, try one more 		if (brace_count[no] <= (brace_min[no] <= brace_max[no] 					     ? brace_min[no] : brace_max[no])) 		{ 		    rp = regstack_push(RS_BRCPLX_MORE, scan); 		    if (rp == NULL) 			status = RA_FAIL; 		    else 		    { 			rp->rs_no = no; 			reg_save(&rp->rs_un.regsave, &backpos); 			next = OPERAND(scan); 			// We continue and handle the result when done. 		    } 		    break; 		}  		// If matched enough times, may try matching some more 		if (brace_min[no] <= brace_max[no]) 		{ 		    // Range is the normal way around, use longest match 		    if (brace_count[no] <= brace_max[no]) 		    { 			rp = regstack_push(RS_BRCPLX_LONG, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    rp->rs_no = no; 			    reg_save(&rp->rs_un.regsave, &backpos); 			    next = OPERAND(scan); 			    // We continue and handle the result when done. 			} 		    } 		} 		else 		{ 		    // Range is backwards, use shortest match first 		    if (brace_count[no] <= brace_min[no]) 		    { 			rp = regstack_push(RS_BRCPLX_SHORT, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    reg_save(&rp->rs_un.regsave, &backpos); 			    // We continue and handle the result when done. 			} 		    } 		} 	    } 	    break;  	  case BRACE_SIMPLE: 	  case STAR: 	  case PLUS: 	    { 		regstar_T	rst;  		// Lookahead to avoid useless match attempts when we know 		// what character comes next. 		if (OP(next) == EXACTLY) 		{ 		    rst.nextb = *OPERAND(next); 		    if (rex.reg_ic) 		    { 			if (MB_ISUPPER(rst.nextb)) 			    rst.nextb_ic = MB_TOLOWER(rst.nextb); 			else 			    rst.nextb_ic = MB_TOUPPER(rst.nextb); 		    } 		    else 			rst.nextb_ic = rst.nextb; 		} 		else 		{ 		    rst.nextb = NUL; 		    rst.nextb_ic = NUL; 		} 		if (op != BRACE_SIMPLE) 		{ 		    rst.minval = (op == STAR) ? 0 : 1; 		    rst.maxval = MAX_LIMIT; 		} 		else 		{ 		    rst.minval = bl_minval; 		    rst.maxval = bl_maxval; 		}  		// When maxval > minval, try matching as much as possible, up 		// to maxval.  When maxval < minval, try matching at least the 		// minimal number (since the range is backwards, that's also 		// maxval!). 		rst.count = regrepeat(OPERAND(scan), rst.maxval); 		if (got_int) 		{ 		    status = RA_FAIL; 		    break; 		} 		if (rst.minval <= rst.maxval 			  ? rst.count >= rst.minval : rst.count >= rst.maxval) 		{ 		    // It could match.  Prepare for trying to match what 		    // follows.  The code is below.  Parameters are stored in 		    // a regstar_T on the regstack. 		    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) 		    { 			emsg(_(e_pattern_uses_more_memory_than_maxmempattern)); 			status = RA_FAIL; 		    } 		    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL) 			status = RA_FAIL; 		    else 		    { 			regstack.ga_len += sizeof(regstar_T); 			rp = regstack_push(rst.minval <= rst.maxval 					? RS_STAR_LONG : RS_STAR_SHORT, scan); 			if (rp == NULL) 			    status = RA_FAIL; 			else 			{ 			    *(((regstar_T *)rp) - 1) = rst; 			    status = RA_BREAK;	    // skip the restore bits 			} 		    } 		} 		else 		    status = RA_NOMATCH;  	    } 	    break;  	  case NOMATCH: 	  case MATCH: 	  case SUBPAT: 	    rp = regstack_push(RS_NOMATCH, scan); 	    if (rp == NULL) 		status = RA_FAIL; 	    else 	    { 		rp->rs_no = op; 		reg_save(&rp->rs_un.regsave, &backpos); 		next = OPERAND(scan); 		// We continue and handle the result when done. 	    } 	    break;  	  case BEHIND: 	  case NOBEHIND: 	    // Need a bit of room to store extra positions. 	    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) 	    { 		emsg(_(e_pattern_uses_more_memory_than_maxmempattern)); 		status = RA_FAIL; 	    } 	    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL) 		status = RA_FAIL; 	    else 	    { 		regstack.ga_len += sizeof(regbehind_T); 		rp = regstack_push(RS_BEHIND1, scan); 		if (rp == NULL) 		    status = RA_FAIL; 		else 		{ 		    // Need to save the subexpr to be able to restore them 		    // when there is a match but we don't use it. 		    save_subexpr(((regbehind_T *)rp) - 1);  		    rp->rs_no = op; 		    reg_save(&rp->rs_un.regsave, &backpos); 		    // First try if what follows matches.  If it does then we 		    // check the behind match by looping. 		} 	    } 	    break;  	  case BHPOS: 	    if (REG_MULTI) 	    { 		if (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line) 			|| behind_pos.rs_u.pos.lnum != rex.lnum) 		    status = RA_NOMATCH; 	    } 	    else if (behind_pos.rs_u.ptr != rex.input) 		status = RA_NOMATCH; 	    break;  	  case NEWL: 	    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline 			     || rex.reg_line_lbr) 					   && (c != '\n' || !rex.reg_line_lbr)) 		status = RA_NOMATCH; 	    else if (rex.reg_line_lbr) 		ADVANCE_REGINPUT(); 	    else 		reg_nextline(); 	    break;  	  case END: 	    status = RA_MATCH;	// Success! 	    break;  	  default: 	    iemsg(_(e_corrupted_regexp_program)); #ifdef DEBUG 	    printf(""Illegal op code %d\n"", op); #endif 	    status = RA_FAIL; 	    break; 	  } 	}  	// If we can't continue sequentially, break the inner loop. 	if (status != RA_CONT) 	    break;  	// Continue in inner loop, advance to next item. 	scan = next;      } // end of inner loop      // If there is something on the regstack execute the code for the state.     // If the state is popped then loop and use the older state.     while (regstack.ga_len > 0 && status != RA_FAIL)     { 	rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1; 	switch (rp->rs_state) 	{ 	  case RS_NOPEN: 	    // Result is passed on as-is, simply pop the state. 	    regstack_pop(&scan); 	    break;  	  case RS_MOPEN: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no], 						  &rex.reg_startp[rp->rs_no]); 	    regstack_pop(&scan); 	    break;  #ifdef FEAT_SYN_HL 	  case RS_ZOPEN: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no], 						 &reg_startzp[rp->rs_no]); 	    regstack_pop(&scan); 	    break; #endif  	  case RS_MCLOSE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no], 						    &rex.reg_endp[rp->rs_no]); 	    regstack_pop(&scan); 	    break;  #ifdef FEAT_SYN_HL 	  case RS_ZCLOSE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no], 						   &reg_endzp[rp->rs_no]); 	    regstack_pop(&scan); 	    break; #endif  	  case RS_BRANCH: 	    if (status == RA_MATCH) 		// this branch matched, use it 		regstack_pop(&scan); 	    else 	    { 		if (status != RA_BREAK) 		{ 		    // After a non-matching branch: try next one. 		    reg_restore(&rp->rs_un.regsave, &backpos); 		    scan = rp->rs_scan; 		} 		if (scan == NULL || OP(scan) != BRANCH) 		{ 		    // no more branches, didn't find a match 		    status = RA_NOMATCH; 		    regstack_pop(&scan); 		} 		else 		{ 		    // Prepare to try a branch. 		    rp->rs_scan = regnext(scan); 		    reg_save(&rp->rs_un.regsave, &backpos); 		    scan = OPERAND(scan); 		} 	    } 	    break;  	  case RS_BRCPLX_MORE: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 	    { 		reg_restore(&rp->rs_un.regsave, &backpos); 		--brace_count[rp->rs_no];	// decrement match count 	    } 	    regstack_pop(&scan); 	    break;  	  case RS_BRCPLX_LONG: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 	    { 		// There was no match, but we did find enough matches. 		reg_restore(&rp->rs_un.regsave, &backpos); 		--brace_count[rp->rs_no]; 		// continue with the items after ""\{}"" 		status = RA_CONT; 	    } 	    regstack_pop(&scan); 	    if (status == RA_CONT) 		scan = regnext(scan); 	    break;  	  case RS_BRCPLX_SHORT: 	    // Pop the state.  Restore pointers when there is no match. 	    if (status == RA_NOMATCH) 		// There was no match, try to match one more item. 		reg_restore(&rp->rs_un.regsave, &backpos); 	    regstack_pop(&scan); 	    if (status == RA_NOMATCH) 	    { 		scan = OPERAND(scan); 		status = RA_CONT; 	    } 	    break;  	  case RS_NOMATCH: 	    // Pop the state.  If the operand matches for NOMATCH or 	    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup, 	    // except for SUBPAT, and continue with the next item. 	    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH)) 		status = RA_NOMATCH; 	    else 	    { 		status = RA_CONT; 		if (rp->rs_no != SUBPAT)	// zero-width 		    reg_restore(&rp->rs_un.regsave, &backpos); 	    } 	    regstack_pop(&scan); 	    if (status == RA_CONT) 		scan = regnext(scan); 	    break;  	  case RS_BEHIND1: 	    if (status == RA_NOMATCH) 	    { 		regstack_pop(&scan); 		regstack.ga_len -= sizeof(regbehind_T); 	    } 	    else 	    { 		// The stuff after BEHIND/NOBEHIND matches.  Now try if 		// the behind part does (not) match before the current 		// position in the input.  This must be done at every 		// position in the input and checking if the match ends at 		// the current position.  		// save the position after the found match for next 		reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);  		// Start looking for a match with operand at the current 		// position.  Go back one character until we find the 		// result, hitting the start of the line or the previous 		// line (for multi-line matching). 		// Set behind_pos to where the match should end, BHPOS 		// will match it.  Save the current value. 		(((regbehind_T *)rp) - 1)->save_behind = behind_pos; 		behind_pos = rp->rs_un.regsave;  		rp->rs_state = RS_BEHIND2;  		reg_restore(&rp->rs_un.regsave, &backpos); 		scan = OPERAND(rp->rs_scan) + 4; 	    } 	    break;  	  case RS_BEHIND2: 	    // Looping for BEHIND / NOBEHIND match. 	    if (status == RA_MATCH && reg_save_equal(&behind_pos)) 	    { 		// found a match that ends where ""next"" started 		behind_pos = (((regbehind_T *)rp) - 1)->save_behind; 		if (rp->rs_no == BEHIND) 		    reg_restore(&(((regbehind_T *)rp) - 1)->save_after, 								    &backpos); 		else 		{ 		    // But we didn't want a match.  Need to restore the 		    // subexpr, because what follows matched, so they have 		    // been set. 		    status = RA_NOMATCH; 		    restore_subexpr(((regbehind_T *)rp) - 1); 		} 		regstack_pop(&scan); 		regstack.ga_len -= sizeof(regbehind_T); 	    } 	    else 	    { 		long limit;  		// No match or a match that doesn't end where we want it: Go 		// back one character.  May go to previous line once. 		no = OK; 		limit = OPERAND_MIN(rp->rs_scan); 		if (REG_MULTI) 		{ 		    if (limit > 0 			    && ((rp->rs_un.regsave.rs_u.pos.lnum 						    < behind_pos.rs_u.pos.lnum 				    ? (colnr_T)STRLEN(rex.line) 				    : behind_pos.rs_u.pos.col) 				- rp->rs_un.regsave.rs_u.pos.col >= limit)) 			no = FAIL; 		    else if (rp->rs_un.regsave.rs_u.pos.col == 0) 		    { 			if (rp->rs_un.regsave.rs_u.pos.lnum 					< behind_pos.rs_u.pos.lnum 				|| reg_getline( 					--rp->rs_un.regsave.rs_u.pos.lnum) 								  == NULL) 			    no = FAIL; 			else 			{ 			    reg_restore(&rp->rs_un.regsave, &backpos); 			    rp->rs_un.regsave.rs_u.pos.col = 						 (colnr_T)STRLEN(rex.line); 			} 		    } 		    else 		    { 			if (has_mbyte) 			{ 			    char_u *line = 				  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);  			    rp->rs_un.regsave.rs_u.pos.col -= 				(*mb_head_off)(line, line 				    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1; 			} 			else 			    --rp->rs_un.regsave.rs_u.pos.col; 		    } 		} 		else 		{ 		    if (rp->rs_un.regsave.rs_u.ptr == rex.line) 			no = FAIL; 		    else 		    { 			MB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr); 			if (limit > 0 && (long)(behind_pos.rs_u.ptr 				     - rp->rs_un.regsave.rs_u.ptr) > limit) 			    no = FAIL; 		    } 		} 		if (no == OK) 		{ 		    // Advanced, prepare for finding match again. 		    reg_restore(&rp->rs_un.regsave, &backpos); 		    scan = OPERAND(rp->rs_scan) + 4; 		    if (status == RA_MATCH) 		    { 			// We did match, so subexpr may have been changed, 			// need to restore them for the next try. 			status = RA_NOMATCH; 			restore_subexpr(((regbehind_T *)rp) - 1); 		    } 		} 		else 		{ 		    // Can't advance.  For NOBEHIND that's a match. 		    behind_pos = (((regbehind_T *)rp) - 1)->save_behind; 		    if (rp->rs_no == NOBEHIND) 		    { 			reg_restore(&(((regbehind_T *)rp) - 1)->save_after, 								    &backpos); 			status = RA_MATCH; 		    } 		    else 		    { 			// We do want a proper match.  Need to restore the 			// subexpr if we had a match, because they may have 			// been set. 			if (status == RA_MATCH) 			{ 			    status = RA_NOMATCH; 			    restore_subexpr(((regbehind_T *)rp) - 1); 			} 		    } 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regbehind_T); 		} 	    } 	    break;  	  case RS_STAR_LONG: 	  case RS_STAR_SHORT: 	    { 		regstar_T	    *rst = ((regstar_T *)rp) - 1;  		if (status == RA_MATCH) 		{ 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regstar_T); 		    break; 		}  		// Tried once already, restore input pointers. 		if (status != RA_BREAK) 		    reg_restore(&rp->rs_un.regsave, &backpos);  		// Repeat until we found a position where it could match. 		for (;;) 		{ 		    if (status != RA_BREAK) 		    { 			// Tried first position already, advance. 			if (rp->rs_state == RS_STAR_LONG) 			{ 			    // Trying for longest match, but couldn't or 			    // didn't match -- back up one char. 			    if (--rst->count < rst->minval) 				break; 			    if (rex.input == rex.line) 			    { 				// backup to last char of previous line 				--rex.lnum; 				rex.line = reg_getline(rex.lnum); 				// Just in case regrepeat() didn't count 				// right. 				if (rex.line == NULL) 				    break; 				rex.input = rex.line + STRLEN(rex.line); 				fast_breakcheck(); 			    } 			    else 				MB_PTR_BACK(rex.line, rex.input); 			} 			else 			{ 			    // Range is backwards, use shortest match first. 			    // Careful: maxval and minval are exchanged! 			    // Couldn't or didn't match: try advancing one 			    // char. 			    if (rst->count == rst->minval 				  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0) 				break; 			    ++rst->count; 			} 			if (got_int) 			    break; 		    } 		    else 			status = RA_NOMATCH;  		    // If it could match, try it. 		    if (rst->nextb == NUL || *rex.input == rst->nextb 					     || *rex.input == rst->nextb_ic) 		    { 			reg_save(&rp->rs_un.regsave, &backpos); 			scan = regnext(rp->rs_scan); 			status = RA_CONT; 			break; 		    } 		} 		if (status != RA_CONT) 		{ 		    // Failed. 		    regstack_pop(&scan); 		    regstack.ga_len -= sizeof(regstar_T); 		    status = RA_NOMATCH; 		} 	    } 	    break; 	}  	// If we want to continue the inner loop or didn't pop a state 	// continue matching loop 	if (status == RA_CONT || rp == (regitem_T *) 			     ((char *)regstack.ga_data + regstack.ga_len) - 1) 	    break;     }      // May need to continue with the inner loop, starting at ""scan"".     if (status == RA_CONT) 	continue;      // If the regstack is empty or something failed we are done.     if (regstack.ga_len == 0 || status == RA_FAIL)     { 	if (scan == NULL) 	{ 	    // We get here only if there's trouble -- normally ""case END"" is 	    // the terminating point. 	    iemsg(_(e_corrupted_regexp_program)); #ifdef DEBUG 	    printf(""Premature EOL\n""); #endif 	} 	return (status == RA_MATCH);     }    } // End of loop until the regstack is empty.    // NOTREACHED }"
"206942_CWE-125.c","CWE-125","eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate) {     char_u	*p;     char_u	*end;     int		extra = interpolate ? 1 : 0;     int		off = interpolate ? 0 : 1;     int		len;      // Find the end of the string, skipping backslashed characters.     for (p = *arg + off; *p != NUL && *p != '""'; MB_PTR_ADV(p))     { 	if (*p == '\\' && p[1] != NUL) 	{ 	    ++p; 	    // A ""\<x>"" form occupies at least 4 characters, and produces up 	    // to 9 characters (6 for the char and 3 for a modifier): 	    // reserve space for 5 extra. 	    if (*p == '<') 		extra += 5; 	} 	else if (interpolate && (*p == '{' || *p == '}')) 	{ 	    if (*p == '{' && p[1] != '{') // start of expression 		break; 	    ++p; 	    if (p[-1] == '}' && *p != '}') // single '}' is an error 	    { 		semsg(_(e_stray_closing_curly_str), *arg); 		return FAIL; 	    } 	    --extra;  // ""{{"" becomes ""{"", ""}}"" becomes ""}"" 	}     }      if (*p != '""' && !(interpolate && *p == '{'))     { 	semsg(_(e_missing_double_quote_str), *arg); 	return FAIL;     }      // If only parsing, set *arg and return here     if (!evaluate)     { 	*arg = p + off; 	return OK;     }      // Copy the string into allocated memory, handling backslashed     // characters.     rettv->v_type = VAR_STRING;     len = (int)(p - *arg + extra);     rettv->vval.v_string = alloc(len);     if (rettv->vval.v_string == NULL) 	return FAIL;     end = rettv->vval.v_string;      for (p = *arg + off; *p != NUL && *p != '""'; )     { 	if (*p == '\\') 	{ 	    switch (*++p) 	    { 		case 'b': *end++ = BS; ++p; break; 		case 'e': *end++ = ESC; ++p; break; 		case 'f': *end++ = FF; ++p; break; 		case 'n': *end++ = NL; ++p; break; 		case 'r': *end++ = CAR; ++p; break; 		case 't': *end++ = TAB; ++p; break;  		case 'X': // hex: ""\x1"", ""\x12"" 		case 'x': 		case 'u': // Unicode: ""\u0023"" 		case 'U': 			  if (vim_isxdigit(p[1])) 			  { 			      int	n, nr; 			      int	c = toupper(*p);  			      if (c == 'X') 				  n = 2; 			      else if (*p == 'u') 				  n = 4; 			      else 				  n = 8; 			      nr = 0; 			      while (--n >= 0 && vim_isxdigit(p[1])) 			      { 				  ++p; 				  nr = (nr << 4) + hex2nr(*p); 			      } 			      ++p; 			      // For ""\u"" store the number according to 			      // 'encoding'. 			      if (c != 'X') 				  end += (*mb_char2bytes)(nr, end); 			      else 				  *end++ = nr; 			  } 			  break;  			  // octal: ""\1"", ""\12"", ""\123"" 		case '0': 		case '1': 		case '2': 		case '3': 		case '4': 		case '5': 		case '6': 		case '7': *end = *p++ - '0'; 			  if (*p >= '0' && *p <= '7') 			  { 			      *end = (*end << 3) + *p++ - '0'; 			      if (*p >= '0' && *p <= '7') 				  *end = (*end << 3) + *p++ - '0'; 			  } 			  ++end; 			  break;  			  // Special key, e.g.: ""\<C-W>"" 		case '<': 			  { 			      int flags = FSK_KEYCODE | FSK_IN_STRING;  			      if (p[1] != '*') 				  flags |= FSK_SIMPLIFY; 			      extra = trans_special(&p, end, flags, FALSE, NULL); 			      if (extra != 0) 			      { 				  end += extra; 				  if (end >= rettv->vval.v_string + len) 				      iemsg(""eval_string() used more space than allocated""); 				  break; 			      } 			  } 			  // FALLTHROUGH  		default: MB_COPY_CHAR(p, end); 			  break; 	    } 	} 	else 	{ 	    if (interpolate && (*p == '{' || *p == '}')) 	    { 		if (*p == '{' && p[1] != '{') // start of expression 		    break; 		++p;  // reduce ""{{"" to ""{"" and ""}}"" to ""}"" 	    } 	    MB_COPY_CHAR(p, end); 	}     }     *end = NUL;     if (*p == '""' && !interpolate) 	++p;     *arg = p;      return OK; }"
"206946_CWE-703.c","CWE-703","cmdopts_t *cmdopts_parse(int argc, char **argv) { 	enum { 		CMDOPT_HELP = 0, 		CMDOPT_VERBOSE, 		CMDOPT_QUIET, 		CMDOPT_INFILE, 		CMDOPT_INFMT, 		CMDOPT_INOPT, 		CMDOPT_OUTFILE, 		CMDOPT_OUTFMT, 		CMDOPT_OUTOPT, 		CMDOPT_VERSION, 		CMDOPT_DEBUG, 		CMDOPT_CMPTNO, 		CMDOPT_SRGB, 		CMDOPT_MAXMEM, 		CMDOPT_LIST_ENABLED_CODECS, 		CMDOPT_LIST_ALL_CODECS, 		CMDOPT_ENABLE_FORMAT, 		CMDOPT_ENABLE_ALL_FORMATS, 	};  	static const jas_opt_t cmdoptions[] = { 		{CMDOPT_HELP, ""help"", 0}, 		{CMDOPT_VERBOSE, ""verbose"", 0}, 		{CMDOPT_QUIET, ""quiet"", 0}, 		{CMDOPT_QUIET, ""q"", 0}, 		{CMDOPT_INFILE, ""input"", JAS_OPT_HASARG}, 		{CMDOPT_INFILE, ""f"", JAS_OPT_HASARG}, 		{CMDOPT_INFMT, ""input-format"", JAS_OPT_HASARG}, 		{CMDOPT_INFMT, ""t"", JAS_OPT_HASARG}, 		{CMDOPT_INOPT, ""input-option"", JAS_OPT_HASARG}, 		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG}, 		{CMDOPT_OUTFILE, ""output"", JAS_OPT_HASARG}, 		{CMDOPT_OUTFILE, ""F"", JAS_OPT_HASARG}, 		{CMDOPT_OUTFMT, ""output-format"", JAS_OPT_HASARG}, 		{CMDOPT_OUTFMT, ""T"", JAS_OPT_HASARG}, 		{CMDOPT_OUTOPT, ""output-option"", JAS_OPT_HASARG}, 		{CMDOPT_OUTOPT, ""O"", JAS_OPT_HASARG}, 		{CMDOPT_VERSION, ""version"", 0}, 		{CMDOPT_DEBUG, ""debug-level"", JAS_OPT_HASARG}, 		{CMDOPT_CMPTNO, ""cmptno"", JAS_OPT_HASARG}, 		{CMDOPT_SRGB, ""force-srgb"", 0}, 		{CMDOPT_SRGB, ""S"", 0}, 		{CMDOPT_MAXMEM, ""memory-limit"", JAS_OPT_HASARG}, 		{CMDOPT_LIST_ENABLED_CODECS, ""list-enabled-formats"", 0}, 		{CMDOPT_LIST_ALL_CODECS, ""list-all-formats"", 0}, 		{CMDOPT_ENABLE_FORMAT, ""enable-format"", JAS_OPT_HASARG}, 		{CMDOPT_ENABLE_ALL_FORMATS, ""enable-all-formats"", 0}, 		{-1, 0, 0} 	};  	cmdopts_t *cmdopts; 	int c;  	if (!(cmdopts = malloc(sizeof(cmdopts_t)))) { 		fprintf(stderr, ""error: insufficient memory\n""); 		exit(EXIT_FAILURE); 	}  	cmdopts->infile = 0; 	cmdopts->infmt = -1; 	cmdopts->infmt_str = 0; 	cmdopts->inopts = 0; 	cmdopts->inoptsbuf[0] = '\0'; 	cmdopts->outfile = 0; 	cmdopts->outfmt = -1; 	cmdopts->outfmt_str = 0; 	cmdopts->outopts = 0; 	cmdopts->outoptsbuf[0] = '\0'; 	cmdopts->verbose = 0; 	cmdopts->version = 0; 	cmdopts->cmptno = -1; 	cmdopts->debug = 0; 	cmdopts->srgb = 0; 	cmdopts->list_codecs = 0; 	cmdopts->list_codecs_all = 0; 	cmdopts->help = 0; 	cmdopts->max_mem = get_default_max_mem_usage(); 	cmdopts->enable_format = 0; 	cmdopts->enable_all_formats = 0;  	while ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) { 		switch (c) { 		case CMDOPT_HELP: 			cmdopts->help = 1; 			break; 		case CMDOPT_VERBOSE: 			cmdopts->verbose = 1; 			break; 		case CMDOPT_QUIET: 			cmdopts->verbose = -1; 			break; 		case CMDOPT_VERSION: 			cmdopts->version = 1; 			break; 		case CMDOPT_LIST_ENABLED_CODECS: 			cmdopts->list_codecs = 1; 			cmdopts->list_codecs_all = 0; 			break; 		case CMDOPT_LIST_ALL_CODECS: 			cmdopts->list_codecs = 1; 			cmdopts->list_codecs_all = 1; 			break; 		case CMDOPT_DEBUG: 			cmdopts->debug = atoi(jas_optarg); 			break; 		case CMDOPT_INFILE: 			cmdopts->infile = jas_optarg; 			break; 		case CMDOPT_INFMT: 			cmdopts->infmt_str= jas_optarg; 			break; 		case CMDOPT_INOPT: 			addopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg); 			cmdopts->inopts = cmdopts->inoptsbuf; 			break; 		case CMDOPT_OUTFILE: 			cmdopts->outfile = jas_optarg; 			break; 		case CMDOPT_OUTFMT: 			cmdopts->outfmt_str = jas_optarg; 			break; 		case CMDOPT_OUTOPT: 			addopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg); 			cmdopts->outopts = cmdopts->outoptsbuf; 			break; 		case CMDOPT_CMPTNO: 			cmdopts->cmptno = atoi(jas_optarg); 			break; 		case CMDOPT_SRGB: 			cmdopts->srgb = 1; 			break; 		case CMDOPT_MAXMEM: 			cmdopts->max_mem = strtoull(jas_optarg, 0, 10); 			break; 		case CMDOPT_ENABLE_FORMAT: 			cmdopts->enable_format = jas_optarg; 			break; 		case CMDOPT_ENABLE_ALL_FORMATS: 			cmdopts->enable_all_formats = 1; 			break; 		default: 			badusage(); 			break; 		} 	}  	while (jas_optind < argc) { 		fprintf(stderr, 		  ""warning: ignoring bogus command line argument %s\n"", 		  argv[jas_optind]); 		++jas_optind; 	}  	if (cmdopts->version || cmdopts->list_codecs || cmdopts->help) { 		goto done; 	}  	if (!cmdopts->outfmt_str && !cmdopts->outfile) { 		fprintf(stderr, ""error: cannot determine output format\n""); 		badusage(); 	}  done: 	return cmdopts; }"
"206989_CWE-74.c","CWE-74","apply_extra_data (FlatpakDir   *self,                   GFile        *checkoutdir,                   GCancellable *cancellable,                   GError      **error) {   g_autoptr(GFile) metadata = NULL;   g_autofree char *metadata_contents = NULL;   gsize metadata_size;   g_autoptr(GKeyFile) metakey = NULL;   g_autofree char *id = NULL;   g_autofree char *runtime_pref = NULL;   g_autoptr(FlatpakDecomposed) runtime_ref = NULL;   g_autoptr(FlatpakDeploy) runtime_deploy = NULL;   g_autoptr(FlatpakBwrap) bwrap = NULL;   g_autoptr(GFile) app_files = NULL;   g_autoptr(GFile) apply_extra_file = NULL;   g_autoptr(GFile) app_export_file = NULL;   g_autoptr(GFile) extra_export_file = NULL;   g_autoptr(GFile) extra_files = NULL;   g_autoptr(GFile) runtime_files = NULL;   g_autoptr(FlatpakContext) app_context = NULL;   g_auto(GStrv) minimal_envp = NULL;   g_autofree char *runtime_arch = NULL;   int exit_status;   const char *group = FLATPAK_METADATA_GROUP_APPLICATION;   g_autoptr(GError) local_error = NULL;    apply_extra_file = g_file_resolve_relative_path (checkoutdir, ""files/bin/apply_extra"");   if (!g_file_query_exists (apply_extra_file, cancellable))     return TRUE;    metadata = g_file_get_child (checkoutdir, ""metadata"");    if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))     return FALSE;    metakey = g_key_file_new ();   if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))     return FALSE;    id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,                               &local_error);   if (id == NULL)     {       group = FLATPAK_METADATA_GROUP_RUNTIME;       id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,                                   NULL);       if (id == NULL)         {           g_propagate_error (error, g_steal_pointer (&local_error));           return FALSE;         }       g_clear_error (&local_error);     }    runtime_pref = g_key_file_get_string (metakey, group,                                         FLATPAK_METADATA_KEY_RUNTIME, error);   if (runtime_pref == NULL)     runtime_pref = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_EXTENSION_OF,                                           FLATPAK_METADATA_KEY_RUNTIME, NULL);   if (runtime_pref == NULL)     return FALSE;    runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime_pref, error);   if (runtime_ref == NULL)     return FALSE;   runtime_arch = flatpak_decomposed_dup_arch (runtime_ref);    if (!g_key_file_get_boolean (metakey, FLATPAK_METADATA_GROUP_EXTRA_DATA,                                FLATPAK_METADATA_KEY_NO_RUNTIME, NULL))     {       /* We pass in self here so that we ensure that we find the runtime in case it only          exists in this installation (which might be custom) */       runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), NULL, self, cancellable, error);       if (runtime_deploy == NULL)         return FALSE;       runtime_files = flatpak_deploy_get_files (runtime_deploy);     }    app_files = g_file_get_child (checkoutdir, ""files"");   app_export_file = g_file_get_child (checkoutdir, ""export"");   extra_files = g_file_get_child (app_files, ""extra"");   extra_export_file = g_file_get_child (extra_files, ""export"");    minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);   bwrap = flatpak_bwrap_new (minimal_envp);   flatpak_bwrap_add_args (bwrap, flatpak_get_bwrap (), NULL);    if (runtime_files)     flatpak_bwrap_add_args (bwrap,                             ""--ro-bind"", flatpak_file_get_path_cached (runtime_files), ""/usr"",                             ""--lock-file"", ""/usr/.ref"",                             NULL);    flatpak_bwrap_add_args (bwrap,                           ""--ro-bind"", flatpak_file_get_path_cached (app_files), ""/app"",                           ""--bind"", flatpak_file_get_path_cached (extra_files), ""/app/extra"",                           ""--chdir"", ""/app/extra"",                           /* We run as root in the system-helper case, so drop all caps */                           ""--cap-drop"", ""ALL"",                           NULL);    if (!flatpak_run_setup_base_argv (bwrap, runtime_files, NULL, runtime_arch,                                     /* Might need multiarch in apply_extra (see e.g. #3742). Should be pretty safe in this limited context */                                     FLATPAK_RUN_FLAG_MULTIARCH |                                     FLATPAK_RUN_FLAG_NO_SESSION_HELPER | FLATPAK_RUN_FLAG_NO_PROC,                                     error))     return FALSE;    app_context = flatpak_context_new ();    if (!flatpak_run_add_environment_args (bwrap, NULL,                                          FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY |                                          FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY |                                          FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY,                                          id,                                          app_context, NULL, NULL, NULL, cancellable, error))     return FALSE;    flatpak_bwrap_add_arg (bwrap, ""/app/bin/apply_extra"");    flatpak_bwrap_finish (bwrap);    g_debug (""Running /app/bin/apply_extra "");    /* We run the sandbox without caps, but it can still create files owned by itself with    * arbitrary permissions, including setuid myself. This is extra risky in the case where    * this runs as root in the system helper case. We canonicalize the permissions at the    * end, but to avoid non-canonical permissions leaking out before then we make the    * toplevel dir only accessible to the user */   if (chmod (flatpak_file_get_path_cached (extra_files), 0700) != 0)     {       glnx_set_error_from_errno (error);       return FALSE;     }    if (!g_spawn_sync (NULL,                      (char **) bwrap->argv->pdata,                      bwrap->envp,                      G_SPAWN_SEARCH_PATH,                      child_setup, bwrap->fds,                      NULL, NULL,                      &exit_status,                      error))     return FALSE;    if (!flatpak_canonicalize_permissions (AT_FDCWD, flatpak_file_get_path_cached (extra_files),                                          getuid () == 0 ? 0 : -1,                                          getuid () == 0 ? 0 : -1,                                          error))     return FALSE;    if (exit_status != 0)     {       g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,                    _(""apply_extra script failed, exit status %d""), exit_status);       return FALSE;     }    if (g_file_query_exists (extra_export_file, cancellable))     {       if (!flatpak_mkdir_p (app_export_file, cancellable, error))         return FALSE;       if (!flatpak_cp_a (extra_export_file,                          app_export_file,                          FLATPAK_CP_FLAGS_MERGE,                          cancellable, error))         return FALSE;     }    return TRUE; }"
"207068_CWE-120.c","CWE-120","static ssize_t remove_slot_store(struct kobject *kobj, 				 struct kobj_attribute *attr, 				 const char *buf, size_t nbytes) { 	char drc_name[MAX_DRC_NAME_LEN]; 	int rc; 	char *end;  	if (nbytes >= MAX_DRC_NAME_LEN) 		return 0;  	memcpy(drc_name, buf, nbytes);  	end = strchr(drc_name, '\n'); 	if (!end) 		end = &drc_name[nbytes]; 	*end = '\0';  	rc = dlpar_remove_slot(drc_name); 	if (rc) 		return rc;  	return nbytes; }"
"207069_CWE-120.c","CWE-120","static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr, 			      const char *buf, size_t nbytes) { 	char drc_name[MAX_DRC_NAME_LEN]; 	char *end; 	int rc;  	if (nbytes >= MAX_DRC_NAME_LEN) 		return 0;  	memcpy(drc_name, buf, nbytes);  	end = strchr(drc_name, '\n'); 	if (!end) 		end = &drc_name[nbytes]; 	*end = '\0';  	rc = dlpar_add_slot(drc_name); 	if (rc) 		return rc;  	return nbytes; }"
"207071_CWE-125.cpp","CWE-125","DeepTiledInputFile::initialize () {     if (_data->partNumber == -1)         if (_data->header.type() != DEEPTILE)             throw IEX_NAMESPACE::ArgExc (""Expected a deep tiled file but the file is not deep tiled."");    if(_data->header.version()!=1)    {        THROW(IEX_NAMESPACE::ArgExc, ""Version "" << _data->header.version() << "" not supported for deeptiled images in this version of the library"");    }              _data->header.sanityCheck (true);      //     // before allocating memory for tile offsets, confirm file is large enough     // to contain tile offset table     // (for multipart files, the chunk offset table has already been read)     //     if (!isMultiPart(_data->version))     {         _data->validateStreamSize();     }       _data->tileDesc = _data->header.tileDescription();     _data->lineOrder = _data->header.lineOrder();      //     // Save the dataWindow information     //      const Box2i &dataWindow = _data->header.dataWindow();     _data->minX = dataWindow.min.x;     _data->maxX = dataWindow.max.x;     _data->minY = dataWindow.min.y;     _data->maxY = dataWindow.max.y;      //     // Precompute level and tile information to speed up utility functions     //      precalculateTileInfo (_data->tileDesc,                           _data->minX, _data->maxX,                           _data->minY, _data->maxY,                           _data->numXTiles, _data->numYTiles,                           _data->numXLevels, _data->numYLevels);      //     // Create all the TileBuffers and allocate their internal buffers     //      _data->tileOffsets = TileOffsets (_data->tileDesc.mode,                                       _data->numXLevels,                                       _data->numYLevels,                                       _data->numXTiles,                                       _data->numYTiles);      for (size_t i = 0; i < _data->tileBuffers.size(); i++)         _data->tileBuffers[i] = new TileBuffer ();      _data->maxSampleCountTableSize = _data->tileDesc.ySize *                                      _data->tileDesc.xSize *                                      sizeof(int);      _data->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);      _data->sampleCountTableComp = newCompressor(_data->header.compression(),                                                 _data->maxSampleCountTableSize,                                                 _data->header);                                                                                                       const ChannelList & c=_data->header.channels();     _data->combinedSampleSize=0;     for(ChannelList::ConstIterator i=c.begin();i!=c.end();i++)     {         switch( i.channel().type )         {             case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF  :                 _data->combinedSampleSize+=Xdr::size<half>();                 break;             case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT :                 _data->combinedSampleSize+=Xdr::size<float>();                 break;             case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT  :                 _data->combinedSampleSize+=Xdr::size<unsigned int>();                 break;             default :                 THROW(IEX_NAMESPACE::ArgExc, ""Bad type for channel "" << i.name() << "" initializing deepscanline reader"");         }     }                                                    }"
"207150_CWE-703.cpp","CWE-703","static SQInteger thread_call(HSQUIRRELVM v) {     SQObjectPtr o = stack_get(v,1);     if(sq_type(o) == OT_THREAD) {         SQInteger nparams = sq_gettop(v);         _thread(o)->Push(_thread(o)->_roottable);         for(SQInteger i = 2; i<(nparams+1); i++)             sq_move(_thread(o),v,i);         if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {             sq_move(v,_thread(o),-1);             sq_pop(_thread(o),1);             return 1;         }         v->_lasterror = _thread(o)->_lasterror;         return SQ_ERROR;     }     return sq_throwerror(v,_SC(""wrong parameter"")); }"
"207280_CWE-122.c","CWE-122","win_redr_status(win_T *wp, int ignore_pum UNUSED) {     int		row;     char_u	*p;     int		len;     int		fillchar;     int		attr;     int		this_ru_col;     static int  busy = FALSE;      // It's possible to get here recursively when 'statusline' (indirectly)     // invokes "":redrawstatus"".  Simply ignore the call then.     if (busy) 	return;     busy = TRUE;      row = statusline_row(wp);      wp->w_redr_status = FALSE;     if (wp->w_status_height == 0)     { 	// no status line, can only be last window 	redraw_cmdline = TRUE;     }     else if (!redrawing() 	    // don't update status line when popup menu is visible and may be 	    // drawn over it, unless it will be redrawn later 	    || (!ignore_pum && pum_visible()))     { 	// Don't redraw right now, do it later. 	wp->w_redr_status = TRUE;     } #ifdef FEAT_STL_OPT     else if (*p_stl != NUL || *wp->w_p_stl != NUL)     { 	// redraw custom status line 	redraw_custom_statusline(wp);     } #endif     else     { 	fillchar = fillchar_status(&attr, wp);  	get_trans_bufname(wp->w_buffer); 	p = NameBuff; 	len = (int)STRLEN(p);  	if (bt_help(wp->w_buffer) #ifdef FEAT_QUICKFIX 		|| wp->w_p_pvw #endif 		|| bufIsChanged(wp->w_buffer) 		|| wp->w_buffer->b_p_ro) 	    *(p + len++) = ' '; 	if (bt_help(wp->w_buffer)) 	{ 	    STRCPY(p + len, _(""[Help]"")); 	    len += (int)STRLEN(p + len); 	} #ifdef FEAT_QUICKFIX 	if (wp->w_p_pvw) 	{ 	    STRCPY(p + len, _(""[Preview]"")); 	    len += (int)STRLEN(p + len); 	} #endif 	if (bufIsChanged(wp->w_buffer) #ifdef FEAT_TERMINAL 		&& !bt_terminal(wp->w_buffer) #endif 		) 	{ 	    STRCPY(p + len, ""[+]""); 	    len += 3; 	} 	if (wp->w_buffer->b_p_ro) 	{ 	    STRCPY(p + len, _(""[RO]"")); 	    len += (int)STRLEN(p + len); 	}  	this_ru_col = ru_col - (Columns - wp->w_width); 	if (this_ru_col < (wp->w_width + 1) / 2) 	    this_ru_col = (wp->w_width + 1) / 2; 	if (this_ru_col <= 1) 	{ 	    p = (char_u *)""<"";		// No room for file name! 	    len = 1; 	} 	else if (has_mbyte) 	{ 	    int	clen = 0, i;  	    // Count total number of display cells. 	    clen = mb_string2cells(p, -1);  	    // Find first character that will fit. 	    // Going from start to end is much faster for DBCS. 	    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1; 		    i += (*mb_ptr2len)(p + i)) 		clen -= (*mb_ptr2cells)(p + i); 	    len = clen; 	    if (i > 0) 	    { 		p = p + i - 1; 		*p = '<'; 		++len; 	    }  	} 	else if (len > this_ru_col - 1) 	{ 	    p += len - (this_ru_col - 1); 	    *p = '<'; 	    len = this_ru_col - 1; 	}  	screen_puts(p, row, wp->w_wincol, attr); 	screen_fill(row, row + 1, len + wp->w_wincol, 			this_ru_col + wp->w_wincol, fillchar, fillchar, attr);  	if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL) 		&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1)) 	    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff) 						   - 1 + wp->w_wincol), attr);  #ifdef FEAT_CMDL_INFO 	win_redr_ruler(wp, TRUE, ignore_pum); #endif     }      /*      * May need to draw the character below the vertical separator.      */     if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())     { 	if (stl_connected(wp)) 	    fillchar = fillchar_status(&attr, wp); 	else 	    fillchar = fillchar_vsep(&attr); 	screen_putchar(fillchar, row, W_ENDCOL(wp), attr);     }     busy = FALSE; }"
"207461_CWE-787.c","CWE-787","at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data) {   FILE *fd;   unsigned char buffer[64];   int ColormapSize, rowbytes, Maps;   gboolean Grey = FALSE;   unsigned char ColorMap[256][3];   at_bitmap image = at_bitmap_init(0, 0, 0, 1);   unsigned char *image_storage;   at_exception_type exp = at_exception_new(msg_func, msg_data);   char magick[2];   Bitmap_Channel masks[4];    fd = fopen(filename, ""rb"");    if (!fd) {     LOG(""Can't open \""%s\""\n"", filename);     at_exception_fatal(&exp, ""bmp: cannot open input file"");     goto cleanup;   }    /* It is a File. Now is it a Bitmap? Read the shortest possible header. */    if (!ReadOK(fd, magick, 2) || 	  !(!strncmp(magick, ""BA"", 2) || 		  !strncmp(magick, ""BM"", 2) || 		  !strncmp(magick, ""IC"", 2) || 		  !strncmp(magick, ""PT"", 2) || 		  !strncmp(magick, ""CI"", 2) || 		  !strncmp(magick, ""CP"", 2)))   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    while (!strncmp(magick, ""BA"", 2))   { 	  if (!ReadOK(fd, buffer, 12)) 	  { 		  LOG(""%s is not a valid BMP file"", filename); 		  at_exception_fatal(&exp, ""bmp: invalid input file""); 		  goto cleanup; 	  }  	  if (!ReadOK(fd, magick, 2)) 	  { 		  LOG(""%s is not a valid BMP file"", filename); 		  at_exception_fatal(&exp, ""bmp: invalid input file""); 		  goto cleanup; 	  }   }    if (!ReadOK(fd, buffer, 12))////   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    /* bring them to the right byteorder. Not too nice, but it should work */    Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);   Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);   Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);   Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);    if (!ReadOK(fd, buffer, 4))   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    Bitmap_File_Head.biSize = ToL(&buffer[0x00]);    /* What kind of bitmap is it? */    if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */     if (!ReadOK(fd, buffer, 8)) {       LOG(""Error reading BMP file header\n"");       at_exception_fatal(&exp, ""Error reading BMP file header"");       goto cleanup;     }      Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */     Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */     Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */     Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */     Bitmap_Head.biCompr = 0;     Bitmap_Head.biSizeIm = 0;     Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;     Bitmap_Head.biClrUsed = 0;     Bitmap_Head.biClrImp = 0;     Bitmap_Head.masks[0] = 0;     Bitmap_Head.masks[1] = 0;     Bitmap_Head.masks[2] = 0;     Bitmap_Head.masks[3] = 0;      memset(masks, 0, sizeof(masks));     Maps = 3;    } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */     if (!ReadOK(fd, buffer, 36))     {       LOG (""Error reading BMP file header\n"");       at_exception_fatal(&exp, ""Error reading BMP file header"");       goto cleanup;     }                 Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */     Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */     Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */     Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */     Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */     Bitmap_Head.masks[0] = 0;     Bitmap_Head.masks[1] = 0;     Bitmap_Head.masks[2] = 0;     Bitmap_Head.masks[3] = 0;      Maps = 4;     memset(masks, 0, sizeof(masks));      if (Bitmap_Head.biCompr == BI_BITFIELDS)       { 	if (!ReadOK(fd, buffer, 3 * sizeof(unsigned long))) 	  { 	    LOG(""Error reading BMP file header\n""); 	    at_exception_fatal(&exp, ""Error reading BMP file header""); 	    goto cleanup; 	  }  	Bitmap_Head.masks[0] = ToL(&buffer[0x00]); 	Bitmap_Head.masks[1] = ToL(&buffer[0x04]); 	Bitmap_Head.masks[2] = ToL(&buffer[0x08]);  	ReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);       }     else if (Bitmap_Head.biCompr == BI_RGB)       { 	setMasksDefault(Bitmap_Head.biBitCnt, masks);       }     else if ((Bitmap_Head.biCompr != BI_RLE4) && 	     (Bitmap_Head.biCompr != BI_RLE8))       { 	/* BI_ALPHABITFIELDS, etc. */ 	LOG(""Unsupported compression in BMP file\n""); 	at_exception_fatal(&exp, ""Unsupported compression in BMP file""); 	goto cleanup;       }   }   else if (Bitmap_File_Head.biSize >= 56 && 	   Bitmap_File_Head.biSize <= 64)   {     /* enhanced Windows format with bit masks */      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))     {        LOG(""Error reading BMP file header\n"");       at_exception_fatal(&exp, ""Error reading BMP file header"");       goto cleanup;     }      Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */     Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */     Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */     Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */     Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */     Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       /* 36 */     Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       /* 3A */     Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       /* 3E */     Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       /* 42 */      Maps = 4;     ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);   }   else if (Bitmap_File_Head.biSize == 108 ||            Bitmap_File_Head.biSize == 124)   {     /* BMP Version 4 or 5 */      if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))     { 	    LOG(""Error reading BMP file header\n""); 	    at_exception_fatal(&exp, ""Error reading BMP file header""); 	    goto cleanup;     }      Bitmap_Head.biWidth = ToL(&buffer[0x00]);     Bitmap_Head.biHeight = ToL(&buffer[0x04]);     Bitmap_Head.biPlanes = ToS(&buffer[0x08]);     Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);     Bitmap_Head.biCompr = ToL(&buffer[0x0C]);     Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);     Bitmap_Head.biXPels = ToL(&buffer[0x14]);     Bitmap_Head.biYPels = ToL(&buffer[0x18]);     Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);     Bitmap_Head.biClrImp = ToL(&buffer[0x20]);     Bitmap_Head.masks[0] = ToL(&buffer[0x24]);     Bitmap_Head.masks[1] = ToL(&buffer[0x28]);     Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);     Bitmap_Head.masks[3] = ToL(&buffer[0x30]);      Maps = 4;      if (Bitmap_Head.biCompr == BI_BITFIELDS)     { 	    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);     }     else if (Bitmap_Head.biCompr == BI_RGB)     { 	    setMasksDefault(Bitmap_Head.biBitCnt, masks);     }   } else {     LOG(""Error reading BMP file header\n"");     at_exception_fatal(&exp, ""Error reading BMP file header"");     goto cleanup;   }    /* Valid options 1, 4, 8, 16, 24, 32 */   /* 16 is awful, we should probably shoot whoever invented it */    switch (Bitmap_Head.biBitCnt)   {   case 1:   case 2:   case 4:   case 8:   case 16:   case 24:   case 32: 	  break;   default: 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    /* There should be some colors used! */    ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;    if ((Bitmap_Head.biClrUsed == 0) &&       (Bitmap_Head.biBitCnt <= 8))   { 	  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;   }    if (ColormapSize > 256)     ColormapSize = 256;    /* Sanity checks */    if (Bitmap_Head.biHeight == 0 || 	  Bitmap_Head.biWidth == 0)   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    /* biHeight may be negative, but -2147483648 is dangerous because: 	 -2147483648 == -(-2147483648) */   if (Bitmap_Head.biWidth < 0 || 	  Bitmap_Head.biHeight == -2147483648)   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    if (Bitmap_Head.biPlanes != 1)   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    if (Bitmap_Head.biClrUsed > 256 && 	  Bitmap_Head.biBitCnt <= 8)   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    /* protect against integer overflows caused by malicious BMPs */   /* use divisions in comparisons to avoid type overflows */    if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt || 	  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)   { 	  LOG(""%s is not a valid BMP file"", filename); 	  at_exception_fatal(&exp, ""bmp: invalid input file""); 	  goto cleanup;   }    /* Windows and OS/2 declare filler so that rows are a multiple of    * word length (32 bits == 4 bytes)    */       unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;   if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {     LOG(""Error reading BMP file header. Width is too large\n"");     at_exception_fatal(&exp, ""Error reading BMP file header. Width is too large"");     goto cleanup;   }    rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;  #ifdef DEBUG   printf(""\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\n"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes); #endif     if (Bitmap_Head.biBitCnt <= 8)   { #ifdef DEBUG     printf(""Colormap read\n""); #endif 	  /* Get the Colormap */ 	  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp)) 		  goto cleanup;   }    fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);    /* Get the Image and return the ID or -1 on error */   image_storage = ReadImage(fd,  	Bitmap_Head.biWidth, Bitmap_Head.biHeight, 	ColorMap,         Bitmap_Head.biClrUsed, 	Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,         Grey, 	masks, 	&exp);    image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3); cleanup:   fclose(fd);   return (image); }"
"207520_CWE-787.c","CWE-787","static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev, 	RzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) { 	size_t i; 	const char *comp_dir = NULL; 	ut64 line_info_offset = UT64_MAX; 	for (i = 0; i < abbrev->count - 1; i++) { 		memset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));  		buf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i], 			&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);  		RzBinDwarfAttrValue *attribute = &die->attr_values[i];  		if (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) { 			comp_dir = attribute->string.content; 		} 		if (attribute->attr_name == DW_AT_stmt_list) { 			if (attribute->kind == DW_AT_KIND_CONSTANT) { 				line_info_offset = attribute->uconstant; 			} else if (attribute->kind == DW_AT_KIND_REFERENCE) { 				line_info_offset = attribute->reference; 			} 		} 		die->count++; 	}  	// If this is a compilation unit dir attribute, we want to cache it so the line info parsing 	// which will need this info can quickly look it up. 	if (comp_dir && line_info_offset != UT64_MAX) { 		char *name = strdup(comp_dir); 		if (name) { 			if (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) { 				free(name); 			} 		} 	}  	return buf; }"
"207700_CWE-362.cpp","CWE-362","TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {   auto it = idInfoMap.find(id);   if (it == idInfoMap.end()) {     STFATAL << "" Tried to read from an id that no longer exists"";   }   return it->second; }"
"207703_CWE-362.cpp","CWE-362","set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {   lock_guard<std::recursive_mutex> guard(globalMutex);    string pipePath = endpoint.name();   if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {     throw runtime_error(""Tried to listen twice on the same path"");   }    sockaddr_un local;    int fd = socket(AF_UNIX, SOCK_STREAM, 0);   FATAL_FAIL(fd);   initServerSocket(fd);   local.sun_family = AF_UNIX; /* local is declared before socket() ^ */   strcpy(local.sun_path, pipePath.c_str());   unlink(local.sun_path);    FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));   ::listen(fd, 5); #ifndef WIN32   FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR)); #endif    pipeServerSockets[pipePath] = set<int>({fd});   return pipeServerSockets[pipePath]; }"
"207719_CWE-787.c","CWE-787","display_dollar(colnr_T col) {     colnr_T save_col;      if (!redrawing()) 	return;      cursor_off();     save_col = curwin->w_cursor.col;     curwin->w_cursor.col = col;     if (has_mbyte)     { 	char_u *p;  	// If on the last byte of a multi-byte move to the first byte. 	p = ml_get_curline(); 	curwin->w_cursor.col -= (*mb_head_off)(p, p + col);     }     curs_columns(FALSE);	    // recompute w_wrow and w_wcol     if (curwin->w_wcol < curwin->w_width)     { 	edit_putchar('$', FALSE); 	dollar_vcol = curwin->w_virtcol;     }     curwin->w_cursor.col = save_col; }"
"207753_CWE-284.c","CWE-284","static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes, 			 struct iov_iter *i) { 	struct pipe_inode_info *pipe = i->pipe; 	struct pipe_buffer *buf; 	unsigned int p_tail = pipe->tail; 	unsigned int p_mask = pipe->ring_size - 1; 	unsigned int i_head = i->head; 	size_t off;  	if (unlikely(bytes > i->count)) 		bytes = i->count;  	if (unlikely(!bytes)) 		return 0;  	if (!sanity(i)) 		return 0;  	off = i->iov_offset; 	buf = &pipe->bufs[i_head & p_mask]; 	if (off) { 		if (offset == off && buf->page == page) { 			/* merge with the last one */ 			buf->len += bytes; 			i->iov_offset += bytes; 			goto out; 		} 		i_head++; 		buf = &pipe->bufs[i_head & p_mask]; 	} 	if (pipe_full(i_head, p_tail, pipe->max_usage)) 		return 0;  	buf->ops = &page_cache_pipe_buf_ops; 	get_page(page); 	buf->page = page; 	buf->offset = offset; 	buf->len = bytes;  	pipe->head = i_head + 1; 	i->iov_offset = offset + bytes; 	i->head = i_head; out: 	i->count -= bytes; 	return bytes; }"
"207754_CWE-284.c","CWE-284","static size_t push_pipe(struct iov_iter *i, size_t size, 			int *iter_headp, size_t *offp) { 	struct pipe_inode_info *pipe = i->pipe; 	unsigned int p_tail = pipe->tail; 	unsigned int p_mask = pipe->ring_size - 1; 	unsigned int iter_head; 	size_t off; 	ssize_t left;  	if (unlikely(size > i->count)) 		size = i->count; 	if (unlikely(!size)) 		return 0;  	left = size; 	data_start(i, &iter_head, &off); 	*iter_headp = iter_head; 	*offp = off; 	if (off) { 		left -= PAGE_SIZE - off; 		if (left <= 0) { 			pipe->bufs[iter_head & p_mask].len += size; 			return size; 		} 		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE; 		iter_head++; 	} 	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) { 		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask]; 		struct page *page = alloc_page(GFP_USER); 		if (!page) 			break;  		buf->ops = &default_pipe_buf_ops; 		buf->page = page; 		buf->offset = 0; 		buf->len = min_t(ssize_t, left, PAGE_SIZE); 		left -= buf->len; 		iter_head++; 		pipe->head = iter_head;  		if (left == 0) 			return size; 	} 	return size - left; }"
"207755_CWE-200.c","CWE-200","PHP_FUNCTION(openssl_encrypt) { 	zend_bool raw_output = 0; 	char *data, *method, *password, *iv = """"; 	int data_len, method_len, password_len, iv_len = 0, max_iv_len; 	const EVP_CIPHER *cipher_type; 	EVP_CIPHER_CTX cipher_ctx; 	int i, outlen, keylen; 	unsigned char *outbuf, *key; 	zend_bool free_iv;  	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sss|bs"", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) { 		return; 	} 	cipher_type = EVP_get_cipherbyname(method); 	if (!cipher_type) { 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown cipher algorithm""); 		RETURN_FALSE; 	}  	keylen = EVP_CIPHER_key_length(cipher_type); 	if (keylen > password_len) { 		key = emalloc(keylen); 		memset(key, 0, keylen); 		memcpy(key, password, password_len); 	} else { 		key = (unsigned char*)password; 	}  	max_iv_len = EVP_CIPHER_iv_length(cipher_type); 	if (iv_len <= 0 && max_iv_len > 0) { 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Using an empty Initialization Vector (iv) is potentially insecure and not recommended""); 	} 	free_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);  	outlen = data_len + EVP_CIPHER_block_size(cipher_type); 	outbuf = emalloc(outlen + 1);  	EVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL); 	if (password_len > keylen) { 		EVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len); 	} 	EVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv); 	EVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len); 	outlen = i; 	if (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) { 		outlen += i; 		if (raw_output) { 			outbuf[outlen] = '\0'; 			RETVAL_STRINGL((char *)outbuf, outlen, 0); 		} else { 			int base64_str_len; 			char *base64_str;  			base64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len); 			efree(outbuf); 			RETVAL_STRINGL(base64_str, base64_str_len, 0); 		} 	} else { 		efree(outbuf); 		RETVAL_FALSE; 	} 	if (key != (unsigned char*)password) { 		efree(key); 	} 	if (free_iv) { 		efree(iv); 	} 	EVP_CIPHER_CTX_cleanup(&cipher_ctx); }"
"207762_CWE-924.cpp","CWE-924","negotiate_handshake_newstyle_options (void) {   GET_CONN;   struct nbd_new_option new_option;   size_t nr_options;   bool list_seen = false;   uint64_t version;   uint32_t option;   uint32_t optlen;   struct nbd_export_name_option_reply handshake_finish;   const char *optname;   uint64_t exportsize;   struct backend *b;    for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {     CLEANUP_FREE char *data = NULL;      if (conn_recv_full (&new_option, sizeof new_option,                         ""reading option: conn->recv: %m"") == -1)       return -1;      version = be64toh (new_option.version);     if (version != NBD_NEW_VERSION) {       nbdkit_error (""unknown option version %"" PRIx64                     "", expecting %"" PRIx64,                     version, NBD_NEW_VERSION);       return -1;     }      /* There is a maximum option length we will accept, regardless      * of the option type.      */     optlen = be32toh (new_option.optlen);     if (optlen > MAX_REQUEST_SIZE) {       nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);       return -1;     }     data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */     if (data == NULL) {       nbdkit_error (""malloc: %m"");       return -1;     }      option = be32toh (new_option.option);     optname = name_of_nbd_opt (option);      /* If the client lacks fixed newstyle support, it should only send      * NBD_OPT_EXPORT_NAME.      */     if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&         option != NBD_OPT_EXPORT_NAME) {       if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))         return -1;       continue;     }      /* In --tls=require / FORCEDTLS mode the only options allowed      * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.      */     if (tls == 2 && !conn->using_tls &&         !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {       if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))         return -1;       continue;     }      switch (option) {     case NBD_OPT_EXPORT_NAME:       if (conn_recv_full (data, optlen,                           ""read: %s: %m"", name_of_nbd_opt (option)) == -1)         return -1;       if (check_export_name (option, data, optlen, optlen) == -1)         return -1;        /* We have to finish the handshake by sending handshake_finish.        * On failure, we have to disconnect.        */       if (finish_newstyle_options (&exportsize, data, optlen) == -1)         return -1;        memset (&handshake_finish, 0, sizeof handshake_finish);       handshake_finish.exportsize = htobe64 (exportsize);       handshake_finish.eflags = htobe16 (conn->eflags);        if (conn->send (&handshake_finish,                       (conn->cflags & NBD_FLAG_NO_ZEROES)                       ? offsetof (struct nbd_export_name_option_reply, zeroes)                       : sizeof handshake_finish, 0) == -1) {         nbdkit_error (""write: %s: %m"", optname);         return -1;       }       break;      case NBD_OPT_ABORT:       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;       debug (""client sent %s to abort the connection"",              name_of_nbd_opt (option));       return -1;      case NBD_OPT_LIST:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        if (list_seen) {         debug (""newstyle negotiation: %s: export list already advertised"",                name_of_nbd_opt (option));         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)           return -1;         continue;       }       else {         /* Send back the exportname list. */         debug (""newstyle negotiation: %s: advertising exports"",                name_of_nbd_opt (option));         if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)           return -1;         list_seen = true;       }       break;      case NBD_OPT_STARTTLS:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        if (tls == 0) {           /* --tls=off (NOTLS mode). */ #ifdef HAVE_GNUTLS #define NO_TLS_REPLY NBD_REP_ERR_POLICY #else #define NO_TLS_REPLY NBD_REP_ERR_UNSUP #endif         if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)           return -1;       }       else /* --tls=on or --tls=require */ {         /* We can't upgrade to TLS twice on the same connection. */         if (conn->using_tls) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)             return -1;           continue;         }          /* We have to send the (unencrypted) reply before starting          * the handshake.          */         if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)           return -1;          /* Upgrade the connection to TLS.  Also performs access control. */         if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)           return -1;         conn->using_tls = true;         debug (""using TLS on this connection"");         /* Wipe out any cached default export name. */         for_each_backend (b) {           free (conn->default_exportname[b->i]);           conn->default_exportname[b->i] = NULL;         }       }       break;      case NBD_OPT_INFO:     case NBD_OPT_GO:       if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)         return -1;        if (optlen < 6) { /* 32 bit export length + 16 bit nr info */         debug (""newstyle negotiation: %s option length < 6"", optname);          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         continue;       }        {         uint32_t exportnamelen;         uint16_t nrinfos;         uint16_t info;         size_t i;          /* Validate the name length and number of INFO requests. */         memcpy (&exportnamelen, &data[0], 4);         exportnamelen = be32toh (exportnamelen);         if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {           debug (""newstyle negotiation: %s: export name too long"", optname);           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }         memcpy (&nrinfos, &data[exportnamelen+4], 2);         nrinfos = be16toh (nrinfos);         if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {           debug (""newstyle negotiation: %s: ""                  ""number of information requests incorrect"", optname);           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* As with NBD_OPT_EXPORT_NAME we print the export name and          * save it in the connection.  If an earlier          * NBD_OPT_SET_META_CONTEXT used an export name, it must match          * or else we drop the support for that context.          */         if (check_export_name (option, &data[4], exportnamelen,                                optlen - 6) == -1) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* The spec is confusing, but it is required that we send back          * NBD_INFO_EXPORT, even if the client did not request it!          * qemu client in particular does not request this, but will          * fail if we don't send it.  Note that if .open fails, but we          * succeed at .close, then we merely return an error to the          * client and let them try another NBD_OPT, rather than          * disconnecting.          */         if (finish_newstyle_options (&exportsize,                                      &data[4], exportnamelen) == -1) {           if (conn->top_context) {             if (backend_finalize (conn->top_context) == -1)               return -1;             backend_close (conn->top_context);             conn->top_context = NULL;           }           if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)             return -1;           continue;         }          if (send_newstyle_option_reply_info_export (option,                                                     NBD_REP_INFO,                                                     NBD_INFO_EXPORT,                                                     exportsize) == -1)           return -1;          /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if          * requested, and ignore all other info requests (including          * NBD_INFO_EXPORT if it was requested, because we replied          * already above).          */         for (i = 0; i < nrinfos; ++i) {           memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);           info = be16toh (info);           switch (info) {           case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;           case NBD_INFO_NAME:             {               const char *name = &data[4];               size_t namelen = exportnamelen;                if (exportnamelen == 0) {                 name = backend_default_export (top, read_only);                 if (!name) {                   debug (""newstyle negotiation: %s: ""                          ""NBD_INFO_NAME: no name to send"", optname);                   break;                 }                 namelen = -1;               }               if (send_newstyle_option_reply_info_str (option,                                                        NBD_REP_INFO,                                                        NBD_INFO_NAME,                                                        name, namelen) == -1)                 return -1;             }             break;           case NBD_INFO_DESCRIPTION:             {               const char *desc = backend_export_description (conn->top_context);                if (!desc) {                 debug (""newstyle negotiation: %s: ""                        ""NBD_INFO_DESCRIPTION: no description to send"",                        optname);                 break;               }               if (send_newstyle_option_reply_info_str (option,                                                        NBD_REP_INFO,                                                        NBD_INFO_DESCRIPTION,                                                        desc, -1) == -1)                 return -1;             }             break;           default:             debug (""newstyle negotiation: %s: ""                    ""ignoring NBD_INFO_* request %u (%s)"",                    optname, (unsigned) info, name_of_nbd_info (info));             break;           }         }       }        /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK        * or ERROR packet.  If this was NBD_OPT_LIST, call .close.        */       if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;        if (option == NBD_OPT_INFO) {         if (backend_finalize (conn->top_context) == -1)           return -1;         backend_close (conn->top_context);         conn->top_context = NULL;       }        break;      case NBD_OPT_STRUCTURED_REPLY:       if (optlen != 0) {         if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)             == -1)           return -1;         if (conn_recv_full (data, optlen,                             ""read: %s: %m"", name_of_nbd_opt (option)) == -1)           return -1;         continue;       }        debug (""newstyle negotiation: %s: client requested structured replies"",              name_of_nbd_opt (option));        if (no_sr) {         /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;          * but failing with ERR_POLICY would have been nicer.          */         if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)           return -1;         debug (""newstyle negotiation: %s: structured replies are disabled"",                name_of_nbd_opt (option));         break;       }        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)         return -1;        conn->structured_replies = true;       break;      case NBD_OPT_LIST_META_CONTEXT:     case NBD_OPT_SET_META_CONTEXT:       {         uint32_t opt_index;         uint32_t exportnamelen;         uint32_t nr_queries;         uint32_t querylen;         const char *what;          if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)           return -1;          /* Note that we support base:allocation whether or not the plugin          * supports can_extents.          */         if (!conn->structured_replies) {           if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          /* Minimum length of the option payload is:          *   32 bit export name length followed by empty export name          * + 32 bit number of queries followed by no queries          * = 8 bytes.          */         what = ""optlen < 8"";         if (optlen < 8) {         opt_meta_invalid_option_len:           debug (""newstyle negotiation: %s: invalid option length: %s"",                  optname, what);            if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)               == -1)             return -1;           continue;         }          memcpy (&exportnamelen, &data[0], 4);         exportnamelen = be32toh (exportnamelen);         what = ""validating export name"";         if (check_export_name (option, &data[4], exportnamelen,                                optlen - 8) == -1)           goto opt_meta_invalid_option_len;          /* Remember the export name: the NBD spec says that if the client          * later uses NBD_OPT_GO on a different export, then the context          * returned here is not usable.          */         if (option == NBD_OPT_SET_META_CONTEXT) {           conn->exportname_from_set_meta_context =             strndup (&data[4], exportnamelen);           if (conn->exportname_from_set_meta_context == NULL) {             nbdkit_error (""malloc: %m"");             return -1;           }         }          opt_index = 4 + exportnamelen;          /* Read the number of queries. */         what = ""reading number of queries"";         if (opt_index+4 > optlen)           goto opt_meta_invalid_option_len;         memcpy (&nr_queries, &data[opt_index], 4);         nr_queries = be32toh (nr_queries);         opt_index += 4;          /* for LIST: nr_queries == 0 means return all meta contexts          * for SET: nr_queries == 0 means reset all contexts          */         debug (""newstyle negotiation: %s: %s count: %d"", optname,                option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",                nr_queries);         if (option == NBD_OPT_SET_META_CONTEXT)           conn->meta_context_base_allocation = false;         if (nr_queries == 0) {           if (option == NBD_OPT_LIST_META_CONTEXT) {             if (send_newstyle_option_reply_meta_context (option,                                                          NBD_REP_META_CONTEXT,                                                          0, ""base:allocation"")                 == -1)               return -1;           }            if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)             return -1;         }         else {           /* Read and answer each query. */           while (nr_queries > 0) {             what = ""reading query string length"";             if (opt_index+4 > optlen)               goto opt_meta_invalid_option_len;             memcpy (&querylen, &data[opt_index], 4);             querylen = be32toh (querylen);             opt_index += 4;             what = ""reading query string"";             if (check_string (option, &data[opt_index], querylen,                               optlen - opt_index, ""meta context query"") == -1)               goto opt_meta_invalid_option_len;              debug (""newstyle negotiation: %s: %s %.*s"",                    optname,                    option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",                    (int) querylen, &data[opt_index]);              /* For LIST, ""base:"" returns all supported contexts in the              * base namespace.  We only support ""base:allocation"".              */             if (option == NBD_OPT_LIST_META_CONTEXT &&                 querylen == 5 &&                 strncmp (&data[opt_index], ""base:"", 5) == 0) {               if (send_newstyle_option_reply_meta_context                   (option, NBD_REP_META_CONTEXT,                    0, ""base:allocation"") == -1)                 return -1;             }             /* ""base:allocation"" requested by name. */             else if (querylen == 15 &&                      strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {               if (send_newstyle_option_reply_meta_context                   (option, NBD_REP_META_CONTEXT,                    option == NBD_OPT_SET_META_CONTEXT                    ? base_allocation_id : 0,                    ""base:allocation"") == -1)                 return -1;               if (option == NBD_OPT_SET_META_CONTEXT)                 conn->meta_context_base_allocation = true;             }             /* Every other query must be ignored. */              opt_index += querylen;             nr_queries--;           }           if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)             return -1;         }         debug (""newstyle negotiation: %s: reply complete"", optname);       }       break;      default:       /* Unknown option. */       if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)         return -1;       if (conn_recv_full (data, optlen,                           ""reading unknown option data: conn->recv: %m"") == -1)         return -1;     }      /* Note, since it's not very clear from the protocol doc, that the      * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and      * that ends option negotiation.      */     if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)       break;   }    if (nr_options == 0) {     nbdkit_error (""client spent too much time negotiating without selecting ""                   ""an export"");     return -1;   }    /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS    * by the time we finish option negotiation.  If not, give up.    */   if (tls == 2 && !conn->using_tls) {     nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");     return -1;   }    return 0; }"
"207780_CWE-703.c","CWE-703","static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) { 	RList *bins = r_list_newf ((RListFree)free_bin); 	ut16 *depArray = NULL; 	cache_imgxtr_t *extras = NULL; 	if (!bins) { 		return NULL; 	}  	char *target_libs = NULL; 	RList *target_lib_names = NULL; 	int *deps = NULL; 	target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER""); 	if (target_libs) { 		target_lib_names = r_str_split_list (target_libs, "":"", 0); 		if (!target_lib_names) { 			r_list_free (bins); 			return NULL; 		} 		deps = R_NEWS0 (int, cache->hdr->imagesCount); 		if (!deps) { 			r_list_free (bins); 			r_list_free (target_lib_names); 			return NULL; 		} 	}  	ut32 i; 	for (i = 0; i < cache->n_hdr; i++) { 		cache_hdr_t *hdr = &cache->hdr[i]; 		ut64 hdr_offset = cache->hdr_offset[i]; 		ut32 maps_index = cache->maps_index[i]; 		cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset); 		if (!img) { 			goto next; 		}  		ut32 j; 		if (target_libs) { 			HtPU *path_to_idx = NULL; 			if (cache->accel) { 				depArray = R_NEWS0 (ut16, cache->accel->depListCount); 				if (!depArray) { 					goto next; 				}  				if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) { 					goto next; 				}  				extras = read_cache_imgextra (cache->buf, hdr, cache->accel); 				if (!extras) { 					goto next; 				} 			} else { 				path_to_idx = create_path_to_index (cache->buf, img, hdr); 			}  			for (j = 0; j < hdr->imagesCount; j++) { 				bool printing = !deps[j]; 				char *lib_name = get_lib_name (cache->buf, &img[j]); 				if (!lib_name) { 					break; 				} 				if (strstr (lib_name, ""libobjc.A.dylib"")) { 					deps[j]++; 				} 				if (!r_list_find (target_lib_names, lib_name, string_contains)) { 					R_FREE (lib_name); 					continue; 				} 				if (printing) { 					eprintf (""FILTER: %s\n"", lib_name); 				} 				R_FREE (lib_name); 				deps[j]++;  				if (extras && depArray) { 					ut32 k; 					for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) { 						ut16 dep_index = depArray[k] & 0x7fff; 						deps[dep_index]++;  						char *dep_name = get_lib_name (cache->buf, &img[dep_index]); 						if (!dep_name) { 							break; 						} 						if (printing) { 							eprintf (""-> %s\n"", dep_name); 						} 						free (dep_name); 					} 				} else if (path_to_idx) { 					carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing); 				} 			}  			ht_pu_free (path_to_idx); 			R_FREE (depArray); 			R_FREE (extras); 		}  		for (j = 0; j < hdr->imagesCount; j++) { 			if (deps && !deps[j]) { 				continue; 			} 			ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL); 			if (pa == UT64_MAX) { 				continue; 			} 			ut8 magicbytes[4]; 			r_buf_read_at (cache->buf, pa, magicbytes, 4); 			int magic = r_read_le32 (magicbytes); 			switch (magic) { 			case MH_MAGIC_64: 			{ 				char file[256]; 				RDyldBinImage *bin = R_NEW0 (RDyldBinImage); 				if (!bin) { 					goto next; 				} 				bin->header_at = pa; 				bin->hdr_offset = hdr_offset; 				bin->symbols_off = resolve_symbols_off (cache, pa); 				bin->va = img[j].address; 				if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) { 					file[255] = 0; 					char *last_slash = strrchr (file, '/'); 					if (last_slash && *last_slash) { 						if (last_slash > file) { 							char *scan = last_slash - 1; 							while (scan > file && *scan != '/') { 								scan--; 							} 							if (*scan == '/') { 								bin->file = strdup (scan + 1); 							} else { 								bin->file = strdup (last_slash + 1); 							} 						} else { 							bin->file = strdup (last_slash + 1); 						} 					} else { 						bin->file = strdup (file); 					} 				} 				r_list_append (bins, bin); 				break; 			} 			default: 				eprintf (""Unknown sub-bin\n""); 				break; 			} 		} next: 		R_FREE (depArray); 		R_FREE (extras); 		R_FREE (img); 	} 	if (r_list_empty (bins)) { 		r_list_free (bins); 		bins = NULL; 	} 	R_FREE (deps); 	R_FREE (target_libs); 	r_list_free (target_lib_names); 	return bins; }"
"207803_CWE-200.c","CWE-200","void add_interrupt_randomness(int irq, int irq_flags) { 	struct entropy_store	*r; 	struct fast_pool	*fast_pool = this_cpu_ptr(&irq_randomness); 	struct pt_regs		*regs = get_irq_regs(); 	unsigned long		now = jiffies; 	cycles_t		cycles = random_get_entropy(); 	__u32			c_high, j_high; 	__u64			ip; 	unsigned long		seed; 	int			credit = 0;  	if (cycles == 0) 		cycles = get_reg(fast_pool, regs); 	c_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0; 	j_high = (sizeof(now) > 4) ? now >> 32 : 0; 	fast_pool->pool[0] ^= cycles ^ j_high ^ irq; 	fast_pool->pool[1] ^= now ^ c_high; 	ip = regs ? instruction_pointer(regs) : _RET_IP_; 	fast_pool->pool[2] ^= ip; 	fast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 : 		get_reg(fast_pool, regs);  	fast_mix(fast_pool); 	add_interrupt_bench(cycles);  	if (unlikely(crng_init == 0)) { 		if ((fast_pool->count >= 64) && 		    crng_fast_load((char *) fast_pool->pool, 				   sizeof(fast_pool->pool))) { 			fast_pool->count = 0; 			fast_pool->last = now; 		} 		return; 	}  	if ((fast_pool->count < 64) && 	    !time_after(now, fast_pool->last + HZ)) 		return;  	r = &input_pool; 	if (!spin_trylock(&r->lock)) 		return;  	fast_pool->last = now; 	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));  	/* 	 * If we have architectural seed generator, produce a seed and 	 * add it to the pool.  For the sake of paranoia don't let the 	 * architectural seed generator dominate the input from the 	 * interrupt noise. 	 */ 	if (arch_get_random_seed_long(&seed)) { 		__mix_pool_bytes(r, &seed, sizeof(seed)); 		credit = 1; 	} 	spin_unlock(&r->lock);  	fast_pool->count = 0;  	/* award one bit for the contents of the fast pool */ 	credit_entropy_bits(r, credit + 1); }"
"207804_CWE-200.c","CWE-200","void update_process_times(int user_tick) { 	struct task_struct *p = current;  	/* Note: this timer irq context must be accounted for as well. */ 	account_process_tick(p, user_tick); 	run_local_timers(); 	rcu_sched_clock_irq(user_tick); #ifdef CONFIG_IRQ_WORK 	if (in_irq()) 		irq_work_tick(); #endif 	scheduler_tick(); 	if (IS_ENABLED(CONFIG_POSIX_TIMERS)) 		run_posix_cpu_timers(); }"
"207826_CWE-362.c","CWE-362","inline int nci_request(struct nci_dev *ndev, 		       void (*req)(struct nci_dev *ndev, 				   const void *opt), 		       const void *opt, __u32 timeout) { 	int rc;  	if (!test_bit(NCI_UP, &ndev->flags)) 		return -ENETDOWN;  	/* Serialize all requests */ 	mutex_lock(&ndev->req_lock); 	rc = __nci_request(ndev, req, opt, timeout); 	mutex_unlock(&ndev->req_lock);  	return rc; }"
"207990_CWE-703.c","CWE-703","static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,   BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept) { int length = 1; int size; PCRE2_SPTR alternative; BOOL quit_found = FALSE; BOOL accept_found = FALSE; BOOL setsom_found = FALSE; BOOL setmark_found = FALSE; BOOL capture_last_found = FALSE; BOOL control_head_found = FALSE;  #if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD SLJIT_ASSERT(common->control_head_ptr != 0); control_head_found = TRUE; #endif  /* Calculate the sum of the private machine words. */ while (cc < ccend)   {   size = 0;   switch(*cc)     {     case OP_SET_SOM:     SLJIT_ASSERT(common->has_set_som);     setsom_found = TRUE;     cc += 1;     break;      case OP_RECURSE:     if (common->has_set_som)       setsom_found = TRUE;     if (common->mark_ptr != 0)       setmark_found = TRUE;     if (common->capture_last_ptr != 0)       capture_last_found = TRUE;     cc += 1 + LINK_SIZE;     break;      case OP_KET:     if (PRIVATE_DATA(cc) != 0)       {       length++;       SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);       cc += PRIVATE_DATA(cc + 1);       }     cc += 1 + LINK_SIZE;     break;      case OP_ASSERT:     case OP_ASSERT_NOT:     case OP_ASSERTBACK:     case OP_ASSERTBACK_NOT:     case OP_ASSERT_NA:     case OP_ASSERTBACK_NA:     case OP_ONCE:     case OP_SCRIPT_RUN:     case OP_BRAPOS:     case OP_SBRA:     case OP_SBRAPOS:     case OP_SCOND:     length++;     SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);     cc += 1 + LINK_SIZE;     break;      case OP_CBRA:     case OP_SCBRA:     length += 2;     if (common->capture_last_ptr != 0)       capture_last_found = TRUE;     if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)       length++;     cc += 1 + LINK_SIZE + IMM2_SIZE;     break;      case OP_CBRAPOS:     case OP_SCBRAPOS:     length += 2 + 2;     if (common->capture_last_ptr != 0)       capture_last_found = TRUE;     cc += 1 + LINK_SIZE + IMM2_SIZE;     break;      case OP_COND:     /* Might be a hidden SCOND. */     alternative = cc + GET(cc, 1);     if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)       length++;     cc += 1 + LINK_SIZE;     break;      CASE_ITERATOR_PRIVATE_DATA_1     if (PRIVATE_DATA(cc) != 0)       length++;     cc += 2; #ifdef SUPPORT_UNICODE     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]); #endif     break;      CASE_ITERATOR_PRIVATE_DATA_2A     if (PRIVATE_DATA(cc) != 0)       length += 2;     cc += 2; #ifdef SUPPORT_UNICODE     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]); #endif     break;      CASE_ITERATOR_PRIVATE_DATA_2B     if (PRIVATE_DATA(cc) != 0)       length += 2;     cc += 2 + IMM2_SIZE; #ifdef SUPPORT_UNICODE     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]); #endif     break;      CASE_ITERATOR_TYPE_PRIVATE_DATA_1     if (PRIVATE_DATA(cc) != 0)       length++;     cc += 1;     break;      CASE_ITERATOR_TYPE_PRIVATE_DATA_2A     if (PRIVATE_DATA(cc) != 0)       length += 2;     cc += 1;     break;      CASE_ITERATOR_TYPE_PRIVATE_DATA_2B     if (PRIVATE_DATA(cc) != 0)       length += 2;     cc += 1 + IMM2_SIZE;     break;      case OP_CLASS:     case OP_NCLASS: #if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8     case OP_XCLASS:     size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR); #else     size = 1 + 32 / (int)sizeof(PCRE2_UCHAR); #endif     if (PRIVATE_DATA(cc) != 0)       length += get_class_iterator_size(cc + size);     cc += size;     break;      case OP_MARK:     case OP_COMMIT_ARG:     case OP_PRUNE_ARG:     case OP_THEN_ARG:     SLJIT_ASSERT(common->mark_ptr != 0);     if (!setmark_found)       setmark_found = TRUE;     if (common->control_head_ptr != 0)       control_head_found = TRUE;     if (*cc != OP_MARK)       quit_found = TRUE;      cc += 1 + 2 + cc[1];     break;      case OP_PRUNE:     case OP_SKIP:     case OP_COMMIT:     quit_found = TRUE;     cc++;     break;      case OP_SKIP_ARG:     quit_found = TRUE;     cc += 1 + 2 + cc[1];     break;      case OP_THEN:     SLJIT_ASSERT(common->control_head_ptr != 0);     quit_found = TRUE;     if (!control_head_found)       control_head_found = TRUE;     cc++;     break;      case OP_ACCEPT:     case OP_ASSERT_ACCEPT:     accept_found = TRUE;     cc++;     break;      default:     cc = next_opcode(common, cc);     SLJIT_ASSERT(cc != NULL);     break;     }   } SLJIT_ASSERT(cc == ccend);  if (control_head_found)   length++; if (capture_last_found)   length++; if (quit_found)   {   if (setsom_found)     length++;   if (setmark_found)     length++;   }  *needs_control_head = control_head_found; *has_quit = quit_found; *has_accept = accept_found; return length; }"
"208076_CWE-476.c","CWE-476","RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { 	RList *entries = r_list_newf (free); 	if (!entries) { 		return NULL; 	} 	RList *segments = r_bin_ne_get_segments (bin); 	if (!segments) { 		r_list_free (entries); 		return NULL; 	} 	if (bin->ne_header->csEntryPoint) { 		RBinAddr *entry = R_NEW0 (RBinAddr); 		if (!entry) { 			r_list_free (entries); 			return NULL; 		} 		entry->bits = 16; 		ut32 entry_cs = bin->ne_header->csEntryPoint; 		RBinSection *s = r_list_get_n (segments, entry_cs - 1); 		entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);  		r_list_append (entries, entry); 	} 	int off = 0; 	size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; 	while (off < bin->ne_header->EntryTableLength) { 		if (tableat + off >= r_buf_size (bin->buf)) { 			break; 		} 		ut8 bundle_length = *(ut8 *)(bin->entry_table + off); 		if (!bundle_length) { 			break; 		} 		off++; 		ut8 bundle_type = *(ut8 *)(bin->entry_table + off); 		off++; 		int i; 		for (i = 0; i < bundle_length; i++) { 			if (tableat + off + 4 >= r_buf_size (bin->buf)) { 				break; 			} 			RBinAddr *entry = R_NEW0 (RBinAddr); 			if (!entry) { 				r_list_free (entries); 				return NULL; 			} 			off++; 			if (!bundle_type) { // Skip 				off--; 				free (entry); 				break; 			} else if (bundle_type == 0xff) { // moveable 				off += 2; 				ut8 segnum = *(bin->entry_table + off); 				off++; 				ut16 segoff = *(ut16 *)(bin->entry_table + off); 				if (segnum > 0) { 					entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; 				} 			} else { // Fixed 				if (bundle_type < bin->ne_header->SegCount) { 					entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset 						* bin->alignment + *(ut16 *)(bin->entry_table + off); 				} 			} 			off += 2; 			r_list_append (entries, entry); 		} 	} 	r_list_free (segments); 	bin->entries = entries; 	return entries; }"
"208107_CWE-703.c","CWE-703","static int xfrm_expand_policies(const struct flowi *fl, u16 family, 				struct xfrm_policy **pols, 				int *num_pols, int *num_xfrms) { 	int i;  	if (*num_pols == 0 || !pols[0]) { 		*num_pols = 0; 		*num_xfrms = 0; 		return 0; 	} 	if (IS_ERR(pols[0])) 		return PTR_ERR(pols[0]);  	*num_xfrms = pols[0]->xfrm_nr;  #ifdef CONFIG_XFRM_SUB_POLICY 	if (pols[0]->action == XFRM_POLICY_ALLOW && 	    pols[0]->type != XFRM_POLICY_TYPE_MAIN) { 		pols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]), 						    XFRM_POLICY_TYPE_MAIN, 						    fl, family, 						    XFRM_POLICY_OUT, 						    pols[0]->if_id); 		if (pols[1]) { 			if (IS_ERR(pols[1])) { 				xfrm_pols_put(pols, *num_pols); 				return PTR_ERR(pols[1]); 			} 			(*num_pols)++; 			(*num_xfrms) += pols[1]->xfrm_nr; 		} 	} #endif 	for (i = 0; i < *num_pols; i++) { 		if (pols[i]->action != XFRM_POLICY_ALLOW) { 			*num_xfrms = -1; 			break; 		} 	}  	return 0;  }"
"208115_CWE-703.c","CWE-703","static int xemaclite_of_probe(struct platform_device *ofdev) { 	struct resource *res; 	struct net_device *ndev = NULL; 	struct net_local *lp = NULL; 	struct device *dev = &ofdev->dev;  	int rc = 0;  	dev_info(dev, ""Device Tree Probing\n"");  	/* Create an ethernet device instance */ 	ndev = alloc_etherdev(sizeof(struct net_local)); 	if (!ndev) 		return -ENOMEM;  	dev_set_drvdata(dev, ndev); 	SET_NETDEV_DEV(ndev, &ofdev->dev);  	lp = netdev_priv(ndev); 	lp->ndev = ndev;  	/* Get IRQ for the device */ 	res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0); 	if (!res) { 		dev_err(dev, ""no IRQ found\n""); 		rc = -ENXIO; 		goto error; 	}  	ndev->irq = res->start;  	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0); 	lp->base_addr = devm_ioremap_resource(&ofdev->dev, res); 	if (IS_ERR(lp->base_addr)) { 		rc = PTR_ERR(lp->base_addr); 		goto error; 	}  	ndev->mem_start = res->start; 	ndev->mem_end = res->end;  	spin_lock_init(&lp->reset_lock); 	lp->next_tx_buf_to_use = 0x0; 	lp->next_rx_buf_to_use = 0x0; 	lp->tx_ping_pong = get_bool(ofdev, ""xlnx,tx-ping-pong""); 	lp->rx_ping_pong = get_bool(ofdev, ""xlnx,rx-ping-pong"");  	rc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr); 	if (rc) { 		dev_warn(dev, ""No MAC address found, using random\n""); 		eth_hw_addr_random(ndev); 	}  	/* Clear the Tx CSR's in case this is a restart */ 	xemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET); 	xemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);  	/* Set the MAC address in the EmacLite device */ 	xemaclite_update_address(lp, ndev->dev_addr);  	lp->phy_node = of_parse_phandle(ofdev->dev.of_node, ""phy-handle"", 0); 	xemaclite_mdio_setup(lp, &ofdev->dev);  	dev_info(dev, ""MAC address is now %pM\n"", ndev->dev_addr);  	ndev->netdev_ops = &xemaclite_netdev_ops; 	ndev->ethtool_ops = &xemaclite_ethtool_ops; 	ndev->flags &= ~IFF_MULTICAST; 	ndev->watchdog_timeo = TX_TIMEOUT;  	/* Finally, register the device */ 	rc = register_netdev(ndev); 	if (rc) { 		dev_err(dev, 			""Cannot register network device, aborting\n""); 		goto error; 	}  	dev_info(dev, 		 ""Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\n"", 		 (unsigned long __force)ndev->mem_start, 		 (unsigned long __force)lp->base_addr, ndev->irq); 	return 0;  error: 	free_netdev(ndev); 	return rc; }"
"208140_CWE-200.c","CWE-200","int main(int argc, char **argv) { 	int c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0; 	struct libmnt_context *cxt; 	struct libmnt_table *fstab = NULL; 	char *srcbuf = NULL; 	char *types = NULL; 	unsigned long oper = 0;  	enum { 		MOUNT_OPT_SHARED = CHAR_MAX + 1, 		MOUNT_OPT_SLAVE, 		MOUNT_OPT_PRIVATE, 		MOUNT_OPT_UNBINDABLE, 		MOUNT_OPT_RSHARED, 		MOUNT_OPT_RSLAVE, 		MOUNT_OPT_RPRIVATE, 		MOUNT_OPT_RUNBINDABLE, 		MOUNT_OPT_TARGET, 		MOUNT_OPT_SOURCE 	};  	static const struct option longopts[] = { 		{ ""all"", 0, 0, 'a' }, 		{ ""fake"", 0, 0, 'f' }, 		{ ""fstab"", 1, 0, 'T' }, 		{ ""fork"", 0, 0, 'F' }, 		{ ""help"", 0, 0, 'h' }, 		{ ""no-mtab"", 0, 0, 'n' }, 		{ ""read-only"", 0, 0, 'r' }, 		{ ""ro"", 0, 0, 'r' }, 		{ ""verbose"", 0, 0, 'v' }, 		{ ""version"", 0, 0, 'V' }, 		{ ""read-write"", 0, 0, 'w' }, 		{ ""rw"", 0, 0, 'w' }, 		{ ""options"", 1, 0, 'o' }, 		{ ""test-opts"", 1, 0, 'O' }, 		{ ""pass-fd"", 1, 0, 'p' }, 		{ ""types"", 1, 0, 't' }, 		{ ""uuid"", 1, 0, 'U' }, 		{ ""label"", 1, 0, 'L'}, 		{ ""bind"", 0, 0, 'B' }, 		{ ""move"", 0, 0, 'M' }, 		{ ""rbind"", 0, 0, 'R' }, 		{ ""make-shared"", 0, 0, MOUNT_OPT_SHARED }, 		{ ""make-slave"", 0, 0, MOUNT_OPT_SLAVE }, 		{ ""make-private"", 0, 0, MOUNT_OPT_PRIVATE }, 		{ ""make-unbindable"", 0, 0, MOUNT_OPT_UNBINDABLE }, 		{ ""make-rshared"", 0, 0, MOUNT_OPT_RSHARED }, 		{ ""make-rslave"", 0, 0, MOUNT_OPT_RSLAVE }, 		{ ""make-rprivate"", 0, 0, MOUNT_OPT_RPRIVATE }, 		{ ""make-runbindable"", 0, 0, MOUNT_OPT_RUNBINDABLE }, 		{ ""no-canonicalize"", 0, 0, 'c' }, 		{ ""internal-only"", 0, 0, 'i' }, 		{ ""show-labels"", 0, 0, 'l' }, 		{ ""target"", 1, 0, MOUNT_OPT_TARGET }, 		{ ""source"", 1, 0, MOUNT_OPT_SOURCE }, 		{ NULL, 0, 0, 0 } 	};  	static const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */ 		{ 'B','M','R',			/* bind,move,rbind */ 		   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE, 		   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE, 		   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE, 		   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },  		{ 'L','U', MOUNT_OPT_SOURCE },	/* label,uuid,source */ 		{ 0 } 	}; 	int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;  	sanitize_env(); 	setlocale(LC_ALL, """"); 	bindtextdomain(PACKAGE, LOCALEDIR); 	textdomain(PACKAGE); 	atexit(close_stdout);  	mnt_init_debug(0); 	cxt = mnt_new_context(); 	if (!cxt) 		err(MOUNT_EX_SYSERR, _(""libmount context allocation failed""));  	mnt_context_set_tables_errcb(cxt, table_parser_errcb);  	while ((c = getopt_long(argc, argv, ""aBcfFhilL:Mno:O:p:rRsU:vVwt:T:"", 					longopts, NULL)) != -1) {  		/* only few options are allowed for non-root users */ 		if (mnt_context_is_restricted(cxt) && 		    !strchr(""hlLUVvpris"", c) && 		    c != MOUNT_OPT_TARGET && 		    c != MOUNT_OPT_SOURCE) 			exit_non_root(option_to_longopt(c, longopts));  		err_exclusive_options(c, longopts, excl, excl_st);  		switch(c) { 		case 'a': 			all = 1; 			break; 		case 'c': 			mnt_context_disable_canonicalize(cxt, TRUE); 			break; 		case 'f': 			mnt_context_enable_fake(cxt, TRUE); 			break; 		case 'F': 			mnt_context_enable_fork(cxt, TRUE); 			break; 		case 'h': 			usage(stdout); 			break; 		case 'i': 			mnt_context_disable_helpers(cxt, TRUE); 			break; 		case 'n': 			mnt_context_disable_mtab(cxt, TRUE); 			break; 		case 'r': 			if (mnt_context_append_options(cxt, ""ro"")) 				err(MOUNT_EX_SYSERR, _(""failed to append options"")); 			readwrite = 0; 			break; 		case 'v': 			mnt_context_enable_verbose(cxt, TRUE); 			break; 		case 'V': 			print_version(); 			break; 		case 'w': 			if (mnt_context_append_options(cxt, ""rw"")) 				err(MOUNT_EX_SYSERR, _(""failed to append options"")); 			readwrite = 1; 			break; 		case 'o': 			if (mnt_context_append_options(cxt, optarg)) 				err(MOUNT_EX_SYSERR, _(""failed to append options"")); 			break; 		case 'O': 			if (mnt_context_set_options_pattern(cxt, optarg)) 				err(MOUNT_EX_SYSERR, _(""failed to set options pattern"")); 			break; 		case 'p':                         warnx(_(""--pass-fd is no longer supported"")); 			break; 		case 'L': 			xasprintf(&srcbuf, ""LABEL=\""%s\"""", optarg); 			mnt_context_disable_swapmatch(cxt, 1); 			mnt_context_set_source(cxt, srcbuf); 			free(srcbuf); 			break; 		case 'U': 			xasprintf(&srcbuf, ""UUID=\""%s\"""", optarg); 			mnt_context_disable_swapmatch(cxt, 1); 			mnt_context_set_source(cxt, srcbuf); 			free(srcbuf); 			break; 		case 'l': 			show_labels = 1; 			break; 		case 't': 			types = optarg; 			break; 		case 'T': 			fstab = append_fstab(cxt, fstab, optarg); 			break; 		case 's': 			mnt_context_enable_sloppy(cxt, TRUE); 			break; 		case 'B': 			oper |= MS_BIND; 			break; 		case 'M': 			oper |= MS_MOVE; 			break; 		case 'R': 			oper |= (MS_BIND | MS_REC); 			break; 		case MOUNT_OPT_SHARED: 			oper |= MS_SHARED; 			break; 		case MOUNT_OPT_SLAVE: 			oper |= MS_SLAVE; 			break; 		case MOUNT_OPT_PRIVATE: 			oper |= MS_PRIVATE; 			break; 		case MOUNT_OPT_UNBINDABLE: 			oper |= MS_UNBINDABLE; 			break; 		case MOUNT_OPT_RSHARED: 			oper |= (MS_SHARED | MS_REC); 			break; 		case MOUNT_OPT_RSLAVE: 			oper |= (MS_SLAVE | MS_REC); 			break; 		case MOUNT_OPT_RPRIVATE: 			oper |= (MS_PRIVATE | MS_REC); 			break; 		case MOUNT_OPT_RUNBINDABLE: 			oper |= (MS_UNBINDABLE | MS_REC); 			break; 		case MOUNT_OPT_TARGET: 			mnt_context_disable_swapmatch(cxt, 1); 			mnt_context_set_target(cxt, optarg); 			break; 		case MOUNT_OPT_SOURCE: 			mnt_context_disable_swapmatch(cxt, 1); 			mnt_context_set_source(cxt, optarg); 			break; 		default: 			usage(stderr); 			break; 		} 	}  	argc -= optind; 	argv += optind;  	if (fstab && !mnt_context_is_nocanonicalize(cxt)) { 		/* 		 * We have external (context independent) fstab instance, let's 		 * make a connection between the fstab and the canonicalization 		 * cache. 		 */ 		struct libmnt_cache *cache = mnt_context_get_cache(cxt); 		mnt_table_set_cache(fstab, cache); 	}  	if (!mnt_context_get_source(cxt) && 	    !mnt_context_get_target(cxt) && 	    !argc && 	    !all) { 		if (oper) 			usage(stderr); 		print_all(cxt, types, show_labels); 		goto done; 	}  	if (oper && (types || all || mnt_context_get_source(cxt))) 		usage(stderr);  	if (types && (all || strchr(types, ',') || 			     strncmp(types, ""no"", 2) == 0)) 		mnt_context_set_fstype_pattern(cxt, types); 	else if (types) 		mnt_context_set_fstype(cxt, types);  	if (all) { 		/* 		 * A) Mount all 		 */ 		rc = mount_all(cxt); 		goto done;  	} else if (argc == 0 && (mnt_context_get_source(cxt) || 				 mnt_context_get_target(cxt))) { 		/* 		 * B) mount -L|-U|--source|--target 		 */ 		if (mnt_context_is_restricted(cxt) && 		    mnt_context_get_source(cxt) && 		    mnt_context_get_target(cxt)) 			exit_non_root(NULL);  	} else if (argc == 1) { 		/* 		 * C) mount [-L|-U|--source] <target> 		 *    mount <source|target> 		 * 		 * non-root may specify source *or* target, but not both 		 */ 		if (mnt_context_is_restricted(cxt) && 		    mnt_context_get_source(cxt)) 			exit_non_root(NULL);  		mnt_context_set_target(cxt, argv[0]);  	} else if (argc == 2 && !mnt_context_get_source(cxt) 			     && !mnt_context_get_target(cxt)) { 		/* 		 * D) mount <source> <target> 		 */ 		if (mnt_context_is_restricted(cxt)) 			exit_non_root(NULL); 		mnt_context_set_source(cxt, argv[0]); 		mnt_context_set_target(cxt, argv[1]);  	} else 		usage(stderr);  	if (oper) { 		/* MS_PROPAGATION operations, let's set the mount flags */ 		mnt_context_set_mflags(cxt, oper);  		/* For -make* or --bind is fstab unnecessary */ 		mnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB); 	}  	rc = mnt_context_mount(cxt); 	rc = mk_exit_code(cxt, rc);  	if (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt)) 		success_message(cxt); done: 	mnt_free_context(cxt); 	mnt_free_table(fstab); 	return rc; }"
"208370_CWE-787.c","CWE-787","bracketed_paste(paste_mode_T mode, int drop, garray_T *gap) {     int		c;     char_u	buf[NUMBUFLEN + MB_MAXBYTES];     int		idx = 0;     char_u	*end = find_termcode((char_u *)""PE"");     int		ret_char = -1;     int		save_allow_keys = allow_keys;     int		save_paste = p_paste;      // If the end code is too long we can't detect it, read everything.     if (end != NULL && STRLEN(end) >= NUMBUFLEN) 	end = NULL;     ++no_mapping;     allow_keys = 0;     if (!p_paste) 	// Also have the side effects of setting 'paste' to make it work much 	// faster. 	set_option_value((char_u *)""paste"", TRUE, NULL, 0);      for (;;)     { 	// When the end is not defined read everything there is. 	if (end == NULL && vpeekc() == NUL) 	    break; 	do 	    c = vgetc(); 	while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR); 	if (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C)) 	    // When CTRL-C was encountered the typeahead will be flushed and we 	    // won't get the end sequence.  Except when using "":normal"". 	    break;  	if (has_mbyte) 	    idx += (*mb_char2bytes)(c, buf + idx); 	else 	    buf[idx++] = c; 	buf[idx] = NUL; 	if (end != NULL && STRNCMP(buf, end, idx) == 0) 	{ 	    if (end[idx] == NUL) 		break; // Found the end of paste code. 	    continue; 	} 	if (!drop) 	{ 	    switch (mode) 	    { 		case PASTE_CMDLINE: 		    put_on_cmdline(buf, idx, TRUE); 		    break;  		case PASTE_EX: 		    if (gap != NULL && ga_grow(gap, idx) == OK) 		    { 			mch_memmove((char *)gap->ga_data + gap->ga_len, 							     buf, (size_t)idx); 			gap->ga_len += idx; 		    } 		    break;  		case PASTE_INSERT: 		    if (stop_arrow() == OK) 		    { 			c = buf[0]; 			if (idx == 1 && (c == CAR || c == K_KENTER || c == NL)) 			    ins_eol(c); 			else 			{ 			    ins_char_bytes(buf, idx); 			    AppendToRedobuffLit(buf, idx); 			} 		    } 		    break;  		case PASTE_ONE_CHAR: 		    if (ret_char == -1) 		    { 			if (has_mbyte) 			    ret_char = (*mb_ptr2char)(buf); 			else 			    ret_char = buf[0]; 		    } 		    break; 	    } 	} 	idx = 0;     }      --no_mapping;     allow_keys = save_allow_keys;     if (!save_paste) 	set_option_value((char_u *)""paste"", FALSE, NULL, 0);      return ret_char; }"
"208411_CWE-787.c","CWE-787","check_termcode(     int		max_offset,     char_u	*buf,     int		bufsize,     int		*buflen) {     char_u	*tp;     char_u	*p;     int		slen = 0;	// init for GCC     int		modslen;     int		len;     int		retval = 0;     int		offset;     char_u	key_name[2];     int		modifiers;     char_u	*modifiers_start = NULL;     int		key;     int		new_slen;   // Length of what will replace the termcode     char_u	string[MAX_KEY_CODE_LEN + 1];     int		i, j;     int		idx = 0;     int		cpo_koffset;      cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);      /*      * Speed up the checks for terminal codes by gathering all first bytes      * used in termleader[].  Often this is just a single <Esc>.      */     if (need_gather) 	gather_termleader();      /*      * Check at several positions in typebuf.tb_buf[], to catch something like      * ""x<Up>"" that can be mapped. Stop at max_offset, because characters      * after that cannot be used for mapping, and with @r commands      * typebuf.tb_buf[] can become very long.      * This is used often, KEEP IT FAST!      */     for (offset = 0; offset < max_offset; ++offset)     { 	if (buf == NULL) 	{ 	    if (offset >= typebuf.tb_len) 		break; 	    tp = typebuf.tb_buf + typebuf.tb_off + offset; 	    len = typebuf.tb_len - offset;	// length of the input 	} 	else 	{ 	    if (offset >= *buflen) 		break; 	    tp = buf + offset; 	    len = *buflen - offset; 	}  	/* 	 * Don't check characters after K_SPECIAL, those are already 	 * translated terminal chars (avoid translating ~@^Hx). 	 */ 	if (*tp == K_SPECIAL) 	{ 	    offset += 2;	// there are always 2 extra characters 	    continue; 	}  	/* 	 * Skip this position if the character does not appear as the first 	 * character in term_strings. This speeds up a lot, since most 	 * termcodes start with the same character (ESC or CSI). 	 */ 	i = *tp; 	for (p = termleader; *p && *p != i; ++p) 	    ; 	if (*p == NUL) 	    continue;  	/* 	 * Skip this position if p_ek is not set and tp[0] is an ESC and we 	 * are in Insert mode. 	 */ 	if (*tp == ESC && !p_ek && (State & MODE_INSERT)) 	    continue;  	key_name[0] = NUL;	// no key name found yet 	key_name[1] = NUL;	// no key name found yet 	modifiers = 0;		// no modifiers yet  #ifdef FEAT_GUI 	if (gui.in_use) 	{ 	    /* 	     * GUI special key codes are all of the form [CSI xx]. 	     */ 	    if (*tp == CSI)	    // Special key from GUI 	    { 		if (len < 3) 		    return -1;	    // Shouldn't happen 		slen = 3; 		key_name[0] = tp[1]; 		key_name[1] = tp[2]; 	    } 	} 	else #endif // FEAT_GUI 	{ 	    int  mouse_index_found = -1;  	    for (idx = 0; idx < tc_len; ++idx) 	    { 		/* 		 * Ignore the entry if we are not at the start of 		 * typebuf.tb_buf[] 		 * and there are not enough characters to make a match. 		 * But only when the 'K' flag is in 'cpoptions'. 		 */ 		slen = termcodes[idx].len; 		modifiers_start = NULL; 		if (cpo_koffset && offset && len < slen) 		    continue; 		if (STRNCMP(termcodes[idx].code, tp, 				     (size_t)(slen > len ? len : slen)) == 0) 		{ 		    int	    looks_like_mouse_start = FALSE;  		    if (len < slen)		// got a partial sequence 			return -1;		// need to get more chars  		    /* 		     * When found a keypad key, check if there is another key 		     * that matches and use that one.  This makes <Home> to be 		     * found instead of <kHome> when they produce the same 		     * key code. 		     */ 		    if (termcodes[idx].name[0] == 'K' 				       && VIM_ISDIGIT(termcodes[idx].name[1])) 		    { 			for (j = idx + 1; j < tc_len; ++j) 			    if (termcodes[j].len == slen && 				    STRNCMP(termcodes[idx].code, 					    termcodes[j].code, slen) == 0) 			    { 				idx = j; 				break; 			    } 		    }  		    if (slen == 2 && len > 2 			    && termcodes[idx].code[0] == ESC 			    && termcodes[idx].code[1] == '[') 		    { 			// The mouse termcode ""ESC ["" is also the prefix of 			// ""ESC [ I"" (focus gained) and other keys.  Check some 			// more bytes to find out. 			if (!isdigit(tp[2])) 			{ 			    // ESC [ without number following: Only use it when 			    // there is no other match. 			    looks_like_mouse_start = TRUE; 			} 			else if (termcodes[idx].name[0] == KS_DEC_MOUSE) 			{ 			    char_u  *nr = tp + 2; 			    int	    count = 0;  			    // If a digit is following it could be a key with 			    // modifier, e.g., ESC [ 1;2P.  Can be confused 			    // with DEC_MOUSE, which requires four numbers 			    // following.  If not then it can't be a DEC_MOUSE 			    // code. 			    for (;;) 			    { 				++count; 				(void)getdigits(&nr); 				if (nr >= tp + len) 				    return -1;	// partial sequence 				if (*nr != ';') 				    break; 				++nr; 				if (nr >= tp + len) 				    return -1;	// partial sequence 			    } 			    if (count < 4) 				continue;	// no match 			} 		    } 		    if (looks_like_mouse_start) 		    { 			// Only use it when there is no other match. 			if (mouse_index_found < 0) 			    mouse_index_found = idx; 		    } 		    else 		    { 			key_name[0] = termcodes[idx].name[0]; 			key_name[1] = termcodes[idx].name[1]; 			break; 		    } 		}  		/* 		 * Check for code with modifier, like xterm uses: 		 * <Esc>[123;*X  (modslen == slen - 3) 		 * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X ) 		 * Also <Esc>O*X and <M-O>*X (modslen == slen - 2). 		 * When there is a modifier the * matches a number. 		 * When there is no modifier the ;* or * is omitted. 		 */ 		if (termcodes[idx].modlen > 0 && mouse_index_found < 0) 		{ 		    int at_code;  		    modslen = termcodes[idx].modlen; 		    if (cpo_koffset && offset && len < modslen) 			continue; 		    at_code = termcodes[idx].code[modslen] == '@'; 		    if (STRNCMP(termcodes[idx].code, tp, 				(size_t)(modslen > len ? len : modslen)) == 0) 		    { 			int	    n;  			if (len <= modslen)	// got a partial sequence 			    return -1;		// need to get more chars  			if (tp[modslen] == termcodes[idx].code[slen - 1]) 			    // no modifiers 			    slen = modslen + 1; 			else if (tp[modslen] != ';' && modslen == slen - 3) 			    // no match for ""code;*X"" with ""code;"" 			    continue; 			else if (at_code && tp[modslen] != '1') 			    // no match for ""<Esc>[@"" with ""<Esc>[1"" 			    continue; 			else 			{ 			    // Skip over the digits, the final char must 			    // follow. URXVT can use a negative value, thus 			    // also accept '-'. 			    for (j = slen - 2; j < len && (isdigit(tp[j]) 				       || tp[j] == '-' || tp[j] == ';'); ++j) 				; 			    ++j; 			    if (len < j)	// got a partial sequence 				return -1;	// need to get more chars 			    if (tp[j - 1] != termcodes[idx].code[slen - 1]) 				continue;	// no match  			    modifiers_start = tp + slen - 2;  			    // Match!  Convert modifier bits. 			    n = atoi((char *)modifiers_start); 			    modifiers |= decode_modifiers(n);  			    slen = j; 			} 			key_name[0] = termcodes[idx].name[0]; 			key_name[1] = termcodes[idx].name[1]; 			break; 		    } 		} 	    } 	    if (idx == tc_len && mouse_index_found >= 0) 	    { 		key_name[0] = termcodes[mouse_index_found].name[0]; 		key_name[1] = termcodes[mouse_index_found].name[1]; 	    } 	}  #ifdef FEAT_TERMRESPONSE 	if (key_name[0] == NUL 	    // Mouse codes of DEC and pterm start with <ESC>[.  When 	    // detecting the start of these mouse codes they might as well be 	    // another key code or terminal response. # ifdef FEAT_MOUSE_DEC 	    || key_name[0] == KS_DEC_MOUSE # endif # ifdef FEAT_MOUSE_PTERM 	    || key_name[0] == KS_PTERM_MOUSE # endif 	   ) 	{ 	    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;  	    /* 	     * Check for responses from the terminal starting with {lead}: 	     * ""<Esc>["" or CSI followed by [0-9>?] 	     * 	     * - Xterm version string: {lead}>{x};{vers};{y}c 	     *   Also eat other possible responses to t_RV, rxvt returns 	     *   ""{lead}?1;2c"". 	     * 	     * - Cursor position report: {lead}{row};{col}R 	     *   The final byte must be 'R'. It is used for checking the 	     *   ambiguous-width character state. 	     * 	     * - window position reply: {lead}3;{x};{y}t 	     * 	     * - key with modifiers when modifyOtherKeys is enabled: 	     *	    {lead}27;{modifier};{key}~ 	     *	    {lead}{key};{modifier}u 	     */ 	    if (((tp[0] == ESC && len >= 3 && tp[1] == '[') 			    || (tp[0] == CSI && len >= 2)) 		    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?')) 	    { 		int resp = handle_csi(tp, len, argp, offset, buf, 					     bufsize, buflen, key_name, &slen); 		if (resp != 0) 		{ # ifdef DEBUG_TERMRESPONSE 		    if (resp == -1) 			LOG_TR((""Not enough characters for CSI sequence"")); # endif 		    return resp; 		} 	    }  	    // Check for fore/background color response from the terminal, 	    // starting} with <Esc>] or OSC 	    else if ((*T_RBG != NUL || *T_RFG != NUL) 			&& ((tp[0] == ESC && len >= 2 && tp[1] == ']') 			    || tp[0] == OSC)) 	    { 		if (handle_osc(tp, argp, len, key_name, &slen) == FAIL) 		    return -1; 	    }  	    // Check for key code response from xterm, 	    // starting with <Esc>P or DCS 	    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT) 		    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P') 			|| tp[0] == DCS)) 	    { 		if (handle_dcs(tp, argp, len, key_name, &slen) == FAIL) 		    return -1; 	    } 	} #endif  	if (key_name[0] == NUL) 	    continue;	    // No match at this position, try next one  	// We only get here when we have a complete termcode match  #ifdef FEAT_GUI 	/* 	 * Only in the GUI: Fetch the pointer coordinates of the scroll event 	 * so that we know which window to scroll later. 	 */ 	if (gui.in_use 		&& key_name[0] == (int)KS_EXTRA 		&& (key_name[1] == (int)KE_X1MOUSE 		    || key_name[1] == (int)KE_X2MOUSE 		    || key_name[1] == (int)KE_MOUSEMOVE_XY 		    || key_name[1] == (int)KE_MOUSELEFT 		    || key_name[1] == (int)KE_MOUSERIGHT 		    || key_name[1] == (int)KE_MOUSEDOWN 		    || key_name[1] == (int)KE_MOUSEUP)) 	{ 	    char_u	bytes[6]; 	    int		num_bytes = get_bytes_from_buf(tp + slen, bytes, 4);  	    if (num_bytes == -1)	// not enough coordinates 		return -1; 	    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1; 	    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1; 	    slen += num_bytes; 	    // equal to K_MOUSEMOVE 	    if (key_name[1] == (int)KE_MOUSEMOVE_XY) 		key_name[1] = (int)KE_MOUSEMOVE; 	} 	else #endif 	/* 	 * If it is a mouse click, get the coordinates. 	 */ 	if (key_name[0] == KS_MOUSE #ifdef FEAT_MOUSE_GPM 		|| key_name[0] == KS_GPM_MOUSE #endif #ifdef FEAT_MOUSE_JSB 		|| key_name[0] == KS_JSBTERM_MOUSE #endif #ifdef FEAT_MOUSE_NET 		|| key_name[0] == KS_NETTERM_MOUSE #endif #ifdef FEAT_MOUSE_DEC 		|| key_name[0] == KS_DEC_MOUSE #endif #ifdef FEAT_MOUSE_PTERM 		|| key_name[0] == KS_PTERM_MOUSE #endif #ifdef FEAT_MOUSE_URXVT 		|| key_name[0] == KS_URXVT_MOUSE #endif 		|| key_name[0] == KS_SGR_MOUSE 		|| key_name[0] == KS_SGR_MOUSE_RELEASE) 	{ 	    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx, 							     &modifiers) == -1) 		return -1; 	}  #ifdef FEAT_GUI 	/* 	 * If using the GUI, then we get menu and scrollbar events. 	 * 	 * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by 	 * four bytes which are to be taken as a pointer to the vimmenu_T 	 * structure. 	 * 	 * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where ""nr"" 	 * is one byte with the tab index. 	 * 	 * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed 	 * by one byte representing the scrollbar number, and then four bytes 	 * representing a long_u which is the new value of the scrollbar. 	 * 	 * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR, 	 * KE_FILLER followed by four bytes representing a long_u which is the 	 * new value of the scrollbar. 	 */ # ifdef FEAT_MENU 	else if (key_name[0] == (int)KS_MENU) 	{ 	    long_u	val; 	    int		num_bytes = get_long_from_buf(tp + slen, &val);  	    if (num_bytes == -1) 		return -1; 	    current_menu = (vimmenu_T *)val; 	    slen += num_bytes;  	    // The menu may have been deleted right after it was used, check 	    // for that. 	    if (check_menu_pointer(root_menu, current_menu) == FAIL) 	    { 		key_name[0] = KS_EXTRA; 		key_name[1] = (int)KE_IGNORE; 	    } 	} # endif # ifdef FEAT_GUI_TABLINE 	else if (key_name[0] == (int)KS_TABLINE) 	{ 	    // Selecting tabline tab or using its menu. 	    char_u	bytes[6]; 	    int		num_bytes = get_bytes_from_buf(tp + slen, bytes, 1);  	    if (num_bytes == -1) 		return -1; 	    current_tab = (int)bytes[0]; 	    if (current_tab == 255)	// -1 in a byte gives 255 		current_tab = -1; 	    slen += num_bytes; 	} 	else if (key_name[0] == (int)KS_TABMENU) 	{ 	    // Selecting tabline tab or using its menu. 	    char_u	bytes[6]; 	    int		num_bytes = get_bytes_from_buf(tp + slen, bytes, 2);  	    if (num_bytes == -1) 		return -1; 	    current_tab = (int)bytes[0]; 	    current_tabmenu = (int)bytes[1]; 	    slen += num_bytes; 	} # endif # ifndef USE_ON_FLY_SCROLL 	else if (key_name[0] == (int)KS_VER_SCROLLBAR) 	{ 	    long_u	val; 	    char_u	bytes[6]; 	    int		num_bytes;  	    // Get the last scrollbar event in the queue of the same type 	    j = 0; 	    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR 						     && tp[j + 2] != NUL; ++i) 	    { 		j += 3; 		num_bytes = get_bytes_from_buf(tp + j, bytes, 1); 		if (num_bytes == -1) 		    break; 		if (i == 0) 		    current_scrollbar = (int)bytes[0]; 		else if (current_scrollbar != (int)bytes[0]) 		    break; 		j += num_bytes; 		num_bytes = get_long_from_buf(tp + j, &val); 		if (num_bytes == -1) 		    break; 		scrollbar_value = val; 		j += num_bytes; 		slen = j; 	    } 	    if (i == 0)		// not enough characters to make one 		return -1; 	} 	else if (key_name[0] == (int)KS_HOR_SCROLLBAR) 	{ 	    long_u	val; 	    int		num_bytes;  	    // Get the last horiz. scrollbar event in the queue 	    j = 0; 	    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR 						     && tp[j + 2] != NUL; ++i) 	    { 		j += 3; 		num_bytes = get_long_from_buf(tp + j, &val); 		if (num_bytes == -1) 		    break; 		scrollbar_value = val; 		j += num_bytes; 		slen = j; 	    } 	    if (i == 0)		// not enough characters to make one 		return -1; 	} # endif // !USE_ON_FLY_SCROLL #endif // FEAT_GUI  #if (defined(UNIX) || defined(VMS)) 	/* 	 * Handle FocusIn/FocusOut event sequences reported by XTerm. 	 * (CSI I/CSI O) 	 */ 	if (key_name[0] == KS_EXTRA # ifdef FEAT_GUI 		&& !gui.in_use # endif 	    ) 	{ 	    if (key_name[1] == KE_FOCUSGAINED) 	    { 		if (!focus_state) 		{ 		    ui_focus_change(TRUE); 		    did_cursorhold = TRUE; 		    focus_state = TRUE; 		} 		key_name[1] = (int)KE_IGNORE; 	    } 	    else if (key_name[1] == KE_FOCUSLOST) 	    { 		if (focus_state) 		{ 		    ui_focus_change(FALSE); 		    did_cursorhold = TRUE; 		    focus_state = FALSE; 		} 		key_name[1] = (int)KE_IGNORE; 	    } 	} #endif  	/* 	 * Change <xHome> to <Home>, <xUp> to <Up>, etc. 	 */ 	key = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));  	/* 	 * Add any modifier codes to our string. 	 */ 	new_slen = modifiers2keycode(modifiers, &key, string);  	// Finally, add the special key code to our string 	key_name[0] = KEY2TERMCAP0(key); 	key_name[1] = KEY2TERMCAP1(key); 	if (key_name[0] == KS_KEY) 	{ 	    // from "":set <M-b>=xx"" 	    if (has_mbyte) 		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen); 	    else 		string[new_slen++] = key_name[1]; 	} 	else if (new_slen == 0 && key_name[0] == KS_EXTRA 						  && key_name[1] == KE_IGNORE) 	{ 	    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED 	    // to indicate what happened. 	    retval = KEYLEN_REMOVED; 	} 	else 	{ 	    string[new_slen++] = K_SPECIAL; 	    string[new_slen++] = key_name[0]; 	    string[new_slen++] = key_name[1]; 	} 	if (put_string_in_typebuf(offset, slen, string, new_slen, 						 buf, bufsize, buflen) == FAIL) 	    return -1; 	return retval == 0 ? (len + new_slen - slen + offset) : retval;     }  #ifdef FEAT_TERMRESPONSE     LOG_TR((""normal character"")); #endif      return 0;			    // no match found }"
"208421_CWE-416.c","CWE-416","ex_diffgetput(exarg_T *eap) {     linenr_T	lnum;     int		count;     linenr_T	off = 0;     diff_T	*dp;     diff_T	*dprev;     diff_T	*dfree;     int		idx_cur;     int		idx_other;     int		idx_from;     int		idx_to;     int		i;     int		added;     char_u	*p;     aco_save_T	aco;     buf_T	*buf;     int		start_skip, end_skip;     int		new_count;     int		buf_empty;     int		found_not_ma = FALSE;      // Find the current buffer in the list of diff buffers.     idx_cur = diff_buf_idx(curbuf);     if (idx_cur == DB_COUNT)     { 	emsg(_(e_current_buffer_is_not_in_diff_mode)); 	return;     }      if (*eap->arg == NUL)     { 	// No argument: Find the other buffer in the list of diff buffers. 	for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) 	    if (curtab->tp_diffbuf[idx_other] != curbuf 		    && curtab->tp_diffbuf[idx_other] != NULL) 	    { 		if (eap->cmdidx != CMD_diffput 				     || curtab->tp_diffbuf[idx_other]->b_p_ma) 		    break; 		found_not_ma = TRUE; 	    } 	if (idx_other == DB_COUNT) 	{ 	    if (found_not_ma) 		emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable)); 	    else 		emsg(_(e_no_other_buffer_in_diff_mode)); 	    return; 	}  	// Check that there isn't a third buffer in the list 	for (i = idx_other + 1; i < DB_COUNT; ++i) 	    if (curtab->tp_diffbuf[i] != curbuf 		    && curtab->tp_diffbuf[i] != NULL 		    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma)) 	    { 		emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use)); 		return; 	    }     }     else     { 	// Buffer number or pattern given.  Ignore trailing white space. 	p = eap->arg + STRLEN(eap->arg); 	while (p > eap->arg && VIM_ISWHITE(p[-1])) 	    --p; 	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) 	    ; 	if (eap->arg + i == p)	    // digits only 	    i = atol((char *)eap->arg); 	else 	{ 	    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE); 	    if (i < 0) 		return;		// error message already given 	} 	buf = buflist_findnr(i); 	if (buf == NULL) 	{ 	    semsg(_(e_cant_find_buffer_str), eap->arg); 	    return; 	} 	if (buf == curbuf) 	    return;		// nothing to do 	idx_other = diff_buf_idx(buf); 	if (idx_other == DB_COUNT) 	{ 	    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg); 	    return; 	}     }      diff_busy = TRUE;      // When no range given include the line above or below the cursor.     if (eap->addr_count == 0)     { 	// Make it possible that "":diffget"" on the last line gets line below 	// the cursor line when there is no difference above the cursor. 	if (eap->cmdidx == CMD_diffget 		&& eap->line1 == curbuf->b_ml.ml_line_count 		&& diff_check(curwin, eap->line1) == 0 		&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0)) 	    ++eap->line2; 	else if (eap->line1 > 0) 	    --eap->line1;     }      if (eap->cmdidx == CMD_diffget)     { 	idx_from = idx_other; 	idx_to = idx_cur;     }     else     { 	idx_from = idx_cur; 	idx_to = idx_other; 	// Need to make the other buffer the current buffer to be able to make 	// changes in it. 	// set curwin/curbuf to buf and save a few things 	aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);     }      // May give the warning for a changed buffer here, which can trigger the     // FileChangedRO autocommand, which may do nasty things and mess     // everything up.     if (!curbuf->b_changed)     { 	change_warning(0); 	if (diff_buf_idx(curbuf) != idx_to) 	{ 	    emsg(_(e_buffer_changed_unexpectedly)); 	    goto theend; 	}     }      dprev = NULL;     for (dp = curtab->tp_first_diff; dp != NULL; )     { 	if (dp->df_lnum[idx_cur] > eap->line2 + off) 	    break;	// past the range that was specified  	dfree = NULL; 	lnum = dp->df_lnum[idx_to]; 	count = dp->df_count[idx_to]; 	if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off 		&& u_save(lnum - 1, lnum + count) != FAIL) 	{ 	    // Inside the specified range and saving for undo worked. 	    start_skip = 0; 	    end_skip = 0; 	    if (eap->addr_count > 0) 	    { 		// A range was specified: check if lines need to be skipped. 		start_skip = eap->line1 + off - dp->df_lnum[idx_cur]; 		if (start_skip > 0) 		{ 		    // range starts below start of current diff block 		    if (start_skip > count) 		    { 			lnum += count; 			count = 0; 		    } 		    else 		    { 			count -= start_skip; 			lnum += start_skip; 		    } 		} 		else 		    start_skip = 0;  		end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1 							 - (eap->line2 + off); 		if (end_skip > 0) 		{ 		    // range ends above end of current/from diff block 		    if (idx_cur == idx_from)	// :diffput 		    { 			i = dp->df_count[idx_cur] - start_skip - end_skip; 			if (count > i) 			    count = i; 		    } 		    else			// :diffget 		    { 			count -= end_skip; 			end_skip = dp->df_count[idx_from] - start_skip - count; 			if (end_skip < 0) 			    end_skip = 0; 		    } 		} 		else 		    end_skip = 0; 	    }  	    buf_empty = BUFEMPTY(); 	    added = 0; 	    for (i = 0; i < count; ++i) 	    { 		// remember deleting the last line of the buffer 		buf_empty = curbuf->b_ml.ml_line_count == 1; 		ml_delete(lnum); 		--added; 	    } 	    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) 	    { 		linenr_T nr;  		nr = dp->df_lnum[idx_from] + start_skip + i; 		if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count) 		    break; 		p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], 								  nr, FALSE)); 		if (p != NULL) 		{ 		    ml_append(lnum + i - 1, p, 0, FALSE); 		    vim_free(p); 		    ++added; 		    if (buf_empty && curbuf->b_ml.ml_line_count == 2) 		    { 			// Added the first line into an empty buffer, need to 			// delete the dummy empty line. 			buf_empty = FALSE; 			ml_delete((linenr_T)2); 		    } 		} 	    } 	    new_count = dp->df_count[idx_to] + added; 	    dp->df_count[idx_to] = new_count;  	    if (start_skip == 0 && end_skip == 0) 	    { 		// Check if there are any other buffers and if the diff is 		// equal in them. 		for (i = 0; i < DB_COUNT; ++i) 		    if (curtab->tp_diffbuf[i] != NULL && i != idx_from 								&& i != idx_to 			    && !diff_equal_entry(dp, idx_from, i)) 			break; 		if (i == DB_COUNT) 		{ 		    // delete the diff entry, the buffers are now equal here 		    dfree = dp; 		    dp = dp->df_next; 		    if (dprev == NULL) 			curtab->tp_first_diff = dp; 		    else 			dprev->df_next = dp; 		} 	    }  	    // Adjust marks.  This will change the following entries! 	    if (added != 0) 	    { 		mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added); 		if (curwin->w_cursor.lnum >= lnum) 		{ 		    // Adjust the cursor position if it's in/after the changed 		    // lines. 		    if (curwin->w_cursor.lnum >= lnum + count) 			curwin->w_cursor.lnum += added; 		    else if (added < 0) 			curwin->w_cursor.lnum = lnum; 		} 	    } 	    changed_lines(lnum, 0, lnum + count, (long)added);  	    if (dfree != NULL) 	    { 		// Diff is deleted, update folds in other windows. #ifdef FEAT_FOLDING 		diff_fold_update(dfree, idx_to); #endif 		vim_free(dfree); 	    } 	    else 		// mark_adjust() may have changed the count in a wrong way 		dp->df_count[idx_to] = new_count;  	    // When changing the current buffer, keep track of line numbers 	    if (idx_cur == idx_to) 		off += added; 	}  	// If before the range or not deleted, go to next diff. 	if (dfree == NULL) 	{ 	    dprev = dp; 	    dp = dp->df_next; 	}     }      // restore curwin/curbuf and a few other things     if (eap->cmdidx != CMD_diffget)     { 	// Syncing undo only works for the current buffer, but we change 	// another buffer.  Sync undo if the command was typed.  This isn't 	// 100% right when "":diffput"" is used in a function or mapping. 	if (KeyTyped) 	    u_sync(FALSE); 	aucmd_restbuf(&aco);     }  theend:     diff_busy = FALSE;     if (diff_need_update) 	ex_diffupdate(NULL);      // Check that the cursor is on a valid character and update its     // position.  When there were filler lines the topline has become     // invalid.     check_cursor();     changed_line_abv_curs();      if (diff_need_update) 	// redraw already done by ex_diffupdate() 	diff_need_update = FALSE;     else     { 	// Also need to redraw the other buffers. 	diff_redraw(FALSE); 	apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);     } }"
"208430_CWE-787.c","CWE-787","static ssize_t hid_debug_events_read(struct file *file, char __user *buffer, 		size_t count, loff_t *ppos) { 	struct hid_debug_list *list = file->private_data; 	int ret = 0, len; 	DECLARE_WAITQUEUE(wait, current);  	mutex_lock(&list->read_mutex); 	while (ret == 0) { 		if (list->head == list->tail) { 			add_wait_queue(&list->hdev->debug_wait, &wait); 			set_current_state(TASK_INTERRUPTIBLE);  			while (list->head == list->tail) { 				if (file->f_flags & O_NONBLOCK) { 					ret = -EAGAIN; 					break; 				} 				if (signal_pending(current)) { 					ret = -ERESTARTSYS; 					break; 				}  				if (!list->hdev || !list->hdev->debug) { 					ret = -EIO; 					set_current_state(TASK_RUNNING); 					goto out; 				}  				/* allow O_NONBLOCK from other threads */ 				mutex_unlock(&list->read_mutex); 				schedule(); 				mutex_lock(&list->read_mutex); 				set_current_state(TASK_INTERRUPTIBLE); 			}  			set_current_state(TASK_RUNNING); 			remove_wait_queue(&list->hdev->debug_wait, &wait); 		}  		if (ret) 			goto out;  		/* pass the ringbuffer contents to userspace */ copy_rest: 		if (list->tail == list->head) 			goto out; 		if (list->tail > list->head) { 			len = list->tail - list->head;  			if (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) { 				ret = -EFAULT; 				goto out; 			} 			ret += len; 			list->head += len; 		} else { 			len = HID_DEBUG_BUFSIZE - list->head;  			if (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) { 				ret = -EFAULT; 				goto out; 			} 			list->head = 0; 			ret += len; 			goto copy_rest; 		}  	} out: 	mutex_unlock(&list->read_mutex); 	return ret; }"
"208464_CWE-415.c","CWE-415","static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, 		int closing, int tx_ring) { 	struct pgv *pg_vec = NULL; 	struct packet_sock *po = pkt_sk(sk); 	unsigned long *rx_owner_map = NULL; 	int was_running, order = 0; 	struct packet_ring_buffer *rb; 	struct sk_buff_head *rb_queue; 	__be16 num; 	int err; 	/* Added to avoid minimal code churn */ 	struct tpacket_req *req = &req_u->req;  	rb = tx_ring ? &po->tx_ring : &po->rx_ring; 	rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;  	err = -EBUSY; 	if (!closing) { 		if (atomic_read(&po->mapped)) 			goto out; 		if (packet_read_pending(rb)) 			goto out; 	}  	if (req->tp_block_nr) { 		unsigned int min_frame_size;  		/* Sanity tests and some calculations */ 		err = -EBUSY; 		if (unlikely(rb->pg_vec)) 			goto out;  		switch (po->tp_version) { 		case TPACKET_V1: 			po->tp_hdrlen = TPACKET_HDRLEN; 			break; 		case TPACKET_V2: 			po->tp_hdrlen = TPACKET2_HDRLEN; 			break; 		case TPACKET_V3: 			po->tp_hdrlen = TPACKET3_HDRLEN; 			break; 		}  		err = -EINVAL; 		if (unlikely((int)req->tp_block_size <= 0)) 			goto out; 		if (unlikely(!PAGE_ALIGNED(req->tp_block_size))) 			goto out; 		min_frame_size = po->tp_hdrlen + po->tp_reserve; 		if (po->tp_version >= TPACKET_V3 && 		    req->tp_block_size < 		    BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size) 			goto out; 		if (unlikely(req->tp_frame_size < min_frame_size)) 			goto out; 		if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1))) 			goto out;  		rb->frames_per_block = req->tp_block_size / req->tp_frame_size; 		if (unlikely(rb->frames_per_block == 0)) 			goto out; 		if (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr)) 			goto out; 		if (unlikely((rb->frames_per_block * req->tp_block_nr) != 					req->tp_frame_nr)) 			goto out;  		err = -ENOMEM; 		order = get_order(req->tp_block_size); 		pg_vec = alloc_pg_vec(req, order); 		if (unlikely(!pg_vec)) 			goto out; 		switch (po->tp_version) { 		case TPACKET_V3: 			/* Block transmit is not supported yet */ 			if (!tx_ring) { 				init_prb_bdqc(po, rb, pg_vec, req_u); 			} else { 				struct tpacket_req3 *req3 = &req_u->req3;  				if (req3->tp_retire_blk_tov || 				    req3->tp_sizeof_priv || 				    req3->tp_feature_req_word) { 					err = -EINVAL; 					goto out_free_pg_vec; 				} 			} 			break; 		default: 			if (!tx_ring) { 				rx_owner_map = bitmap_alloc(req->tp_frame_nr, 					GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO); 				if (!rx_owner_map) 					goto out_free_pg_vec; 			} 			break; 		} 	} 	/* Done */ 	else { 		err = -EINVAL; 		if (unlikely(req->tp_frame_nr)) 			goto out; 	}   	/* Detach socket from network */ 	spin_lock(&po->bind_lock); 	was_running = po->running; 	num = po->num; 	if (was_running) { 		WRITE_ONCE(po->num, 0); 		__unregister_prot_hook(sk, false); 	} 	spin_unlock(&po->bind_lock);  	synchronize_net();  	err = -EBUSY; 	mutex_lock(&po->pg_vec_lock); 	if (closing || atomic_read(&po->mapped) == 0) { 		err = 0; 		spin_lock_bh(&rb_queue->lock); 		swap(rb->pg_vec, pg_vec); 		if (po->tp_version <= TPACKET_V2) 			swap(rb->rx_owner_map, rx_owner_map); 		rb->frame_max = (req->tp_frame_nr - 1); 		rb->head = 0; 		rb->frame_size = req->tp_frame_size; 		spin_unlock_bh(&rb_queue->lock);  		swap(rb->pg_vec_order, order); 		swap(rb->pg_vec_len, req->tp_block_nr);  		rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE; 		po->prot_hook.func = (po->rx_ring.pg_vec) ? 						tpacket_rcv : packet_rcv; 		skb_queue_purge(rb_queue); 		if (atomic_read(&po->mapped)) 			pr_err(""packet_mmap: vma is busy: %d\n"", 			       atomic_read(&po->mapped)); 	} 	mutex_unlock(&po->pg_vec_lock);  	spin_lock(&po->bind_lock); 	if (was_running) { 		WRITE_ONCE(po->num, num); 		register_prot_hook(sk); 	} 	spin_unlock(&po->bind_lock); 	if (pg_vec && (po->tp_version > TPACKET_V2)) { 		/* Because we don't support block-based V3 on tx-ring */ 		if (!tx_ring) 			prb_shutdown_retire_blk_timer(po, rb_queue); 	}  out_free_pg_vec: 	bitmap_free(rx_owner_map); 	if (pg_vec) 		free_pg_vec(pg_vec, order, req->tp_block_nr); out: 	return err; }"
"208505_CWE-399.c","CWE-399","networkstatus_parse_vote_from_string(const char *s, const char **eos_out,                                      networkstatus_type_t ns_type) {   smartlist_t *tokens = smartlist_create();   smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;   networkstatus_voter_info_t *voter = NULL;   networkstatus_t *ns = NULL;   digests_t ns_digests;   const char *cert, *end_of_header, *end_of_footer, *s_dup = s;   directory_token_t *tok;   int ok;   struct in_addr in;   int i, inorder, n_signatures = 0;   memarea_t *area = NULL, *rs_area = NULL;   consensus_flavor_t flav = FLAV_NS;    tor_assert(s);    if (eos_out)     *eos_out = NULL;    if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {     log_warn(LD_DIR, ""Unable to compute digest of network-status"");     goto err;   }    area = memarea_new();   end_of_header = find_start_of_next_routerstatus(s);   if (tokenize_string(area, s, end_of_header, tokens,                       (ns_type == NS_TYPE_CONSENSUS) ?                       networkstatus_consensus_token_table :                       networkstatus_token_table, 0)) {     log_warn(LD_DIR, ""Error tokenizing network-status vote header"");     goto err;   }    ns = tor_malloc_zero(sizeof(networkstatus_t));   memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));    tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);   tor_assert(tok);   if (tok->n_args > 1) {     int flavor = networkstatus_parse_flavor_name(tok->args[1]);     if (flavor < 0) {       log_warn(LD_DIR, ""Can't parse document with unknown flavor %s"",                escaped(tok->args[2]));       goto err;     }     ns->flavor = flav = flavor;   }   if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {     log_warn(LD_DIR, ""Flavor found on non-consensus networkstatus."");     goto err;   }    if (ns_type != NS_TYPE_CONSENSUS) {     const char *end_of_cert = NULL;     if (!(cert = strstr(s, ""\ndir-key-certificate-version"")))       goto err;     ++cert;     ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);     if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)       goto err;   }    tok = find_by_keyword(tokens, K_VOTE_STATUS);   tor_assert(tok->n_args);   if (!strcmp(tok->args[0], ""vote"")) {     ns->type = NS_TYPE_VOTE;   } else if (!strcmp(tok->args[0], ""consensus"")) {     ns->type = NS_TYPE_CONSENSUS;   } else if (!strcmp(tok->args[0], ""opinion"")) {     ns->type = NS_TYPE_OPINION;   } else {     log_warn(LD_DIR, ""Unrecognized vote status %s in network-status"",              escaped(tok->args[0]));     goto err;   }   if (ns_type != ns->type) {     log_warn(LD_DIR, ""Got the wrong kind of v3 networkstatus."");     goto err;   }    if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {     tok = find_by_keyword(tokens, K_PUBLISHED);     if (parse_iso_time(tok->args[0], &ns->published))       goto err;      ns->supported_methods = smartlist_create();     tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);     if (tok) {       for (i=0; i < tok->n_args; ++i)         smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));     } else {       smartlist_add(ns->supported_methods, tor_strdup(""1""));     }   } else {     tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);     if (tok) {       ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,                                                  &ok, NULL);       if (!ok)         goto err;     } else {       ns->consensus_method = 1;     }   }    tok = find_by_keyword(tokens, K_VALID_AFTER);   if (parse_iso_time(tok->args[0], &ns->valid_after))     goto err;    tok = find_by_keyword(tokens, K_FRESH_UNTIL);   if (parse_iso_time(tok->args[0], &ns->fresh_until))     goto err;    tok = find_by_keyword(tokens, K_VALID_UNTIL);   if (parse_iso_time(tok->args[0], &ns->valid_until))     goto err;    tok = find_by_keyword(tokens, K_VOTING_DELAY);   tor_assert(tok->n_args >= 2);   ns->vote_seconds =     (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);   if (!ok)     goto err;   ns->dist_seconds =     (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);   if (!ok)     goto err;   if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {     log_warn(LD_DIR, ""Vote/consensus freshness interval is too short"");     goto err;   }   if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {     log_warn(LD_DIR, ""Vote/consensus liveness interval is too short"");     goto err;   }   if (ns->vote_seconds < MIN_VOTE_SECONDS) {     log_warn(LD_DIR, ""Vote seconds is too short"");     goto err;   }   if (ns->dist_seconds < MIN_DIST_SECONDS) {     log_warn(LD_DIR, ""Dist seconds is too short"");     goto err;   }    if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {     ns->client_versions = tor_strdup(tok->args[0]);   }   if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {     ns->server_versions = tor_strdup(tok->args[0]);   }    tok = find_by_keyword(tokens, K_KNOWN_FLAGS);   ns->known_flags = smartlist_create();   inorder = 1;   for (i = 0; i < tok->n_args; ++i) {     smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));     if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {       log_warn(LD_DIR, ""%s >= %s"", tok->args[i-1], tok->args[i]);       inorder = 0;     }   }   if (!inorder) {     log_warn(LD_DIR, ""known-flags not in order"");     goto err;   }    tok = find_opt_by_keyword(tokens, K_PARAMS);   if (tok) {     inorder = 1;     ns->net_params = smartlist_create();     for (i = 0; i < tok->n_args; ++i) {       int ok=0;       char *eq = strchr(tok->args[i], '=');       if (!eq) {         log_warn(LD_DIR, ""Bad element '%s' in params"", escaped(tok->args[i]));         goto err;       }       tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);       if (!ok) {         log_warn(LD_DIR, ""Bad element '%s' in params"", escaped(tok->args[i]));         goto err;       }       if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {         log_warn(LD_DIR, ""%s >= %s"", tok->args[i-1], tok->args[i]);         inorder = 0;       }       smartlist_add(ns->net_params, tor_strdup(tok->args[i]));     }     if (!inorder) {       log_warn(LD_DIR, ""params not in order"");       goto err;     }   }    ns->voters = smartlist_create();    SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {     tok = _tok;     if (tok->tp == K_DIR_SOURCE) {       tor_assert(tok->n_args >= 6);        if (voter)         smartlist_add(ns->voters, voter);       voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));       voter->sigs = smartlist_create();       if (ns->type != NS_TYPE_CONSENSUS)         memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);        voter->nickname = tor_strdup(tok->args[0]);       if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||           base16_decode(voter->identity_digest, sizeof(voter->identity_digest),                         tok->args[1], HEX_DIGEST_LEN) < 0) {         log_warn(LD_DIR, ""Error decoding identity digest %s in ""                  ""network-status vote."", escaped(tok->args[1]));         goto err;       }       if (ns->type != NS_TYPE_CONSENSUS &&           tor_memneq(ns->cert->cache_info.identity_digest,                  voter->identity_digest, DIGEST_LEN)) {         log_warn(LD_DIR,""Mismatch between identities in certificate and vote"");         goto err;       }       voter->address = tor_strdup(tok->args[2]);       if (!tor_inet_aton(tok->args[3], &in)) {         log_warn(LD_DIR, ""Error decoding IP address %s in network-status."",                  escaped(tok->args[3]));         goto err;       }       voter->addr = ntohl(in.s_addr);       voter->dir_port = (uint16_t)         tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);       if (!ok)         goto err;       voter->or_port = (uint16_t)         tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);       if (!ok)         goto err;     } else if (tok->tp == K_CONTACT) {       if (!voter || voter->contact) {         log_warn(LD_DIR, ""contact element is out of place."");         goto err;       }       voter->contact = tor_strdup(tok->args[0]);     } else if (tok->tp == K_VOTE_DIGEST) {       tor_assert(ns->type == NS_TYPE_CONSENSUS);       tor_assert(tok->n_args >= 1);       if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {         log_warn(LD_DIR, ""vote-digest element is out of place."");         goto err;       }       if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||         base16_decode(voter->vote_digest, sizeof(voter->vote_digest),                       tok->args[0], HEX_DIGEST_LEN) < 0) {         log_warn(LD_DIR, ""Error decoding vote digest %s in ""                  ""network-status consensus."", escaped(tok->args[0]));         goto err;       }     }   } SMARTLIST_FOREACH_END(_tok);   if (voter) {     smartlist_add(ns->voters, voter);     voter = NULL;   }   if (smartlist_len(ns->voters) == 0) {     log_warn(LD_DIR, ""Missing dir-source elements in a vote networkstatus."");     goto err;   } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {     log_warn(LD_DIR, ""Too many dir-source elements in a vote networkstatus."");     goto err;   }    if (ns->type != NS_TYPE_CONSENSUS &&       (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {     int bad = 1;     if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {       networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);       if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,                         tok->args[0], HEX_DIGEST_LEN)<0)         bad = 1;       else         bad = 0;     }     if (bad) {       log_warn(LD_DIR, ""Invalid legacy key digest %s on vote."",                escaped(tok->args[0]));     }   }    /* Parse routerstatus lines. */   rs_tokens = smartlist_create();   rs_area = memarea_new();   s = end_of_header;   ns->routerstatus_list = smartlist_create();    while (!strcmpstart(s, ""r "")) {     if (ns->type != NS_TYPE_CONSENSUS) {       vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));       if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,                                                rs, 0, 0))         smartlist_add(ns->routerstatus_list, rs);       else {         tor_free(rs->version);         tor_free(rs);       }     } else {       routerstatus_t *rs;       if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,                                                      NULL, NULL,                                                      ns->consensus_method,                                                      flav)))         smartlist_add(ns->routerstatus_list, rs);     }   }   for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {     routerstatus_t *rs1, *rs2;     if (ns->type != NS_TYPE_CONSENSUS) {       vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);       vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);       rs1 = &a->status; rs2 = &b->status;     } else {       rs1 = smartlist_get(ns->routerstatus_list, i-1);       rs2 = smartlist_get(ns->routerstatus_list, i);     }     if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)         >= 0) {       log_warn(LD_DIR, ""Vote networkstatus entries not sorted by identity ""                ""digest"");       goto err;     }   }    /* Parse footer; check signature. */   footer_tokens = smartlist_create();   if ((end_of_footer = strstr(s, ""\nnetwork-status-version "")))     ++end_of_footer;   else     end_of_footer = s + strlen(s);   if (tokenize_string(area,s, end_of_footer, footer_tokens,                       networkstatus_vote_footer_token_table, 0)) {     log_warn(LD_DIR, ""Error tokenizing network-status vote footer."");     goto err;   }    {     int found_sig = 0;     SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {       tok = _tok;       if (tok->tp == K_DIRECTORY_SIGNATURE)         found_sig = 1;       else if (found_sig) {         log_warn(LD_DIR, ""Extraneous token after first directory-signature"");         goto err;       }     } SMARTLIST_FOREACH_END(_tok);   }    if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {     if (tok != smartlist_get(footer_tokens, 0)) {       log_warn(LD_DIR, ""Misplaced directory-footer token"");       goto err;     }   }    tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);   if (tok) {     ns->weight_params = smartlist_create();     for (i = 0; i < tok->n_args; ++i) {       int ok=0;       char *eq = strchr(tok->args[i], '=');       if (!eq) {         log_warn(LD_DIR, ""Bad element '%s' in weight params"",                  escaped(tok->args[i]));         goto err;       }       tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);       if (!ok) {         log_warn(LD_DIR, ""Bad element '%s' in params"", escaped(tok->args[i]));         goto err;       }       smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));     }   }    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {     char declared_identity[DIGEST_LEN];     networkstatus_voter_info_t *v;     document_signature_t *sig;     const char *id_hexdigest = NULL;     const char *sk_hexdigest = NULL;     digest_algorithm_t alg = DIGEST_SHA1;     tok = _tok;     if (tok->tp != K_DIRECTORY_SIGNATURE)       continue;     tor_assert(tok->n_args >= 2);     if (tok->n_args == 2) {       id_hexdigest = tok->args[0];       sk_hexdigest = tok->args[1];     } else {       const char *algname = tok->args[0];       int a;       id_hexdigest = tok->args[1];       sk_hexdigest = tok->args[2];       a = crypto_digest_algorithm_parse_name(algname);       if (a<0) {         log_warn(LD_DIR, ""Unknown digest algorithm %s; skipping"",                  escaped(algname));         continue;       }       alg = a;     }      if (!tok->object_type ||         strcmp(tok->object_type, ""SIGNATURE"") ||         tok->object_size < 128 || tok->object_size > 512) {       log_warn(LD_DIR, ""Bad object type or length on directory-signature"");       goto err;     }      if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||         base16_decode(declared_identity, sizeof(declared_identity),                       id_hexdigest, HEX_DIGEST_LEN) < 0) {       log_warn(LD_DIR, ""Error decoding declared identity %s in ""                ""network-status vote."", escaped(id_hexdigest));       goto err;     }     if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {       log_warn(LD_DIR, ""ID on signature on network-status vote does not match ""                ""any declared directory source."");       goto err;     }     sig = tor_malloc_zero(sizeof(document_signature_t));     memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);     sig->alg = alg;     if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||         base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),                       sk_hexdigest, HEX_DIGEST_LEN) < 0) {       log_warn(LD_DIR, ""Error decoding declared signing key digest %s in ""                ""network-status vote."", escaped(sk_hexdigest));       tor_free(sig);       goto err;     }      if (ns->type != NS_TYPE_CONSENSUS) {       if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,                  DIGEST_LEN)) {         log_warn(LD_DIR, ""Digest mismatch between declared and actual on ""                  ""network-status vote."");         tor_free(sig);         goto err;       }     }      if (voter_get_sig_by_algorithm(v, sig->alg)) {       /* We already parsed a vote with this algorithm from this voter. Use the          first one. */       log_fn(LOG_PROTOCOL_WARN, LD_DIR, ""We received a networkstatus ""              ""that contains two votes from the same voter with the same ""              ""algorithm. Ignoring the second vote."");       tor_free(sig);       continue;     }      if (ns->type != NS_TYPE_CONSENSUS) {       if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,                                 tok, ns->cert->signing_key, 0,                                 ""network-status vote"")) {         tor_free(sig);         goto err;       }       sig->good_signature = 1;     } else {       if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {         tor_free(sig);         goto err;       }       sig->signature = tor_memdup(tok->object_body, tok->object_size);       sig->signature_len = (int) tok->object_size;     }     smartlist_add(v->sigs, sig);      ++n_signatures;   } SMARTLIST_FOREACH_END(_tok);    if (! n_signatures) {     log_warn(LD_DIR, ""No signatures on networkstatus vote."");     goto err;   } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {     log_warn(LD_DIR, ""Received more than one signature on a ""              ""network-status vote."");     goto err;   }    if (eos_out)     *eos_out = end_of_footer;    goto done;  err:   dump_desc(s_dup, ""v3 networkstatus"");   networkstatus_vote_free(ns);   ns = NULL;  done:   if (tokens) {     SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));     smartlist_free(tokens);   }   if (voter) {     if (voter->sigs) {       SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,                         document_signature_free(sig));       smartlist_free(voter->sigs);     }     tor_free(voter->nickname);     tor_free(voter->address);     tor_free(voter->contact);     tor_free(voter);   }   if (rs_tokens) {     SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));     smartlist_free(rs_tokens);   }   if (footer_tokens) {     SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));     smartlist_free(footer_tokens);   }   if (area) {     DUMP_AREA(area, ""v3 networkstatus"");     memarea_drop_all(area);   }   if (rs_area)     memarea_drop_all(rs_area);    return ns; }"
"208506_CWE-476.cpp","CWE-476","tgs_build_reply(astgs_request_t priv, 		hdb_entry_ex *krbtgt, 		krb5_enctype krbtgt_etype, 		const krb5_keyblock *replykey, 		int rk_is_subkey, 		krb5_ticket *ticket, 		const char **e_text, 		AuthorizationData **auth_data, 		const struct sockaddr *from_addr) {     krb5_context context = priv->context;     krb5_kdc_configuration *config = priv->config;     KDC_REQ *req = &priv->req;     KDC_REQ_BODY *b = &priv->req.req_body;     const char *from = priv->from;     krb5_error_code ret, ret2;     krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;     krb5_principal krbtgt_out_principal = NULL;     char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;     hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;     HDB *clientdb, *s4u2self_impersonated_clientdb;     krb5_realm ref_realm = NULL;     EncTicketPart *tgt = &ticket->ticket;     krb5_principals spp = NULL;     const EncryptionKey *ekey;     krb5_keyblock sessionkey;     krb5_kvno kvno;     krb5_data rspac;     const char *tgt_realm = /* Realm of TGT issuer */         krb5_principal_get_realm(context, krbtgt->entry.principal);     const char *our_realm = /* Realm of this KDC */         krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);     char **capath = NULL;     size_t num_capath = 0;      hdb_entry_ex *krbtgt_out = NULL;      METHOD_DATA enc_pa_data;      PrincipalName *s;     Realm r;     EncTicketPart adtkt;     char opt_str[128];     int signedpath = 0;      Key *tkey_check;     Key *tkey_sign;     int flags = HDB_F_FOR_TGS_REQ;      memset(&sessionkey, 0, sizeof(sessionkey));     memset(&adtkt, 0, sizeof(adtkt));     krb5_data_zero(&rspac);     memset(&enc_pa_data, 0, sizeof(enc_pa_data));      s = b->sname;     r = b->realm;      /*      * The canonicalize KDC option is passed as a hint to the backend, but      * can typically be ignored. Per RFC 6806, names are not canonicalized      * in response to a TGS request (although we make an exception, see      * force-canonicalize below).      */     if (b->kdc_options.canonicalize) 	flags |= HDB_F_CANON;      if(b->kdc_options.enc_tkt_in_skey){ 	Ticket *t; 	hdb_entry_ex *uu; 	krb5_principal p; 	Key *uukey; 	krb5uint32 second_kvno = 0; 	krb5uint32 *kvno_ptr = NULL;  	if(b->additional_tickets == NULL || 	   b->additional_tickets->len == 0){ 	    ret = KRB5KDC_ERR_BADOPTION; /* ? */ 	    kdc_log(context, config, 4, 		    ""No second ticket present in user-to-user request"");             _kdc_audit_addreason((kdc_request_t)priv,                                  ""No second ticket present in user-to-user request""); 	    goto out; 	} 	t = &b->additional_tickets->val[0]; 	if(!get_krbtgt_realm(&t->sname)){ 	    kdc_log(context, config, 4, 		    ""Additional ticket is not a ticket-granting ticket"");             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Additional ticket is not a ticket-granting ticket""); 	    ret = KRB5KDC_ERR_POLICY; 	    goto out; 	} 	_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm); 	ret = krb5_unparse_name(context, p, &tpn); 	if (ret) 		goto out; 	if(t->enc_part.kvno){ 	    second_kvno = *t->enc_part.kvno; 	    kvno_ptr = &second_kvno; 	} 	ret = _kdc_db_fetch(context, config, p, 			    HDB_F_GET_KRBTGT, kvno_ptr, 			    NULL, &uu); 	krb5_free_principal(context, p); 	if(ret){ 	    if (ret == HDB_ERR_NOENTRY) 		ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;             _kdc_audit_addreason((kdc_request_t)priv,                                  ""User-to-user service principal (TGS) unknown""); 	    goto out; 	} 	ret = hdb_enctype2key(context, &uu->entry, NULL, 			      t->enc_part.etype, &uukey); 	if(ret){ 	    _kdc_free_ent(context, uu); 	    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */             _kdc_audit_addreason((kdc_request_t)priv,                                  ""User-to-user enctype not supported""); 	    goto out; 	} 	ret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0); 	_kdc_free_ent(context, uu); 	if(ret) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""User-to-user TGT decrypt failure""); 	    goto out;         }  	ret = verify_flags(context, config, &adtkt, tpn); 	if (ret) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""User-to-user TGT expired or invalid""); 	    goto out;         }  	s = &adtkt.cname; 	r = adtkt.crealm;     }      _krb5_principalname2krb5_principal(context, &sp, *s, r);     ret = krb5_unparse_name(context, sp, &priv->sname);     if (ret) 	goto out;     spn = priv->sname;     _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);     ret = krb5_unparse_name(context, cp, &priv->cname);     if (ret) 	goto out;     cpn = priv->cname;     unparse_flags (KDCOptions2int(b->kdc_options), 		   asn1_KDCOptions_units(), 		   opt_str, sizeof(opt_str));     if(*opt_str) 	kdc_log(context, config, 4, 		""TGS-REQ %s from %s for %s [%s]"", 		cpn, from, spn, opt_str);     else 	kdc_log(context, config, 4, 		""TGS-REQ %s from %s for %s"", cpn, from, spn);      /*      * Fetch server      */  server_lookup:     ret = _kdc_db_fetch(context, config, sp,                         HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags, 			NULL, NULL, &server);     priv->server = server;     if (ret == HDB_ERR_NOT_FOUND_HERE) { 	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"", spn);         _kdc_audit_addreason((kdc_request_t)priv, ""Target not found here""); 	goto out;     } else if (ret == HDB_ERR_WRONG_REALM) {         free(ref_realm); 	ref_realm = strdup(server->entry.principal->realm); 	if (ref_realm == NULL) {             ret = krb5_enomem(context); 	    goto out; 	}  	kdc_log(context, config, 4, 		""Returning a referral to realm %s for "" 		""server %s."", 		ref_realm, spn); 	krb5_free_principal(context, sp); 	sp = NULL; 	ret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME, 				  ref_realm, NULL); 	if (ret) 	    goto out; 	free(priv->sname);         priv->sname = NULL; 	ret = krb5_unparse_name(context, sp, &priv->sname); 	if (ret) 	    goto out; 	spn = priv->sname;  	goto server_lookup;     } else if (ret) { 	const char *new_rlm, *msg; 	Realm req_rlm; 	krb5_realm *realms;  	if ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {             if (capath == NULL) {                 /* With referalls, hierarchical capaths are always enabled */                 ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,                                          req_rlm, TRUE, &capath, &num_capath);                 if (ret2) {                     ret = ret2;                     _kdc_audit_addreason((kdc_request_t)priv,                                          ""No trusted path from client realm to ours"");                     goto out;                 }             }             new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;             if (new_rlm) {                 kdc_log(context, config, 5, ""krbtgt from %s via %s for ""                         ""realm %s not found, trying %s"", tgt->crealm,                         our_realm, req_rlm, new_rlm);                  free(ref_realm);                 ref_realm = strdup(new_rlm);                 if (ref_realm == NULL) {                     ret = krb5_enomem(context);                     goto out;                 }                  krb5_free_principal(context, sp);                 sp = NULL;                 krb5_make_principal(context, &sp, r,                                     KRB5_TGS_NAME, ref_realm, NULL);                 free(priv->sname);                 priv->sname = NULL;                 ret = krb5_unparse_name(context, sp, &priv->sname);                 if (ret)                     goto out;                 spn = priv->sname;                 goto server_lookup;             } 	} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) { 	    if (strcmp(realms[0], sp->realm) != 0) { 		kdc_log(context, config, 4, 			""Returning a referral to realm %s for "" 			""server %s that was not found"", 			realms[0], spn); 		krb5_free_principal(context, sp);                 sp = NULL; 		krb5_make_principal(context, &sp, r, KRB5_TGS_NAME, 				    realms[0], NULL); 		free(priv->sname);                 priv->sname = NULL; 		ret = krb5_unparse_name(context, sp, &priv->sname); 		if (ret) { 		    krb5_free_host_realm(context, realms); 		    goto out; 		} 		spn = priv->sname;                  free(ref_realm); 		ref_realm = strdup(realms[0]);  		krb5_free_host_realm(context, realms); 		goto server_lookup; 	    } 	    krb5_free_host_realm(context, realms); 	} 	msg = krb5_get_error_message(context, ret); 	kdc_log(context, config, 3, 		""Server not found in database: %s: %s"", spn, msg); 	krb5_free_error_message(context, msg); 	if (ret == HDB_ERR_NOENTRY) 	    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;         _kdc_audit_addreason((kdc_request_t)priv,                              ""Service principal unknown""); 	goto out;     }      /*      * RFC 6806 notes that names MUST NOT be changed in the response to      * a TGS request. Hence we ignore the setting of the canonicalize      * KDC option. However, for legacy interoperability we do allow the      * backend to override this by setting the force-canonicalize HDB      * flag in the server entry.      */     if (server->entry.flags.force_canonicalize) 	rsp = server->entry.principal;     else 	rsp = sp;      /*      * Select enctype, return key and kvno.      */      { 	krb5_enctype etype;  	if(b->kdc_options.enc_tkt_in_skey) { 	    size_t i; 	    ekey = &adtkt.key; 	    for(i = 0; i < b->etype.len; i++) 		if (b->etype.val[i] == adtkt.key.keytype) 		    break; 	    if(i == b->etype.len) { 		kdc_log(context, config, 4, 			""Addition ticket have not matching etypes""); 		krb5_clear_error_message(context); 		ret = KRB5KDC_ERR_ETYPE_NOSUPP;                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""No matching enctypes for 2nd ticket""); 		goto out; 	    } 	    etype = b->etype.val[i]; 	    kvno = 0; 	} else { 	    Key *skey;  	    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp) 							     ? KFE_IS_TGS : 0, 				  b->etype.val, b->etype.len, &etype, NULL, 				  NULL); 	    if(ret) { 		kdc_log(context, config, 4, 			""Server (%s) has no support for etypes"", spn);                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""Enctype not supported""); 		goto out; 	    } 	    ret = _kdc_get_preferred_key(context, config, server, spn, 					 NULL, &skey); 	    if(ret) { 		kdc_log(context, config, 4, 			""Server (%s) has no supported etypes"", spn);                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""Enctype not supported""); 		goto out; 	    } 	    ekey = &skey->key; 	    kvno = server->entry.kvno; 	}  	ret = krb5_generate_random_keyblock(context, etype, &sessionkey); 	if (ret) 	    goto out;     }      /*      * Check that service is in the same realm as the krbtgt. If it's      * not the same, it's someone that is using a uni-directional trust      * backward.      */      /*      * Validate authorization data      */      ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */ 			  krbtgt_etype, &tkey_check);     if(ret) { 	kdc_log(context, config, 4, 		    ""Failed to find key for krbtgt PAC check"");         _kdc_audit_addreason((kdc_request_t)priv,                              ""No key for krbtgt PAC check""); 	goto out;     }      /*       * Now refetch the primary krbtgt, and get the current kvno (the      * sign check may have been on an old kvno, and the server may      * have been an incoming trust)      */          ret = krb5_make_principal(context,                               &krbtgt_out_principal,                               our_realm,                               KRB5_TGS_NAME,                               our_realm,                               NULL);     if (ret) {         kdc_log(context, config, 4,                 ""Failed to make krbtgt principal name object for ""                 ""authz-data signatures"");         goto out;     }     ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);     if (ret) {         kdc_log(context, config, 4,                 ""Failed to make krbtgt principal name object for ""                 ""authz-data signatures"");         goto out;     }      ret = _kdc_db_fetch(context, config, krbtgt_out_principal, 			HDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);     if (ret) { 	char *ktpn = NULL; 	ret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn); 	kdc_log(context, config, 4, 		""No such principal %s (needed for authz-data signature keys) "" 		""while processing TGS-REQ for service %s with krbtg %s"", 		krbtgt_out_n, spn, (ret == 0) ? ktpn : ""<unknown>""); 	free(ktpn); 	ret = KRB5KRB_AP_ERR_NOT_US; 	goto out;     }      /*       * The first realm is the realm of the service, the second is      * krbtgt/<this>/@REALM component of the krbtgt DN the request was      * encrypted to.  The redirection via the krbtgt_out entry allows      * the DB to possibly correct the case of the realm (Samba4 does      * this) before the strcmp()       */     if (strcmp(krb5_principal_get_realm(context, server->entry.principal), 	       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) { 	char *ktpn; 	ret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn); 	kdc_log(context, config, 4, 		""Request with wrong krbtgt: %s"", 		(ret == 0) ? ktpn : ""<unknown>""); 	if(ret == 0) 	    free(ktpn); 	ret = KRB5KRB_AP_ERR_NOT_US;         _kdc_audit_addreason((kdc_request_t)priv, ""Request with wrong TGT""); 	goto out;     }      ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n, 				 NULL, &tkey_sign);     if (ret) { 	kdc_log(context, config, 4, 		    ""Failed to find key for krbtgt PAC signature"");         _kdc_audit_addreason((kdc_request_t)priv,                              ""Failed to find key for krbtgt PAC signature""); 	goto out;     }     ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL, 			  tkey_sign->key.keytype, &tkey_sign);     if(ret) { 	kdc_log(context, config, 4, 		    ""Failed to find key for krbtgt PAC signature"");         _kdc_audit_addreason((kdc_request_t)priv,                              ""Failed to find key for krbtgt PAC signature""); 	goto out;     }      {         krb5_data verified_cas;          /*          * If the client doesn't exist in the HDB but has a TGT and it's          * obtained with PKINIT then we assume it's a synthetic client -- that          * is, a client whose name was vouched for by a CA using a PKINIT SAN,          * but which doesn't exist in the HDB proper.  We'll allow such a          * client to do TGT requests even though normally we'd reject all          * clients that don't exist in the HDB.          */         ret = krb5_ticket_get_authorization_data_type(context, ticket,                                                       KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,                                                       &verified_cas);         if (ret == 0) {             krb5_data_free(&verified_cas);             flags |= HDB_F_SYNTHETIC_OK;         }     }     ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags, 			NULL, &clientdb, &client);     flags &= ~HDB_F_SYNTHETIC_OK;     priv->client = client;     if(ret == HDB_ERR_NOT_FOUND_HERE) { 	/* This is OK, we are just trying to find out if they have 	 * been disabled or deleted in the meantime, missing secrets 	 * is OK */     } else if(ret){ 	const char *krbtgt_realm, *msg;  	/* 	 * If the client belongs to the same realm as our krbtgt, it 	 * should exist in the local database. 	 * 	 */  	krbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);  	if(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) { 	    if (ret == HDB_ERR_NOENTRY) 		ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; 	    kdc_log(context, config, 4, ""Client no longer in database: %s"", 		    cpn);             _kdc_audit_addreason((kdc_request_t)priv, ""Client no longer in HDB""); 	    goto out; 	}  	msg = krb5_get_error_message(context, ret); 	kdc_log(context, config, 4, ""Client not found in database: %s"", msg);         _kdc_audit_addreason((kdc_request_t)priv, ""Client does not exist""); 	krb5_free_error_message(context, msg);     } else if (ret == 0 &&                (client->entry.flags.invalid || !client->entry.flags.client)) {         _kdc_audit_addreason((kdc_request_t)priv, ""Client has invalid bit set"");         kdc_log(context, config, 4, ""Client has invalid bit set"");         ret = KRB5KDC_ERR_POLICY;         goto out;     }      ret = check_PAC(context, config, cp, NULL, 		    client, server, krbtgt, 		    &tkey_check->key, 		    ekey, &tkey_sign->key, 		    tgt, &rspac, &signedpath);     if (ret) { 	const char *msg = krb5_get_error_message(context, ret);         _kdc_audit_addreason((kdc_request_t)priv, ""PAC check failed""); 	kdc_log(context, config, 4, 		""Verify PAC failed for %s (%s) from %s with %s"", 		spn, cpn, from, msg); 	krb5_free_error_message(context, msg); 	goto out;     }      /* also check the krbtgt for signature */     ret = check_KRB5SignedPath(context, 			       config, 			       krbtgt, 			       cp, 			       tgt, 			       &spp, 			       &signedpath);     if (ret) { 	const char *msg = krb5_get_error_message(context, ret);         _kdc_audit_addreason((kdc_request_t)priv, ""KRB5SignedPath check failed""); 	kdc_log(context, config, 4, 		""KRB5SignedPath check failed for %s (%s) from %s with %s"", 		spn, cpn, from, msg); 	krb5_free_error_message(context, msg); 	goto out;     }      /*      * Process request      */      /* by default the tgt principal matches the client principal */     tp = cp;     tpn = cpn;      if (client) { 	const PA_DATA *sdata; 	int i = 0;  	sdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER); 	if (sdata) { 	    struct astgs_request_desc imp_req; 	    krb5_crypto crypto; 	    krb5_data datack; 	    PA_S4U2Self self; 	    const char *str;  	    ret = decode_PA_S4U2Self(sdata->padata_value.data, 				     sdata->padata_value.length, 				     &self, NULL); 	    if (ret) {                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""Failed to decode PA-S4U2Self""); 		kdc_log(context, config, 4, ""Failed to decode PA-S4U2Self""); 		goto out; 	    }  	    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) { 		free_PA_S4U2Self(&self);                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""PA-S4U2Self with unkeyed checksum""); 		kdc_log(context, config, 4, ""Reject PA-S4U2Self with unkeyed checksum""); 		ret = KRB5KRB_AP_ERR_INAPP_CKSUM; 		goto out; 	    }  	    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack); 	    if (ret) 		goto out;  	    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto); 	    if (ret) { 		const char *msg = krb5_get_error_message(context, ret); 		free_PA_S4U2Self(&self); 		krb5_data_free(&datack); 		kdc_log(context, config, 4, ""krb5_crypto_init failed: %s"", msg); 		krb5_free_error_message(context, msg); 		goto out; 	    }  	    /* Allow HMAC_MD5 checksum with any key type */ 	    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) { 		struct krb5_crypto_iov iov; 		unsigned char csdata[16]; 		Checksum cs;  		cs.checksum.length = sizeof(csdata); 		cs.checksum.data = &csdata;  		iov.data.data = datack.data; 		iov.data.length = datack.length; 		iov.flags = KRB5_CRYPTO_TYPE_DATA;  		ret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key, 					      KRB5_KU_OTHER_CKSUM, &iov, 1, 					      &cs); 		if (ret == 0 && 		    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0) 		    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; 	    } 	    else { 		ret = krb5_verify_checksum(context, 					   crypto, 					   KRB5_KU_OTHER_CKSUM, 					   datack.data, 					   datack.length, 					   &self.cksum); 	    } 	    krb5_data_free(&datack); 	    krb5_crypto_destroy(context, crypto); 	    if (ret) { 		const char *msg = krb5_get_error_message(context, ret); 		free_PA_S4U2Self(&self);                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""S4U2Self checksum failed""); 		kdc_log(context, config, 4, 			""krb5_verify_checksum failed for S4U2Self: %s"", msg); 		krb5_free_error_message(context, msg); 		goto out; 	    }  	    ret = _krb5_principalname2krb5_principal(context, 						     &tp, 						     self.name, 						     self.realm); 	    free_PA_S4U2Self(&self); 	    if (ret) 		goto out;  	    ret = krb5_unparse_name(context, tp, &tpn); 	    if (ret) 		goto out;              /*              * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients              * is probably not desirable!              */ 	    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags, 				NULL, &s4u2self_impersonated_clientdb, 				&s4u2self_impersonated_client); 	    if (ret) { 		const char *msg;  		/* 		 * If the client belongs to the same realm as our krbtgt, it 		 * should exist in the local database. 		 * 		 */  		if (ret == HDB_ERR_NOENTRY) 		    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; 		msg = krb5_get_error_message(context, ret);                 _kdc_audit_addreason((kdc_request_t)priv,                                      ""S4U2Self principal to impersonate not found""); 		kdc_log(context, config, 2, 			""S4U2Self principal to impersonate %s not found in database: %s"", 			tpn, msg); 		krb5_free_error_message(context, msg); 		goto out; 	    }  	    /* Ignore require_pwchange and pw_end attributes (as Windows does), 	     * since S4U2Self is not password authentication. */ 	    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE; 	    free(s4u2self_impersonated_client->entry.pw_end); 	    s4u2self_impersonated_client->entry.pw_end = NULL;  	    imp_req = *priv; 	    imp_req.client = s4u2self_impersonated_client; 	    imp_req.client_princ = tp;  	    ret = kdc_check_flags(&imp_req, FALSE); 	    if (ret) 		goto out; /* kdc_check_flags() calls _kdc_audit_addreason() */  	    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */ 	    if(rspac.data) { 		krb5_pac p = NULL; 		krb5_data_free(&rspac); 		ret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p); 		if (ret) {                     _kdc_audit_addreason((kdc_request_t)priv,                                          ""KRB5SignedPath missing""); 		    kdc_log(context, config, 4, ""PAC generation failed for -- %s"", 			    tpn); 		    goto out; 		} 		if (p != NULL) { 		    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime, 					 s4u2self_impersonated_client->entry.principal, 					 ekey, &tkey_sign->key, 					 &rspac); 		    krb5_pac_free(context, p); 		    if (ret) { 			kdc_log(context, config, 4, ""PAC signing failed for -- %s"", 				tpn); 			goto out; 		    } 		} 	    }  	    /* 	     * Check that service doing the impersonating is 	     * requesting a ticket to it-self. 	     */ 	    ret = check_s4u2self(context, config, clientdb, client, sp); 	    if (ret) { 		kdc_log(context, config, 4, ""S4U2Self: %s is not allowed "" 			""to impersonate to service "" 			""(tried for user %s to service %s)"", 			cpn, tpn, spn); 		goto out; 	    }  	    /* 	     * If the service isn't trusted for authentication to 	     * delegation or if the impersonate client is disallowed 	     * forwardable, remove the forwardable flag. 	     */  	    if (client->entry.flags.trusted_for_delegation && 		s4u2self_impersonated_client->entry.flags.forwardable) { 		str = ""[forwardable]""; 	    } else { 		b->kdc_options.forwardable = 0; 		str = """"; 	    } 	    kdc_log(context, config, 4, ""s4u2self %s impersonating %s to "" 		    ""service %s %s"", cpn, tpn, spn, str); 	}     }      /*      * Constrained delegation      */      if (client != NULL 	&& b->additional_tickets != NULL 	&& b->additional_tickets->len != 0 	&& b->kdc_options.cname_in_addl_tkt 	&& b->kdc_options.enc_tkt_in_skey == 0)     { 	int ad_signedpath = 0; 	Key *clientkey; 	Ticket *t;  	/* 	 * Require that the KDC have issued the service's krbtgt (not 	 * self-issued ticket with kimpersonate(1). 	 */ 	if (!signedpath) { 	    ret = KRB5KDC_ERR_BADOPTION;             _kdc_audit_addreason((kdc_request_t)priv, ""KRB5SignedPath missing""); 	    kdc_log(context, config, 4, 		    ""Constrained delegation done on service ticket %s/%s"", 		    cpn, spn); 	    goto out; 	}  	t = &b->additional_tickets->val[0];  	ret = hdb_enctype2key(context, &client->entry, 			      hdb_kvno2keys(context, &client->entry, 					    t->enc_part.kvno ? * t->enc_part.kvno : 0), 			      t->enc_part.etype, &clientkey); 	if(ret){ 	    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */ 	    goto out; 	}  	ret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0); 	if (ret) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Failed to decrypt constrained delegation ticket""); 	    kdc_log(context, config, 4, 		    ""failed to decrypt ticket for "" 		    ""constrained delegation from %s to %s "", cpn, spn); 	    goto out; 	}  	ret = _krb5_principalname2krb5_principal(context, 						 &tp, 						 adtkt.cname, 						 adtkt.crealm); 	if (ret) 	    goto out;  	ret = krb5_unparse_name(context, tp, &tpn); 	if (ret) 	    goto out;          _kdc_audit_addkv((kdc_request_t)priv, 0, ""impersonatee"", ""%s"", tpn);  	ret = _krb5_principalname2krb5_principal(context, 						 &dp, 						 t->sname, 						 t->realm); 	if (ret) 	    goto out;  	ret = krb5_unparse_name(context, dp, &dpn); 	if (ret) 	    goto out;  	/* check that ticket is valid */ 	if (adtkt.flags.forwardable == 0) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Missing forwardable flag on ticket for constrained delegation""); 	    kdc_log(context, config, 4, 		    ""Missing forwardable flag on ticket for "" 		    ""constrained delegation from %s (%s) as %s to %s "", 		    cpn, dpn, tpn, spn); 	    ret = KRB5KDC_ERR_BADOPTION; 	    goto out; 	}  	ret = check_constrained_delegation(context, config, clientdb, 					   client, server, sp); 	if (ret) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Constrained delegation not allowed""); 	    kdc_log(context, config, 4, 		    ""constrained delegation from %s (%s) as %s to %s not allowed"", 		    cpn, dpn, tpn, spn); 	    goto out; 	}  	ret = verify_flags(context, config, &adtkt, tpn); 	if (ret) {             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Constrained delegation ticket expired or invalid""); 	    goto out; 	}  	krb5_data_free(&rspac);  	/* 	 * generate the PAC for the user. 	 * 	 * TODO: pass in t->sname and t->realm and build 	 * a S4U_DELEGATION_INFO blob to the PAC. 	 */ 	ret = check_PAC(context, config, tp, dp, 			client, server, krbtgt, 			&clientkey->key, 			ekey, &tkey_sign->key, 			&adtkt, &rspac, &ad_signedpath); 	if (ret) { 	    const char *msg = krb5_get_error_message(context, ret);             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Constrained delegation ticket PAC check failed""); 	    kdc_log(context, config, 4, 		    ""Verify delegated PAC failed to %s for client"" 		    ""%s (%s) as %s from %s with %s"", 		    spn, cpn, dpn, tpn, from, msg); 	    krb5_free_error_message(context, msg); 	    goto out; 	}  	/* 	 * Check that the KDC issued the user's ticket. 	 */ 	ret = check_KRB5SignedPath(context, 				   config, 				   krbtgt, 				   cp, 				   &adtkt, 				   NULL, 				   &ad_signedpath); 	if (ret) { 	    const char *msg = krb5_get_error_message(context, ret); 	    kdc_log(context, config, 4, 		    ""KRB5SignedPath check from service %s failed "" 		    ""for delegation to %s for client %s (%s)"" 		    ""from %s failed with %s"", 		    spn, tpn, dpn, cpn, from, msg); 	    krb5_free_error_message(context, msg);             _kdc_audit_addreason((kdc_request_t)priv,                                  ""KRB5SignedPath check failed""); 	    goto out; 	}  	if (!ad_signedpath) { 	    ret = KRB5KDC_ERR_BADOPTION; 	    kdc_log(context, config, 4, 		    ""Ticket not signed with PAC nor SignedPath service %s failed "" 		    ""for delegation to %s for client %s (%s)"" 		    ""from %s"", 		    spn, tpn, dpn, cpn, from);             _kdc_audit_addreason((kdc_request_t)priv,                                  ""Constrained delegation ticket not signed""); 	    goto out; 	}  	kdc_log(context, config, 4, ""constrained delegation for %s "" 		""from %s (%s) to %s"", tpn, cpn, dpn, spn);     }      /*      * Check flags      */      ret = kdc_check_flags(priv, FALSE);     if(ret) 	goto out;      if((b->kdc_options.validate || b->kdc_options.renew) &&        !krb5_principal_compare(context, 			       krbtgt->entry.principal, 			       server->entry.principal)){         _kdc_audit_addreason((kdc_request_t)priv, ""Inconsistent request""); 	kdc_log(context, config, 4, ""Inconsistent request.""); 	ret = KRB5KDC_ERR_SERVER_NOMATCH; 	goto out;     }      /* check for valid set of addresses */     if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {         if (config->check_ticket_addresses) {             ret = KRB5KRB_AP_ERR_BADADDR;             _kdc_audit_addkv((kdc_request_t)priv, 0, ""wrongaddr"", ""yes"");             kdc_log(context, config, 4, ""Request from wrong address"");             _kdc_audit_addreason((kdc_request_t)priv, ""Request from wrong address"");             goto out;         } else if (config->warn_ticket_addresses) {             _kdc_audit_addkv((kdc_request_t)priv, 0, ""wrongaddr"", ""yes"");         }     }      /* check local and per-principal anonymous ticket issuance policy */     if (is_anon_tgs_request_p(b, tgt)) { 	ret = _kdc_check_anon_policy(priv); 	if (ret) 	    goto out;     }      /*      * If this is an referral, add server referral data to the      * auth_data reply .      */     if (ref_realm) { 	PA_DATA pa; 	krb5_crypto crypto;  	kdc_log(context, config, 3, 		""Adding server referral to %s"", ref_realm);  	ret = krb5_crypto_init(context, &sessionkey, 0, &crypto); 	if (ret) 	    goto out;  	ret = build_server_referral(context, config, crypto, ref_realm, 				    NULL, s, &pa.padata_value); 	krb5_crypto_destroy(context, crypto); 	if (ret) {             _kdc_audit_addreason((kdc_request_t)priv, ""Referral build failed""); 	    kdc_log(context, config, 4, 		    ""Failed building server referral""); 	    goto out; 	} 	pa.padata_type = KRB5_PADATA_SERVER_REFERRAL;  	ret = add_METHOD_DATA(&enc_pa_data, &pa); 	krb5_data_free(&pa.padata_value); 	if (ret) { 	    kdc_log(context, config, 4, 		    ""Add server referral METHOD-DATA failed""); 	    goto out; 	}     }      /*      *      */      ret = tgs_make_reply(priv, 			 tp, 			 tgt, 			 replykey, 			 rk_is_subkey, 			 ekey, 			 &sessionkey, 			 kvno, 			 *auth_data, 			 server, 			 rsp, 			 client, 			 cp,                          tgt_realm, 			 krbtgt_out, 			 tkey_sign->key.keytype, 			 spp, 			 &rspac, 			 &enc_pa_data);  out:     if (tpn != cpn) 	    free(tpn);     free(dpn);     free(krbtgt_out_n);     _krb5_free_capath(context, capath);      krb5_data_free(&rspac);     krb5_free_keyblock_contents(context, &sessionkey);     if(krbtgt_out) 	_kdc_free_ent(context, krbtgt_out);     if(server) 	_kdc_free_ent(context, server);     if(client) 	_kdc_free_ent(context, client);     if(s4u2self_impersonated_client) 	_kdc_free_ent(context, s4u2self_impersonated_client);      if (tp && tp != cp) 	krb5_free_principal(context, tp);     krb5_free_principal(context, cp);     krb5_free_principal(context, dp);     krb5_free_principal(context, sp);     krb5_free_principal(context, krbtgt_out_principal);     free(ref_realm);     free_METHOD_DATA(&enc_pa_data);      free_EncTicketPart(&adtkt);      return ret; }"
"208522_CWE-190.c","CWE-190","dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg) {     size_t i, j; 	// Insert 'local-zone: ""2.dnscrypt-cert.example.com"" deny'     if(!cfg_str2list_insert(&cfg->local_zones,                             strdup(dnscenv->provider_name),                             strdup(""deny""))) {         log_err(""Could not load dnscrypt local-zone: %s deny"",                 dnscenv->provider_name);         return -1;     }      // Add local data entry of type:     // 2.dnscrypt-cert.example.com 86400 IN TXT ""DNSC......""     for(i=0; i<dnscenv->signed_certs_count; i++) {         const char *ttl_class_type = "" 86400 IN TXT \"""";         int rotated_cert = 0; 	uint32_t serial; 	uint16_t rrlen; 	char* rr;         struct SignedCert *cert = dnscenv->signed_certs + i; 		// Check if the certificate is being rotated and should not be published         for(j=0; j<dnscenv->rotated_certs_count; j++){             if(cert == dnscenv->rotated_certs[j]) {                 rotated_cert = 1;                 break;             }         } 		memcpy(&serial, cert->serial, sizeof serial); 		serial = htonl(serial);         if(rotated_cert) {             verbose(VERB_OPS,                 ""DNSCrypt: not adding cert with serial #%""                 PRIu32                 "" to local-data as it is rotated"",                 serial             );             continue;         }         rrlen = strlen(dnscenv->provider_name) +                          strlen(ttl_class_type) +                          4 * sizeof(struct SignedCert) + // worst case scenario                          1 + // trailing double quote                          1;         rr = malloc(rrlen);         if(!rr) {             log_err(""Could not allocate memory"");             return -2;         }         snprintf(rr, rrlen - 1, ""%s 86400 IN TXT \"""", dnscenv->provider_name);         for(j=0; j<sizeof(struct SignedCert); j++) { 			int c = (int)*((const uint8_t *) cert + j);             if (isprint(c) && c != '""' && c != '\\') {                 snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), ""%c"", c);             } else {                 snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), ""\\%03d"", c);             }         }         verbose(VERB_OPS, 			""DNSCrypt: adding cert with serial #%"" 			PRIu32 			"" to local-data to config: %s"", 			serial, rr 		);         snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), ""\"""");         cfg_strlist_insert(&cfg->local_data, strdup(rr));         free(rr);     }     return dnscenv->signed_certs_count; }"
"208525_CWE-787.c","CWE-787","cmdline_insert_reg(int *gotesc UNUSED) {     int		i;     int		c;  #ifdef USE_ON_FLY_SCROLL     dont_scroll = TRUE;	// disallow scrolling here #endif     putcmdline('""', TRUE);     ++no_mapping;     ++allow_keys;     i = c = plain_vgetc();	// CTRL-R <char>     if (i == Ctrl_O) 	i = Ctrl_R;		// CTRL-R CTRL-O == CTRL-R CTRL-R     if (i == Ctrl_R) 	c = plain_vgetc();	// CTRL-R CTRL-R <char>     extra_char = NUL;     --no_mapping;     --allow_keys; #ifdef FEAT_EVAL     /*      * Insert the result of an expression.      * Need to save the current command line, to be able to enter      * a new one...      */     new_cmdpos = -1;     if (c == '=')     { 	if (ccline.cmdfirstc == '='  // can't do this recursively 		|| cmdline_star > 0) // or when typing a password 	{ 	    beep_flush(); 	    c = ESC; 	} 	else 	    c = get_expr_register();     } #endif     if (c != ESC)	    // use ESC to cancel inserting register     { 	cmdline_paste(c, i == Ctrl_R, FALSE);  #ifdef FEAT_EVAL 	// When there was a serious error abort getting the 	// command line. 	if (aborting()) 	{ 	    *gotesc = TRUE;  // will free ccline.cmdbuff after 	    // putting it in history 	    return GOTO_NORMAL_MODE; 	} #endif 	KeyTyped = FALSE;	// Don't do p_wc completion. #ifdef FEAT_EVAL 	if (new_cmdpos >= 0) 	{ 	    // set_cmdline_pos() was used 	    if (new_cmdpos > ccline.cmdlen) 		ccline.cmdpos = ccline.cmdlen; 	    else 		ccline.cmdpos = new_cmdpos; 	} #endif     }     // remove the double quote     redrawcmd();      // The text has been stuffed, the command line didn't change yet.     return CMDLINE_NOT_CHANGED; }"
"208533_CWE-20.c","CWE-20","xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len, 		      int what, xmlChar end, xmlChar  end2, xmlChar end3) {     xmlChar *buffer = NULL;     size_t buffer_size = 0;     size_t nbchars = 0;      xmlChar *current = NULL;     xmlChar *rep = NULL;     const xmlChar *last;     xmlEntityPtr ent;     int c,l;      if ((ctxt == NULL) || (str == NULL) || (len < 0)) 	return(NULL);     last = str + len;      if (((ctxt->depth > 40) &&          ((ctxt->options & XML_PARSE_HUGE) == 0)) || 	(ctxt->depth > 1024)) { 	xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL); 	return(NULL);     }      /*      * allocate a translation buffer.      */     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);     if (buffer == NULL) goto mem_error;      /*      * OK loop until we reach one of the ending char or a size limit.      * we are operating on already parsed values.      */     if (str < last) 	c = CUR_SCHAR(str, l);     else         c = 0;     while ((c != 0) && (c != end) && /* non input consuming loop */ 	   (c != end2) && (c != end3)) {  	if (c == 0) break;         if ((c == '&') && (str[1] == '#')) { 	    int val = xmlParseStringCharRef(ctxt, &str); 	    if (val != 0) { 		COPY_BUF(0,buffer,nbchars,val); 	    } 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) { 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE); 	    } 	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) { 	    if (xmlParserDebugEntities) 		xmlGenericError(xmlGenericErrorContext, 			""String decoding Entity Reference: %.30s\n"", 			str); 	    ent = xmlParseStringEntityRef(ctxt, &str); 	    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) || 	        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR)) 	        goto int_error; 	    xmlParserEntityCheck(ctxt, 0, ent, 0); 	    if (ent != NULL) 	        ctxt->nbentities += ent->checked / 2; 	    if ((ent != NULL) && 		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) { 		if (ent->content != NULL) { 		    COPY_BUF(0,buffer,nbchars,ent->content[0]); 		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) { 			growBuffer(buffer, XML_PARSER_BUFFER_SIZE); 		    } 		} else { 		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR, 			    ""predefined entity has no content\n""); 		} 	    } else if ((ent != NULL) && (ent->content != NULL)) { 		ctxt->depth++; 		rep = xmlStringDecodeEntities(ctxt, ent->content, what, 			                      0, 0, 0); 		ctxt->depth--;  		if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) || 		    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR)) 		    goto int_error;  		if (rep != NULL) { 		    current = rep; 		    while (*current != 0) { /* non input consuming loop */ 			buffer[nbchars++] = *current++; 			if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) { 			    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0)) 				goto int_error; 			    growBuffer(buffer, XML_PARSER_BUFFER_SIZE); 			} 		    } 		    xmlFree(rep); 		    rep = NULL; 		} 	    } else if (ent != NULL) { 		int i = xmlStrlen(ent->name); 		const xmlChar *cur = ent->name;  		buffer[nbchars++] = '&'; 		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) { 		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE); 		} 		for (;i > 0;i--) 		    buffer[nbchars++] = *cur++; 		buffer[nbchars++] = ';'; 	    } 	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) { 	    if (xmlParserDebugEntities) 		xmlGenericError(xmlGenericErrorContext, 			""String decoding PE Reference: %.30s\n"", str); 	    ent = xmlParseStringPEReference(ctxt, &str); 	    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP) 	        goto int_error; 	    xmlParserEntityCheck(ctxt, 0, ent, 0); 	    if (ent != NULL) 	        ctxt->nbentities += ent->checked / 2; 	    if (ent != NULL) {                 if (ent->content == NULL) { 		    xmlLoadEntityContent(ctxt, ent); 		} 		ctxt->depth++; 		rep = xmlStringDecodeEntities(ctxt, ent->content, what, 			                      0, 0, 0); 		ctxt->depth--; 		if (rep != NULL) { 		    current = rep; 		    while (*current != 0) { /* non input consuming loop */ 			buffer[nbchars++] = *current++; 			if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) { 			    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0)) 			        goto int_error; 			    growBuffer(buffer, XML_PARSER_BUFFER_SIZE); 			} 		    } 		    xmlFree(rep); 		    rep = NULL; 		} 	    } 	} else { 	    COPY_BUF(l,buffer,nbchars,c); 	    str += l; 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) { 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE); 	    } 	} 	if (str < last) 	    c = CUR_SCHAR(str, l); 	else 	    c = 0;     }     buffer[nbchars] = 0;     return(buffer);  mem_error:     xmlErrMemory(ctxt, NULL); int_error:     if (rep != NULL)         xmlFree(rep);     if (buffer != NULL)         xmlFree(buffer);     return(NULL); }"
"208535_CWE-415.c","CWE-415","static RzList *relocs(RzBinFile *bf) { 	rz_return_val_if_fail(bf && bf->o, NULL); 	QnxObj *qo = bf->o->bin_obj; 	return rz_list_clone(qo->fixups); }"
"208654_CWE-416.c","CWE-416","PHP_MINIT_FUNCTION(snmp) { 	netsnmp_log_handler *logh; 	zend_class_entry ce, cex;  	le_snmp_session = zend_register_list_destructors_ex(php_snmp_session_destructor, NULL, PHP_SNMP_SESSION_RES_NAME, module_number);  	init_snmp(""snmpapp"");  #ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE 	/* Prevent update of the snmpapp.conf file */ 	netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1); #endif  	/* Disable logging, use exit status'es and related variabled to detect errors */ 	shutdown_snmp_logging(); 	logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, LOG_ERR); 	if (logh) { 		logh->pri_max = LOG_ERR; 	}  	memcpy(&php_snmp_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 	php_snmp_object_handlers.read_property = php_snmp_read_property; 	php_snmp_object_handlers.write_property = php_snmp_write_property; 	php_snmp_object_handlers.has_property = php_snmp_has_property; 	php_snmp_object_handlers.get_properties = php_snmp_get_properties;  	/* Register SNMP Class */ 	INIT_CLASS_ENTRY(ce, ""SNMP"", php_snmp_class_methods); 	ce.create_object = php_snmp_object_new; 	php_snmp_object_handlers.clone_obj = NULL; 	php_snmp_ce = zend_register_internal_class(&ce TSRMLS_CC);  	/* Register SNMP Class properties */ 	zend_hash_init(&php_snmp_properties, 0, NULL, NULL, 1); 	PHP_SNMP_ADD_PROPERTIES(&php_snmp_properties, php_snmp_property_entries);  	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_SUFFIX"",	NETSNMP_OID_OUTPUT_SUFFIX,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_MODULE"",	NETSNMP_OID_OUTPUT_MODULE,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_FULL"",		NETSNMP_OID_OUTPUT_FULL,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_NUMERIC"",	NETSNMP_OID_OUTPUT_NUMERIC,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_UCD"",		NETSNMP_OID_OUTPUT_UCD,		CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OID_OUTPUT_NONE"",		NETSNMP_OID_OUTPUT_NONE,	CONST_CS | CONST_PERSISTENT);  	REGISTER_LONG_CONSTANT(""SNMP_VALUE_LIBRARY"",	SNMP_VALUE_LIBRARY,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_VALUE_PLAIN"",	SNMP_VALUE_PLAIN,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_VALUE_OBJECT"",	SNMP_VALUE_OBJECT,	CONST_CS | CONST_PERSISTENT);  	REGISTER_LONG_CONSTANT(""SNMP_BIT_STR"",		ASN_BIT_STR,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OCTET_STR"",	ASN_OCTET_STR,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OPAQUE"",		ASN_OPAQUE,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_NULL"",		ASN_NULL,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_OBJECT_ID"",	ASN_OBJECT_ID,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_IPADDRESS"",	ASN_IPADDRESS,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_COUNTER"",		ASN_GAUGE,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_UNSIGNED"",		ASN_UNSIGNED,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_TIMETICKS"",	ASN_TIMETICKS,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_UINTEGER"",		ASN_UINTEGER,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_INTEGER"",		ASN_INTEGER,	CONST_CS | CONST_PERSISTENT); 	REGISTER_LONG_CONSTANT(""SNMP_COUNTER64"",	ASN_COUNTER64,	CONST_CS | CONST_PERSISTENT);  	REGISTER_SNMP_CLASS_CONST_LONG(""VERSION_1"",			SNMP_VERSION_1); 	REGISTER_SNMP_CLASS_CONST_LONG(""VERSION_2c"",			SNMP_VERSION_2c); 	REGISTER_SNMP_CLASS_CONST_LONG(""VERSION_2C"",			SNMP_VERSION_2c); 	REGISTER_SNMP_CLASS_CONST_LONG(""VERSION_3"",			SNMP_VERSION_3);  	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_NOERROR"",			PHP_SNMP_ERRNO_NOERROR); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_ANY"",			PHP_SNMP_ERRNO_ANY); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_GENERIC"",			PHP_SNMP_ERRNO_GENERIC); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_TIMEOUT"",			PHP_SNMP_ERRNO_TIMEOUT); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_ERROR_IN_REPLY"",		PHP_SNMP_ERRNO_ERROR_IN_REPLY); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_OID_NOT_INCREASING"",	PHP_SNMP_ERRNO_OID_NOT_INCREASING); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_OID_PARSING_ERROR"",	PHP_SNMP_ERRNO_OID_PARSING_ERROR); 	REGISTER_SNMP_CLASS_CONST_LONG(""ERRNO_MULTIPLE_SET_QUERIES"",	PHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);  	/* Register SNMPException class */ 	INIT_CLASS_ENTRY(cex, ""SNMPException"", NULL); #ifdef HAVE_SPL 	php_snmp_exception_ce = zend_register_internal_class_ex(&cex, spl_ce_RuntimeException, NULL TSRMLS_CC); #else 	php_snmp_exception_ce = zend_register_internal_class_ex(&cex, zend_exception_get_default(TSRMLS_C), NULL TSRMLS_CC); #endif  	return SUCCESS; }"
"208673_CWE-74.c","CWE-74","handle_spawn (PortalFlatpak         *object,               GDBusMethodInvocation *invocation,               GUnixFDList           *fd_list,               const gchar           *arg_cwd_path,               const gchar *const    *arg_argv,               GVariant              *arg_fds,               GVariant              *arg_envs,               guint                  arg_flags,               GVariant              *arg_options) {   g_autoptr(GError) error = NULL;   ChildSetupData child_setup_data = { NULL };   GPid pid;   PidData *pid_data;   InstanceIdReadData *instance_id_read_data = NULL;   gsize i, j, n_fds, n_envs;   const gint *fds = NULL;   gint fds_len = 0;   g_autofree FdMapEntry *fd_map = NULL;   gchar **env;   gint32 max_fd;   GKeyFile *app_info;   g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);   g_autofree char *app_id = NULL;   g_autofree char *branch = NULL;   g_autofree char *arch = NULL;   g_autofree char *app_commit = NULL;   g_autofree char *runtime_ref = NULL;   g_auto(GStrv) runtime_parts = NULL;   g_autofree char *runtime_commit = NULL;   g_autofree char *instance_path = NULL;   g_auto(GStrv) extra_args = NULL;   g_auto(GStrv) shares = NULL;   g_auto(GStrv) sockets = NULL;   g_auto(GStrv) devices = NULL;   g_auto(GStrv) sandbox_expose = NULL;   g_auto(GStrv) sandbox_expose_ro = NULL;   g_autoptr(GVariant) sandbox_expose_fd = NULL;   g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;   g_autoptr(GOutputStream) instance_id_out_stream = NULL;   guint sandbox_flags = 0;   gboolean sandboxed;   gboolean expose_pids;   gboolean share_pids;   gboolean notify_start;   gboolean devel;   g_autoptr(GString) env_string = g_string_new ("""");    child_setup_data.instance_id_fd = -1;   child_setup_data.env_fd = -1;    if (fd_list != NULL)     fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);    app_info = g_object_get_data (G_OBJECT (invocation), ""app-info"");   g_assert (app_info != NULL);    app_id = g_key_file_get_string (app_info,                                   FLATPAK_METADATA_GROUP_APPLICATION,                                   FLATPAK_METADATA_KEY_NAME, NULL);   g_assert (app_id != NULL);    g_debug (""spawn() called from app: '%s'"", app_id);   if (*app_id == 0)     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                              G_DBUS_ERROR_INVALID_ARGS,                                              ""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak"");       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    if (*arg_cwd_path == 0)     arg_cwd_path = NULL;    if (arg_argv == NULL || *arg_argv == NULL)     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                              G_DBUS_ERROR_INVALID_ARGS,                                              ""No command given"");       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,                                              ""Unsupported flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    runtime_ref = g_key_file_get_string (app_info,                                        FLATPAK_METADATA_GROUP_APPLICATION,                                        FLATPAK_METADATA_KEY_RUNTIME, NULL);   if (runtime_ref == NULL)     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,                                              ""No runtime found"");       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    runtime_parts = g_strsplit (runtime_ref, ""/"", -1);    branch = g_key_file_get_string (app_info,                                   FLATPAK_METADATA_GROUP_INSTANCE,                                   FLATPAK_METADATA_KEY_BRANCH, NULL);   instance_path = g_key_file_get_string (app_info,                                          FLATPAK_METADATA_GROUP_INSTANCE,                                          FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);   arch = g_key_file_get_string (app_info,                                 FLATPAK_METADATA_GROUP_INSTANCE,                                 FLATPAK_METADATA_KEY_ARCH, NULL);   extra_args = g_key_file_get_string_list (app_info,                                            FLATPAK_METADATA_GROUP_INSTANCE,                                            FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);   app_commit = g_key_file_get_string (app_info,                                       FLATPAK_METADATA_GROUP_INSTANCE,                                       FLATPAK_METADATA_KEY_APP_COMMIT, NULL);   runtime_commit = g_key_file_get_string (app_info,                                           FLATPAK_METADATA_GROUP_INSTANCE,                                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);   shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,                                        FLATPAK_METADATA_KEY_SHARED, NULL, NULL);   sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,                                        FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);   devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,                                         FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);    devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,                                   FLATPAK_METADATA_KEY_DEVEL, NULL);    g_variant_lookup (arg_options, ""sandbox-expose"", ""^as"", &sandbox_expose);   g_variant_lookup (arg_options, ""sandbox-expose-ro"", ""^as"", &sandbox_expose_ro);   g_variant_lookup (arg_options, ""sandbox-flags"", ""u"", &sandbox_flags);   sandbox_expose_fd = g_variant_lookup_value (arg_options, ""sandbox-expose-fd"", G_VARIANT_TYPE (""ah""));   sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, ""sandbox-expose-fd-ro"", G_VARIANT_TYPE (""ah""));    if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,                                              ""Unsupported sandbox flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    if (instance_path == NULL &&       ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||        (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))     {       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                              G_DBUS_ERROR_INVALID_ARGS,                                              ""Invalid sandbox expose, caller has no instance path"");       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)     {       const char *expose = sandbox_expose[i];        g_debug (""exposing %s"", expose);       if (!is_valid_expose (expose, &error))         {           g_dbus_method_invocation_return_gerror (invocation, error);           return G_DBUS_METHOD_INVOCATION_HANDLED;         }     }    for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)     {       const char *expose = sandbox_expose_ro[i];       g_debug (""exposing %s"", expose);       if (!is_valid_expose (expose, &error))         {           g_dbus_method_invocation_return_gerror (invocation, error);           return G_DBUS_METHOD_INVOCATION_HANDLED;         }     }    g_debug (""Running spawn command %s"", arg_argv[0]);    n_fds = 0;   if (fds != NULL)     n_fds = g_variant_n_children (arg_fds);   fd_map = g_new0 (FdMapEntry, n_fds);    child_setup_data.fd_map = fd_map;   child_setup_data.fd_map_len = n_fds;    max_fd = -1;   for (i = 0; i < n_fds; i++)     {       gint32 handle, dest_fd;       int handle_fd;        g_variant_get_child (arg_fds, i, ""{uh}"", &dest_fd, &handle);        if (handle >= fds_len || handle < 0)         {           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                  G_DBUS_ERROR_INVALID_ARGS,                                                  ""No file descriptor for handle %d"",                                                  handle);           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        handle_fd = fds[handle];        fd_map[i].to = dest_fd;       fd_map[i].from = handle_fd;       fd_map[i].final = fd_map[i].to;        /* If stdin/out/err is a tty we try to set it as the controlling          tty for the app, this way we can use this to run in a terminal. */       if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&           !child_setup_data.set_tty &&           isatty (handle_fd))         {           child_setup_data.set_tty = TRUE;           child_setup_data.tty = handle_fd;         }        max_fd = MAX (max_fd, fd_map[i].to);       max_fd = MAX (max_fd, fd_map[i].from);     }    /* We make a second pass over the fds to find if any ""to"" fd index      overlaps an already in use fd (i.e. one in the ""from"" category      that are allocated randomly). If a fd overlaps ""to"" fd then its      a caller issue and not our fault, so we ignore that. */   for (i = 0; i < n_fds; i++)     {       int to_fd = fd_map[i].to;       gboolean conflict = FALSE;        /* At this point we're fine with using ""from"" values for this          value (because we handle to==from in the code), or values          that are before ""i"" in the fd_map (because those will be          closed at this point when dup:ing). However, we can't          reuse a fd that is in ""from"" for j > i. */       for (j = i + 1; j < n_fds; j++)         {           int from_fd = fd_map[j].from;           if (from_fd == to_fd)             {               conflict = TRUE;               break;             }         }        if (conflict)         fd_map[i].to = ++max_fd;     }    /* TODO: Ideally we should let `flatpak run` inherit the portal's    * environment, in case e.g. a LD_LIBRARY_PATH is needed to be able    * to run `flatpak run`, but tell it to start from a blank environment    * when running the Flatpak app; but this isn't currently possible, so    * for now we preserve existing behaviour. */   if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)     {       char *empty[] = { NULL };       env = g_strdupv (empty);     }   else     env = g_get_environ ();    /* Let the environment variables given by the caller override the ones    * from extra_args. Don't add them to @env, because they are controlled    * by our caller, which might be trying to use them to inject code into    * flatpak(1); add them to the environment block instead.    *    * We don't use --env= here, so that if the values are something that    * should not be exposed to other uids, they can remain confidential. */   n_envs = g_variant_n_children (arg_envs);   for (i = 0; i < n_envs; i++)     {       const char *var = NULL;       const char *val = NULL;       g_variant_get_child (arg_envs, i, ""{&s&s}"", &var, &val);        if (var[0] == '\0')         {           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                  G_DBUS_ERROR_INVALID_ARGS,                                                  ""Environment variable cannot have empty name"");           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        if (strchr (var, '=') != NULL)         {           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                  G_DBUS_ERROR_INVALID_ARGS,                                                  ""Environment variable name cannot contain '='"");           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        g_string_append (env_string, var);       g_string_append_c (env_string, '=');       g_string_append (env_string, val);       g_string_append_c (env_string, '\0');     }    g_ptr_array_add (flatpak_argv, g_strdup (""flatpak""));   g_ptr_array_add (flatpak_argv, g_strdup (""run""));    sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;    if (sandboxed)     {       g_ptr_array_add (flatpak_argv, g_strdup (""--sandbox""));        if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)         {           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""wayland""))             g_ptr_array_add (flatpak_argv, g_strdup (""--socket=wayland""));           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""fallback-x11""))             g_ptr_array_add (flatpak_argv, g_strdup (""--socket=fallback-x11""));           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""x11""))             g_ptr_array_add (flatpak_argv, g_strdup (""--socket=x11""));           if (shares != NULL && g_strv_contains ((const char * const *) shares, ""ipc"") &&               sockets != NULL && (g_strv_contains ((const char * const *) sockets, ""fallback-x11"") ||                                   g_strv_contains ((const char * const *) sockets, ""x11"")))             g_ptr_array_add (flatpak_argv, g_strdup (""--share=ipc""));         }       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)         {           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""pulseaudio""))             g_ptr_array_add (flatpak_argv, g_strdup (""--socket=pulseaudio""));         }       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)         {           if (devices != NULL &&               (g_strv_contains ((const char * const *) devices, ""dri"") ||                g_strv_contains ((const char * const *) devices, ""all"")))             g_ptr_array_add (flatpak_argv, g_strdup (""--device=dri""));         }       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)         g_ptr_array_add (flatpak_argv, g_strdup (""--session-bus""));       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)         g_ptr_array_add (flatpak_argv, g_strdup (""--a11y-bus""));     }   else     {       for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)         {           if (g_str_has_prefix (extra_args[i], ""--env=""))             {               const char *var_val = extra_args[i] + strlen (""--env="");                if (var_val[0] == '\0' || var_val[0] == '=')                 {                   g_warning (""Environment variable in extra-args has empty name"");                   continue;                 }                if (strchr (var_val, '=') == NULL)                 {                   g_warning (""Environment variable in extra-args has no value"");                   continue;                 }                g_string_append (env_string, var_val);               g_string_append_c (env_string, '\0');             }           else             {               g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));             }         }     }    if (env_string->len > 0)     {       g_auto(GLnxTmpfile) env_tmpf  = { 0, };        if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, ""environ"",                                                       env_string->str,                                                       env_string->len, &error))         {           g_dbus_method_invocation_return_gerror (invocation, error);           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);       g_ptr_array_add (flatpak_argv,                        g_strdup_printf (""--env-fd=%d"",                                         child_setup_data.env_fd));     }    expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;   share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;    if (expose_pids || share_pids)     {       g_autofree char *instance_id = NULL;       int sender_pid1 = 0;        if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))         {           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                  G_DBUS_ERROR_NOT_SUPPORTED,                                                  ""Expose pids not supported with setuid bwrap"");           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        instance_id = g_key_file_get_string (app_info,                                            FLATPAK_METADATA_GROUP_INSTANCE,                                            FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);        if (instance_id)         {           g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);           sender_pid1 = flatpak_instance_get_child_pid (instance);         }        if (sender_pid1 == 0)         {           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                  G_DBUS_ERROR_INVALID_ARGS,                                                  ""Could not find requesting pid"");           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        g_ptr_array_add (flatpak_argv, g_strdup_printf (""--parent-pid=%d"", sender_pid1));        if (share_pids)         g_ptr_array_add (flatpak_argv, g_strdup (""--parent-share-pids""));       else         g_ptr_array_add (flatpak_argv, g_strdup (""--parent-expose-pids""));     }    notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;   if (notify_start)     {       int pipe_fds[2];       if (pipe (pipe_fds) == -1)         {           int errsv = errno;           g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,                                                  g_io_error_from_errno (errsv),                                                  ""Failed to create instance ID pipe: %s"",                                                  g_strerror (errsv));           return G_DBUS_METHOD_INVOCATION_HANDLED;         }        GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));       /* This is saved to ensure the portal's end gets closed after the exec. */       instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));        instance_id_read_data = g_new0 (InstanceIdReadData, 1);        g_input_stream_read_async (in_stream, instance_id_read_data->buffer,                                  INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,                                  instance_id_read_finish, instance_id_read_data);        g_ptr_array_add (flatpak_argv, g_strdup_printf (""--instance-id-fd=%d"", pipe_fds[1]));       child_setup_data.instance_id_fd = pipe_fds[1];     }    if (devel)     g_ptr_array_add (flatpak_argv, g_strdup (""--devel""));    /* Inherit launcher network access from launcher, unless      NO_NETWORK set. */   if (shares != NULL && g_strv_contains ((const char * const *) shares, ""network"") &&       !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))     g_ptr_array_add (flatpak_argv, g_strdup (""--share=network""));   else     g_ptr_array_add (flatpak_argv, g_strdup (""--unshare=network""));     if (instance_path)     {       for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)         g_ptr_array_add (flatpak_argv,                          filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));       for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)         g_ptr_array_add (flatpak_argv,                          filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));     }    for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)     {       const char *expose = sandbox_expose_ro[i];       g_debug (""exposing %s"", expose);     }    if (sandbox_expose_fd != NULL)     {       gsize len = g_variant_n_children (sandbox_expose_fd);       for (i = 0; i < len; i++)         {           gint32 handle;           g_variant_get_child (sandbox_expose_fd, i, ""h"", &handle);           if (handle >= 0 && handle < fds_len)             {               int handle_fd = fds[handle];               g_autofree char *path = NULL;               gboolean writable = FALSE;                path = get_path_for_fd (handle_fd, &writable, &error);                if (path)                 {                   g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));                 }               else                 {                   g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"",                            handle_fd, error->message);                   g_clear_error (&error);                 }             }           else             {               g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                      G_DBUS_ERROR_INVALID_ARGS,                                                      ""No file descriptor for handle %d"",                                                      handle);               return G_DBUS_METHOD_INVOCATION_HANDLED;             }         }     }    if (sandbox_expose_fd_ro != NULL)     {       gsize len = g_variant_n_children (sandbox_expose_fd_ro);       for (i = 0; i < len; i++)         {           gint32 handle;           g_variant_get_child (sandbox_expose_fd_ro, i, ""h"", &handle);           if (handle >= 0 && handle < fds_len)             {               int handle_fd = fds[handle];               g_autofree char *path = NULL;               gboolean writable = FALSE;                path = get_path_for_fd (handle_fd, &writable, &error);                if (path)                 {                   g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));                 }               else                 {                   g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"",                            handle_fd, error->message);                   g_clear_error (&error);                 }             }           else             {               g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,                                                      G_DBUS_ERROR_INVALID_ARGS,                                                      ""No file descriptor for handle %d"",                                                      handle);               return G_DBUS_METHOD_INVOCATION_HANDLED;             }         }     }    g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime=%s"", runtime_parts[1]));   g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-version=%s"", runtime_parts[3]));    if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)     {       if (app_commit)         g_ptr_array_add (flatpak_argv, g_strdup_printf (""--commit=%s"", app_commit));       if (runtime_commit)         g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-commit=%s"", runtime_commit));     }    if (arg_cwd_path != NULL)     g_ptr_array_add (flatpak_argv, g_strdup_printf (""--cwd=%s"", arg_cwd_path));    if (arg_argv[0][0] != 0)     g_ptr_array_add (flatpak_argv, g_strdup_printf (""--command=%s"", arg_argv[0]));    g_ptr_array_add (flatpak_argv, g_strdup_printf (""%s/%s/%s"", app_id, arch ? arch : """", branch ? branch : """"));   for (i = 1; arg_argv[i] != NULL; i++)     g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));   g_ptr_array_add (flatpak_argv, NULL);    if (opt_verbose)     {       g_autoptr(GString) cmd = g_string_new ("""");        for (i = 0; flatpak_argv->pdata[i] != NULL; i++)         {           if (i > 0)             g_string_append (cmd, "" "");           g_string_append (cmd, flatpak_argv->pdata[i]);         }        g_debug (""Starting: %s\n"", cmd->str);     }    /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */   if (!g_spawn_async_with_pipes (NULL,                                  (char **) flatpak_argv->pdata,                                  env,                                  G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,                                  child_setup_func, &child_setup_data,                                  &pid,                                  NULL,                                  NULL,                                  NULL,                                  &error))     {       gint code = G_DBUS_ERROR_FAILED;       if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))         code = G_DBUS_ERROR_ACCESS_DENIED;       else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))         code = G_DBUS_ERROR_FILE_NOT_FOUND;       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,                                              ""Failed to start command: %s"",                                              error->message);       return G_DBUS_METHOD_INVOCATION_HANDLED;     }    if (instance_id_read_data)     instance_id_read_data->pid = pid;    pid_data = g_new0 (PidData, 1);   pid_data->pid = pid;   pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));   pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;   pid_data->expose_or_share_pids = (expose_pids || share_pids);   pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,                                                   pid,                                                   child_watch_died,                                                   pid_data,                                                   NULL);    g_debug (""Client Pid is %d"", pid_data->pid);    g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),                         pid_data);    portal_flatpak_complete_spawn (object, invocation, NULL, pid);   return G_DBUS_METHOD_INVOCATION_HANDLED; }"
"208680_CWE-416.c","CWE-416","R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) { 	bool cfg_anal_strings = r_config_get_i (core->config, ""anal.strings""); 	bool emu_lazy = r_config_get_i (core->config, ""emu.lazy""); 	bool gp_fixed = r_config_get_i (core->config, ""anal.gpfixed""); 	RAnalEsil *ESIL = core->anal->esil; 	ut64 refptr = 0LL; 	const char *pcname; 	RAnalOp op = R_EMPTY; 	ut8 *buf = NULL; 	bool end_address_set = false; 	int iend; 	int minopsize = 4; // XXX this depends on asm->mininstrsize 	bool archIsArm = false; 	ut64 addr = core->offset; 	ut64 start = addr; 	ut64 end = 0LL; 	ut64 cur; 	if (esil_anal_stop || r_cons_is_breaked ()) { 		// faster ^C 		return; 	}  	mycore = core; 	if (!strcmp (str, ""?"")) { 		eprintf (""Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\n""); 		eprintf (""  aae $SS @ $S             - analyze the whole section\n""); 		eprintf (""  aae $SS str.Hello @ $S   - find references for str.Hellow\n""); 		eprintf (""  aaef                     - analyze functions discovered with esil\n""); 		return; 	} #define CHECKREF(x) ((refptr && (x) == refptr) || !refptr) 	if (target) { 		const char *expr = r_str_trim_head_ro (target); 		if (*expr) { 			refptr = ntarget = r_num_math (core->num, expr); 			if (!refptr) { 				ntarget = refptr = addr; 			} 		} else { 			ntarget = UT64_MAX; 			refptr = 0LL; 		} 	} else { 		ntarget = UT64_MAX; 		refptr = 0LL; 	} 	RAnalFunction *fcn = NULL; 	if (!strcmp (str, ""f"")) { 		fcn = r_anal_get_fcn_in (core->anal, core->offset, 0); 		if (fcn) { 			start = r_anal_function_min_addr (fcn); 			addr = fcn->addr; 			end = r_anal_function_max_addr (fcn); 			end_address_set = true; 		} 	}  	if (!end_address_set) { 		if (str[0] == ' ') { 			end = addr + r_num_math (core->num, str + 1); 		} else { 			RIOMap *map = r_io_map_get_at (core->io, addr); 			if (map) { 				end = r_io_map_end (map); 			} else { 				end = addr + core->blocksize; 			} 		} 	}  	iend = end - start; 	if (iend < 0) { 		return; 	} 	if (iend > MAX_SCAN_SIZE) { 		eprintf (""Warning: Not going to analyze 0x%08""PFMT64x"" bytes.\n"", (ut64)iend); 		return; 	} 	buf = malloc ((size_t)iend + 2); 	if (!buf) { 		perror (""malloc""); 		return; 	} 	esilbreak_last_read = UT64_MAX; 	r_io_read_at (core->io, start, buf, iend + 1); 	if (!ESIL) { 		r_core_cmd0 (core, ""aei""); 		ESIL = core->anal->esil; 		if (!ESIL) { 			eprintf (""ESIL not initialized\n""); 			return; 		} 		r_core_cmd0 (core, ""aeim""); 		ESIL = core->anal->esil; 	} 	const char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP); 	if (!spname) { 		eprintf (""Error: No =SP defined in the reg profile.\n""); 		return; 	} 	EsilBreakCtx ctx = { 		&op, 		fcn, 		spname, 		r_reg_getv (core->anal->reg, spname) 	}; 	ESIL->cb.hook_reg_write = &esilbreak_reg_write; 	//this is necessary for the hook to read the id of analop 	ESIL->user = &ctx; 	ESIL->cb.hook_mem_read = &esilbreak_mem_read; 	ESIL->cb.hook_mem_write = &esilbreak_mem_write;  	if (fcn && fcn->reg_save_area) { 		r_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area); 	} 	//eprintf (""Analyzing ESIL refs from 0x%""PFMT64x"" - 0x%""PFMT64x""\n"", addr, end); 	// TODO: backup/restore register state before/after analysis 	pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC); 	if (!pcname || !*pcname) { 		eprintf (""Cannot find program counter register in the current profile.\n""); 		return; 	} 	esil_anal_stop = false; 	r_cons_break_push (cccb, core);  	int arch = -1; 	if (!strcmp (core->anal->cur->arch, ""arm"")) { 		switch (core->anal->cur->bits) { 		case 64: arch = R2_ARCH_ARM64; break; 		case 32: arch = R2_ARCH_ARM32; break; 		case 16: arch = R2_ARCH_THUMB; break; 		} 		archIsArm = true; 	}  	ut64 gp = r_config_get_i (core->config, ""anal.gp""); 	const char *gp_reg = NULL; 	if (!strcmp (core->anal->cur->arch, ""mips"")) { 		gp_reg = ""gp""; 		arch = R2_ARCH_MIPS; 	}  	const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN); 	if (!sn) { 		eprintf (""Warning: No SN reg alias for current architecture.\n""); 	} 	r_reg_arena_push (core->anal->reg);  	IterCtx ictx = { start, end, fcn, NULL }; 	size_t i = addr - start; 	size_t i_old = 0; 	do { 		if (esil_anal_stop || r_cons_is_breaked ()) { 			break; 		} 		cur = start + i; 		if (!r_io_is_valid_offset (core->io, cur, 0)) { 			break; 		} #if 0 		// disabled because it causes some tests to fail 		{ 			RPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY); 			void **it; 			r_pvector_foreach (list, it) { 				RIntervalNode *node = *it; 				RAnalMetaItem *meta = node->data; 				switch (meta->type) { 				case R_META_TYPE_DATA: 				case R_META_TYPE_STRING: 				case R_META_TYPE_FORMAT: #if 0 					{ 						int msz = r_meta_get_size (core->anal, meta->type); 						i += (msz > 0)? msz: minopsize; 					} 					r_pvector_free (list); 					goto loopback; #elif 0 					{ 						int msz = r_meta_get_size (core->anal, meta->type); 						i += (msz > 0)? msz: minopsize; 						i--; 					} #else 					i += 4; 					goto repeat; #endif 				default: 					break; 				} 			} 			r_pvector_free (list); 		} #endif  		/* realign address if needed */ 		r_core_seek_arch_bits (core, cur); 		int opalign = core->anal->pcalign; 		if (opalign > 0) { 			cur -= (cur % opalign); 		}  		r_anal_op_fini (&op); 		r_asm_set_pc (core->rasm, cur); 		i_old = i; #if 1 		if (i > iend) { 			goto repeat; 		} #endif 		if (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) { 			i += minopsize - 1; //   XXX dupe in op.size below 		} 		if (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) { 			// i += 2 			r_anal_op_fini (&op); 			goto repeat; 		} 		//we need to check again i because buf+i may goes beyond its boundaries 		//because of i+= minopsize - 1 		if (op.size < 1) { 			i += minopsize - 1; 			goto repeat; 		} 		if (emu_lazy) { 			if (op.type & R_ANAL_OP_TYPE_REP) { 				i += op.size - 1; 				goto repeat; 			} 			switch (op.type & R_ANAL_OP_TYPE_MASK) { 			case R_ANAL_OP_TYPE_JMP: 			case R_ANAL_OP_TYPE_CJMP: 			case R_ANAL_OP_TYPE_CALL: 			case R_ANAL_OP_TYPE_RET: 			case R_ANAL_OP_TYPE_ILL: 			case R_ANAL_OP_TYPE_NOP: 			case R_ANAL_OP_TYPE_UJMP: 			case R_ANAL_OP_TYPE_IO: 			case R_ANAL_OP_TYPE_LEAVE: 			case R_ANAL_OP_TYPE_CRYPTO: 			case R_ANAL_OP_TYPE_CPL: 			case R_ANAL_OP_TYPE_SYNC: 			case R_ANAL_OP_TYPE_SWI: 			case R_ANAL_OP_TYPE_CMP: 			case R_ANAL_OP_TYPE_ACMP: 			case R_ANAL_OP_TYPE_NULL: 			case R_ANAL_OP_TYPE_CSWI: 			case R_ANAL_OP_TYPE_TRAP: 				i += op.size - 1; 				goto repeat; 			//  those require write support 			case R_ANAL_OP_TYPE_PUSH: 			case R_ANAL_OP_TYPE_POP: 				i += op.size - 1; 				goto repeat; 			} 		} 		if (sn && op.type == R_ANAL_OP_TYPE_SWI) { 			r_strf_buffer (64); 			r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS); 			int snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn); 			RSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1); 			if (si) { 			//	eprintf (""0x%08""PFMT64x"" SYSCALL %-4d %s\n"", cur, snv, si->name); 				r_flag_set_next (core->flags, r_strf (""syscall.%s"", si->name), cur, 1); 			} else { 				//todo were doing less filtering up top because we can't match against 80 on all platforms 				// might get too many of this path now.. 			//	eprintf (""0x%08""PFMT64x"" SYSCALL %d\n"", cur, snv); 				r_flag_set_next (core->flags, r_strf (""syscall.%d"", snv), cur, 1); 			} 			r_flag_space_set (core->flags, NULL); 			r_syscall_item_free (si); 		} 		const char *esilstr = R_STRBUF_SAFEGET (&op.esil); 		i += op.size - 1; 		if (R_STR_ISEMPTY (esilstr)) { 			goto repeat; 		} 		r_anal_esil_set_pc (ESIL, cur); 		r_reg_setv (core->anal->reg, pcname, cur + op.size); 		if (gp_fixed && gp_reg) { 			r_reg_setv (core->anal->reg, gp_reg, gp); 		} 		(void)r_anal_esil_parse (ESIL, esilstr); 		// looks like ^C is handled by esil_parse !!!! 		//r_anal_esil_dumpstack (ESIL); 		//r_anal_esil_stack_free (ESIL); 		switch (op.type) { 		case R_ANAL_OP_TYPE_LEA: 			// arm64 			if (core->anal->cur && arch == R2_ARCH_ARM64) { 				if (CHECKREF (ESIL->cur)) { 					r_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING); 				} 			} else if ((target && op.ptr == ntarget) || !target) { 				if (CHECKREF (ESIL->cur)) { 					if (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) { 						r_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING); 					} else { 						r_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING); 					} 				} 			} 			if (cfg_anal_strings) { 				add_string_ref (core, op.addr, op.ptr); 			} 			break; 		case R_ANAL_OP_TYPE_ADD: 			/* TODO: test if this is valid for other archs too */ 			if (core->anal->cur && archIsArm) { 				/* This code is known to work on Thumb, ARM and ARM64 */ 				ut64 dst = ESIL->cur; 				if ((target && dst == ntarget) || !target) { 					if (CHECKREF (dst)) { 						int type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA; 						r_anal_xrefs_set (core->anal, cur, dst, type); 					} 				} 				if (cfg_anal_strings) { 					add_string_ref (core, op.addr, dst); 				} 			} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) { 				ut64 dst = ESIL->cur; 				if (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) { 					break; 				} 				if (!strcmp (op.src[0]->reg->name, ""sp"")) { 					break; 				} 				if (!strcmp (op.src[0]->reg->name, ""zero"")) { 					break; 				} 				if ((target && dst == ntarget) || !target) { 					if (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) { 						RFlagItem *f; 						char *str; 						if (CHECKREF (dst) || CHECKREF (cur)) { 							r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA); 							if (cfg_anal_strings) { 								add_string_ref (core, op.addr, dst); 							} 							if ((f = r_core_flag_get_by_spaces (core->flags, dst))) { 								r_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name); 							} else if ((str = is_string_at (mycore, dst, NULL))) { 								char *str2 = r_str_newf (""esilref: '%s'"", str); 								// HACK avoid format string inside string used later as format 								// string crashes disasm inside agf under some conditions. 								// https://github.com/radareorg/radare2/issues/6937 								r_str_replace_char (str2, '%', '&'); 								r_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2); 								free (str2); 								free (str); 							} 						} 					} 				} 			} 			break; 		case R_ANAL_OP_TYPE_LOAD: 			{ 				ut64 dst = esilbreak_last_read; 				if (dst != UT64_MAX && CHECKREF (dst)) { 					if (myvalid (mycore->io, dst)) { 						r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA); 						if (cfg_anal_strings) { 							add_string_ref (core, op.addr, dst); 						} 					} 				} 				dst = esilbreak_last_data; 				if (dst != UT64_MAX && CHECKREF (dst)) { 					if (myvalid (mycore->io, dst)) { 						r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA); 						if (cfg_anal_strings) { 							add_string_ref (core, op.addr, dst); 						} 					} 				} 			} 			break; 		case R_ANAL_OP_TYPE_JMP: 			{ 				ut64 dst = op.jump; 				if (CHECKREF (dst)) { 					if (myvalid (core->io, dst)) { 						r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE); 					} 				} 			} 			break; 		case R_ANAL_OP_TYPE_CALL: 			{ 				ut64 dst = op.jump; 				if (CHECKREF (dst)) { 					if (myvalid (core->io, dst)) { 						r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL); 					} 					ESIL->old = cur + op.size; 					getpcfromstack (core, ESIL); 				} 			} 			break; 		case R_ANAL_OP_TYPE_UJMP: 		case R_ANAL_OP_TYPE_UCALL: 		case R_ANAL_OP_TYPE_ICALL: 		case R_ANAL_OP_TYPE_RCALL: 		case R_ANAL_OP_TYPE_IRCALL: 		case R_ANAL_OP_TYPE_MJMP: 			{ 				ut64 dst = core->anal->esil->jump_target; 				if (dst == 0 || dst == UT64_MAX) { 					dst = r_reg_getv (core->anal->reg, pcname); 				} 				if (CHECKREF (dst)) { 					if (myvalid (core->io, dst)) { 						RAnalRefType ref = 							(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL 							? R_ANAL_REF_TYPE_CALL 							: R_ANAL_REF_TYPE_CODE; 						r_anal_xrefs_set (core->anal, cur, dst, ref); 						r_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1); // analyze function here #if 0 						if (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) { 							eprintf (""0x%08""PFMT64x""  RCALL TO %llx\n"", cur, dst); 						} #endif 					} 				} 			} 			break; 		default: 			break; 		} 		r_anal_esil_stack_free (ESIL); repeat: 		if (!r_anal_get_block_at (core->anal, cur)) { 			size_t fcn_i; 			for (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) { 				if (r_anal_get_function_at (core->anal, start + fcn_i)) { 					i = fcn_i - 1; 					break; 				} 			} 		} 		if (i >= iend) { 			break; 		} 	} while (get_next_i (&ictx, &i)); 	r_list_free (ictx.bbl); 	r_list_free (ictx.path); 	r_list_free (ictx.switch_path); 	free (buf); 	ESIL->cb.hook_mem_read = NULL; 	ESIL->cb.hook_mem_write = NULL; 	ESIL->cb.hook_reg_write = NULL; 	ESIL->user = NULL; 	r_anal_op_fini (&op); 	r_cons_break_pop (); 	// restore register 	r_reg_arena_pop (core->anal->reg); }"
"208912_CWE-416.c","CWE-416","getcmdline_int(     int		firstc,     long	count UNUSED,	// only used for incremental search     int		indent,		// indent for inside conditionals     int		clear_ccline)	// clear ccline first {     static int	depth = 0;	    // call depth     int		c;     int		i;     int		j;     int		gotesc = FALSE;		// TRUE when <ESC> just typed     int		do_abbr;		// when TRUE check for abbr.     char_u	*lookfor = NULL;	// string to match     int		hiscnt;			// current history line in use     int		histype;		// history type to be used #ifdef FEAT_SEARCH_EXTRA     incsearch_state_T	is_state; #endif     int		did_wild_list = FALSE;	// did wild_list() recently     int		wim_index = 0;		// index in wim_flags[]     int		res;     int		save_msg_scroll = msg_scroll;     int		save_State = State;	// remember State when called     int		some_key_typed = FALSE;	// one of the keys was typed     // mouse drag and release events are ignored, unless they are     // preceded with a mouse down event     int		ignore_drag_release = TRUE; #ifdef FEAT_EVAL     int		break_ctrl_c = FALSE; #endif     expand_T	xpc;     long	*b_im_ptr = NULL;     cmdline_info_T save_ccline;     int		did_save_ccline = FALSE;     int		cmdline_type;     int		wild_type;      // one recursion level deeper     ++depth;      if (ccline.cmdbuff != NULL)     { 	// Being called recursively.  Since ccline is global, we need to save 	// the current buffer and restore it when returning. 	save_cmdline(&save_ccline); 	did_save_ccline = TRUE;     }     if (clear_ccline) 	CLEAR_FIELD(ccline);  #ifdef FEAT_EVAL     if (firstc == -1)     { 	firstc = NUL; 	break_ctrl_c = TRUE;     } #endif #ifdef FEAT_RIGHTLEFT     // start without Hebrew mapping for a command line     if (firstc == ':' || firstc == '=' || firstc == '>') 	cmd_hkmap = 0; #endif  #ifdef FEAT_SEARCH_EXTRA     init_incsearch_state(&is_state); #endif      if (init_ccline(firstc, indent) != OK) 	goto theend;	// out of memory      if (depth == 50)     { 	// Somehow got into a loop recursively calling getcmdline(), bail out. 	emsg(_(e_command_too_recursive)); 	goto theend;     }      ExpandInit(&xpc);     ccline.xpc = &xpc;  #ifdef FEAT_RIGHTLEFT     if (curwin->w_p_rl && *curwin->w_p_rlc == 's' 					  && (firstc == '/' || firstc == '?')) 	cmdmsg_rl = TRUE;     else 	cmdmsg_rl = FALSE; #endif      redir_off = TRUE;		// don't redirect the typed command     if (!cmd_silent)     { 	i = msg_scrolled; 	msg_scrolled = 0;		// avoid wait_return() message 	gotocmdline(TRUE); 	msg_scrolled += i; 	redrawcmdprompt();		// draw prompt or indent 	set_cmdspos();     }     xpc.xp_context = EXPAND_NOTHING;     xpc.xp_backslash = XP_BS_NONE; #ifndef BACKSLASH_IN_FILENAME     xpc.xp_shell = FALSE; #endif  #if defined(FEAT_EVAL)     if (ccline.input_fn)     { 	xpc.xp_context = ccline.xp_context; 	xpc.xp_pattern = ccline.cmdbuff; 	xpc.xp_arg = ccline.xp_arg;     } #endif      /*      * Avoid scrolling when called by a recursive do_cmdline(), e.g. when      * doing "":@0"" when register 0 doesn't contain a CR.      */     msg_scroll = FALSE;      State = MODE_CMDLINE;      if (firstc == '/' || firstc == '?' || firstc == '@')     { 	// Use "":lmap"" mappings for search pattern and input(). 	if (curbuf->b_p_imsearch == B_IMODE_USE_INSERT) 	    b_im_ptr = &curbuf->b_p_iminsert; 	else 	    b_im_ptr = &curbuf->b_p_imsearch; 	if (*b_im_ptr == B_IMODE_LMAP) 	    State |= MODE_LANGMAP; #ifdef HAVE_INPUT_METHOD 	im_set_active(*b_im_ptr == B_IMODE_IM); #endif     } #ifdef HAVE_INPUT_METHOD     else if (p_imcmdline) 	im_set_active(TRUE); #endif      setmouse(); #ifdef CURSOR_SHAPE     ui_cursor_shape();		// may show different cursor shape #endif      // When inside an autocommand for writing ""exiting"" may be set and     // terminal mode set to cooked.  Need to set raw mode here then.     settmode(TMODE_RAW);      // Trigger CmdlineEnter autocommands.     cmdline_type = firstc == NUL ? '-' : firstc;     trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER); #ifdef FEAT_EVAL     if (!debug_mode) 	may_trigger_modechanged(); #endif      init_history();     hiscnt = get_hislen();	// set hiscnt to impossible history value     histype = hist_char2type(firstc);  #ifdef FEAT_DIGRAPHS     do_digraph(-1);		// init digraph typeahead #endif      // If something above caused an error, reset the flags, we do want to type     // and execute commands. Display may be messed up a bit.     if (did_emsg) 	redrawcmd();  #ifdef FEAT_STL_OPT     // Redraw the statusline in case it uses the current mode using the mode()     // function.     if (!cmd_silent && msg_scrolled == 0)     { 	int	found_one = FALSE; 	win_T	*wp;  	FOR_ALL_WINDOWS(wp) 	    if (*p_stl != NUL || *wp->w_p_stl != NUL) 	    { 		wp->w_redr_status = TRUE; 		found_one = TRUE; 	    }  	if (*p_tal != NUL) 	{ 	    redraw_tabline = TRUE; 	    found_one = TRUE; 	}  	if (found_one) 	    redraw_statuslines();     } #endif      did_emsg = FALSE;     got_int = FALSE;      /*      * Collect the command string, handling editing keys.      */     for (;;)     { 	int trigger_cmdlinechanged = TRUE; 	int end_wildmenu;  	redir_off = TRUE;	// Don't redirect the typed command. 				// Repeated, because a "":redir"" inside 				// completion may switch it on. #ifdef USE_ON_FLY_SCROLL 	dont_scroll = FALSE;	// allow scrolling here #endif 	quit_more = FALSE;	// reset after CTRL-D which had a more-prompt  	did_emsg = FALSE;	// There can't really be a reason why an error 				// that occurs while typing a command should 				// cause the command not to be executed.  	// Trigger SafeState if nothing is pending. 	may_trigger_safestate(xpc.xp_numfiles <= 0);  	// Get a character.  Ignore K_IGNORE and K_NOP, they should not do 	// anything, such as stop completion. 	do 	{ 	    cursorcmd();		// set the cursor on the right spot 	    c = safe_vgetc(); 	} while (c == K_IGNORE || c == K_NOP);  	if (c == K_COMMAND || c == K_SCRIPT_COMMAND) 	{ 	    int	    clen = ccline.cmdlen;  	    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK) 	    { 		if (clen == ccline.cmdlen) 		    trigger_cmdlinechanged = FALSE; 		goto cmdline_changed; 	    } 	}  	if (KeyTyped) 	{ 	    some_key_typed = TRUE; #ifdef FEAT_RIGHTLEFT 	    if (cmd_hkmap) 		c = hkmap(c); 	    if (cmdmsg_rl && !KeyStuffed) 	    { 		// Invert horizontal movements and operations.  Only when 		// typed by the user directly, not when the result of a 		// mapping. 		switch (c) 		{ 		    case K_RIGHT:   c = K_LEFT; break; 		    case K_S_RIGHT: c = K_S_LEFT; break; 		    case K_C_RIGHT: c = K_C_LEFT; break; 		    case K_LEFT:    c = K_RIGHT; break; 		    case K_S_LEFT:  c = K_S_RIGHT; break; 		    case K_C_LEFT:  c = K_C_RIGHT; break; 		} 	    } #endif 	}  	/* 	 * Ignore got_int when CTRL-C was typed here. 	 * Don't ignore it in :global, we really need to break then, e.g., for 	 * "":g/pat/normal /pat"" (without the <CR>). 	 * Don't ignore it for the input() function. 	 */ 	if ((c == Ctrl_C #ifdef UNIX 		|| c == intr_char #endif 				) #if defined(FEAT_EVAL) || defined(FEAT_CRYPT) 		&& firstc != '@' #endif #ifdef FEAT_EVAL 		// do clear got_int in Ex mode to avoid infinite Ctrl-C loop 		&& (!break_ctrl_c || exmode_active) #endif 		&& !global_busy) 	    got_int = FALSE;  	// free old command line when finished moving around in the history 	// list 	if (lookfor != NULL 		&& c != K_S_DOWN && c != K_S_UP 		&& c != K_DOWN && c != K_UP 		&& c != K_PAGEDOWN && c != K_PAGEUP 		&& c != K_KPAGEDOWN && c != K_KPAGEUP 		&& c != K_LEFT && c != K_RIGHT 		&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N))) 	    VIM_CLEAR(lookfor);  	/* 	 * When there are matching completions to select <S-Tab> works like 	 * CTRL-P (unless 'wc' is <S-Tab>). 	 */ 	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0) 	    c = Ctrl_P;  	if (p_wmnu) 	    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);  	if (cmdline_pum_active()) 	{ 	    // Ctrl-Y: Accept the current selection and close the popup menu. 	    // Ctrl-E: cancel the cmdline popup menu and return the original 	    // text. 	    if (c == Ctrl_E || c == Ctrl_Y) 	    { 		wild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY; 		if (nextwild(&xpc, wild_type, WILD_NO_BEEP, 							firstc != '@') == FAIL) 		    break; 		c = Ctrl_E; 	    } 	}  	// The wildmenu is cleared if the pressed key is not used for 	// navigating the wild menu (i.e. the key is not 'wildchar' or 	// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L). 	// If the popup menu is displayed, then PageDown and PageUp keys are 	// also used to navigate the menu. 	end_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm 		&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L); 	end_wildmenu = end_wildmenu && (!cmdline_pum_active() || 			    (c != K_PAGEDOWN && c != K_PAGEUP 			     && c != K_KPAGEDOWN && c != K_KPAGEUP));  	// free expanded names when finished walking through matches 	if (end_wildmenu) 	{ 	    if (cmdline_pum_active()) 		cmdline_pum_remove(); 	    if (xpc.xp_numfiles != -1) 		(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE); 	    did_wild_list = FALSE; 	    if (!p_wmnu || (c != K_UP && c != K_DOWN)) 		xpc.xp_context = EXPAND_NOTHING; 	    wim_index = 0; 	    wildmenu_cleanup(&ccline); 	}  	if (p_wmnu) 	    c = wildmenu_process_key(&ccline, c, &xpc);  	// CTRL-\ CTRL-N goes to Normal mode, CTRL-\ CTRL-G goes to Insert 	// mode when 'insertmode' is set, CTRL-\ e prompts for an expression. 	if (c == Ctrl_BSL) 	{ 	    res = cmdline_handle_backslash_key(c, &gotesc); 	    if (res == CMDLINE_CHANGED) 		goto cmdline_changed; 	    else if (res == CMDLINE_NOT_CHANGED) 		goto cmdline_not_changed; 	    else if (res == GOTO_NORMAL_MODE) 		goto returncmd;		// back to cmd mode 	    c = Ctrl_BSL;		// backslash key not processed by 					// cmdline_handle_backslash_key() 	}  #ifdef FEAT_CMDWIN 	if (c == cedit_key || c == K_CMDWIN) 	{ 	    // TODO: why is ex_normal_busy checked here? 	    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE) 	    { 		/* 		 * Open a window to edit the command line (and history). 		 */ 		c = open_cmdwin(); 		some_key_typed = TRUE; 	    } 	} # ifdef FEAT_DIGRAPHS 	else # endif #endif #ifdef FEAT_DIGRAPHS 	    c = do_digraph(c); #endif  	if (c == '\n' || c == '\r' || c == K_KENTER || (c == ESC 			&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) 	{ 	    // In Ex mode a backslash escapes a newline. 	    if (exmode_active 		    && c != ESC 		    && ccline.cmdpos == ccline.cmdlen 		    && ccline.cmdpos > 0 		    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\') 	    { 		if (c == K_KENTER) 		    c = '\n'; 	    } 	    else 	    { 		gotesc = FALSE;	// Might have typed ESC previously, don't 				// truncate the cmdline now. 		if (ccheck_abbr(c + ABBR_OFF)) 		    goto cmdline_changed; 		if (!cmd_silent) 		{ 		    windgoto(msg_row, 0); 		    out_flush(); 		} 		break; 	    } 	}  	// Completion for 'wildchar' or 'wildcharm' key. 	if ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm) 	{ 	    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list, 		    &wim_index, &xpc, &gotesc); 	    if (res == CMDLINE_CHANGED) 		goto cmdline_changed; 	}  	gotesc = FALSE;  	// <S-Tab> goes to last match, in a clumsy way 	if (c == K_S_TAB && KeyTyped) 	{ 	    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK) 	    { 		if (xpc.xp_numfiles > 1 		    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST)) 			    || p_wmnu)) 		{ 		    // Trigger the popup menu when wildoptions=pum 		    showmatches(&xpc, p_wmnu 			    && ((wim_flags[wim_index] & WIM_LIST) == 0)); 		} 		if (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK 			&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK) 		    goto cmdline_changed; 	    } 	}  	if (c == NUL || c == K_ZERO)	    // NUL is stored as NL 	    c = NL;  	do_abbr = TRUE;		// default: check for abbreviation  	/* 	 * Big switch for a typed command line character. 	 */ 	switch (c) 	{ 	case K_BS: 	case Ctrl_H: 	case K_DEL: 	case K_KDEL: 	case Ctrl_W: 	    res = cmdline_erase_chars(c, indent #ifdef FEAT_SEARCH_EXTRA 		    , &is_state #endif 		    ); 	    if (res == CMDLINE_NOT_CHANGED) 		goto cmdline_not_changed; 	    else if (res == GOTO_NORMAL_MODE) 		goto returncmd;		// back to cmd mode 	    goto cmdline_changed;  	case K_INS: 	case K_KINS: 		ccline.overstrike = !ccline.overstrike; #ifdef CURSOR_SHAPE 		ui_cursor_shape();	// may show different cursor shape #endif 		goto cmdline_not_changed;  	case Ctrl_HAT: 		cmdline_toggle_langmap(b_im_ptr); 		goto cmdline_not_changed;  //	case '@':   only in very old vi 	case Ctrl_U: 		// delete all characters left of the cursor 		j = ccline.cmdpos; 		ccline.cmdlen -= j; 		i = ccline.cmdpos = 0; 		while (i < ccline.cmdlen) 		    ccline.cmdbuff[i++] = ccline.cmdbuff[j++]; 		// Truncate at the end, required for multi-byte chars. 		ccline.cmdbuff[ccline.cmdlen] = NUL; #ifdef FEAT_SEARCH_EXTRA 		if (ccline.cmdlen == 0) 		    is_state.search_start = is_state.save_cursor; #endif 		redrawcmd(); 		goto cmdline_changed;  #ifdef FEAT_CLIPBOARD 	case Ctrl_Y: 		// Copy the modeless selection, if there is one. 		if (clip_star.state != SELECT_CLEARED) 		{ 		    if (clip_star.state == SELECT_DONE) 			clip_copy_modeless_selection(TRUE); 		    goto cmdline_not_changed; 		} 		break; #endif  	case ESC:	// get here if p_wc != ESC or when ESC typed twice 	case Ctrl_C: 		// In exmode it doesn't make sense to return.  Except when 		// "":normal"" runs out of characters. 		if (exmode_active 			       && (ex_normal_busy == 0 || typebuf.tb_len > 0)) 		    goto cmdline_not_changed;  		gotesc = TRUE;		// will free ccline.cmdbuff after 					// putting it in history 		goto returncmd;		// back to cmd mode  	case Ctrl_R:			// insert register 		res = cmdline_insert_reg(&gotesc); 		if (res == CMDLINE_NOT_CHANGED) 		    goto cmdline_not_changed; 		else if (res == GOTO_NORMAL_MODE) 		    goto returncmd; 		goto cmdline_changed;  	case Ctrl_D: 		if (showmatches(&xpc, FALSE) == EXPAND_NOTHING) 		    break;	// Use ^D as normal char instead  		redrawcmd(); 		continue;	// don't do incremental search now  	case K_RIGHT: 	case K_S_RIGHT: 	case K_C_RIGHT: 		do 		{ 		    if (ccline.cmdpos >= ccline.cmdlen) 			break; 		    i = cmdline_charsize(ccline.cmdpos); 		    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows) 			break; 		    ccline.cmdspos += i; 		    if (has_mbyte) 			ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff 							     + ccline.cmdpos); 		    else 			++ccline.cmdpos; 		} 		while ((c == K_S_RIGHT || c == K_C_RIGHT 			       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))) 			&& ccline.cmdbuff[ccline.cmdpos] != ' '); 		if (has_mbyte) 		    set_cmdspos_cursor(); 		goto cmdline_not_changed;  	case K_LEFT: 	case K_S_LEFT: 	case K_C_LEFT: 		if (ccline.cmdpos == 0) 		    goto cmdline_not_changed; 		do 		{ 		    --ccline.cmdpos; 		    if (has_mbyte)	// move to first byte of char 			ccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff, 					      ccline.cmdbuff + ccline.cmdpos); 		    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos); 		} 		while (ccline.cmdpos > 0 			&& (c == K_S_LEFT || c == K_C_LEFT 			       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))) 			&& ccline.cmdbuff[ccline.cmdpos - 1] != ' '); 		if (has_mbyte) 		    set_cmdspos_cursor(); 		goto cmdline_not_changed;  	case K_IGNORE: 		// Ignore mouse event or open_cmdwin() result. 		goto cmdline_not_changed;  #ifdef FEAT_GUI_MSWIN 	    // On MS-Windows ignore <M-F4>, we get it when closing the window 	    // was cancelled. 	case K_F4: 	    if (mod_mask == MOD_MASK_ALT) 	    { 		redrawcmd();	    // somehow the cmdline is cleared 		goto cmdline_not_changed; 	    } 	    break; #endif  	case K_MIDDLEDRAG: 	case K_MIDDLERELEASE: 		goto cmdline_not_changed;	// Ignore mouse  	case K_MIDDLEMOUSE: # ifdef FEAT_GUI 		// When GUI is active, also paste when 'mouse' is empty 		if (!gui.in_use) # endif 		    if (!mouse_has(MOUSE_COMMAND)) 			goto cmdline_not_changed;   // Ignore mouse # ifdef FEAT_CLIPBOARD 		if (clip_star.available) 		    cmdline_paste('*', TRUE, TRUE); 		else # endif 		    cmdline_paste(0, TRUE, TRUE); 		redrawcmd(); 		goto cmdline_changed;  # ifdef FEAT_DND 	case K_DROP: 		cmdline_paste('~', TRUE, FALSE); 		redrawcmd(); 		goto cmdline_changed; # endif  	case K_LEFTDRAG: 	case K_LEFTRELEASE: 	case K_RIGHTDRAG: 	case K_RIGHTRELEASE: 		// Ignore drag and release events when the button-down wasn't 		// seen before. 		if (ignore_drag_release) 		    goto cmdline_not_changed; 		// FALLTHROUGH 	case K_LEFTMOUSE: 	case K_RIGHTMOUSE: 		cmdline_left_right_mouse(c, &ignore_drag_release); 		goto cmdline_not_changed;  	// Mouse scroll wheel: ignored here 	case K_MOUSEDOWN: 	case K_MOUSEUP: 	case K_MOUSELEFT: 	case K_MOUSERIGHT: 	// Alternate buttons ignored here 	case K_X1MOUSE: 	case K_X1DRAG: 	case K_X1RELEASE: 	case K_X2MOUSE: 	case K_X2DRAG: 	case K_X2RELEASE: 	case K_MOUSEMOVE: 		goto cmdline_not_changed;  #ifdef FEAT_GUI 	case K_LEFTMOUSE_NM:	// mousefocus click, ignored 	case K_LEFTRELEASE_NM: 		goto cmdline_not_changed;  	case K_VER_SCROLLBAR: 		if (msg_scrolled == 0) 		{ 		    gui_do_scroll(); 		    redrawcmd(); 		} 		goto cmdline_not_changed;  	case K_HOR_SCROLLBAR: 		if (msg_scrolled == 0) 		{ 		    gui_do_horiz_scroll(scrollbar_value, FALSE); 		    redrawcmd(); 		} 		goto cmdline_not_changed; #endif #ifdef FEAT_GUI_TABLINE 	case K_TABLINE: 	case K_TABMENU: 		// Don't want to change any tabs here.  Make sure the same tab 		// is still selected. 		if (gui_use_tabline()) 		    gui_mch_set_curtab(tabpage_index(curtab)); 		goto cmdline_not_changed; #endif  	case K_SELECT:	    // end of Select mode mapping - ignore 		goto cmdline_not_changed;  	case Ctrl_B:	    // begin of command line 	case K_HOME: 	case K_KHOME: 	case K_S_HOME: 	case K_C_HOME: 		ccline.cmdpos = 0; 		set_cmdspos(); 		goto cmdline_not_changed;  	case Ctrl_E:	    // end of command line 	case K_END: 	case K_KEND: 	case K_S_END: 	case K_C_END: 		ccline.cmdpos = ccline.cmdlen; 		set_cmdspos_cursor(); 		goto cmdline_not_changed;  	case Ctrl_A:	    // all matches 		if (cmdline_pum_active()) 		    // As Ctrl-A completes all the matches, close the popup 		    // menu (if present) 		    cmdline_pum_cleanup(&ccline);  		if (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL) 		    break; 		xpc.xp_context = EXPAND_NOTHING; 		did_wild_list = FALSE; 		goto cmdline_changed;  	case Ctrl_L: #ifdef FEAT_SEARCH_EXTRA 		if (may_add_char_to_search(firstc, &c, &is_state) == OK) 		    goto cmdline_not_changed; #endif  		// completion: longest common part 		if (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL) 		    break; 		goto cmdline_changed;  	case Ctrl_N:	    // next match 	case Ctrl_P:	    // previous match 		if (xpc.xp_numfiles > 0) 		{ 		    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT; 		    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL) 			break; 		    goto cmdline_not_changed; 		} 		// FALLTHROUGH 	case K_UP: 	case K_DOWN: 	case K_S_UP: 	case K_S_DOWN: 	case K_PAGEUP: 	case K_KPAGEUP: 	case K_PAGEDOWN: 	case K_KPAGEDOWN: 		if (cmdline_pum_active() 			&& (c == K_PAGEUP || c == K_PAGEDOWN || 			    c == K_KPAGEUP || c == K_KPAGEDOWN)) 		{ 		    // If the popup menu is displayed, then PageUp and PageDown 		    // are used to scroll the menu. 		    wild_type = WILD_PAGEUP; 		    if (c == K_PAGEDOWN || c == K_KPAGEDOWN) 			wild_type = WILD_PAGEDOWN; 		    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL) 			break; 		    goto cmdline_not_changed; 		} 		else 		{ 		    res = cmdline_browse_history(c, firstc, &lookfor, histype, 			    &hiscnt, &xpc); 		    if (res == CMDLINE_CHANGED) 			goto cmdline_changed; 		    else if (res == GOTO_NORMAL_MODE) 			goto returncmd; 		} 		goto cmdline_not_changed;  #ifdef FEAT_SEARCH_EXTRA 	case Ctrl_G:	    // next match 	case Ctrl_T:	    // previous match 		if (may_adjust_incsearch_highlighting( 					  firstc, count, &is_state, c) == FAIL) 		    goto cmdline_not_changed; 		break; #endif  	case Ctrl_V: 	case Ctrl_Q: 		{ 		    ignore_drag_release = TRUE; 		    putcmdline('^', TRUE);  		    // Get next (two) character(s).  Do not change any 		    // modifyOtherKeys ESC sequence to a normal key for 		    // CTRL-SHIFT-V. 		    c = get_literal(mod_mask & MOD_MASK_SHIFT);  		    do_abbr = FALSE;	    // don't do abbreviation now 		    extra_char = NUL; 		    // may need to remove ^ when composing char was typed 		    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent) 		    { 			draw_cmdline(ccline.cmdpos, 						ccline.cmdlen - ccline.cmdpos); 			msg_putchar(' '); 			cursorcmd(); 		    } 		}  		break;  #ifdef FEAT_DIGRAPHS 	case Ctrl_K: 		ignore_drag_release = TRUE; 		putcmdline('?', TRUE); # ifdef USE_ON_FLY_SCROLL 		dont_scroll = TRUE;	    // disallow scrolling here # endif 		c = get_digraph(TRUE); 		extra_char = NUL; 		if (c != NUL) 		    break;  		redrawcmd(); 		goto cmdline_not_changed; #endif // FEAT_DIGRAPHS  #ifdef FEAT_RIGHTLEFT 	case Ctrl__:	    // CTRL-_: switch language mode 		if (!p_ari) 		    break; 		cmd_hkmap = !cmd_hkmap; 		goto cmdline_not_changed; #endif  	case K_PS: 		bracketed_paste(PASTE_CMDLINE, FALSE, NULL); 		goto cmdline_changed;  	default: #ifdef UNIX 		if (c == intr_char) 		{ 		    gotesc = TRUE;	// will free ccline.cmdbuff after 					// putting it in history 		    goto returncmd;	// back to Normal mode 		} #endif 		/* 		 * Normal character with no special meaning.  Just set mod_mask 		 * to 0x0 so that typing Shift-Space in the GUI doesn't enter 		 * the string <S-Space>.  This should only happen after ^V. 		 */ 		if (!IS_SPECIAL(c)) 		    mod_mask = 0x0; 		break; 	} 	/* 	 * End of switch on command line character. 	 * We come here if we have a normal character. 	 */  	if (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c)) 		&& (ccheck_abbr( 			// Add ABBR_OFF for characters above 0x100, this is 			// what check_abbr() expects. 				(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c) 		    || c == Ctrl_RSB)) 	    goto cmdline_changed;  	/* 	 * put the character in the command line 	 */ 	if (IS_SPECIAL(c) || mod_mask != 0) 	    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE); 	else 	{ 	    if (has_mbyte) 	    { 		j = (*mb_char2bytes)(c, IObuff); 		IObuff[j] = NUL;	// exclude composing chars 		put_on_cmdline(IObuff, j, TRUE); 	    } 	    else 	    { 		IObuff[0] = c; 		put_on_cmdline(IObuff, 1, TRUE); 	    } 	} 	goto cmdline_changed;  /*  * This part implements incremental searches for ""/"" and ""?""  * Jump to cmdline_not_changed when a character has been read but the command  * line did not change. Then we only search and redraw if something changed in  * the past.  * Jump to cmdline_changed when the command line did change.  * (Sorry for the goto's, I know it is ugly).  */ cmdline_not_changed: #ifdef FEAT_SEARCH_EXTRA 	if (!is_state.incsearch_postponed) 	    continue; #endif  cmdline_changed: #ifdef FEAT_SEARCH_EXTRA 	// If the window changed incremental search state is not valid. 	if (is_state.winid != curwin->w_id) 	    init_incsearch_state(&is_state); #endif 	if (trigger_cmdlinechanged) 	    // Trigger CmdlineChanged autocommands. 	    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);  #ifdef FEAT_SEARCH_EXTRA 	if (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL)) 	    may_do_incsearch_highlighting(firstc, count, &is_state); #endif  #ifdef FEAT_RIGHTLEFT 	if (cmdmsg_rl # ifdef FEAT_ARABIC 		|| (p_arshape && !p_tbidi 				       && cmdline_has_arabic(0, ccline.cmdlen)) # endif 		) 	    // Always redraw the whole command line to fix shaping and 	    // right-left typing.  Not efficient, but it works. 	    // Do it only when there are no characters left to read 	    // to avoid useless intermediate redraws. 	    if (vpeekc() == NUL) 		redrawcmd(); #endif     }  returncmd:  #ifdef FEAT_RIGHTLEFT     cmdmsg_rl = FALSE; #endif      ExpandCleanup(&xpc);     ccline.xpc = NULL;  #ifdef FEAT_SEARCH_EXTRA     finish_incsearch_highlighting(gotesc, &is_state, FALSE); #endif      if (ccline.cmdbuff != NULL)     { 	/* 	 * Put line in history buffer ("":"" and ""="" only when it was typed). 	 */ 	if (ccline.cmdlen && firstc != NUL 		&& (some_key_typed || histype == HIST_SEARCH)) 	{ 	    add_to_history(histype, ccline.cmdbuff, TRUE, 				       histype == HIST_SEARCH ? firstc : NUL); 	    if (firstc == ':') 	    { 		vim_free(new_last_cmdline); 		new_last_cmdline = vim_strsave(ccline.cmdbuff); 	    } 	}  	if (gotesc) 	    abandon_cmdline();     }      /*      * If the screen was shifted up, redraw the whole screen (later).      * If the line is too long, clear it, so ruler and shown command do      * not get printed in the middle of it.      */     msg_check();     msg_scroll = save_msg_scroll;     redir_off = FALSE;      // When the command line was typed, no need for a wait-return prompt.     if (some_key_typed) 	need_wait_return = FALSE;      // Trigger CmdlineLeave autocommands.     trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);      State = save_State;  #ifdef FEAT_EVAL     if (!debug_mode) 	may_trigger_modechanged(); #endif  #ifdef HAVE_INPUT_METHOD     if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP) 	im_save_status(b_im_ptr);     im_set_active(FALSE); #endif     setmouse(); #ifdef CURSOR_SHAPE     ui_cursor_shape();		// may show different cursor shape #endif     sb_text_end_cmdline();  theend:     { 	char_u *p = ccline.cmdbuff;  	--depth; 	if (did_save_ccline) 	    restore_cmdline(&save_ccline); 	else 	    ccline.cmdbuff = NULL; 	return p;     } }"
"208983_CWE-119.c","CWE-119","jas_image_t *jp2_decode(jas_stream_t *in, char *optstr) { 	jp2_box_t *box; 	int found; 	jas_image_t *image; 	jp2_dec_t *dec; 	bool samedtype; 	int dtype; 	unsigned int i; 	jp2_cmap_t *cmapd; 	jp2_pclr_t *pclrd; 	jp2_cdef_t *cdefd; 	unsigned int channo; 	int newcmptno; 	int_fast32_t *lutents; #if 0 	jp2_cdefchan_t *cdefent; 	int cmptno; #endif 	jp2_cmapent_t *cmapent; 	jas_icchdr_t icchdr; 	jas_iccprof_t *iccprof;  	dec = 0; 	box = 0; 	image = 0;  	if (!(dec = jp2_dec_create())) { 		goto error; 	}  	/* Get the first box.  This should be a JP box. */ 	if (!(box = jp2_box_get(in))) { 		jas_eprintf(""error: cannot get box\n""); 		goto error; 	} 	if (box->type != JP2_BOX_JP) { 		jas_eprintf(""error: expecting signature box\n""); 		goto error; 	} 	if (box->data.jp.magic != JP2_JP_MAGIC) { 		jas_eprintf(""incorrect magic number\n""); 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Get the second box.  This should be a FTYP box. */ 	if (!(box = jp2_box_get(in))) { 		goto error; 	} 	if (box->type != JP2_BOX_FTYP) { 		jas_eprintf(""expecting file type box\n""); 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Get more boxes... */ 	found = 0; 	while ((box = jp2_box_get(in))) { 		if (jas_getdbglevel() >= 1) { 			jas_eprintf(""box type %s\n"", box->info->name); 		} 		switch (box->type) { 		case JP2_BOX_JP2C: 			found = 1; 			break; 		case JP2_BOX_IHDR: 			if (!dec->ihdr) { 				dec->ihdr = box; 				box = 0; 			} 			break; 		case JP2_BOX_BPCC: 			if (!dec->bpcc) { 				dec->bpcc = box; 				box = 0; 			} 			break; 		case JP2_BOX_CDEF: 			if (!dec->cdef) { 				dec->cdef = box; 				box = 0; 			} 			break; 		case JP2_BOX_PCLR: 			if (!dec->pclr) { 				dec->pclr = box; 				box = 0; 			} 			break; 		case JP2_BOX_CMAP: 			if (!dec->cmap) { 				dec->cmap = box; 				box = 0; 			} 			break; 		case JP2_BOX_COLR: 			if (!dec->colr) { 				dec->colr = box; 				box = 0; 			} 			break; 		} 		if (box) { 			jp2_box_destroy(box); 			box = 0; 		} 		if (found) { 			break; 		} 	}  	if (!found) { 		jas_eprintf(""error: no code stream found\n""); 		goto error; 	}  	if (!(dec->image = jpc_decode(in, optstr))) { 		jas_eprintf(""error: cannot decode code stream\n""); 		goto error; 	}  	/* An IHDR box must be present. */ 	if (!dec->ihdr) { 		jas_eprintf(""error: missing IHDR box\n""); 		goto error; 	}  	/* Does the number of components indicated in the IHDR box match 	  the value specified in the code stream? */ 	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint, jas_image_numcmpts(dec->image))) { 		jas_eprintf(""warning: number of components mismatch\n""); 	}  	/* At least one component must be present. */ 	if (!jas_image_numcmpts(dec->image)) { 		jas_eprintf(""error: no components\n""); 		goto error; 	}  	/* Determine if all components have the same data type. */ 	samedtype = true; 	dtype = jas_image_cmptdtype(dec->image, 0); 	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) { 		if (jas_image_cmptdtype(dec->image, i) != dtype) { 			samedtype = false; 			break; 		} 	}  	/* Is the component data type indicated in the IHDR box consistent 	  with the data in the code stream? */ 	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) || 	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) { 		jas_eprintf(""warning: component data type mismatch\n""); 	}  	/* Is the compression type supported? */ 	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) { 		jas_eprintf(""error: unsupported compression type\n""); 		goto error; 	}  	if (dec->bpcc) { 		/* Is the number of components indicated in the BPCC box 		  consistent with the code stream data? */ 		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts( 		  dec->image))) { 			jas_eprintf(""warning: number of components mismatch\n""); 		} 		/* Is the component data type information indicated in the BPCC 		  box consistent with the code stream data? */ 		if (!samedtype) { 			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) { 				if (jas_image_cmptdtype(dec->image, i) != JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) { 					jas_eprintf(""warning: component data type mismatch\n""); 				} 			} 		} else { 			jas_eprintf(""warning: superfluous BPCC box\n""); 		} 	}  	/* A COLR box must be present. */ 	if (!dec->colr) { 		jas_eprintf(""error: no COLR box\n""); 		goto error; 	}  	switch (dec->colr->data.colr.method) { 	case JP2_COLR_ENUM: 		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr)); 		break; 	case JP2_COLR_ICC: 		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp, 		  dec->colr->data.colr.iccplen); 		assert(iccprof); 		jas_iccprof_gethdr(iccprof, &icchdr); 		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc); 		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc)); 		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof); 		assert(dec->image->cmprof_); 		jas_iccprof_destroy(iccprof); 		break; 	}  	/* If a CMAP box is present, a PCLR box must also be present. */ 	if (dec->cmap && !dec->pclr) { 		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n""); 		jp2_box_destroy(dec->cmap); 		dec->cmap = 0; 	}  	/* If a CMAP box is not present, a PCLR box must not be present. */ 	if (!dec->cmap && dec->pclr) { 		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n""); 		jp2_box_destroy(dec->pclr); 		dec->pclr = 0; 	}  	/* Determine the number of channels (which is essentially the number 	  of components after any palette mappings have been applied). */ 	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans : JAS_CAST(uint, jas_image_numcmpts(dec->image));  	/* Perform a basic sanity check on the CMAP box if present. */ 	if (dec->cmap) { 		for (i = 0; i < dec->numchans; ++i) { 			/* Is the component number reasonable? */ 			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint, jas_image_numcmpts(dec->image))) { 				jas_eprintf(""error: invalid component number in CMAP box\n""); 				goto error; 			} 			/* Is the LUT index reasonable? */ 			if (dec->cmap->data.cmap.ents[i].pcol >= dec->pclr->data.pclr.numchans) { 				jas_eprintf(""error: invalid CMAP LUT index\n""); 				goto error; 			} 		} 	}  	/* Allocate space for the channel-number to component-number LUT. */ 	if (!(dec->chantocmptlut = jas_malloc(dec->numchans * sizeof(uint_fast16_t)))) { 		jas_eprintf(""error: no memory\n""); 		goto error; 	}  	if (!dec->cmap) { 		for (i = 0; i < dec->numchans; ++i) { 			dec->chantocmptlut[i] = i; 		} 	} else { 		cmapd = &dec->cmap->data.cmap; 		pclrd = &dec->pclr->data.pclr; 		cdefd = &dec->cdef->data.cdef; 		for (channo = 0; channo < cmapd->numchans; ++channo) { 			cmapent = &cmapd->ents[channo]; 			if (cmapent->map == JP2_CMAP_DIRECT) { 				dec->chantocmptlut[channo] = channo; 			} else if (cmapent->map == JP2_CMAP_PALETTE) { 				lutents = jas_malloc(pclrd->numlutents * sizeof(int_fast32_t)); 				for (i = 0; i < pclrd->numlutents; ++i) { 					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans]; 				} 				newcmptno = jas_image_numcmpts(dec->image); 				jas_image_depalettize(dec->image, cmapent->cmptno, pclrd->numlutents, lutents, JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno); 				dec->chantocmptlut[channo] = newcmptno; 				jas_free(lutents); #if 0 				if (dec->cdef) { 					cdefent = jp2_cdef_lookup(cdefd, channo); 					if (!cdefent) { 						abort(); 					} 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc)); 				} else { 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1)); 				} #endif 			} 		} 	}  	/* Mark all components as being of unknown type. */  	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) { 		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN); 	}  	/* Determine the type of each component. */ 	if (dec->cdef) { 		for (i = 0; i < dec->numchans; ++i) { 			jas_image_setcmpttype(dec->image, 			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo], 			  jp2_getct(jas_image_clrspc(dec->image), 			  dec->cdef->data.cdef.ents[i].type, dec->cdef->data.cdef.ents[i].assoc)); 		} 	} else { 		for (i = 0; i < dec->numchans; ++i) { 			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i], 			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1)); 		} 	}  	/* Delete any components that are not of interest. */ 	for (i = jas_image_numcmpts(dec->image); i > 0; --i) { 		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) { 			jas_image_delcmpt(dec->image, i - 1); 		} 	}  	/* Ensure that some components survived. */ 	if (!jas_image_numcmpts(dec->image)) { 		jas_eprintf(""error: no components\n""); 		goto error; 	} #if 0 jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image)); #endif  	/* Prevent the image from being destroyed later. */ 	image = dec->image; 	dec->image = 0;  	jp2_dec_destroy(dec);  	return image;  error: 	if (box) { 		jp2_box_destroy(box); 	} 	if (dec) { 		jp2_dec_destroy(dec); 	} 	return 0; }"
"208987_CWE-416.cpp","CWE-416","PlayerGeneric::~PlayerGeneric() { 	if (mixer) 		delete mixer;  	if (player) 	{ 		if (mixer->isActive() && !mixer->isDeviceRemoved(player)) 			mixer->removeDevice(player); 		delete player; 	}  	delete[] audioDriverName; 	 	delete listener; }"
"209026_CWE-119.c","CWE-119","virNodeDeviceGetMdevTypesCaps(const char *sysfspath,                               virMediatedDeviceTypePtr **mdev_types,                               size_t *nmdev_types) {     virMediatedDeviceTypePtr *types = NULL;     size_t ntypes = 0;     size_t i;      /* this could be a refresh, so clear out the old data */     for (i = 0; i < *nmdev_types; i++)        virMediatedDeviceTypeFree(*mdev_types[i]);     VIR_FREE(*mdev_types);     *nmdev_types = 0;      if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)         return -1;      *mdev_types = g_steal_pointer(&types);     *nmdev_types = ntypes;      return 0; }"
"209049_CWE-119.c","CWE-119","xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,                   const xmlChar **URI, int *tlen) {     const xmlChar *localname;     const xmlChar *prefix;     const xmlChar *attname;     const xmlChar *aprefix;     const xmlChar *nsname;     xmlChar *attvalue;     const xmlChar **atts = ctxt->atts;     int maxatts = ctxt->maxatts;     int nratts, nbatts, nbdef;     int i, j, nbNs, attval, oldline, oldcol;     const xmlChar *base;     unsigned long cur;     int nsNr = ctxt->nsNr;      if (RAW != '<') return(NULL);     NEXT1;      /*      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that      *       point since the attribute values may be stored as pointers to      *       the buffer and calling SHRINK would destroy them !      *       The Shrinking is only possible once the full set of attribute      *       callbacks have been done.      */ reparse:     SHRINK;     base = ctxt->input->base;     cur = ctxt->input->cur - ctxt->input->base;     oldline = ctxt->input->line;     oldcol = ctxt->input->col;     nbatts = 0;     nratts = 0;     nbdef = 0;     nbNs = 0;     attval = 0;     /* Forget any namespaces added during an earlier parse of this element. */     ctxt->nsNr = nsNr;      localname = xmlParseQName(ctxt, &prefix);     if (localname == NULL) { 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, 		       ""StartTag: invalid element name\n"");         return(NULL);     }     *tlen = ctxt->input->cur - ctxt->input->base - cur;      /*      * Now parse the attributes, it ends up with the ending      *      * (S Attribute)* S?      */     SKIP_BLANKS;     GROW;     if (ctxt->input->base != base) goto base_changed;      while (((RAW != '>') && 	   ((RAW != '/') || (NXT(1) != '>')) && 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) { 	const xmlChar *q = CUR_PTR; 	unsigned int cons = ctxt->input->consumed; 	int len = -1, alloc = 0;  	attname = xmlParseAttribute2(ctxt, prefix, localname, 	                             &aprefix, &attvalue, &len, &alloc); 	if (ctxt->input->base != base) { 	    if ((attvalue != NULL) && (alloc != 0)) 	        xmlFree(attvalue); 	    attvalue = NULL; 	    goto base_changed; 	}         if ((attname != NULL) && (attvalue != NULL)) { 	    if (len < 0) len = xmlStrlen(attvalue);             if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { 	        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); 		xmlURIPtr uri;                  if (URL == NULL) { 		    xmlErrMemory(ctxt, ""dictionary allocation failure""); 		    if ((attvalue != NULL) && (alloc != 0)) 			xmlFree(attvalue); 		    return(NULL); 		}                 if (*URL != 0) { 		    uri = xmlParseURI((const char *) URL); 		    if (uri == NULL) { 			xmlNsErr(ctxt, XML_WAR_NS_URI, 			         ""xmlns: '%s' is not a valid URI\n"", 					   URL, NULL, NULL); 		    } else { 			if (uri->scheme == NULL) { 			    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, 				      ""xmlns: URI %s is not absolute\n"", 				      URL, NULL, NULL); 			} 			xmlFreeURI(uri); 		    } 		    if (URL == ctxt->str_xml_ns) { 			if (attname != ctxt->str_xml) { 			    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			 ""xml namespace URI cannot be the default namespace\n"", 				     NULL, NULL, NULL); 			} 			goto skip_default_ns; 		    } 		    if ((len == 29) && 			(xmlStrEqual(URL, 				 BAD_CAST ""http://www.w3.org/2000/xmlns/""))) { 			xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""reuse of the xmlns namespace name is forbidden\n"", 				 NULL, NULL, NULL); 			goto skip_default_ns; 		    } 		} 		/* 		 * check that it's not a defined namespace 		 */ 		for (j = 1;j <= nbNs;j++) 		    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) 			break; 		if (j <= nbNs) 		    xmlErrAttributeDup(ctxt, NULL, attname); 		else 		    if (nsPush(ctxt, NULL, URL) > 0) nbNs++; skip_default_ns: 		if (alloc != 0) xmlFree(attvalue); 		if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 		    break; 		if (!IS_BLANK_CH(RAW)) { 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 				   ""attributes construct error\n""); 		    break; 		} 		SKIP_BLANKS; 		continue; 	    }             if (aprefix == ctxt->str_xmlns) { 	        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); 		xmlURIPtr uri;                  if (attname == ctxt->str_xml) { 		    if (URL != ctxt->str_xml_ns) { 		        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			         ""xml namespace prefix mapped to wrong URI\n"", 			         NULL, NULL, NULL); 		    } 		    /* 		     * Do not keep a namespace definition node 		     */ 		    goto skip_ns; 		}                 if (URL == ctxt->str_xml_ns) { 		    if (attname != ctxt->str_xml) { 		        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			         ""xml namespace URI mapped to wrong prefix\n"", 			         NULL, NULL, NULL); 		    } 		    goto skip_ns; 		}                 if (attname == ctxt->str_xmlns) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""redefinition of the xmlns prefix is forbidden\n"", 			     NULL, NULL, NULL); 		    goto skip_ns; 		} 		if ((len == 29) && 		    (xmlStrEqual(URL, 		                 BAD_CAST ""http://www.w3.org/2000/xmlns/""))) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""reuse of the xmlns namespace name is forbidden\n"", 			     NULL, NULL, NULL); 		    goto skip_ns; 		} 		if ((URL == NULL) || (URL[0] == 0)) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 		             ""xmlns:%s: Empty XML namespace is not allowed\n"", 			          attname, NULL, NULL); 		    goto skip_ns; 		} else { 		    uri = xmlParseURI((const char *) URL); 		    if (uri == NULL) { 			xmlNsErr(ctxt, XML_WAR_NS_URI, 			     ""xmlns:%s: '%s' is not a valid URI\n"", 					   attname, URL, NULL); 		    } else { 			if ((ctxt->pedantic) && (uri->scheme == NULL)) { 			    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, 				      ""xmlns:%s: URI %s is not absolute\n"", 				      attname, URL, NULL); 			} 			xmlFreeURI(uri); 		    } 		}  		/* 		 * check that it's not a defined namespace 		 */ 		for (j = 1;j <= nbNs;j++) 		    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) 			break; 		if (j <= nbNs) 		    xmlErrAttributeDup(ctxt, aprefix, attname); 		else 		    if (nsPush(ctxt, attname, URL) > 0) nbNs++; skip_ns: 		if (alloc != 0) xmlFree(attvalue); 		if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 		    break; 		if (!IS_BLANK_CH(RAW)) { 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 				   ""attributes construct error\n""); 		    break; 		} 		SKIP_BLANKS; 		if (ctxt->input->base != base) goto base_changed; 		continue; 	    }  	    /* 	     * Add the pair to atts 	     */ 	    if ((atts == NULL) || (nbatts + 5 > maxatts)) { 	        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { 		    if (attvalue[len] == 0) 			xmlFree(attvalue); 		    goto failed; 		} 	        maxatts = ctxt->maxatts; 		atts = ctxt->atts; 	    } 	    ctxt->attallocs[nratts++] = alloc; 	    atts[nbatts++] = attname; 	    atts[nbatts++] = aprefix; 	    atts[nbatts++] = NULL; /* the URI will be fetched later */ 	    atts[nbatts++] = attvalue; 	    attvalue += len; 	    atts[nbatts++] = attvalue; 	    /* 	     * tag if some deallocation is needed 	     */ 	    if (alloc != 0) attval = 1; 	} else { 	    if ((attvalue != NULL) && (attvalue[len] == 0)) 		xmlFree(attvalue); 	}  failed:  	GROW         if (ctxt->instate == XML_PARSER_EOF)             break; 	if (ctxt->input->base != base) goto base_changed; 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 	    break; 	if (!IS_BLANK_CH(RAW)) { 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 			   ""attributes construct error\n""); 	    break; 	} 	SKIP_BLANKS;         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&             (attname == NULL) && (attvalue == NULL)) { 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, 	         ""xmlParseStartTag: problem parsing attributes\n""); 	    break; 	}         GROW; 	if (ctxt->input->base != base) goto base_changed;     }      /*      * The attributes defaulting      */     if (ctxt->attsDefault != NULL) {         xmlDefAttrsPtr defaults;  	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix); 	if (defaults != NULL) { 	    for (i = 0;i < defaults->nbAttrs;i++) { 	        attname = defaults->values[5 * i]; 		aprefix = defaults->values[5 * i + 1];                  /* 		 * special work for namespaces defaulted defs 		 */ 		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { 		    /* 		     * check that it's not a defined namespace 		     */ 		    for (j = 1;j <= nbNs;j++) 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) 			    break; 	            if (j <= nbNs) continue;  		    nsname = xmlGetNamespace(ctxt, NULL); 		    if (nsname != defaults->values[5 * i + 2]) { 			if (nsPush(ctxt, NULL, 			           defaults->values[5 * i + 2]) > 0) 			    nbNs++; 		    } 		} else if (aprefix == ctxt->str_xmlns) { 		    /* 		     * check that it's not a defined namespace 		     */ 		    for (j = 1;j <= nbNs;j++) 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) 			    break; 	            if (j <= nbNs) continue;  		    nsname = xmlGetNamespace(ctxt, attname); 		    if (nsname != defaults->values[2]) { 			if (nsPush(ctxt, attname, 			           defaults->values[5 * i + 2]) > 0) 			    nbNs++; 		    } 		} else { 		    /* 		     * check that it's not a defined attribute 		     */ 		    for (j = 0;j < nbatts;j+=5) { 			if ((attname == atts[j]) && (aprefix == atts[j+1])) 			    break; 		    } 		    if (j < nbatts) continue;  		    if ((atts == NULL) || (nbatts + 5 > maxatts)) { 			if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { 			    return(NULL); 			} 			maxatts = ctxt->maxatts; 			atts = ctxt->atts; 		    } 		    atts[nbatts++] = attname; 		    atts[nbatts++] = aprefix; 		    if (aprefix == NULL) 			atts[nbatts++] = NULL; 		    else 		        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix); 		    atts[nbatts++] = defaults->values[5 * i + 2]; 		    atts[nbatts++] = defaults->values[5 * i + 3]; 		    if ((ctxt->standalone == 1) && 		        (defaults->values[5 * i + 4] != NULL)) { 			xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED, 	  ""standalone: attribute %s on %s defaulted from external subset\n"", 	                                 attname, localname); 		    } 		    nbdef++; 		} 	    } 	}     }      /*      * The attributes checkings      */     for (i = 0; i < nbatts;i += 5) {         /* 	* The default namespace does not apply to attribute names. 	*/ 	if (atts[i + 1] != NULL) { 	    nsname = xmlGetNamespace(ctxt, atts[i + 1]); 	    if (nsname == NULL) { 		xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, 		    ""Namespace prefix %s for %s on %s is not defined\n"", 		    atts[i + 1], atts[i], localname); 	    } 	    atts[i + 2] = nsname; 	} else 	    nsname = NULL; 	/* 	 * [ WFC: Unique Att Spec ] 	 * No attribute name may appear more than once in the same 	 * start-tag or empty-element tag. 	 * As extended by the Namespace in XML REC. 	 */         for (j = 0; j < i;j += 5) { 	    if (atts[i] == atts[j]) { 	        if (atts[i+1] == atts[j+1]) { 		    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]); 		    break; 		} 		if ((nsname != NULL) && (atts[j + 2] == nsname)) { 		    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED, 			     ""Namespaced Attribute %s in '%s' redefined\n"", 			     atts[i], nsname, NULL); 		    break; 		} 	    } 	}     }      nsname = xmlGetNamespace(ctxt, prefix);     if ((prefix != NULL) && (nsname == NULL)) { 	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, 	         ""Namespace prefix %s on %s is not defined\n"", 		 prefix, localname, NULL);     }     *pref = prefix;     *URI = nsname;      /*      * SAX: Start of Element !      */     if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) && 	(!ctxt->disableSAX)) { 	if (nbNs > 0) 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, 			  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs], 			  nbatts / 5, nbdef, atts); 	else 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, 	                  nsname, 0, NULL, nbatts / 5, nbdef, atts);     }      /*      * Free up attribute allocated strings if needed      */     if (attval != 0) { 	for (i = 3,j = 0; j < nratts;i += 5,j++) 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) 	        xmlFree((xmlChar *) atts[i]);     }      return(localname);  base_changed:     /*      * the attribute strings are valid iif the base didn't changed      */     if (attval != 0) { 	for (i = 3,j = 0; j < nratts;i += 5,j++) 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) 	        xmlFree((xmlChar *) atts[i]);     }     ctxt->input->cur = ctxt->input->base + cur;     ctxt->input->line = oldline;     ctxt->input->col = oldcol;     if (ctxt->wellFormed == 1) { 	goto reparse;     }     return(NULL); }"
"209102_CWE-703.c","CWE-703","do_mouse(     oparg_T	*oap,		// operator argument, can be NULL     int		c,		// K_LEFTMOUSE, etc     int		dir,		// Direction to 'put' if necessary     long	count,     int		fixindent)	// PUT_FIXINDENT if fixing indent necessary {     static int	do_always = FALSE;	// ignore 'mouse' setting next time     static int	got_click = FALSE;	// got a click some time back      int		which_button;	// MOUSE_LEFT, _MIDDLE or _RIGHT     int		is_click = FALSE; // If FALSE it's a drag or release event     int		is_drag = FALSE;  // If TRUE it's a drag event     int		jump_flags = 0;	// flags for jump_to_mouse()     pos_T	start_visual;     int		moved;		// Has cursor moved?     int		in_status_line;	// mouse in status line     static int	in_tab_line = FALSE; // mouse clicked in tab line     int		in_sep_line;	// mouse in vertical separator line     int		c1, c2; #if defined(FEAT_FOLDING)     pos_T	save_cursor; #endif     win_T	*old_curwin = curwin;     static pos_T orig_cursor;     colnr_T	leftcol, rightcol;     pos_T	end_visual;     int		diff;     int		old_active = VIsual_active;     int		old_mode = VIsual_mode;     int		regname;  #if defined(FEAT_FOLDING)     save_cursor = curwin->w_cursor; #endif      // When GUI is active, always recognize mouse events, otherwise:     // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.     // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.     // - For command line and insert mode 'mouse' is checked before calling     //	 do_mouse().     if (do_always) 	do_always = FALSE;     else #ifdef FEAT_GUI 	if (!gui.in_use) #endif 	{ 	    if (VIsual_active) 	    { 		if (!mouse_has(MOUSE_VISUAL)) 		    return FALSE; 	    } 	    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL)) 		return FALSE; 	}      for (;;)     { 	which_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag); 	if (is_drag) 	{ 	    // If the next character is the same mouse event then use that 	    // one. Speeds up dragging the status line. 	    // Note: Since characters added to the stuff buffer in the code 	    // below need to come before the next character, do not do this 	    // when the current character was stuffed. 	    if (!KeyStuffed && vpeekc() != NUL) 	    { 		int nc; 		int save_mouse_row = mouse_row; 		int save_mouse_col = mouse_col;  		// Need to get the character, peeking doesn't get the actual 		// one. 		nc = safe_vgetc(); 		if (c == nc) 		    continue; 		vungetc(nc); 		mouse_row = save_mouse_row; 		mouse_col = save_mouse_col; 	    } 	} 	break;     }      if (c == K_MOUSEMOVE)     { 	// Mouse moved without a button pressed. #ifdef FEAT_BEVAL_TERM 	ui_may_remove_balloon(); 	if (p_bevalterm) 	{ 	    profile_setlimit(p_bdlay, &bevalexpr_due); 	    bevalexpr_due_set = TRUE; 	} #endif #ifdef FEAT_PROP_POPUP 	popup_handle_mouse_moved(); #endif 	return FALSE;     }  #ifdef FEAT_MOUSESHAPE     // May have stopped dragging the status or separator line.  The pointer is     // most likely still on the status or separator line.     if (!is_drag && drag_status_line)     { 	drag_status_line = FALSE; 	update_mouseshape(SHAPE_IDX_STATUS);     }     if (!is_drag && drag_sep_line)     { 	drag_sep_line = FALSE; 	update_mouseshape(SHAPE_IDX_VSEP);     } #endif      // Ignore drag and release events if we didn't get a click.     if (is_click) 	got_click = TRUE;     else     { 	if (!got_click)			// didn't get click, ignore 	    return FALSE; 	if (!is_drag)			// release, reset got_click 	{ 	    got_click = FALSE; 	    if (in_tab_line) 	    { 		in_tab_line = FALSE; 		return FALSE; 	    } 	}     }      // CTRL right mouse button does CTRL-T     if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)     { 	if (State & MODE_INSERT) 	    stuffcharReadbuff(Ctrl_O); 	if (count > 1) 	    stuffnumReadbuff(count); 	stuffcharReadbuff(Ctrl_T); 	got_click = FALSE;		// ignore drag&release now 	return FALSE;     }      // CTRL only works with left mouse button     if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT) 	return FALSE;      // When a modifier is down, ignore drag and release events, as well as     // multiple clicks and the middle mouse button.     // Accept shift-leftmouse drags when 'mousemodel' is ""popup.*"".     if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT 							     | MOD_MASK_META)) 	    && (!is_click 		|| (mod_mask & MOD_MASK_MULTI_CLICK) 		|| which_button == MOUSE_MIDDLE) 	    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)) 		&& mouse_model_popup() 		&& which_button == MOUSE_LEFT) 	    && !((mod_mask & MOD_MASK_ALT) 		&& !mouse_model_popup() 		&& which_button == MOUSE_RIGHT) 	    ) 	return FALSE;      // If the button press was used as the movement command for an operator     // (eg ""d<MOUSE>""), or it is the middle button that is held down, ignore     // drag/release events.     if (!is_click && which_button == MOUSE_MIDDLE) 	return FALSE;      if (oap != NULL) 	regname = oap->regname;     else 	regname = 0;      // Middle mouse button does a 'put' of the selected text     if (which_button == MOUSE_MIDDLE)     { 	if (State == MODE_NORMAL) 	{ 	    // If an operator was pending, we don't know what the user wanted 	    // to do. Go back to normal mode: Clear the operator and beep(). 	    if (oap != NULL && oap->op_type != OP_NOP) 	    { 		clearopbeep(oap); 		return FALSE; 	    }  	    // If visual was active, yank the highlighted text and put it 	    // before the mouse pointer position. 	    // In Select mode replace the highlighted text with the clipboard. 	    if (VIsual_active) 	    { 		if (VIsual_select) 		{ 		    stuffcharReadbuff(Ctrl_G); 		    stuffReadbuff((char_u *)""\""+p""); 		} 		else 		{ 		    stuffcharReadbuff('y'); 		    stuffcharReadbuff(K_MIDDLEMOUSE); 		} 		do_always = TRUE;	// ignore 'mouse' setting next time 		return FALSE; 	    } 	    // The rest is below jump_to_mouse() 	}  	else if ((State & MODE_INSERT) == 0) 	    return FALSE;  	// Middle click in insert mode doesn't move the mouse, just insert the 	// contents of a register.  '.' register is special, can't insert that 	// with do_put(). 	// Also paste at the cursor if the current mode isn't in 'mouse' (only 	// happens for the GUI). 	if ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL)) 	{ 	    if (regname == '.') 		insert_reg(regname, TRUE); 	    else 	    { #ifdef FEAT_CLIPBOARD 		if (clip_star.available && regname == 0) 		    regname = '*'; #endif 		if ((State & REPLACE_FLAG) && !yank_register_mline(regname)) 		    insert_reg(regname, TRUE); 		else 		{ 		    do_put(regname, NULL, BACKWARD, 1L, 						      fixindent | PUT_CURSEND);  		    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r 		    AppendCharToRedobuff(Ctrl_R); 		    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O); 		    AppendCharToRedobuff(regname == 0 ? '""' : regname); 		} 	    } 	    return FALSE; 	}     }      // When dragging or button-up stay in the same window.     if (!is_click) 	jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;      start_visual.lnum = 0;      // Check for clicking in the tab page line.     if (mouse_row == 0 && firstwin->w_winrow > 0)     { 	if (is_drag) 	{ 	    if (in_tab_line) 	    { 		c1 = TabPageIdxs[mouse_col]; 		tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab) 								? c1 - 1 : c1); 	    } 	    return FALSE; 	}  	// click in a tab selects that tab page 	if (is_click # ifdef FEAT_CMDWIN 		&& cmdwin_type == 0 # endif 		&& mouse_col < Columns) 	{ 	    in_tab_line = TRUE; 	    c1 = TabPageIdxs[mouse_col]; 	    if (c1 >= 0) 	    { 		if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) 		{ 		    // double click opens new page 		    end_visual_mode_keep_button(); 		    tabpage_new(); 		    tabpage_move(c1 == 0 ? 9999 : c1 - 1); 		} 		else 		{ 		    // Go to specified tab page, or next one if not clicking 		    // on a label. 		    goto_tabpage(c1);  		    // It's like clicking on the status line of a window. 		    if (curwin != old_curwin) 			end_visual_mode_keep_button(); 		} 	    } 	    else 	    { 		tabpage_T	*tp;  		// Close the current or specified tab page. 		if (c1 == -999) 		    tp = curtab; 		else 		    tp = find_tabpage(-c1); 		if (tp == curtab) 		{ 		    if (first_tabpage->tp_next != NULL) 			tabpage_close(FALSE); 		} 		else if (tp != NULL) 		    tabpage_close_other(tp, FALSE); 	    } 	} 	return TRUE;     }     else if (is_drag && in_tab_line)     { 	c1 = TabPageIdxs[mouse_col]; 	tabpage_move(c1 <= 0 ? 9999 : c1 - 1); 	return FALSE;     }      // When 'mousemodel' is ""popup"" or ""popup_setpos"", translate mouse events:     // right button up   -> pop-up menu     // shift-left button -> right button     // alt-left button   -> alt-right button     if (mouse_model_popup())     { 	if (which_button == MOUSE_RIGHT 			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))) 	{ #ifdef USE_POPUP_SETPOS # ifdef FEAT_GUI 	    if (gui.in_use) 	    { #  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \ 			  || defined(FEAT_GUI_PHOTON) 		if (!is_click) 		    // Ignore right button release events, only shows the popup 		    // menu on the button down event. 		    return FALSE; #  endif #  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU) 		if (is_click || is_drag) 		    // Ignore right button down and drag mouse events.  Windows 		    // only shows the popup menu on the button up event. 		    return FALSE; #  endif 	    } # endif # if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU) 	    else # endif # if defined(FEAT_TERM_POPUP_MENU) 	    if (!is_click) 		// Ignore right button release events, only shows the popup 		// menu on the button down event. 		return FALSE; #endif  	    jump_flags = 0; 	    if (STRCMP(p_mousem, ""popup_setpos"") == 0) 	    { 		// First set the cursor position before showing the popup 		// menu. 		if (VIsual_active) 		{ 		    pos_T    m_pos;  		    // set MOUSE_MAY_STOP_VIS if we are outside the 		    // selection or the current window (might have false 		    // negative here) 		    if (mouse_row < curwin->w_winrow 			 || mouse_row 				  > (curwin->w_winrow + curwin->w_height)) 			jump_flags = MOUSE_MAY_STOP_VIS; 		    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER) 			jump_flags = MOUSE_MAY_STOP_VIS; 		    else 		    { 			if ((LT_POS(curwin->w_cursor, VIsual) 				    && (LT_POS(m_pos, curwin->w_cursor) 					|| LT_POS(VIsual, m_pos))) 				|| (LT_POS(VIsual, curwin->w_cursor) 				    && (LT_POS(m_pos, VIsual) 				      || LT_POS(curwin->w_cursor, m_pos)))) 			{ 			    jump_flags = MOUSE_MAY_STOP_VIS; 			} 			else if (VIsual_mode == Ctrl_V) 			{ 			    getvcols(curwin, &curwin->w_cursor, &VIsual, 						     &leftcol, &rightcol); 			    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL); 			    if (m_pos.col < leftcol || m_pos.col > rightcol) 				jump_flags = MOUSE_MAY_STOP_VIS; 			} 		    } 		} 		else 		    jump_flags = MOUSE_MAY_STOP_VIS; 	    } 	    if (jump_flags) 	    { 		jump_flags = jump_to_mouse(jump_flags, NULL, which_button); 		update_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID); 		setcursor(); 		out_flush();    // Update before showing popup menu 	    } # ifdef FEAT_MENU 	    show_popupmenu(); 	    got_click = FALSE;	// ignore release events # endif 	    return (jump_flags & CURSOR_MOVED) != 0; #else 	    return FALSE; #endif 	} 	if (which_button == MOUSE_LEFT 				&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))) 	{ 	    which_button = MOUSE_RIGHT; 	    mod_mask &= ~MOD_MASK_SHIFT; 	}     }      if ((State & (MODE_NORMAL | MODE_INSERT)) 			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))     { 	if (which_button == MOUSE_LEFT) 	{ 	    if (is_click) 	    { 		// stop Visual mode for a left click in a window, but not when 		// on a status line 		if (VIsual_active) 		    jump_flags |= MOUSE_MAY_STOP_VIS; 	    } 	    else if (mouse_has(MOUSE_VISUAL)) 		jump_flags |= MOUSE_MAY_VIS; 	} 	else if (which_button == MOUSE_RIGHT) 	{ 	    if (is_click && VIsual_active) 	    { 		// Remember the start and end of visual before moving the 		// cursor. 		if (LT_POS(curwin->w_cursor, VIsual)) 		{ 		    start_visual = curwin->w_cursor; 		    end_visual = VIsual; 		} 		else 		{ 		    start_visual = VIsual; 		    end_visual = curwin->w_cursor; 		} 	    } 	    jump_flags |= MOUSE_FOCUS; 	    if (mouse_has(MOUSE_VISUAL)) 		jump_flags |= MOUSE_MAY_VIS; 	}     }      // If an operator is pending, ignore all drags and releases until the     // next mouse click.     if (!is_drag && oap != NULL && oap->op_type != OP_NOP)     { 	got_click = FALSE; 	oap->motion_type = MCHAR;     }      // When releasing the button let jump_to_mouse() know.     if (!is_click && !is_drag) 	jump_flags |= MOUSE_RELEASED;      // JUMP!     jump_flags = jump_to_mouse(jump_flags, 			oap == NULL ? NULL : &(oap->inclusive), which_button);  #ifdef FEAT_MENU     // A click in the window toolbar has no side effects.     if (jump_flags & MOUSE_WINBAR) 	return FALSE; #endif     moved = (jump_flags & CURSOR_MOVED);     in_status_line = (jump_flags & IN_STATUS_LINE);     in_sep_line = (jump_flags & IN_SEP_LINE);  #ifdef FEAT_NETBEANS_INTG     if (isNetbeansBuffer(curbuf) 			    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))     { 	int key = KEY2TERMCAP1(c);  	if (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE 					       || key == (int)KE_RIGHTRELEASE) 	    netbeans_button_release(which_button);     } #endif      // When jumping to another window, clear a pending operator.  That's a bit     // friendlier than beeping and not jumping to that window.     if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP) 	clearop(oap);  #ifdef FEAT_FOLDING     if (mod_mask == 0 	    && !is_drag 	    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN)) 	    && which_button == MOUSE_LEFT)     { 	// open or close a fold at this line 	if (jump_flags & MOUSE_FOLD_OPEN) 	    openFold(curwin->w_cursor.lnum, 1L); 	else 	    closeFold(curwin->w_cursor.lnum, 1L); 	// don't move the cursor if still in the same window 	if (curwin == old_curwin) 	    curwin->w_cursor = save_cursor;     } #endif  #if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)     if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)     { 	clip_modeless(which_button, is_click, is_drag); 	return FALSE;     } #endif      // Set global flag that we are extending the Visual area with mouse     // dragging; temporarily minimize 'scrolloff'.     if (VIsual_active && is_drag && get_scrolloff_value())     { 	// In the very first line, allow scrolling one line 	if (mouse_row == 0) 	    mouse_dragging = 2; 	else 	    mouse_dragging = 1;     }      // When dragging the mouse above the window, scroll down.     if (is_drag && mouse_row < 0 && !in_status_line)     { 	scroll_redraw(FALSE, 1L); 	mouse_row = 0;     }      if (start_visual.lnum)		// right click in visual mode     {        // When ALT is pressed make Visual mode blockwise.        if (mod_mask & MOD_MASK_ALT) 	   VIsual_mode = Ctrl_V;  	// In Visual-block mode, divide the area in four, pick up the corner 	// that is in the quarter that the cursor is in. 	if (VIsual_mode == Ctrl_V) 	{ 	    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol); 	    if (curwin->w_curswant > (leftcol + rightcol) / 2) 		end_visual.col = leftcol; 	    else 		end_visual.col = rightcol; 	    if (curwin->w_cursor.lnum >= 				    (start_visual.lnum + end_visual.lnum) / 2) 		end_visual.lnum = start_visual.lnum;  	    // move VIsual to the right column 	    start_visual = curwin->w_cursor;	    // save the cursor pos 	    curwin->w_cursor = end_visual; 	    coladvance(end_visual.col); 	    VIsual = curwin->w_cursor; 	    curwin->w_cursor = start_visual;	    // restore the cursor 	} 	else 	{ 	    // If the click is before the start of visual, change the start. 	    // If the click is after the end of visual, change the end.  If 	    // the click is inside the visual, change the closest side. 	    if (LT_POS(curwin->w_cursor, start_visual)) 		VIsual = end_visual; 	    else if (LT_POS(end_visual, curwin->w_cursor)) 		VIsual = start_visual; 	    else 	    { 		// In the same line, compare column number 		if (end_visual.lnum == start_visual.lnum) 		{ 		    if (curwin->w_cursor.col - start_visual.col > 				    end_visual.col - curwin->w_cursor.col) 			VIsual = start_visual; 		    else 			VIsual = end_visual; 		}  		// In different lines, compare line number 		else 		{ 		    diff = (curwin->w_cursor.lnum - start_visual.lnum) - 				(end_visual.lnum - curwin->w_cursor.lnum);  		    if (diff > 0)		// closest to end 			VIsual = start_visual; 		    else if (diff < 0)	// closest to start 			VIsual = end_visual; 		    else			// in the middle line 		    { 			if (curwin->w_cursor.col < 					(start_visual.col + end_visual.col) / 2) 			    VIsual = end_visual; 			else 			    VIsual = start_visual; 		    } 		} 	    } 	}     }     // If Visual mode started in insert mode, execute ""CTRL-O""     else if ((State & MODE_INSERT) && VIsual_active) 	stuffcharReadbuff(Ctrl_O);      // Middle mouse click: Put text before cursor.     if (which_button == MOUSE_MIDDLE)     { #ifdef FEAT_CLIPBOARD 	if (clip_star.available && regname == 0) 	    regname = '*'; #endif 	if (yank_register_mline(regname)) 	{ 	    if (mouse_past_bottom) 		dir = FORWARD; 	} 	else if (mouse_past_eol) 	    dir = FORWARD;  	if (fixindent) 	{ 	    c1 = (dir == BACKWARD) ? '[' : ']'; 	    c2 = 'p'; 	} 	else 	{ 	    c1 = (dir == FORWARD) ? 'p' : 'P'; 	    c2 = NUL; 	} 	prep_redo(regname, count, NUL, c1, NUL, c2, NUL);  	// Remember where the paste started, so in edit() Insstart can be set 	// to this position 	if (restart_edit != 0) 	    where_paste_started = curwin->w_cursor; 	do_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);     }  #if defined(FEAT_QUICKFIX)     // Ctrl-Mouse click or double click in a quickfix window jumps to the     // error under the mouse pointer.     else if (((mod_mask & MOD_MASK_CTRL) 		|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) 	    && bt_quickfix(curbuf))     { 	if (curwin->w_llist_ref == NULL)	// quickfix window 	    do_cmdline_cmd((char_u *)"".cc""); 	else					// location list window 	    do_cmdline_cmd((char_u *)"".ll""); 	got_click = FALSE;		// ignore drag&release now     } #endif      // Ctrl-Mouse click (or double click in a help window) jumps to the tag     // under the mouse pointer.     else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help 		     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))     { 	if (State & MODE_INSERT) 	    stuffcharReadbuff(Ctrl_O); 	stuffcharReadbuff(Ctrl_RSB); 	got_click = FALSE;		// ignore drag&release now     }      // Shift-Mouse click searches for the next occurrence of the word under     // the mouse pointer     else if ((mod_mask & MOD_MASK_SHIFT))     { 	if ((State & MODE_INSERT) || (VIsual_active && VIsual_select)) 	    stuffcharReadbuff(Ctrl_O); 	if (which_button == MOUSE_LEFT) 	    stuffcharReadbuff('*'); 	else	// MOUSE_RIGHT 	    stuffcharReadbuff('#');     }      // Handle double clicks, unless on status line     else if (in_status_line)     { #ifdef FEAT_MOUSESHAPE 	if ((is_drag || is_click) && !drag_status_line) 	{ 	    drag_status_line = TRUE; 	    update_mouseshape(-1); 	} #endif     }     else if (in_sep_line)     { #ifdef FEAT_MOUSESHAPE 	if ((is_drag || is_click) && !drag_sep_line) 	{ 	    drag_sep_line = TRUE; 	    update_mouseshape(-1); 	} #endif     }     else if ((mod_mask & MOD_MASK_MULTI_CLICK) 				       && (State & (MODE_NORMAL | MODE_INSERT)) 	     && mouse_has(MOUSE_VISUAL))     { 	if (is_click || !VIsual_active) 	{ 	    if (VIsual_active) 		orig_cursor = VIsual; 	    else 	    { 		check_visual_highlight(); 		VIsual = curwin->w_cursor; 		orig_cursor = VIsual; 		VIsual_active = TRUE; 		VIsual_reselect = TRUE; 		// start Select mode if 'selectmode' contains ""mouse"" 		may_start_select('o'); 		setmouse(); 	    } 	    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) 	    { 		// Double click with ALT pressed makes it blockwise. 		if (mod_mask & MOD_MASK_ALT) 		    VIsual_mode = Ctrl_V; 		else 		    VIsual_mode = 'v'; 	    } 	    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK) 		VIsual_mode = 'V'; 	    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK) 		VIsual_mode = Ctrl_V; #ifdef FEAT_CLIPBOARD 	    // Make sure the clipboard gets updated.  Needed because start and 	    // end may still be the same, and the selection needs to be owned 	    clip_star.vmode = NUL; #endif 	} 	// A double click selects a word or a block. 	if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) 	{ 	    pos_T	*pos = NULL; 	    int		gc;  	    if (is_click) 	    { 		// If the character under the cursor (skipping white space) is 		// not a word character, try finding a match and select a (), 		// {}, [], #if/#endif, etc. block. 		end_visual = curwin->w_cursor; 		while (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc)) 		    inc(&end_visual); 		if (oap != NULL) 		    oap->motion_type = MCHAR; 		if (oap != NULL 			&& VIsual_mode == 'v' 			&& !vim_iswordc(gchar_pos(&end_visual)) 			&& EQUAL_POS(curwin->w_cursor, VIsual) 			&& (pos = findmatch(oap, NUL)) != NULL) 		{ 		    curwin->w_cursor = *pos; 		    if (oap->motion_type == MLINE) 			VIsual_mode = 'V'; 		    else if (*p_sel == 'e') 		    { 			if (LT_POS(curwin->w_cursor, VIsual)) 			    ++VIsual.col; 			else 			    ++curwin->w_cursor.col; 		    } 		} 	    }  	    if (pos == NULL && (is_click || is_drag)) 	    { 		// When not found a match or when dragging: extend to include 		// a word. 		if (LT_POS(curwin->w_cursor, orig_cursor)) 		{ 		    find_start_of_word(&curwin->w_cursor); 		    find_end_of_word(&VIsual); 		} 		else 		{ 		    find_start_of_word(&VIsual); 		    if (*p_sel == 'e' && *ml_get_cursor() != NUL) 			curwin->w_cursor.col += 					 (*mb_ptr2len)(ml_get_cursor()); 		    find_end_of_word(&curwin->w_cursor); 		} 	    } 	    curwin->w_set_curswant = TRUE; 	} 	if (is_click) 	    redraw_curbuf_later(UPD_INVERTED);	// update the inversion     }     else if (VIsual_active && !old_active)     { 	if (mod_mask & MOD_MASK_ALT) 	    VIsual_mode = Ctrl_V; 	else 	    VIsual_mode = 'v';     }      // If Visual mode changed show it later.     if ((!VIsual_active && old_active && mode_displayed) 	    || (VIsual_active && p_smd && msg_silent == 0 				 && (!old_active || VIsual_mode != old_mode))) 	redraw_cmdline = TRUE;      return moved; }"
"209106_CWE-416.c","CWE-416","static int ax25_release(struct socket *sock) { 	struct sock *sk = sock->sk; 	ax25_cb *ax25; 	ax25_dev *ax25_dev;  	if (sk == NULL) 		return 0;  	sock_hold(sk); 	lock_sock(sk); 	sock_orphan(sk); 	ax25 = sk_to_ax25(sk); 	ax25_dev = ax25->ax25_dev; 	if (ax25_dev) { 		dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker); 		ax25_dev_put(ax25_dev); 	}  	if (sk->sk_type == SOCK_SEQPACKET) { 		switch (ax25->state) { 		case AX25_STATE_0: 			release_sock(sk); 			ax25_disconnect(ax25, 0); 			lock_sock(sk); 			ax25_destroy_socket(ax25); 			break;  		case AX25_STATE_1: 		case AX25_STATE_2: 			ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND); 			release_sock(sk); 			ax25_disconnect(ax25, 0); 			lock_sock(sk); 			if (!sock_flag(ax25->sk, SOCK_DESTROY)) 				ax25_destroy_socket(ax25); 			break;  		case AX25_STATE_3: 		case AX25_STATE_4: 			ax25_clear_queues(ax25); 			ax25->n2count = 0;  			switch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) { 			case AX25_PROTO_STD_SIMPLEX: 			case AX25_PROTO_STD_DUPLEX: 				ax25_send_control(ax25, 						  AX25_DISC, 						  AX25_POLLON, 						  AX25_COMMAND); 				ax25_stop_t2timer(ax25); 				ax25_stop_t3timer(ax25); 				ax25_stop_idletimer(ax25); 				break; #ifdef CONFIG_AX25_DAMA_SLAVE 			case AX25_PROTO_DAMA_SLAVE: 				ax25_stop_t3timer(ax25); 				ax25_stop_idletimer(ax25); 				break; #endif 			} 			ax25_calculate_t1(ax25); 			ax25_start_t1timer(ax25); 			ax25->state = AX25_STATE_2; 			sk->sk_state                = TCP_CLOSE; 			sk->sk_shutdown            |= SEND_SHUTDOWN; 			sk->sk_state_change(sk); 			sock_set_flag(sk, SOCK_DESTROY); 			break;  		default: 			break; 		} 	} else { 		sk->sk_state     = TCP_CLOSE; 		sk->sk_shutdown |= SEND_SHUTDOWN; 		sk->sk_state_change(sk); 		ax25_destroy_socket(ax25); 	}  	sock->sk   = NULL; 	release_sock(sk); 	sock_put(sk);  	return 0; }"
"209801_CWE-476.c","CWE-476","void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) { 	minify = dominify; 	if (prog->type == AST_LIST) 		pstmlist(-1, prog); 	else { 		pstm(0, prog); 		nl(); 	} 	if (minify > 1) 		putchar('\n'); }"
"209802_CWE-122.c","CWE-122","get_address(     exarg_T	*eap UNUSED,     char_u	**ptr,     cmd_addr_T	addr_type,     int		skip,		// only skip the address, don't use it     int		silent,		// no errors or side effects     int		to_other_file,  // flag: may jump to other file     int		address_count UNUSED) // 1 for first address, >1 after comma {     int		c;     int		i;     long	n;     char_u	*cmd;     pos_T	pos;     pos_T	*fp;     linenr_T	lnum;     buf_T	*buf;      cmd = skipwhite(*ptr);     lnum = MAXLNUM;     do     { 	switch (*cmd) 	{ 	    case '.':			    // '.' - Cursor position 		++cmd; 		switch (addr_type) 		{ 		    case ADDR_LINES: 		    case ADDR_OTHER: 			lnum = curwin->w_cursor.lnum; 			break; 		    case ADDR_WINDOWS: 			lnum = CURRENT_WIN_NR; 			break; 		    case ADDR_ARGUMENTS: 			lnum = curwin->w_arg_idx + 1; 			break; 		    case ADDR_LOADED_BUFFERS: 		    case ADDR_BUFFERS: 			lnum = curbuf->b_fnum; 			break; 		    case ADDR_TABS: 			lnum = CURRENT_TAB_NR; 			break; 		    case ADDR_NONE: 		    case ADDR_TABS_RELATIVE: 		    case ADDR_UNSIGNED: 			addr_error(addr_type); 			cmd = NULL; 			goto error; 			break; 		    case ADDR_QUICKFIX: #ifdef FEAT_QUICKFIX 			lnum = qf_get_cur_idx(eap); #endif 			break; 		    case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX 			lnum = qf_get_cur_valid_idx(eap); #endif 			break; 		} 		break;  	    case '$':			    // '$' - last line 		++cmd; 		switch (addr_type) 		{ 		    case ADDR_LINES: 		    case ADDR_OTHER: 			lnum = curbuf->b_ml.ml_line_count; 			break; 		    case ADDR_WINDOWS: 			lnum = LAST_WIN_NR; 			break; 		    case ADDR_ARGUMENTS: 			lnum = ARGCOUNT; 			break; 		    case ADDR_LOADED_BUFFERS: 			buf = lastbuf; 			while (buf->b_ml.ml_mfp == NULL) 			{ 			    if (buf->b_prev == NULL) 				break; 			    buf = buf->b_prev; 			} 			lnum = buf->b_fnum; 			break; 		    case ADDR_BUFFERS: 			lnum = lastbuf->b_fnum; 			break; 		    case ADDR_TABS: 			lnum = LAST_TAB_NR; 			break; 		    case ADDR_NONE: 		    case ADDR_TABS_RELATIVE: 		    case ADDR_UNSIGNED: 			addr_error(addr_type); 			cmd = NULL; 			goto error; 			break; 		    case ADDR_QUICKFIX: #ifdef FEAT_QUICKFIX 			lnum = qf_get_size(eap); 			if (lnum == 0) 			    lnum = 1; #endif 			break; 		    case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX 			lnum = qf_get_valid_size(eap); 			if (lnum == 0) 			    lnum = 1; #endif 			break; 		} 		break;  	    case '\'':			    // ''' - mark 		if (*++cmd == NUL) 		{ 		    cmd = NULL; 		    goto error; 		} 		if (addr_type != ADDR_LINES) 		{ 		    addr_error(addr_type); 		    cmd = NULL; 		    goto error; 		} 		if (skip) 		    ++cmd; 		else 		{ 		    // Only accept a mark in another file when it is 		    // used by itself: "":'M"". 		    fp = getmark(*cmd, to_other_file && cmd[1] == NUL); 		    ++cmd; 		    if (fp == (pos_T *)-1) 			// Jumped to another file. 			lnum = curwin->w_cursor.lnum; 		    else 		    { 			if (check_mark(fp) == FAIL) 			{ 			    cmd = NULL; 			    goto error; 			} 			lnum = fp->lnum; 		    } 		} 		break;  	    case '/': 	    case '?':			// '/' or '?' - search 		c = *cmd++; 		if (addr_type != ADDR_LINES) 		{ 		    addr_error(addr_type); 		    cmd = NULL; 		    goto error; 		} 		if (skip)	// skip ""/pat/"" 		{ 		    cmd = skip_regexp(cmd, c, magic_isset()); 		    if (*cmd == c) 			++cmd; 		} 		else 		{ 		    int flags;  		    pos = curwin->w_cursor; // save curwin->w_cursor  		    // When '/' or '?' follows another address, start from 		    // there. 		    if (lnum != MAXLNUM) 			curwin->w_cursor.lnum = lnum;  		    // Start a forward search at the end of the line (unless 		    // before the first line). 		    // Start a backward search at the start of the line. 		    // This makes sure we never match in the current 		    // line, and can match anywhere in the 		    // next/previous line. 		    if (c == '/' && curwin->w_cursor.lnum > 0) 			curwin->w_cursor.col = MAXCOL; 		    else 			curwin->w_cursor.col = 0; 		    searchcmdlen = 0; 		    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG; 		    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) 		    { 			curwin->w_cursor = pos; 			cmd = NULL; 			goto error; 		    } 		    lnum = curwin->w_cursor.lnum; 		    curwin->w_cursor = pos; 		    // adjust command string pointer 		    cmd += searchcmdlen; 		} 		break;  	    case '\\':		    // ""\?"", ""\/"" or ""\&"", repeat search 		++cmd; 		if (addr_type != ADDR_LINES) 		{ 		    addr_error(addr_type); 		    cmd = NULL; 		    goto error; 		} 		if (*cmd == '&') 		    i = RE_SUBST; 		else if (*cmd == '?' || *cmd == '/') 		    i = RE_SEARCH; 		else 		{ 		    emsg(_(e_backslash_should_be_followed_by)); 		    cmd = NULL; 		    goto error; 		}  		if (!skip) 		{ 		    /* 		     * When search follows another address, start from 		     * there. 		     */ 		    if (lnum != MAXLNUM) 			pos.lnum = lnum; 		    else 			pos.lnum = curwin->w_cursor.lnum;  		    /* 		     * Start the search just like for the above 		     * do_search(). 		     */ 		    if (*cmd != '?') 			pos.col = MAXCOL; 		    else 			pos.col = 0; 		    pos.coladd = 0; 		    if (searchit(curwin, curbuf, &pos, NULL, 				*cmd == '?' ? BACKWARD : FORWARD, 				(char_u *)"""", 1L, SEARCH_MSG, i, NULL) != FAIL) 			lnum = pos.lnum; 		    else 		    { 			cmd = NULL; 			goto error; 		    } 		} 		++cmd; 		break;  	    default: 		if (VIM_ISDIGIT(*cmd))	// absolute line number 		    lnum = getdigits(&cmd); 	}  	for (;;) 	{ 	    cmd = skipwhite(cmd); 	    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd)) 		break;  	    if (lnum == MAXLNUM) 	    { 		switch (addr_type) 		{ 		    case ADDR_LINES: 		    case ADDR_OTHER: 			// ""+1"" is same as "".+1"" 			lnum = curwin->w_cursor.lnum; 			break; 		    case ADDR_WINDOWS: 			lnum = CURRENT_WIN_NR; 			break; 		    case ADDR_ARGUMENTS: 			lnum = curwin->w_arg_idx + 1; 			break; 		    case ADDR_LOADED_BUFFERS: 		    case ADDR_BUFFERS: 			lnum = curbuf->b_fnum; 			break; 		    case ADDR_TABS: 			lnum = CURRENT_TAB_NR; 			break; 		    case ADDR_TABS_RELATIVE: 			lnum = 1; 			break; 		    case ADDR_QUICKFIX: #ifdef FEAT_QUICKFIX 			lnum = qf_get_cur_idx(eap); #endif 			break; 		    case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX 			lnum = qf_get_cur_valid_idx(eap); #endif 			break; 		    case ADDR_NONE: 		    case ADDR_UNSIGNED: 			lnum = 0; 			break; 		} 	    }  	    if (VIM_ISDIGIT(*cmd)) 		i = '+';		// ""number"" is same as ""+number"" 	    else 		i = *cmd++; 	    if (!VIM_ISDIGIT(*cmd))	// '+' is '+1', but '+0' is not '+1' 		n = 1; 	    else 		n = getdigits(&cmd);  	    if (addr_type == ADDR_TABS_RELATIVE) 	    { 		emsg(_(e_invalid_range)); 		cmd = NULL; 		goto error; 	    } 	    else if (addr_type == ADDR_LOADED_BUFFERS 		    || addr_type == ADDR_BUFFERS) 		lnum = compute_buffer_local_count( 				    addr_type, lnum, (i == '-') ? -1 * n : n); 	    else 	    { #ifdef FEAT_FOLDING 		// Relative line addressing, need to adjust for folded lines 		// now, but only do it after the first address. 		if (addr_type == ADDR_LINES && (i == '-' || i == '+') 			&& address_count >= 2) 		    (void)hasFolding(lnum, NULL, &lnum); #endif 		if (i == '-') 		    lnum -= n; 		else 		    lnum += n; 	    } 	}     } while (*cmd == '/' || *cmd == '?');  error:     *ptr = cmd;     return lnum; }"
"209927_CWE-770.c","CWE-770","static void agent_connect(UdscsConnection *conn) {     struct agent_data *agent_data;     agent_data = g_new0(struct agent_data, 1);     GError *err = NULL;      if (session_info) {         PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);         if (err || pid_uid.pid <= 0) {             static const char msg[] = ""Could not get peer PID, disconnecting new client"";             if (err) {                 syslog(LOG_ERR, ""%s: %s"", msg, err->message);                 g_error_free(err);             } else {                 syslog(LOG_ERR, ""%s"", msg);             }             agent_data_destroy(agent_data);             udscs_server_destroy_connection(server, conn);             return;         }          agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);          uid_t session_uid = session_info_uid_for_session(session_info, agent_data->session);          /* Check that the UID of the PID did not change, this should be done after          * computing the session to avoid race conditions.          * This can happen as vdagent_connection_get_peer_pid_uid get information          * from the time of creating the socket, but the process in the meantime          * have been replaced */         if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid) ||             /* Check that the user launching the Agent is the same as session one              * or root user.              * This prevents session hijacks from other users. */             (pid_uid.uid != 0 && pid_uid.uid != session_uid)) {             syslog(LOG_ERR, ""UID mismatch: UID=%u PID=%u suid=%u"", pid_uid.uid,                    pid_uid.pid, session_uid);             agent_data_destroy(agent_data);             udscs_server_destroy_connection(server, conn);             return;         }     }      g_object_set_data_full(G_OBJECT(conn), ""agent_data"", agent_data,                            (GDestroyNotify) agent_data_destroy);     udscs_write(conn, VDAGENTD_VERSION, 0, 0,                 (uint8_t *)VERSION, strlen(VERSION) + 1);     update_active_session_connection(conn);      if (device_info) {         forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,                                       (uint8_t *) device_info, device_info_size);     } }"
"209931_CWE-190.c","CWE-190","static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,                                                     UINT32 x, UINT32 y, UINT32 width, UINT32 height) { 	VideoClientContextPriv* priv = video->priv; 	PresentationContext* ret = calloc(1, sizeof(*ret)); 	if (!ret) 		return NULL;  	ret->video = video; 	ret->PresentationId = PresentationId;  	ret->h264 = h264_context_new(FALSE); 	if (!ret->h264) 	{ 		WLog_ERR(TAG, ""unable to create a h264 context""); 		goto error_h264; 	} 	h264_context_reset(ret->h264, width, height);  	ret->currentSample = Stream_New(NULL, 4096); 	if (!ret->currentSample) 	{ 		WLog_ERR(TAG, ""unable to create current packet stream""); 		goto error_currentSample; 	}  	ret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4); 	if (!ret->surfaceData) 	{ 		WLog_ERR(TAG, ""unable to allocate surfaceData""); 		goto error_surfaceData; 	}  	ret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height); 	if (!ret->surface) 	{ 		WLog_ERR(TAG, ""unable to create surface""); 		goto error_surface; 	}  	ret->yuv = yuv_context_new(FALSE); 	if (!ret->yuv) 	{ 		WLog_ERR(TAG, ""unable to create YUV decoder""); 		goto error_yuv; 	}  	yuv_context_reset(ret->yuv, width, height); 	ret->refCounter = 1; 	return ret;  error_yuv: 	video->deleteSurface(video, ret->surface); error_surface: 	BufferPool_Return(priv->surfacePool, ret->surfaceData); error_surfaceData: 	Stream_Free(ret->currentSample, TRUE); error_currentSample: 	h264_context_free(ret->h264); error_h264: 	free(ret); 	return NULL; }"
"209955_CWE-476.c","CWE-476","struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev, 			       const struct pci_device_id *ent, 			       const struct iwl_cfg_trans_params *cfg_trans) { 	struct iwl_trans_pcie *trans_pcie; 	struct iwl_trans *trans; 	int ret, addr_size;  	ret = pcim_enable_device(pdev); 	if (ret) 		return ERR_PTR(ret);  	if (cfg_trans->gen2) 		trans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie), 					&pdev->dev, &trans_ops_pcie_gen2); 	else 		trans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie), 					&pdev->dev, &trans_ops_pcie);  	if (!trans) 		return ERR_PTR(-ENOMEM);  	trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);  	trans_pcie->trans = trans; 	trans_pcie->opmode_down = true; 	spin_lock_init(&trans_pcie->irq_lock); 	spin_lock_init(&trans_pcie->reg_lock); 	mutex_init(&trans_pcie->mutex); 	init_waitqueue_head(&trans_pcie->ucode_write_waitq); 	trans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page); 	if (!trans_pcie->tso_hdr_page) { 		ret = -ENOMEM; 		goto out_no_pci; 	} 	trans_pcie->debug_rfkill = -1;  	if (!cfg_trans->base_params->pcie_l1_allowed) { 		/* 		 * W/A - seems to solve weird behavior. We need to remove this 		 * if we don't want to stay in L1 all the time. This wastes a 		 * lot of power. 		 */ 		pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | 				       PCIE_LINK_STATE_L1 | 				       PCIE_LINK_STATE_CLKPM); 	}  	trans_pcie->def_rx_queue = 0;  	if (cfg_trans->use_tfh) { 		addr_size = 64; 		trans_pcie->max_tbs = IWL_TFH_NUM_TBS; 		trans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd); 	} else { 		addr_size = 36; 		trans_pcie->max_tbs = IWL_NUM_OF_TBS; 		trans_pcie->tfd_size = sizeof(struct iwl_tfd); 	} 	trans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);  	pci_set_master(pdev);  	ret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size)); 	if (!ret) 		ret = pci_set_consistent_dma_mask(pdev, 						  DMA_BIT_MASK(addr_size)); 	if (ret) { 		ret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32)); 		if (!ret) 			ret = pci_set_consistent_dma_mask(pdev, 							  DMA_BIT_MASK(32)); 		/* both attempts failed: */ 		if (ret) { 			dev_err(&pdev->dev, ""No suitable DMA available\n""); 			goto out_no_pci; 		} 	}  	ret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME); 	if (ret) { 		dev_err(&pdev->dev, ""pcim_iomap_regions_request_all failed\n""); 		goto out_no_pci; 	}  	trans_pcie->hw_base = pcim_iomap_table(pdev)[0]; 	if (!trans_pcie->hw_base) { 		dev_err(&pdev->dev, ""pcim_iomap_table failed\n""); 		ret = -ENODEV; 		goto out_no_pci; 	}  	/* We disable the RETRY_TIMEOUT register (0x41) to keep 	 * PCI Tx retries from interfering with C3 CPU state */ 	pci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);  	trans_pcie->pci_dev = pdev; 	iwl_disable_interrupts(trans);  	trans->hw_rev = iwl_read32(trans, CSR_HW_REV); 	if (trans->hw_rev == 0xffffffff) { 		dev_err(&pdev->dev, ""HW_REV=0xFFFFFFFF, PCI issues?\n""); 		ret = -EIO; 		goto out_no_pci; 	}  	/* 	 * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have 	 * changed, and now the revision step also includes bit 0-1 (no more 	 * ""dash"" value). To keep hw_rev backwards compatible - we'll store it 	 * in the old format. 	 */ 	if (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000) { 		trans->hw_rev = (trans->hw_rev & 0xfff0) | 				(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);  		ret = iwl_pcie_prepare_card_hw(trans); 		if (ret) { 			IWL_WARN(trans, ""Exit HW not ready\n""); 			goto out_no_pci; 		}  		/* 		 * in-order to recognize C step driver should read chip version 		 * id located at the AUX bus MISC address space. 		 */ 		ret = iwl_finish_nic_init(trans, cfg_trans); 		if (ret) 			goto out_no_pci;  	}  	IWL_DEBUG_INFO(trans, ""HW REV: 0x%0x\n"", trans->hw_rev);  	iwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans); 	trans->hw_id = (pdev->device << 16) + pdev->subsystem_device; 	snprintf(trans->hw_id_str, sizeof(trans->hw_id_str), 		 ""PCI ID: 0x%04X:0x%04X"", pdev->device, pdev->subsystem_device);  	/* Initialize the wait queue for commands */ 	init_waitqueue_head(&trans_pcie->wait_command_queue);  	init_waitqueue_head(&trans_pcie->sx_waitq);  	if (trans_pcie->msix_enabled) { 		ret = iwl_pcie_init_msix_handler(pdev, trans_pcie); 		if (ret) 			goto out_no_pci; 	 } else { 		ret = iwl_pcie_alloc_ict(trans); 		if (ret) 			goto out_no_pci;  		ret = devm_request_threaded_irq(&pdev->dev, pdev->irq, 						iwl_pcie_isr, 						iwl_pcie_irq_handler, 						IRQF_SHARED, DRV_NAME, trans); 		if (ret) { 			IWL_ERR(trans, ""Error allocating IRQ %d\n"", pdev->irq); 			goto out_free_ict; 		} 		trans_pcie->inta_mask = CSR_INI_SET_MASK; 	 }  	trans_pcie->rba.alloc_wq = alloc_workqueue(""rb_allocator"", 						   WQ_HIGHPRI | WQ_UNBOUND, 1); 	INIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);  #ifdef CONFIG_IWLWIFI_DEBUGFS 	trans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED; 	mutex_init(&trans_pcie->fw_mon_data.mutex); #endif  	return trans;  out_free_ict: 	iwl_pcie_free_ict(trans); out_no_pci: 	free_percpu(trans_pcie->tso_hdr_page); 	iwl_trans_free(trans); 	return ERR_PTR(ret); }"
"209968_CWE-772.c","CWE-772","static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len) {   char     temp[MaxTextExtent];    unsigned int     foundiptc,     tagsfound;    unsigned char     recnum,     dataset;    unsigned char     *readable,     *str;    ssize_t     tagindx,     taglen;    int     i,     tagcount = (int) (sizeof(tags) / sizeof(tag_spec));    int     c;    foundiptc = 0; /* found the IPTC-Header */   tagsfound = 0; /* number of tags found */    while (len > 0)   {     c = *s++; len--;     if (c == 0x1c)       foundiptc = 1;     else       {         if (foundiptc)           return -1;         else           continue;       }     /*       We found the 0x1c tag and now grab the dataset and record number tags.     */     c = *s++; len--;     if (len < 0) return -1;     dataset = (unsigned char) c;     c = *s++; len--;     if (len < 0) return -1;     recnum = (unsigned char) c;     /* try to match this record to one of the ones in our named table */     for (i=0; i< tagcount; i++)       if (tags[i].id == (short) recnum)         break;     if (i < tagcount)       readable=(unsigned char *) tags[i].name;     else       readable=(unsigned char *) """";     /*       We decode the length of the block that follows - ssize_t or short fmt.     */     c=(*s++);     len--;     if (len < 0)       return(-1);     if (c & (unsigned char) 0x80)       return(0);     else       {         s--;         len++;         taglen=readWordFromBuffer(&s, &len);       }     if (taglen < 0)       return(-1);     if (taglen > 65535)       return(-1);     /* make a buffer to hold the tag datand snag it from the input stream */     str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MaxTextExtent),       sizeof(*str));     if (str == (unsigned char *) NULL)       return 0;     for (tagindx=0; tagindx<taglen; tagindx++)     {       c = *s++; len--;       if (len < 0)         return(-1);       str[tagindx]=(unsigned char) c;     }     str[taglen]=0;      /* now finish up by formatting this binary data into ASCII equivalent */     if (strlen((char *)readable) > 0)       (void) FormatLocaleString(temp,MaxTextExtent,""%d#%d#%s="",         (unsigned int) dataset,(unsigned int) recnum, readable);     else       (void) FormatLocaleString(temp,MaxTextExtent,""%d#%d="",         (unsigned int) dataset,(unsigned int) recnum);     (void) WriteBlobString(ofile,temp);     formatString( ofile, (char *)str, taglen );     str=(unsigned char *) RelinquishMagickMemory(str);      tagsfound++;   }   return ((int) tagsfound); }"
"210050_CWE-125.c","CWE-125","static void singlevar (LexState *ls, expdesc *var) {   TString *varname = str_checkname(ls);   FuncState *fs = ls->fs;   singlevaraux(fs, varname, var, 1);   if (var->k == VVOID) {  /* global name? */     expdesc key;     singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */     lua_assert(var->k != VVOID);  /* this one must exist */     codestring(&key, varname);  /* key is variable name */     luaK_indexed(fs, var, &key);  /* env[varname] */   } }"
"210090_CWE-787.c","CWE-787","cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,     uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount) { 	const cdf_section_header_t *shp; 	cdf_section_header_t sh; 	const uint8_t *p, *q, *e; 	size_t i, o4, nelements, j, slen, left; 	cdf_property_info_t *inp;  	if (offs > UINT32_MAX / 4) { 		errno = EFTYPE; 		goto out; 	} 	shp = CAST(const cdf_section_header_t *, 	    cdf_offset(sst->sst_tab, offs)); 	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) 		goto out; 	sh.sh_len = CDF_TOLE4(shp->sh_len); 	if (sh.sh_len > CDF_SHLEN_LIMIT) { 		errno = EFTYPE; 		goto out; 	}  	if (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1) 		goto out;  	sh.sh_properties = CDF_TOLE4(shp->sh_properties); 	DPRINTF((""section len: %u properties %u\n"", sh.sh_len, 	    sh.sh_properties)); 	if (sh.sh_properties > CDF_PROP_LIMIT) 		goto out; 	inp = cdf_grow_info(info, maxcount, sh.sh_properties); 	if (inp == NULL) 		goto out; 	inp += *count; 	*count += sh.sh_properties; 	p = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh))); 	e = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len)); 	if (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) 		goto out;  	for (i = 0; i < sh.sh_properties; i++) { 		if ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL) 			goto out; 		inp[i].pi_id = CDF_GETUINT32(p, i << 1); 		left = CAST(size_t, e - q); 		if (left < sizeof(uint32_t)) { 			DPRINTF((""short info (no type)_\n"")); 			goto out; 		} 		inp[i].pi_type = CDF_GETUINT32(q, 0); 		DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%#x type=%#x offs=%#tx,%#x\n"", 		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs)); 		if (inp[i].pi_type & CDF_VECTOR) { 			if (left < sizeof(uint32_t) * 2) { 				DPRINTF((""missing CDF_VECTOR length\n"")); 				goto out; 			} 			nelements = CDF_GETUINT32(q, 1); 			if (nelements == 0) { 				DPRINTF((""CDF_VECTOR with nelements == 0\n"")); 				goto out; 			} 			slen = 2; 		} else { 			nelements = 1; 			slen = 1; 		} 		o4 = slen * sizeof(uint32_t); 		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) 			goto unknown; 		switch (inp[i].pi_type & CDF_TYPEMASK) { 		case CDF_NULL: 		case CDF_EMPTY: 			break; 		case CDF_SIGNED16: 			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t))) 				goto unknown; 			break; 		case CDF_SIGNED32: 		case CDF_BOOL: 		case CDF_UNSIGNED32: 		case CDF_FLOAT: 			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t))) 				goto unknown; 			break; 		case CDF_SIGNED64: 		case CDF_UNSIGNED64: 		case CDF_DOUBLE: 		case CDF_FILETIME: 			if (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t))) 				goto unknown; 			break; 		case CDF_LENGTH32_STRING: 		case CDF_LENGTH32_WSTRING: 			if (nelements > 1) { 				size_t nelem = inp - *info; 				inp = cdf_grow_info(info, maxcount, nelements); 				if (inp == NULL) 					goto out; 				inp += nelem; 			} 			DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"", 			    nelements)); 			for (j = 0; j < nelements && i < sh.sh_properties; 			    j++, i++) 			{ 				uint32_t l;  				if (o4 + sizeof(uint32_t) > left) 					goto out;  				l = CDF_GETUINT32(q, slen); 				o4 += sizeof(uint32_t); 				if (o4 + l > left) 					goto out;  				inp[i].pi_str.s_len = l; 				inp[i].pi_str.s_buf = CAST(const char *, 				    CAST(const void *, &q[o4]));  				DPRINTF((""o=%"" SIZE_T_FORMAT ""u l=%d(%"" 				    SIZE_T_FORMAT ""u), t=%"" SIZE_T_FORMAT 				    ""u s=%s\n"", o4, l, CDF_ROUND(l, sizeof(l)), 				    left, inp[i].pi_str.s_buf));  				if (l & 1) 					l++;  				slen += l >> 1; 				o4 = slen * sizeof(uint32_t); 			} 			i--; 			break; 		case CDF_CLIPBOARD: 			if (inp[i].pi_type & CDF_VECTOR) 				goto unknown; 			break; 		default: 		unknown: 			memset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val)); 			DPRINTF((""Don't know how to deal with %#x\n"", 			    inp[i].pi_type)); 			break; 		} 	} 	return 0; out: 	free(*info); 	*info = NULL; 	*count = 0; 	*maxcount = 0; 	errno = EFTYPE; 	return -1; }"
"210091_CWE-78.c","CWE-78","get_password(const char *prompt, char *input, int capacity) { #ifdef ENABLE_SYSTEMD 	int is_systemd_running; 	struct stat a, b;  	/* We simply test whether the systemd cgroup hierarchy is 	 * mounted */ 	is_systemd_running = (lstat(""/sys/fs/cgroup"", &a) == 0) 		&& (lstat(""/sys/fs/cgroup/systemd"", &b) == 0) 		&& (a.st_dev != b.st_dev);  	if (is_systemd_running) { 		char *cmd, *ret; 		FILE *ask_pass_fp = NULL;  		cmd = ret = NULL; 		if (asprintf(&cmd, ""systemd-ask-password \""%s\"""", prompt) >= 0) { 			ask_pass_fp = popen (cmd, ""re""); 			free (cmd); 		}  		if (ask_pass_fp) { 			ret = fgets(input, capacity, ask_pass_fp); 			pclose(ask_pass_fp); 		}  		if (ret) { 			int len = strlen(input); 			if (input[len - 1] == '\n') 				input[len - 1] = '\0'; 			return input; 		} 	} #endif  	/* 	 * Falling back to getpass(..) 	 * getpass is obsolete, but there's apparently nothing that replaces it 	 */ 	char *tmp_pass = getpass(prompt); 	if (!tmp_pass) 		return NULL;  	strncpy(input, tmp_pass, capacity - 1); 	input[capacity - 1] = '\0';  	/* zero-out the static buffer */ 	memset(tmp_pass, 0, strlen(tmp_pass));  	return input; }"
"210161_CWE-119.c","CWE-119","gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor) { 	const int angle_rounded = (int)floor(angle * 100);  	if (bgcolor < 0 || bgcolor >= gdMaxColors) { 		return NULL; 	}  	/* impact perf a bit, but not that much. Implementation for palette 	   images can be done at a later point. 	*/ 	if (src->trueColor == 0) { 		if (bgcolor >= 0) { 			bgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]); 		} 		gdImagePaletteToTrueColor(src); 	}  	/* no interpolation needed here */ 	switch (angle_rounded) { 		case 9000: 			return gdImageRotate90(src, 0); 		case 18000: 			return gdImageRotate180(src, 0); 		case 27000: 			return gdImageRotate270(src, 0); 	}  	if (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) { 		return NULL; 	}  	switch (src->interpolation_id) { 		case GD_NEAREST_NEIGHBOUR: 			return gdImageRotateNearestNeighbour(src, angle, bgcolor); 			break;  		case GD_BILINEAR_FIXED: 			return gdImageRotateBilinear(src, angle, bgcolor); 			break;  		case GD_BICUBIC_FIXED: 			return gdImageRotateBicubicFixed(src, angle, bgcolor); 			break;  		default: 			return gdImageRotateGeneric(src, angle, bgcolor); 	} 	return NULL; }"
"210203_CWE-787.c","CWE-787","static void *seq_buf_alloc(unsigned long size) { 	return kvmalloc(size, GFP_KERNEL_ACCOUNT); }"
"210204_CWE-362.c","CWE-362","static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa, 				       int attr_len, bool log) {  	struct sw_flow_actions *acts; 	int new_acts_size; 	size_t req_size = NLA_ALIGN(attr_len); 	int next_offset = offsetof(struct sw_flow_actions, actions) + 					(*sfa)->actions_len;  	if (req_size <= (ksize(*sfa) - next_offset)) 		goto out;  	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);  	if (new_acts_size > MAX_ACTIONS_BUFSIZE) { 		if ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) { 			OVS_NLERR(log, ""Flow action size exceeds max %u"", 				  MAX_ACTIONS_BUFSIZE); 			return ERR_PTR(-EMSGSIZE); 		} 		new_acts_size = MAX_ACTIONS_BUFSIZE; 	}  	acts = nla_alloc_flow_actions(new_acts_size); 	if (IS_ERR(acts)) 		return (void *)acts;  	memcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len); 	acts->actions_len = (*sfa)->actions_len; 	acts->orig_len = (*sfa)->orig_len; 	kfree(*sfa); 	*sfa = acts;  out: 	(*sfa)->actions_len += req_size; 	return  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset); }"
"210206_CWE-400.cc","CWE-400","gopherToHTML(GopherStateData * gopherState, char *inbuf, int len) {     char *pos = inbuf;     char *lpos = NULL;     char *tline = NULL;     LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);     LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);     char *name = NULL;     char *selector = NULL;     char *host = NULL;     char *port = NULL;     char *escaped_selector = NULL;     const char *icon_url = NULL;     char gtype;     StoreEntry *entry = NULL;      memset(tmpbuf, '\0', TEMP_BUF_SIZE);     memset(line, '\0', TEMP_BUF_SIZE);      entry = gopherState->entry;      if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {         char *html_url = html_quote(entry->url());         gopherHTMLHeader(entry, ""Gopher Index %s"", html_url);         storeAppendPrintf(entry,                           ""<p>This is a searchable Gopher index. Use the search\n""                           ""function of your browser to enter search terms.\n""                           ""<ISINDEX>\n"");         gopherHTMLFooter(entry);         /* now let start sending stuff to client */         entry->flush();         gopherState->HTML_header_added = 1;          return;     }      if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {         char *html_url = html_quote(entry->url());         gopherHTMLHeader(entry, ""CSO Search of %s"", html_url);         storeAppendPrintf(entry,                           ""<P>A CSO database usually contains a phonebook or\n""                           ""directory.  Use the search function of your browser to enter\n""                           ""search terms.</P><ISINDEX>\n"");         gopherHTMLFooter(entry);         /* now let start sending stuff to client */         entry->flush();         gopherState->HTML_header_added = 1;          return;     }      String outbuf;      if (!gopherState->HTML_header_added) {         if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)             gopherHTMLHeader(entry, ""CSO Search Result"", NULL);         else             gopherHTMLHeader(entry, ""Gopher Menu"", NULL);          outbuf.append (""<PRE>"");          gopherState->HTML_header_added = 1;          gopherState->HTML_pre = 1;     }      while (pos < inbuf + len) {         int llen;         int left = len - (pos - inbuf);         lpos = (char *)memchr(pos, '\n', left);         if (lpos) {             ++lpos;             /* Next line is after \n */             llen = lpos - pos;         } else {             llen = left;         }         if (gopherState->len + llen >= TEMP_BUF_SIZE) {             debugs(10, DBG_IMPORTANT, ""GopherHTML: Buffer overflow. Lost some data on URL: "" << entry->url()  );             llen = TEMP_BUF_SIZE - gopherState->len - 1;         }         if (!lpos) {             /* there is no complete line in inbuf */             /* copy it to temp buffer */             /* note: llen is adjusted above */             memcpy(gopherState->buf + gopherState->len, pos, llen);             gopherState->len += llen;             break;         }         if (gopherState->len != 0) {             /* there is something left from last tx. */             memcpy(line, gopherState->buf, gopherState->len);             memcpy(line + gopherState->len, pos, llen);             llen += gopherState->len;             gopherState->len = 0;         } else {             memcpy(line, pos, llen);         }         line[llen + 1] = '\0';         /* move input to next line */         pos = lpos;          /* at this point. We should have one line in buffer to process */          if (*line == '.') {             /* skip it */             memset(line, '\0', TEMP_BUF_SIZE);             continue;         }          switch (gopherState->conversion) {          case GopherStateData::HTML_INDEX_RESULT:          case GopherStateData::HTML_DIR: {             tline = line;             gtype = *tline;             ++tline;             name = tline;             selector = strchr(tline, TAB);              if (selector) {                 *selector = '\0';                 ++selector;                 host = strchr(selector, TAB);                  if (host) {                     *host = '\0';                     ++host;                     port = strchr(host, TAB);                      if (port) {                         char *junk;                         port[0] = ':';                         junk = strchr(host, TAB);                          if (junk)                             *junk++ = 0;    /* Chop port */                         else {                             junk = strchr(host, '\r');                              if (junk)                                 *junk++ = 0;    /* Chop port */                             else {                                 junk = strchr(host, '\n');                                  if (junk)                                     *junk++ = 0;    /* Chop port */                             }                         }                          if ((port[1] == '0') && (!port[2]))                             port[0] = 0;    /* 0 means none */                     }                      /* escape a selector here */                     escaped_selector = xstrdup(rfc1738_escape_part(selector));                      switch (gtype) {                      case GOPHER_DIRECTORY:                         icon_url = mimeGetIconURL(""internal-menu"");                         break;                      case GOPHER_HTML:                      case GOPHER_FILE:                         icon_url = mimeGetIconURL(""internal-text"");                         break;                      case GOPHER_INDEX:                      case GOPHER_CSO:                         icon_url = mimeGetIconURL(""internal-index"");                         break;                      case GOPHER_IMAGE:                      case GOPHER_GIF:                      case GOPHER_PLUS_IMAGE:                         icon_url = mimeGetIconURL(""internal-image"");                         break;                      case GOPHER_SOUND:                      case GOPHER_PLUS_SOUND:                         icon_url = mimeGetIconURL(""internal-sound"");                         break;                      case GOPHER_PLUS_MOVIE:                         icon_url = mimeGetIconURL(""internal-movie"");                         break;                      case GOPHER_TELNET:                      case GOPHER_3270:                         icon_url = mimeGetIconURL(""internal-telnet"");                         break;                      case GOPHER_BIN:                      case GOPHER_MACBINHEX:                      case GOPHER_DOSBIN:                      case GOPHER_UUENCODED:                         icon_url = mimeGetIconURL(""internal-binary"");                         break;                      case GOPHER_INFO:                         icon_url = NULL;                         break;                      default:                         icon_url = mimeGetIconURL(""internal-unknown"");                         break;                     }                      memset(tmpbuf, '\0', TEMP_BUF_SIZE);                      if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {                         if (strlen(escaped_selector) != 0)                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s@%s%s%s/\"">%s</A>\n"",                                      icon_url, escaped_selector, rfc1738_escape_part(host),                                      *port ? "":"" : """", port, html_quote(name));                         else                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""telnet://%s%s%s/\"">%s</A>\n"",                                      icon_url, rfc1738_escape_part(host), *port ? "":"" : """",                                      port, html_quote(name));                      } else if (gtype == GOPHER_INFO) {                         snprintf(tmpbuf, TEMP_BUF_SIZE, ""\t%s\n"", html_quote(name));                     } else {                         if (strncmp(selector, ""GET /"", 5) == 0) {                             /* WWW link */                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""http://%s/%s\"">%s</A>\n"",                                      icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));                         } else {                             /* Standard link */                             snprintf(tmpbuf, TEMP_BUF_SIZE, ""<IMG border=\""0\"" SRC=\""%s\""> <A HREF=\""gopher://%s/%c%s\"">%s</A>\n"",                                      icon_url, host, gtype, escaped_selector, html_quote(name));                         }                     }                      safe_free(escaped_selector);                     outbuf.append(tmpbuf);                 } else {                     memset(line, '\0', TEMP_BUF_SIZE);                     continue;                 }             } else {                 memset(line, '\0', TEMP_BUF_SIZE);                 continue;             }              break;             }           /* HTML_DIR, HTML_INDEX_RESULT */          case GopherStateData::HTML_CSO_RESULT: {             if (line[0] == '-') {                 int code, recno;                 char *s_code, *s_recno, *result;                  s_code = strtok(line + 1, "":\n"");                 s_recno = strtok(NULL, "":\n"");                 result = strtok(NULL, ""\n"");                  if (!result)                     break;                  code = atoi(s_code);                  recno = atoi(s_recno);                  if (code != 200)                     break;                  if (gopherState->cso_recno != recno) {                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>Record# %d<br><i>%s</i></H2>\n<PRE>"", recno, html_quote(result));                     gopherState->cso_recno = recno;                 } else {                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""%s\n"", html_quote(result));                 }                  outbuf.append(tmpbuf);                 break;             } else {                 int code;                 char *s_code, *result;                  s_code = strtok(line, "":"");                 result = strtok(NULL, ""\n"");                  if (!result)                     break;                  code = atoi(s_code);                  switch (code) {                  case 200: {                     /* OK */                     /* Do nothing here */                     break;                 }                  case 102:   /* Number of matches */                  case 501:   /* No Match */                  case 502: { /* Too Many Matches */                     /* Print the message the server returns */                     snprintf(tmpbuf, TEMP_BUF_SIZE, ""</PRE><HR noshade size=\""1px\""><H2>%s</H2>\n<PRE>"", html_quote(result));                     outbuf.append(tmpbuf);                     break;                 }                  }             }              }           /* HTML_CSO_RESULT */          default:             break;      /* do nothing */          }           /* switch */      }               /* while loop */      if (outbuf.size() > 0) {         entry->append(outbuf.rawBuf(), outbuf.size());         /* now let start sending stuff to client */         entry->flush();     }      outbuf.clean();     return; }"
"210223_CWE-125.c","CWE-125","void vrend_renderer_blit(struct vrend_context *ctx,                          uint32_t dst_handle, uint32_t src_handle,                          const struct pipe_blit_info *info) {    struct vrend_resource *src_res, *dst_res;    src_res = vrend_renderer_ctx_res_lookup(ctx, src_handle);    dst_res = vrend_renderer_ctx_res_lookup(ctx, dst_handle);     if (!src_res) {       report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, src_handle);       return;    }    if (!dst_res) {       report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, dst_handle);       return;    }     if (ctx->in_error)       return;     if (info->render_condition_enable == false)       vrend_pause_render_condition(ctx, true);     VREND_DEBUG(dbg_blit, ctx, ""BLIT: rc:%d scissor:%d filter:%d alpha:%d mask:0x%x\n""                                    ""  From %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n""                                    ""  To   %s(%s) ms:%d [%d, %d, %d]+[%d, %d, %d] lvl:%d\n"",                                    info->render_condition_enable, info->scissor_enable,                                    info->filter, info->alpha_blend, info->mask,                                    util_format_name(src_res->base.format),                                    util_format_name(info->src.format),                                    src_res->base.nr_samples,                                    info->src.box.x, info->src.box.y, info->src.box.z,                                    info->src.box.width, info->src.box.height, info->src.box.depth,                                    info->src.level,                                    util_format_name(dst_res->base.format),                                    util_format_name(info->dst.format),                                    dst_res->base.nr_samples,                                    info->dst.box.x, info->dst.box.y, info->dst.box.z,                                    info->dst.box.width, info->dst.box.height, info->dst.box.depth,                                    info->dst.level);     /* The Gallium blit function can be called for a general blit that may     * scale, convert the data, and apply some rander states, or it is called via     * glCopyImageSubData. If the src or the dst image are equal, or the two     * images formats are the same, then Galliums such calles are redirected     * to resource_copy_region, in this case and if no render states etx need     * to be applied, forward the call to glCopyImageSubData, otherwise do a     * normal blit. */    if (has_feature(feat_copy_image) &&        (!info->render_condition_enable || !ctx->sub->cond_render_gl_mode) &&        format_is_copy_compatible(info->src.format,info->dst.format, false) &&        !info->scissor_enable && (info->filter == PIPE_TEX_FILTER_NEAREST) &&        !info->alpha_blend && (info->mask == PIPE_MASK_RGBA) &&        src_res->base.nr_samples == dst_res->base.nr_samples &&        info->src.box.width == info->dst.box.width &&        info->src.box.height == info->dst.box.height &&        info->src.box.depth == info->dst.box.depth) {       VREND_DEBUG(dbg_blit, ctx,  ""  Use glCopyImageSubData\n"");       vrend_copy_sub_image(src_res, dst_res, info->src.level, &info->src.box,                            info->dst.level, info->dst.box.x, info->dst.box.y,                            info->dst.box.z);    } else {       VREND_DEBUG(dbg_blit, ctx, ""  Use blit_int\n"");       vrend_renderer_blit_int(ctx, src_res, dst_res, info);    }     if (info->render_condition_enable == false)       vrend_pause_render_condition(ctx, false); }"
"210252_CWE-787.c","CWE-787","static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define MonoColorType  1 #define RGBColorType  3    char     property[MagickPathExtent];    CINInfo     cin;    Image     *image;    MagickBooleanType     status;    MagickOffsetType     offset;    QuantumInfo     *quantum_info;    QuantumType     quantum_type;    ssize_t     i;    Quantum     *q;    size_t     length;    ssize_t     count,     y;    unsigned char     magick[4],     *pixels;     /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info,exception);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     File information.   */   offset=0;   count=ReadBlob(image,4,magick);   offset+=count;   if ((count != 4) ||       ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   memset(&cin,0,sizeof(cin));   image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&     (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;   cin.file.image_offset=ReadBlobLong(image);   offset+=4;   cin.file.generic_length=ReadBlobLong(image);   offset+=4;   cin.file.industry_length=ReadBlobLong(image);   offset+=4;   cin.file.user_length=ReadBlobLong(image);   offset+=4;   cin.file.file_size=ReadBlobLong(image);   offset+=4;   offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)     cin.file.version);   (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));   (void) SetImageProperty(image,""dpx:file.version"",property,exception);   offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)     cin.file.filename);   (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));   (void) SetImageProperty(image,""dpx:file.filename"",property,exception);   offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)     cin.file.create_date);   (void) CopyMagickString(property,cin.file.create_date,     sizeof(cin.file.create_date));   (void) SetImageProperty(image,""dpx:file.create_date"",property,exception);   offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)     cin.file.create_time);   (void) CopyMagickString(property,cin.file.create_time,     sizeof(cin.file.create_time));   (void) SetImageProperty(image,""dpx:file.create_time"",property,exception);   offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)     cin.file.reserve);   /*     Image information.   */   cin.image.orientation=(unsigned char) ReadBlobByte(image);   offset++;   if (cin.image.orientation != (unsigned char) (~0))     (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",       cin.image.orientation);   switch (cin.image.orientation)   {     default:     case 0: image->orientation=TopLeftOrientation; break;     case 1: image->orientation=TopRightOrientation; break;     case 2: image->orientation=BottomLeftOrientation; break;     case 3: image->orientation=BottomRightOrientation; break;     case 4: image->orientation=LeftTopOrientation; break;     case 5: image->orientation=RightTopOrientation; break;     case 6: image->orientation=LeftBottomOrientation; break;     case 7: image->orientation=RightBottomOrientation; break;   }   cin.image.number_channels=(unsigned char) ReadBlobByte(image);   offset++;   offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)     cin.image.reserve1);   for (i=0; i < 8; i++)   {     cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);     offset++;     cin.image.channel[i].pixels_per_line=ReadBlobLong(image);     offset+=4;     cin.image.channel[i].lines_per_image=ReadBlobLong(image);     offset+=4;     cin.image.channel[i].min_data=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].min_quantity=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].max_data=ReadBlobFloat(image);     offset+=4;     cin.image.channel[i].max_quantity=ReadBlobFloat(image);     offset+=4;   }   cin.image.white_point[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)     image->chromaticity.white_point.x=cin.image.white_point[0];   cin.image.white_point[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)     image->chromaticity.white_point.y=cin.image.white_point[1];   cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];   cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];   cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];   cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];   cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)     image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];   cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)     image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];   offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)     cin.image.label);   (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));   (void) SetImageProperty(image,""dpx:image.label"",property,exception);   offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)     cin.image.reserve);   /*     Image data format information.   */   cin.data_format.interleave=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.packing=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.sign=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.sense=(unsigned char) ReadBlobByte(image);   offset++;   cin.data_format.line_pad=ReadBlobLong(image);   offset+=4;   cin.data_format.channel_pad=ReadBlobLong(image);   offset+=4;   offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)     cin.data_format.reserve);   /*     Image origination information.   */   cin.origination.x_offset=ReadBlobSignedLong(image);   offset+=4;   if ((size_t) cin.origination.x_offset != ~0UL)     (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",       (double) cin.origination.x_offset);   cin.origination.y_offset=(ssize_t) ReadBlobLong(image);   offset+=4;   if ((size_t) cin.origination.y_offset != ~0UL)     (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",       (double) cin.origination.y_offset);   offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)     cin.origination.filename);   (void) CopyMagickString(property,cin.origination.filename,     sizeof(cin.origination.filename));   (void) SetImageProperty(image,""dpx:origination.filename"",property,exception);   offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)     cin.origination.create_date);   (void) CopyMagickString(property,cin.origination.create_date,     sizeof(cin.origination.create_date));   (void) SetImageProperty(image,""dpx:origination.create_date"",property,     exception);   offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)     cin.origination.create_time);   (void) CopyMagickString(property,cin.origination.create_time,     sizeof(cin.origination.create_time));   (void) SetImageProperty(image,""dpx:origination.create_time"",property,     exception);   offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)     cin.origination.device);   (void) CopyMagickString(property,cin.origination.device,     sizeof(cin.origination.device));   (void) SetImageProperty(image,""dpx:origination.device"",property,exception);   offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)     cin.origination.model);   (void) CopyMagickString(property,cin.origination.model,     sizeof(cin.origination.model));   (void) SetImageProperty(image,""dpx:origination.model"",property,exception);   (void) memset(cin.origination.serial,0,      sizeof(cin.origination.serial));   offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)     cin.origination.serial);   (void) CopyMagickString(property,cin.origination.serial,     sizeof(cin.origination.serial));   (void) SetImageProperty(image,""dpx:origination.serial"",property,exception);   cin.origination.x_pitch=ReadBlobFloat(image);   offset+=4;   cin.origination.y_pitch=ReadBlobFloat(image);   offset+=4;   cin.origination.gamma=ReadBlobFloat(image);   offset+=4;   if (IsFloatDefined(cin.origination.gamma) != MagickFalse)     image->gamma=cin.origination.gamma;   offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)     cin.origination.reserve);   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))     {       int         c;        /*         Image film information.       */       cin.film.id=ReadBlobByte(image);       offset++;       c=cin.film.id;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);       cin.film.type=ReadBlobByte(image);       offset++;       c=cin.film.type;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);       cin.film.offset=ReadBlobByte(image);       offset++;       c=cin.film.offset;       if (c != ~0)         (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",           cin.film.offset);       cin.film.reserve1=ReadBlobByte(image);       offset++;       cin.film.prefix=ReadBlobLong(image);       offset+=4;       if (cin.film.prefix != ~0UL)         (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)           cin.film.prefix);       cin.film.count=ReadBlobLong(image);       offset+=4;       offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)         cin.film.format);       (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));       (void) SetImageProperty(image,""dpx:film.format"",property,exception);       cin.film.frame_position=ReadBlobLong(image);       offset+=4;       if (cin.film.frame_position != ~0UL)         (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",           (double) cin.film.frame_position);       cin.film.frame_rate=ReadBlobFloat(image);       offset+=4;       if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)         (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",           cin.film.frame_rate);       offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)         cin.film.frame_id);       (void) CopyMagickString(property,cin.film.frame_id,         sizeof(cin.film.frame_id));       (void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);       offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)         cin.film.slate_info);       (void) CopyMagickString(property,cin.film.slate_info,         sizeof(cin.film.slate_info));       (void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);       offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)         cin.film.reserve);     }   if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))     {       StringInfo         *profile;        /*         User defined data.       */       if (cin.file.user_length > GetBlobSize(image))         ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");       profile=BlobToStringInfo((const unsigned char *) NULL,         cin.file.user_length);       if (profile == (StringInfo *) NULL)         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");       offset+=ReadBlob(image,GetStringInfoLength(profile),         GetStringInfoDatum(profile));       (void) SetImageProfile(image,""dpx:user.data"",profile,exception);       profile=DestroyStringInfo(profile);     }   image->depth=cin.image.channel[0].bits_per_pixel;   image->columns=cin.image.channel[0].pixels_per_line;   image->rows=cin.image.channel[0].lines_per_image;   if (image_info->ping != MagickFalse)     {       (void) CloseBlob(image);       return(image);     }   if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))     ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)   {     int       c;      c=ReadBlobByte(image);     if (c == EOF)       break;   }   if (offset < (MagickOffsetType) cin.file.image_offset)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   status=SetImageExtent(image,image->columns,image->rows,exception);   if (status == MagickFalse)     return(DestroyImageList(image));   (void) SetImageBackgroundColor(image,exception);   /*     Convert CIN raster image to pixel packets.   */   quantum_info=AcquireQuantumInfo(image_info,image);   if (quantum_info == (QuantumInfo *) NULL)     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");   SetQuantumQuantum(quantum_info,32);   SetQuantumPack(quantum_info,MagickFalse);   quantum_type=RGBQuantum;   length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);   if (cin.image.number_channels == 1)     {       quantum_type=GrayQuantum;       length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);     }   status=SetQuantumPad(image,quantum_info,0);   pixels=GetQuantumPixels(quantum_info);   for (y=0; y < (ssize_t) image->rows; y++)   {     const void       *stream;      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);     if (q == (Quantum *) NULL)       break;     stream=ReadBlobStream(image,length,pixels,&count);     if ((size_t) count != length)       break;     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,       quantum_type,(unsigned char *) stream,exception);     if (SyncAuthenticPixels(image,exception) == MagickFalse)       break;     if (image->previous == (Image *) NULL)       {         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,           image->rows);         if (status == MagickFalse)           break;       }   }   SetQuantumImageType(image,quantum_type);   quantum_info=DestroyQuantumInfo(quantum_info);   if (EOFBlob(image) != MagickFalse)     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",       image->filename);   SetImageColorspace(image,LogColorspace,exception);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"210271_CWE-787.c","CWE-787","sug_filltree(spellinfo_T *spin, slang_T *slang) {     char_u	*byts;     idx_T	*idxs;     int		depth;     idx_T	arridx[MAXWLEN];     int		curi[MAXWLEN];     char_u	tword[MAXWLEN];     char_u	tsalword[MAXWLEN];     int		c;     idx_T	n;     unsigned	words_done = 0;     int		wordcount[MAXWLEN];      // We use si_foldroot for the soundfolded trie.     spin->si_foldroot = wordtree_alloc(spin);     if (spin->si_foldroot == NULL) 	return FAIL;      // let tree_add_word() know we're adding to the soundfolded tree     spin->si_sugtree = TRUE;      /*      * Go through the whole case-folded tree, soundfold each word and put it      * in the trie.      */     byts = slang->sl_fbyts;     idxs = slang->sl_fidxs;      arridx[0] = 0;     curi[0] = 1;     wordcount[0] = 0;      depth = 0;     while (depth >= 0 && !got_int)     { 	if (curi[depth] > byts[arridx[depth]]) 	{ 	    // Done all bytes at this node, go up one level. 	    idxs[arridx[depth]] = wordcount[depth]; 	    if (depth > 0) 		wordcount[depth - 1] += wordcount[depth];  	    --depth; 	    line_breakcheck(); 	} 	else 	{  	    // Do one more byte at this node. 	    n = arridx[depth] + curi[depth]; 	    ++curi[depth];  	    c = byts[n]; 	    if (c == 0) 	    { 		// Sound-fold the word. 		tword[depth] = NUL; 		spell_soundfold(slang, tword, TRUE, tsalword);  		// We use the ""flags"" field for the MSB of the wordnr, 		// ""region"" for the LSB of the wordnr. 		if (tree_add_word(spin, tsalword, spin->si_foldroot, 				words_done >> 16, words_done & 0xffff, 							   0) == FAIL) 		    return FAIL;  		++words_done; 		++wordcount[depth];  		// Reset the block count each time to avoid compression 		// kicking in. 		spin->si_blocks_cnt = 0;  		// Skip over any other NUL bytes (same word with different 		// flags).  But don't go over the end. 		while (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0) 		{ 		    ++n; 		    ++curi[depth]; 		} 	    } 	    else 	    { 		// Normal char, go one level deeper. 		tword[depth++] = c; 		arridx[depth] = idxs[n]; 		curi[depth] = 1; 		wordcount[depth] = 0; 	    } 	}     }      smsg(_(""Total number of words: %d""), words_done);      return OK; }"
"210273_CWE-617.cpp","CWE-617","createRandomCursorExecutor(const CollectionPtr& coll,                            const boost::intrusive_ptr<ExpressionContext>& expCtx,                            long long sampleSize,                            long long numRecords,                            boost::optional<BucketUnpacker> bucketUnpacker) {     OperationContext* opCtx = expCtx->opCtx;      // Verify that we are already under a collection lock. We avoid taking locks ourselves in this     // function because double-locking forces any PlanExecutor we create to adopt a NO_YIELD policy.     invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));      static const double kMaxSampleRatioForRandCursor = 0.05;     if (!expCtx->ns.isTimeseriesBucketsCollection()) {         if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {             return std::pair{nullptr, false};         }     } else {         // Suppose that a time-series bucket collection is observed to contain 200 buckets, and the         // 'gTimeseriesBucketMaxCount' parameter is set to 1000. If all buckets are full, then the         // maximum possible measurment count would be 200 * 1000 = 200,000. While the         // 'SampleFromTimeseriesBucket' plan is more efficient when the sample size is small         // relative to the total number of measurements in the time-series collection, for larger         // sample sizes the top-k sort based sample is faster. Experiments have approximated that         // the tipping point is roughly when the requested sample size is greater than 1% of the         // maximum possible number of measurements in the collection (i.e. numBuckets *         // maxMeasurementsPerBucket).         static const double kCoefficient = 0.01;         if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {             return std::pair{nullptr, false};         }     }      // Attempt to get a random cursor from the RecordStore.     auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);     if (!rsRandCursor) {         // The storage engine has no random cursor support.         return std::pair{nullptr, false};     }      // Build a MultiIteratorStage and pass it the random-sampling RecordCursor.     auto ws = std::make_unique<WorkingSet>();     std::unique_ptr<PlanStage> root =         std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);     static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));      // If the incoming operation is sharded, use the CSS to infer the filtering metadata for the     // collection, otherwise treat it as unsharded     auto collectionFilter =         CollectionShardingState::get(opCtx, coll->ns())             ->getOwnershipFilter(                 opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);      TrialStage* trialStage = nullptr;      // Because 'numRecords' includes orphan documents, our initial decision to optimize the $sample     // cursor may have been mistaken. For sharded collections, build a TRIAL plan that will switch     // to a collection scan if the ratio of orphaned to owned documents encountered over the first     // 100 works() is such that we would have chosen not to optimize.     static const size_t kMaxPresampleSize = 100;     if (collectionFilter.isSharded() && !expCtx->ns.isTimeseriesBucketsCollection()) {         // The ratio of owned to orphaned documents must be at least equal to the ratio between the         // requested sampleSize and the maximum permitted sampleSize for the original constraints to         // be satisfied. For instance, if there are 200 documents and the sampleSize is 5, then at         // least (5 / (200*0.05)) = (5/10) = 50% of those documents must be owned. If less than 5%         // of the documents in the collection are owned, we default to the backup plan.         const auto minAdvancedToWorkRatio = std::max(             sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);         // The trial plan is SHARDING_FILTER-MULTI_ITERATOR.         auto randomCursorPlan = std::make_unique<ShardFilterStage>(             expCtx.get(), collectionFilter, ws.get(), std::move(root));         // The backup plan is SHARDING_FILTER-COLLSCAN.         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);         collScanPlan = std::make_unique<ShardFilterStage>(             expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));         // Place a TRIAL stage at the root of the plan tree, and pass it the trial and backup plans.         root = std::make_unique<TrialStage>(expCtx.get(),                                             ws.get(),                                             std::move(randomCursorPlan),                                             std::move(collScanPlan),                                             kMaxPresampleSize,                                             minAdvancedToWorkRatio);         trialStage = static_cast<TrialStage*>(root.get());     } else if (expCtx->ns.isTimeseriesBucketsCollection()) {         // We can't take ARHASH optimization path for a direct $sample on the system.buckets         // collection because data is in compressed form. If we did have a direct $sample on the         // system.buckets collection, then the 'bucketUnpacker' would not be set up properly. We         // also should bail out early if a $sample is made against a time series collection that is         // empty. If we don't the 'minAdvancedToWorkRatio' can be nan/-nan depending on the         // architecture.         if (!(bucketUnpacker && numRecords)) {             return std::pair{nullptr, false};         }          // Use a 'TrialStage' to run a trial between 'SampleFromTimeseriesBucket' and         // 'UnpackTimeseriesBucket' with $sample left in the pipeline in-place. If the buckets are         // not sufficiently full, or the 'SampleFromTimeseriesBucket' plan draws too many         // duplicates, then we will fall back to the 'TrialStage' backup plan. This backup plan uses         // the top-k sort sampling approach.         //         // Suppose the 'gTimeseriesBucketMaxCount' is 1000, but each bucket only contains 500         // documents on average. The observed trial advanced/work ratio approximates the average         // bucket fullness, noted here as ""abf"". In this example, abf = 500 / 1000 = 0.5.         // Experiments have shown that the optimized 'SampleFromTimeseriesBucket' algorithm performs         // better than backup plan when         //         //     sampleSize < 0.02 * abf * numRecords * gTimeseriesBucketMaxCount         //         //  This inequality can be rewritten as         //         //     abf > sampleSize / (0.02 * numRecords * gTimeseriesBucketMaxCount)         //         // Therefore, if the advanced/work ratio exceeds this threshold, we will use the         // 'SampleFromTimeseriesBucket' plan. Note that as the sample size requested by the user         // becomes larger with respect to the number of buckets, we require a higher advanced/work         // ratio in order to justify using 'SampleFromTimeseriesBucket'.         //         // Additionally, we require the 'TrialStage' to approximate the abf as at least 0.25. When         // buckets are mostly empty, the 'SampleFromTimeseriesBucket' will be inefficient due to a         // lot of sampling ""misses"".         static const auto kCoefficient = 0.02;         static const auto kMinBucketFullness = 0.25;         const auto minAdvancedToWorkRatio = std::max(             std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),             kMinBucketFullness);          auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(             expCtx.get(),             ws.get(),             std::move(root),             *bucketUnpacker,             // By using a quantity slightly higher than 'kMaxPresampleSize', we ensure that the             // 'SampleFromTimeseriesBucket' stage won't fail due to too many consecutive sampling             // attempts during the 'TrialStage's trial period.             kMaxPresampleSize + 5,             sampleSize,             gTimeseriesBucketMaxCount);          std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);          auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(             expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);          root = std::make_unique<TrialStage>(expCtx.get(),                                             ws.get(),                                             std::move(arhashPlan),                                             std::move(topkSortPlan),                                             kMaxPresampleSize,                                             minAdvancedToWorkRatio);         trialStage = static_cast<TrialStage*>(root.get());     }      auto execStatus = plan_executor_factory::make(expCtx,                                                   std::move(ws),                                                   std::move(root),                                                   &coll,                                                   opCtx->inMultiDocumentTransaction()                                                       ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY                                                       : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,                                                   QueryPlannerParams::RETURN_OWNED_DATA);     if (!execStatus.isOK()) {         return execStatus.getStatus();     }      // For sharded collections, the root of the plan tree is a TrialStage that may have chosen     // either a random-sampling cursor trial plan or a COLLSCAN backup plan. We can only optimize     // the $sample aggregation stage if the trial plan was chosen.     return std::pair{std::move(execStatus.getValue()),                      !trialStage || !trialStage->pickedBackupPlan()}; }"
"210278_CWE-476.c","CWE-476","void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) {     if (!block) {         return;     }      //if (block->host) {     //    ram_block_notify_remove(block->host, block->max_length);     //}      QLIST_REMOVE(block, next);     uc->ram_list.mru_block = NULL;     /* Write list before version */     //smp_wmb();     // call_rcu(block, reclaim_ramblock, rcu);     reclaim_ramblock(uc, block); }"
"210282_CWE-125.c","CWE-125","static int i2c_ddc_rx(I2CSlave *i2c) {     I2CDDCState *s = I2CDDC(i2c);      int value;     value = s->edid_blob[s->reg];     s->reg++;     return value; }"
"210283_CWE-703.c","CWE-703","vhost_user_set_inflight_fd(struct virtio_net **pdev, 			   struct vhu_msg_context *ctx, 			   int main_fd __rte_unused) { 	uint64_t mmap_size, mmap_offset; 	uint16_t num_queues, queue_size; 	struct virtio_net *dev = *pdev; 	uint32_t pervq_inflight_size; 	struct vhost_virtqueue *vq; 	void *addr; 	int fd, i; 	int numa_node = SOCKET_ID_ANY;  	fd = ctx->fds[0]; 	if (ctx->msg.size != sizeof(ctx->msg.payload.inflight) || fd < 0) { 		VHOST_LOG_CONFIG(ERR, ""(%s) invalid set_inflight_fd message size is %d,fd is %d\n"", 			dev->ifname, ctx->msg.size, fd); 		return RTE_VHOST_MSG_RESULT_ERR; 	}  	mmap_size = ctx->msg.payload.inflight.mmap_size; 	mmap_offset = ctx->msg.payload.inflight.mmap_offset; 	num_queues = ctx->msg.payload.inflight.num_queues; 	queue_size = ctx->msg.payload.inflight.queue_size;  	if (vq_is_packed(dev)) 		pervq_inflight_size = get_pervq_shm_size_packed(queue_size); 	else 		pervq_inflight_size = get_pervq_shm_size_split(queue_size);  	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd mmap_size: %""PRIu64""\n"", 			dev->ifname, mmap_size); 	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd mmap_offset: %""PRIu64""\n"", 			dev->ifname, mmap_offset); 	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd num_queues: %u\n"", dev->ifname, num_queues); 	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd queue_size: %u\n"", dev->ifname, queue_size); 	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd fd: %d\n"", dev->ifname, fd); 	VHOST_LOG_CONFIG(INFO, ""(%s) set_inflight_fd pervq_inflight_size: %d\n"", 			dev->ifname, pervq_inflight_size);  	/* 	 * If VQ 0 has already been allocated, try to allocate on the same 	 * NUMA node. It can be reallocated later in numa_realloc(). 	 */ 	if (dev->nr_vring > 0) 		numa_node = dev->virtqueue[0]->numa_node;  	if (!dev->inflight_info) { 		dev->inflight_info = rte_zmalloc_socket(""inflight_info"", 				sizeof(struct inflight_mem_info), 0, numa_node); 		if (dev->inflight_info == NULL) { 			VHOST_LOG_CONFIG(ERR, ""(%s) failed to alloc dev inflight area\n"", 					dev->ifname); 			return RTE_VHOST_MSG_RESULT_ERR; 		} 		dev->inflight_info->fd = -1; 	}  	if (dev->inflight_info->addr) { 		munmap(dev->inflight_info->addr, dev->inflight_info->size); 		dev->inflight_info->addr = NULL; 	}  	addr = mmap(0, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, 		    fd, mmap_offset); 	if (addr == MAP_FAILED) { 		VHOST_LOG_CONFIG(ERR, ""(%s) failed to mmap share memory.\n"", dev->ifname); 		return RTE_VHOST_MSG_RESULT_ERR; 	}  	if (dev->inflight_info->fd >= 0) { 		close(dev->inflight_info->fd); 		dev->inflight_info->fd = -1; 	}  	dev->inflight_info->fd = fd; 	dev->inflight_info->addr = addr; 	dev->inflight_info->size = mmap_size;  	for (i = 0; i < num_queues; i++) { 		vq = dev->virtqueue[i]; 		if (!vq) 			continue;  		if (vq_is_packed(dev)) { 			vq->inflight_packed = addr; 			vq->inflight_packed->desc_num = queue_size; 		} else { 			vq->inflight_split = addr; 			vq->inflight_split->desc_num = queue_size; 		} 		addr = (void *)((char *)addr + pervq_inflight_size); 	}  	return RTE_VHOST_MSG_RESULT_OK; }"
"210284_CWE-703.c","CWE-703","vhost_user_get_inflight_fd(struct virtio_net **pdev, 			   struct vhu_msg_context *ctx, 			   int main_fd __rte_unused) { 	struct rte_vhost_inflight_info_packed *inflight_packed; 	uint64_t pervq_inflight_size, mmap_size; 	uint16_t num_queues, queue_size; 	struct virtio_net *dev = *pdev; 	int fd, i, j; 	int numa_node = SOCKET_ID_ANY; 	void *addr;  	if (ctx->msg.size != sizeof(ctx->msg.payload.inflight)) { 		VHOST_LOG_CONFIG(ERR, ""(%s) invalid get_inflight_fd message size is %d\n"", 			dev->ifname, ctx->msg.size); 		return RTE_VHOST_MSG_RESULT_ERR; 	}  	/* 	 * If VQ 0 has already been allocated, try to allocate on the same 	 * NUMA node. It can be reallocated later in numa_realloc(). 	 */ 	if (dev->nr_vring > 0) 		numa_node = dev->virtqueue[0]->numa_node;  	if (dev->inflight_info == NULL) { 		dev->inflight_info = rte_zmalloc_socket(""inflight_info"", 				sizeof(struct inflight_mem_info), 0, numa_node); 		if (!dev->inflight_info) { 			VHOST_LOG_CONFIG(ERR, ""(%s) failed to alloc dev inflight area\n"", 					dev->ifname); 			return RTE_VHOST_MSG_RESULT_ERR; 		} 		dev->inflight_info->fd = -1; 	}  	num_queues = ctx->msg.payload.inflight.num_queues; 	queue_size = ctx->msg.payload.inflight.queue_size;  	VHOST_LOG_CONFIG(INFO, ""(%s) get_inflight_fd num_queues: %u\n"", 		dev->ifname, ctx->msg.payload.inflight.num_queues); 	VHOST_LOG_CONFIG(INFO, ""(%s) get_inflight_fd queue_size: %u\n"", 		dev->ifname, ctx->msg.payload.inflight.queue_size);  	if (vq_is_packed(dev)) 		pervq_inflight_size = get_pervq_shm_size_packed(queue_size); 	else 		pervq_inflight_size = get_pervq_shm_size_split(queue_size);  	mmap_size = num_queues * pervq_inflight_size; 	addr = inflight_mem_alloc(dev, ""vhost-inflight"", mmap_size, &fd); 	if (!addr) { 		VHOST_LOG_CONFIG(ERR, ""(%s) failed to alloc vhost inflight area\n"", dev->ifname); 			ctx->msg.payload.inflight.mmap_size = 0; 		return RTE_VHOST_MSG_RESULT_ERR; 	} 	memset(addr, 0, mmap_size);  	if (dev->inflight_info->addr) { 		munmap(dev->inflight_info->addr, dev->inflight_info->size); 		dev->inflight_info->addr = NULL; 	}  	if (dev->inflight_info->fd >= 0) { 		close(dev->inflight_info->fd); 		dev->inflight_info->fd = -1; 	}  	dev->inflight_info->addr = addr; 	dev->inflight_info->size = ctx->msg.payload.inflight.mmap_size = mmap_size; 	dev->inflight_info->fd = ctx->fds[0] = fd; 	ctx->msg.payload.inflight.mmap_offset = 0; 	ctx->fd_num = 1;  	if (vq_is_packed(dev)) { 		for (i = 0; i < num_queues; i++) { 			inflight_packed = 				(struct rte_vhost_inflight_info_packed *)addr; 			inflight_packed->used_wrap_counter = 1; 			inflight_packed->old_used_wrap_counter = 1; 			for (j = 0; j < queue_size; j++) 				inflight_packed->desc[j].next = j + 1; 			addr = (void *)((char *)addr + pervq_inflight_size); 		} 	}  	VHOST_LOG_CONFIG(INFO, ""(%s) send inflight mmap_size: %""PRIu64""\n"", 			dev->ifname, ctx->msg.payload.inflight.mmap_size); 	VHOST_LOG_CONFIG(INFO, ""(%s) send inflight mmap_offset: %""PRIu64""\n"", 			dev->ifname, ctx->msg.payload.inflight.mmap_offset); 	VHOST_LOG_CONFIG(INFO, ""(%s) send inflight fd: %d\n"", dev->ifname, ctx->fds[0]);  	return RTE_VHOST_MSG_RESULT_REPLY; }"
"210303_CWE-772.c","CWE-772","static Image *ReadWMFImage(const ImageInfo *image_info,ExceptionInfo *exception) {   double     bounding_height,     bounding_width,     image_height,     image_height_inch,     image_width,     image_width_inch,     resolution_y,     resolution_x,     units_per_inch;    float     wmf_width,     wmf_height;    Image     *image;    MagickBooleanType     status;    unsigned long     wmf_options_flags = 0;    wmf_error_t     wmf_error;    wmf_magick_t     *ddata = 0;    wmfAPI     *API = 0;    wmfAPI_Options     wmf_api_options;    wmfD_Rect     bbox;    image=AcquireImage(image_info,exception);   if (OpenBlob(image_info,image,ReadBinaryBlobMode,exception) == MagickFalse)     {       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  OpenBlob failed"");           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       image=DestroyImageList(image);       return((Image *) NULL);     }    /*    * Create WMF API    *    */    /* Register callbacks */   wmf_options_flags |= WMF_OPT_FUNCTION;   (void) ResetMagickMemory(&wmf_api_options, 0, sizeof(wmf_api_options));   wmf_api_options.function = ipa_functions;    /* Ignore non-fatal errors */   wmf_options_flags |= WMF_OPT_IGNORE_NONFATAL;    wmf_error = wmf_api_create(&API, wmf_options_flags, &wmf_api_options);   if (wmf_error != wmf_E_None)     {       if (API)         wmf_api_destroy(API);       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  wmf_api_create failed"");           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       ThrowReaderException(DelegateError,""UnableToInitializeWMFLibrary"");     }    /* Register progress monitor */   wmf_status_function(API,image,magick_progress_callback);    ddata=WMF_MAGICK_GetData(API);   ddata->image=image;   ddata->image_info=image_info;   ddata->draw_info=CloneDrawInfo(image_info,(const DrawInfo *) NULL);   ddata->exception=exception;   ddata->draw_info->font=(char *)     RelinquishMagickMemory(ddata->draw_info->font);   ddata->draw_info->text=(char *)     RelinquishMagickMemory(ddata->draw_info->text);  #if defined(MAGICKCORE_WMF_DELEGATE)   /* Must initialize font subystem for WMFlite interface */   lite_font_init (API,&wmf_api_options); /* similar to wmf_ipa_font_init in src/font.c */   /* wmf_arg_fontdirs (API,options); */ /* similar to wmf_arg_fontdirs in src/wmf.c */  #endif    /*    * Open BLOB input via libwmf API    *    */   wmf_error = wmf_bbuf_input(API,ipa_blob_read,ipa_blob_seek,     ipa_blob_tell,(void*)image);   if (wmf_error != wmf_E_None)     {       wmf_api_destroy(API);       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  wmf_bbuf_input failed"");           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",         image->filename);       image=DestroyImageList(image);       return((Image *) NULL);     }    /*    * Scan WMF file    *    */   if (image->debug != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),       ""  Scanning WMF to obtain bounding box"");   wmf_error=wmf_scan(API, 0, &bbox);   if (wmf_error != wmf_E_None)     {       wmf_api_destroy(API);       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  wmf_scan failed with wmf_error %d"", wmf_error);           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       ThrowReaderException(DelegateError,""FailedToScanFile"");     }    /*    * Compute dimensions and scale factors    *    */    ddata->bbox=bbox;    /* User specified resolution */   resolution_y=DefaultResolution;   if (image->resolution.y != 0.0)     {       resolution_y = image->resolution.y;       if (image->units == PixelsPerCentimeterResolution)         resolution_y *= CENTIMETERS_PER_INCH;     }   resolution_x=DefaultResolution;   if (image->resolution.x != 0.0)     {       resolution_x = image->resolution.x;       if (image->units == PixelsPerCentimeterResolution)         resolution_x *= CENTIMETERS_PER_INCH;     }    /* Obtain output size expressed in metafile units */   wmf_error=wmf_size(API,&wmf_width,&wmf_height);   if (wmf_error != wmf_E_None)     {       wmf_api_destroy(API);       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  wmf_size failed with wmf_error %d"", wmf_error);           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       ThrowReaderException(DelegateError,""FailedToComputeOutputSize"");     }    /* Obtain (or guess) metafile units */   if ((API)->File->placeable)     units_per_inch=(API)->File->pmh->Inch;   else if ( (wmf_width*wmf_height) < 1024*1024)     units_per_inch=POINTS_PER_INCH;  /* MM_TEXT */   else     units_per_inch=TWIPS_PER_INCH;  /* MM_TWIPS */    /* Calculate image width and height based on specified DPI      resolution */   image_width_inch  = (double) wmf_width / units_per_inch;   image_height_inch = (double) wmf_height / units_per_inch;   image_width       = image_width_inch * resolution_x;   image_height      = image_height_inch * resolution_y;    /* Compute bounding box scale factors and origin translations    *    * This all just a hack since libwmf does not currently seem to    * provide the mapping between LOGICAL coordinates and DEVICE    * coordinates. This mapping is necessary in order to know    * where to place the logical bounding box within the image.    *    */    bounding_width  = bbox.BR.x - bbox.TL.x;   bounding_height = bbox.BR.y - bbox.TL.y;    ddata->scale_x = image_width/bounding_width;   ddata->translate_x = 0-bbox.TL.x;   ddata->rotate = 0;    /* Heuristic: guess that if the vertical coordinates mostly span      negative values, then the image must be inverted. */   if ( fabs(bbox.BR.y) > fabs(bbox.TL.y) )     {       /* Normal (Origin at top left of image) */       ddata->scale_y = (image_height/bounding_height);       ddata->translate_y = 0-bbox.TL.y;     }   else     {       /* Inverted (Origin at bottom left of image) */       ddata->scale_y = (-image_height/bounding_height);       ddata->translate_y = 0-bbox.BR.y;     }    if (image->debug != MagickFalse)     {       (void) LogMagickEvent(CoderEvent,GetMagickModule(),          ""  Placeable metafile:          %s"",          (API)->File->placeable ? ""Yes"" : ""No"");        (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Size in metafile units:      %gx%g"",wmf_width,wmf_height);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Metafile units/inch:         %g"",units_per_inch);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Size in inches:              %gx%g"",         image_width_inch,image_height_inch);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Bounding Box:                %g,%g %g,%g"",         bbox.TL.x, bbox.TL.y, bbox.BR.x, bbox.BR.y);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Bounding width x height:     %gx%g"",bounding_width,         bounding_height);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Output resolution:           %gx%g"",resolution_x,resolution_y);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Image size:                  %gx%g"",image_width,image_height);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Bounding box scale factor:   %g,%g"",ddata->scale_x,         ddata->scale_y);       (void) LogMagickEvent(CoderEvent,GetMagickModule(),         ""  Translation:                 %g,%g"",         ddata->translate_x, ddata->translate_y);     }  #if 0 #if 0   {     typedef struct _wmfPlayer_t wmfPlayer_t;     struct _wmfPlayer_t     {       wmfPen   default_pen;       wmfBrush default_brush;       wmfFont  default_font;        wmfDC* dc; /* current dc */     };      wmfDC       *dc;  #define WMF_ELICIT_DC(API) (((wmfPlayer_t*)((API)->player_data))->dc)      dc = WMF_ELICIT_DC(API);      printf(""dc->Window.Ox     = %d\n"", dc->Window.Ox);     printf(""dc->Window.Oy     = %d\n"", dc->Window.Oy);     printf(""dc->Window.width  = %d\n"", dc->Window.width);     printf(""dc->Window.height = %d\n"", dc->Window.height);     printf(""dc->pixel_width   = %g\n"", dc->pixel_width);     printf(""dc->pixel_height  = %g\n"", dc->pixel_height); #if defined(MAGICKCORE_WMF_DELEGATE)  /* Only in libwmf 0.3 */     printf(""dc->Ox            = %.d\n"", dc->Ox);     printf(""dc->Oy            = %.d\n"", dc->Oy);     printf(""dc->width         = %.d\n"", dc->width);     printf(""dc->height        = %.d\n"", dc->height); #endif    } #endif  #endif    /*    * Create canvas image    *    */   image->rows=(unsigned long) ceil(image_height);   image->columns=(unsigned long) ceil(image_width);    if (image_info->ping != MagickFalse)     {       wmf_api_destroy(API);       (void) CloseBlob(image);       if (image->debug != MagickFalse)         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""leave ReadWMFImage()"");       return(GetFirstImageInList(image));     }   status=SetImageExtent(image,image->columns,image->rows,exception);   if (status == MagickFalse)     return(DestroyImageList(image));   if (image->debug != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),        ""  Creating canvas image with size %lux%lu"",(unsigned long) image->rows,        (unsigned long) image->columns);    /*    * Set solid background color    */   {     image->background_color = image_info->background_color;     if (image->background_color.alpha != OpaqueAlpha)       image->alpha_trait=BlendPixelTrait;     (void) SetImageBackgroundColor(image,exception);   }   /*    * Play file to generate Vector drawing commands    *    */    if (image->debug != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),       ""  Playing WMF to prepare vectors"");    wmf_error = wmf_play(API, 0, &bbox);   if (wmf_error != wmf_E_None)     {       wmf_api_destroy(API);       if (image->debug != MagickFalse)         {           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Playing WMF failed with wmf_error %d"", wmf_error);           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""leave ReadWMFImage()"");         }       ThrowReaderException(DelegateError,""FailedToRenderFile"");     }    /*    * Scribble on canvas image    *    */    if (image->debug != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),       ""  Rendering WMF vectors"");   DrawRender(ddata->draw_wand);    if (image->debug != MagickFalse)     (void) LogMagickEvent(CoderEvent,GetMagickModule(),""leave ReadWMFImage()"");    /* Cleanup allocated data */   wmf_api_destroy(API);   (void) CloseBlob(image);    /* Return image */   return image; }"
"210378_CWE-119.c","CWE-119","xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,                   const xmlChar **URI, int *tlen) {     const xmlChar *localname;     const xmlChar *prefix;     const xmlChar *attname;     const xmlChar *aprefix;     const xmlChar *nsname;     xmlChar *attvalue;     const xmlChar **atts = ctxt->atts;     int maxatts = ctxt->maxatts;     int nratts, nbatts, nbdef;     int i, j, nbNs, attval, oldline, oldcol, inputNr;     const xmlChar *base;     unsigned long cur;     int nsNr = ctxt->nsNr;      if (RAW != '<') return(NULL);     NEXT1;      /*      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that      *       point since the attribute values may be stored as pointers to      *       the buffer and calling SHRINK would destroy them !      *       The Shrinking is only possible once the full set of attribute      *       callbacks have been done.      */ reparse:     SHRINK;     base = ctxt->input->base;     cur = ctxt->input->cur - ctxt->input->base;     inputNr = ctxt->inputNr;     oldline = ctxt->input->line;     oldcol = ctxt->input->col;     nbatts = 0;     nratts = 0;     nbdef = 0;     nbNs = 0;     attval = 0;     /* Forget any namespaces added during an earlier parse of this element. */     ctxt->nsNr = nsNr;      localname = xmlParseQName(ctxt, &prefix);     if (localname == NULL) { 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, 		       ""StartTag: invalid element name\n"");         return(NULL);     }     *tlen = ctxt->input->cur - ctxt->input->base - cur;      /*      * Now parse the attributes, it ends up with the ending      *      * (S Attribute)* S?      */     SKIP_BLANKS;     GROW;     if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))         goto base_changed;      while (((RAW != '>') && 	   ((RAW != '/') || (NXT(1) != '>')) && 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) { 	const xmlChar *q = CUR_PTR; 	unsigned int cons = ctxt->input->consumed; 	int len = -1, alloc = 0;  	attname = xmlParseAttribute2(ctxt, prefix, localname, 	                             &aprefix, &attvalue, &len, &alloc); 	if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) { 	    if ((attvalue != NULL) && (alloc != 0)) 	        xmlFree(attvalue); 	    attvalue = NULL; 	    goto base_changed; 	}         if ((attname != NULL) && (attvalue != NULL)) { 	    if (len < 0) len = xmlStrlen(attvalue);             if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { 	        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); 		xmlURIPtr uri;                  if (URL == NULL) { 		    xmlErrMemory(ctxt, ""dictionary allocation failure""); 		    if ((attvalue != NULL) && (alloc != 0)) 			xmlFree(attvalue); 		    return(NULL); 		}                 if (*URL != 0) { 		    uri = xmlParseURI((const char *) URL); 		    if (uri == NULL) { 			xmlNsErr(ctxt, XML_WAR_NS_URI, 			         ""xmlns: '%s' is not a valid URI\n"", 					   URL, NULL, NULL); 		    } else { 			if (uri->scheme == NULL) { 			    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, 				      ""xmlns: URI %s is not absolute\n"", 				      URL, NULL, NULL); 			} 			xmlFreeURI(uri); 		    } 		    if (URL == ctxt->str_xml_ns) { 			if (attname != ctxt->str_xml) { 			    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			 ""xml namespace URI cannot be the default namespace\n"", 				     NULL, NULL, NULL); 			} 			goto skip_default_ns; 		    } 		    if ((len == 29) && 			(xmlStrEqual(URL, 				 BAD_CAST ""http://www.w3.org/2000/xmlns/""))) { 			xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""reuse of the xmlns namespace name is forbidden\n"", 				 NULL, NULL, NULL); 			goto skip_default_ns; 		    } 		} 		/* 		 * check that it's not a defined namespace 		 */ 		for (j = 1;j <= nbNs;j++) 		    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) 			break; 		if (j <= nbNs) 		    xmlErrAttributeDup(ctxt, NULL, attname); 		else 		    if (nsPush(ctxt, NULL, URL) > 0) nbNs++; skip_default_ns: 		if (alloc != 0) xmlFree(attvalue); 		if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 		    break; 		if (!IS_BLANK_CH(RAW)) { 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 				   ""attributes construct error\n""); 		    break; 		} 		SKIP_BLANKS; 		continue; 	    }             if (aprefix == ctxt->str_xmlns) { 	        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); 		xmlURIPtr uri;                  if (attname == ctxt->str_xml) { 		    if (URL != ctxt->str_xml_ns) { 		        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			         ""xml namespace prefix mapped to wrong URI\n"", 			         NULL, NULL, NULL); 		    } 		    /* 		     * Do not keep a namespace definition node 		     */ 		    goto skip_ns; 		}                 if (URL == ctxt->str_xml_ns) { 		    if (attname != ctxt->str_xml) { 		        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			         ""xml namespace URI mapped to wrong prefix\n"", 			         NULL, NULL, NULL); 		    } 		    goto skip_ns; 		}                 if (attname == ctxt->str_xmlns) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""redefinition of the xmlns prefix is forbidden\n"", 			     NULL, NULL, NULL); 		    goto skip_ns; 		} 		if ((len == 29) && 		    (xmlStrEqual(URL, 		                 BAD_CAST ""http://www.w3.org/2000/xmlns/""))) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 			     ""reuse of the xmlns namespace name is forbidden\n"", 			     NULL, NULL, NULL); 		    goto skip_ns; 		} 		if ((URL == NULL) || (URL[0] == 0)) { 		    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, 		             ""xmlns:%s: Empty XML namespace is not allowed\n"", 			          attname, NULL, NULL); 		    goto skip_ns; 		} else { 		    uri = xmlParseURI((const char *) URL); 		    if (uri == NULL) { 			xmlNsErr(ctxt, XML_WAR_NS_URI, 			     ""xmlns:%s: '%s' is not a valid URI\n"", 					   attname, URL, NULL); 		    } else { 			if ((ctxt->pedantic) && (uri->scheme == NULL)) { 			    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, 				      ""xmlns:%s: URI %s is not absolute\n"", 				      attname, URL, NULL); 			} 			xmlFreeURI(uri); 		    } 		}  		/* 		 * check that it's not a defined namespace 		 */ 		for (j = 1;j <= nbNs;j++) 		    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) 			break; 		if (j <= nbNs) 		    xmlErrAttributeDup(ctxt, aprefix, attname); 		else 		    if (nsPush(ctxt, attname, URL) > 0) nbNs++; skip_ns: 		if (alloc != 0) xmlFree(attvalue); 		if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 		    break; 		if (!IS_BLANK_CH(RAW)) { 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 				   ""attributes construct error\n""); 		    break; 		} 		SKIP_BLANKS; 		if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) 		    goto base_changed; 		continue; 	    }  	    /* 	     * Add the pair to atts 	     */ 	    if ((atts == NULL) || (nbatts + 5 > maxatts)) { 	        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { 		    if (attvalue[len] == 0) 			xmlFree(attvalue); 		    goto failed; 		} 	        maxatts = ctxt->maxatts; 		atts = ctxt->atts; 	    } 	    ctxt->attallocs[nratts++] = alloc; 	    atts[nbatts++] = attname; 	    atts[nbatts++] = aprefix; 	    atts[nbatts++] = NULL; /* the URI will be fetched later */ 	    atts[nbatts++] = attvalue; 	    attvalue += len; 	    atts[nbatts++] = attvalue; 	    /* 	     * tag if some deallocation is needed 	     */ 	    if (alloc != 0) attval = 1; 	} else { 	    if ((attvalue != NULL) && (attvalue[len] == 0)) 		xmlFree(attvalue); 	}  failed:  	GROW         if (ctxt->instate == XML_PARSER_EOF)             break; 	if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) 	    goto base_changed; 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) 	    break; 	if (!IS_BLANK_CH(RAW)) { 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, 			   ""attributes construct error\n""); 	    break; 	} 	SKIP_BLANKS;         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&             (attname == NULL) && (attvalue == NULL)) { 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, 	         ""xmlParseStartTag: problem parsing attributes\n""); 	    break; 	}         GROW; 	if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) 	    goto base_changed;     }      /*      * The attributes defaulting      */     if (ctxt->attsDefault != NULL) {         xmlDefAttrsPtr defaults;  	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix); 	if (defaults != NULL) { 	    for (i = 0;i < defaults->nbAttrs;i++) { 	        attname = defaults->values[5 * i]; 		aprefix = defaults->values[5 * i + 1];                  /* 		 * special work for namespaces defaulted defs 		 */ 		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { 		    /* 		     * check that it's not a defined namespace 		     */ 		    for (j = 1;j <= nbNs;j++) 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) 			    break; 	            if (j <= nbNs) continue;  		    nsname = xmlGetNamespace(ctxt, NULL); 		    if (nsname != defaults->values[5 * i + 2]) { 			if (nsPush(ctxt, NULL, 			           defaults->values[5 * i + 2]) > 0) 			    nbNs++; 		    } 		} else if (aprefix == ctxt->str_xmlns) { 		    /* 		     * check that it's not a defined namespace 		     */ 		    for (j = 1;j <= nbNs;j++) 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) 			    break; 	            if (j <= nbNs) continue;  		    nsname = xmlGetNamespace(ctxt, attname); 		    if (nsname != defaults->values[2]) { 			if (nsPush(ctxt, attname, 			           defaults->values[5 * i + 2]) > 0) 			    nbNs++; 		    } 		} else { 		    /* 		     * check that it's not a defined attribute 		     */ 		    for (j = 0;j < nbatts;j+=5) { 			if ((attname == atts[j]) && (aprefix == atts[j+1])) 			    break; 		    } 		    if (j < nbatts) continue;  		    if ((atts == NULL) || (nbatts + 5 > maxatts)) { 			if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { 			    return(NULL); 			} 			maxatts = ctxt->maxatts; 			atts = ctxt->atts; 		    } 		    atts[nbatts++] = attname; 		    atts[nbatts++] = aprefix; 		    if (aprefix == NULL) 			atts[nbatts++] = NULL; 		    else 		        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix); 		    atts[nbatts++] = defaults->values[5 * i + 2]; 		    atts[nbatts++] = defaults->values[5 * i + 3]; 		    if ((ctxt->standalone == 1) && 		        (defaults->values[5 * i + 4] != NULL)) { 			xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED, 	  ""standalone: attribute %s on %s defaulted from external subset\n"", 	                                 attname, localname); 		    } 		    nbdef++; 		} 	    } 	}     }      /*      * The attributes checkings      */     for (i = 0; i < nbatts;i += 5) {         /* 	* The default namespace does not apply to attribute names. 	*/ 	if (atts[i + 1] != NULL) { 	    nsname = xmlGetNamespace(ctxt, atts[i + 1]); 	    if (nsname == NULL) { 		xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, 		    ""Namespace prefix %s for %s on %s is not defined\n"", 		    atts[i + 1], atts[i], localname); 	    } 	    atts[i + 2] = nsname; 	} else 	    nsname = NULL; 	/* 	 * [ WFC: Unique Att Spec ] 	 * No attribute name may appear more than once in the same 	 * start-tag or empty-element tag. 	 * As extended by the Namespace in XML REC. 	 */         for (j = 0; j < i;j += 5) { 	    if (atts[i] == atts[j]) { 	        if (atts[i+1] == atts[j+1]) { 		    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]); 		    break; 		} 		if ((nsname != NULL) && (atts[j + 2] == nsname)) { 		    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED, 			     ""Namespaced Attribute %s in '%s' redefined\n"", 			     atts[i], nsname, NULL); 		    break; 		} 	    } 	}     }      nsname = xmlGetNamespace(ctxt, prefix);     if ((prefix != NULL) && (nsname == NULL)) { 	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, 	         ""Namespace prefix %s on %s is not defined\n"", 		 prefix, localname, NULL);     }     *pref = prefix;     *URI = nsname;      /*      * SAX: Start of Element !      */     if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) && 	(!ctxt->disableSAX)) { 	if (nbNs > 0) 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, 			  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs], 			  nbatts / 5, nbdef, atts); 	else 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, 	                  nsname, 0, NULL, nbatts / 5, nbdef, atts);     }      /*      * Free up attribute allocated strings if needed      */     if (attval != 0) { 	for (i = 3,j = 0; j < nratts;i += 5,j++) 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) 	        xmlFree((xmlChar *) atts[i]);     }      return(localname);  base_changed:     /*      * the attribute strings are valid iif the base didn't changed      */     if (attval != 0) { 	for (i = 3,j = 0; j < nratts;i += 5,j++) 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) 	        xmlFree((xmlChar *) atts[i]);     }      /*      * We can't switch from one entity to another in the middle      * of a start tag      */     if (inputNr != ctxt->inputNr) {         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, 		    ""Start tag doesn't start and stop in the same entity\n""); 	return(NULL);     }      ctxt->input->cur = ctxt->input->base + cur;     ctxt->input->line = oldline;     ctxt->input->col = oldcol;     if (ctxt->wellFormed == 1) { 	goto reparse;     }     return(NULL); }"
"210393_CWE-416.c","CWE-416","do_arg_all(     int	count,     int	forceit,		// hide buffers in current windows     int keep_tabs)		// keep current tabs, for "":tab drop file"" {     int		i;     win_T	*wp, *wpnext;     char_u	*opened;	// Array of weight for which args are open: 				//  0: not opened 				//  1: opened in other tab 				//  2: opened in curtab 				//  3: opened in curtab and curwin 				//     int		opened_len;	// length of opened[]     int		use_firstwin = FALSE;	// use first window for arglist     int		tab_drop_empty_window = FALSE;     int		split_ret = OK;     int		p_ea_save;     alist_T	*alist;		// argument list to be used     buf_T	*buf;     tabpage_T	*tpnext;     int		had_tab = cmdmod.cmod_tab;     win_T	*old_curwin, *last_curwin;     tabpage_T	*old_curtab, *last_curtab;     win_T	*new_curwin = NULL;     tabpage_T	*new_curtab = NULL;  #ifdef FEAT_CMDWIN     if (cmdwin_type != 0)     { 	emsg(_(e_invalid_in_cmdline_window)); 	return;     } #endif     if (ARGCOUNT <= 0)     { 	// Don't give an error message.  We don't want it when the "":all"" 	// command is in the .vimrc. 	return;     }     setpcmark();      opened_len = ARGCOUNT;     opened = alloc_clear(opened_len);     if (opened == NULL) 	return;      // Autocommands may do anything to the argument list.  Make sure it's not     // freed while we are working here by ""locking"" it.  We still have to     // watch out for its size to be changed.     alist = curwin->w_alist;     ++alist->al_refcount;      old_curwin = curwin;     old_curtab = curtab;  # ifdef FEAT_GUI     need_mouse_correct = TRUE; # endif      // Try closing all windows that are not in the argument list.     // Also close windows that are not full width;     // When 'hidden' or ""forceit"" set the buffer becomes hidden.     // Windows that have a changed buffer and can't be hidden won't be closed.     // When the "":tab"" modifier was used do this for all tab pages.     if (had_tab > 0) 	goto_tabpage_tp(first_tabpage, TRUE, TRUE);     for (;;)     { 	tpnext = curtab->tp_next; 	for (wp = firstwin; wp != NULL; wp = wpnext) 	{ 	    wpnext = wp->w_next; 	    buf = wp->w_buffer; 	    if (buf->b_ffname == NULL 		    || (!keep_tabs && (buf->b_nwindows > 1 			    || wp->w_width != Columns))) 		i = opened_len; 	    else 	    { 		// check if the buffer in this window is in the arglist 		for (i = 0; i < opened_len; ++i) 		{ 		    if (i < alist->al_ga.ga_len 			    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum 				|| fullpathcmp(alist_name(&AARGLIST(alist)[i]), 					buf->b_ffname, TRUE, TRUE) & FPC_SAME)) 		    { 			int weight = 1;  			if (old_curtab == curtab) 			{ 			    ++weight; 			    if (old_curwin == wp) 				++weight; 			}  			if (weight > (int)opened[i]) 			{ 			    opened[i] = (char_u)weight; 			    if (i == 0) 			    { 				if (new_curwin != NULL) 				    new_curwin->w_arg_idx = opened_len; 				new_curwin = wp; 				new_curtab = curtab; 			    } 			} 			else if (keep_tabs) 			    i = opened_len;  			if (wp->w_alist != alist) 			{ 			    // Use the current argument list for all windows 			    // containing a file from it. 			    alist_unlink(wp->w_alist); 			    wp->w_alist = alist; 			    ++wp->w_alist->al_refcount; 			} 			break; 		    } 		} 	    } 	    wp->w_arg_idx = i;  	    if (i == opened_len && !keep_tabs)// close this window 	    { 		if (buf_hide(buf) || forceit || buf->b_nwindows > 1 							|| !bufIsChanged(buf)) 		{ 		    // If the buffer was changed, and we would like to hide it, 		    // try autowriting. 		    if (!buf_hide(buf) && buf->b_nwindows <= 1 							 && bufIsChanged(buf)) 		    { 			bufref_T    bufref;  			set_bufref(&bufref, buf);  			(void)autowrite(buf, FALSE);  			// check if autocommands removed the window 			if (!win_valid(wp) || !bufref_valid(&bufref)) 			{ 			    wpnext = firstwin;	// start all over... 			    continue; 			} 		    } 		    // don't close last window 		    if (ONE_WINDOW 			    && (first_tabpage->tp_next == NULL || !had_tab)) 			use_firstwin = TRUE; 		    else 		    { 			win_close(wp, !buf_hide(buf) && !bufIsChanged(buf));  			// check if autocommands removed the next window 			if (!win_valid(wpnext)) 			    wpnext = firstwin;	// start all over... 		    } 		} 	    } 	}  	// Without the "":tab"" modifier only do the current tab page. 	if (had_tab == 0 || tpnext == NULL) 	    break;  	// check if autocommands removed the next tab page 	if (!valid_tabpage(tpnext)) 	    tpnext = first_tabpage;	// start all over...  	goto_tabpage_tp(tpnext, TRUE, TRUE);     }      // Open a window for files in the argument list that don't have one.     // ARGCOUNT may change while doing this, because of autocommands.     if (count > opened_len || count <= 0) 	count = opened_len;      // Don't execute Win/Buf Enter/Leave autocommands here.     ++autocmd_no_enter;     ++autocmd_no_leave;     last_curwin = curwin;     last_curtab = curtab;     win_enter(lastwin, FALSE);     // "":tab drop file"" should re-use an empty window to avoid ""--remote-tab""     // leaving an empty tab page when executed locally.     if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1 			    && curbuf->b_ffname == NULL && !curbuf->b_changed)     { 	use_firstwin = TRUE; 	tab_drop_empty_window = TRUE;     }      for (i = 0; i < count && !got_int; ++i)     { 	if (alist == &global_alist && i == global_alist.al_ga.ga_len - 1) 	    arg_had_last = TRUE; 	if (opened[i] > 0) 	{ 	    // Move the already present window to below the current window 	    if (curwin->w_arg_idx != i) 	    { 		FOR_ALL_WINDOWS(wpnext) 		{ 		    if (wpnext->w_arg_idx == i) 		    { 			if (keep_tabs) 			{ 			    new_curwin = wpnext; 			    new_curtab = curtab; 			} 			else if (wpnext->w_frame->fr_parent 						 != curwin->w_frame->fr_parent) 			{ 			    emsg(_(""E249: window layout changed unexpectedly"")); 			    i = count; 			    break; 			} 			else 			    win_move_after(wpnext, curwin); 			break; 		    } 		} 	    } 	} 	else if (split_ret == OK) 	{ 	    // trigger events for tab drop 	    if (tab_drop_empty_window && i == count - 1) 		--autocmd_no_enter; 	    if (!use_firstwin)		// split current window 	    { 		p_ea_save = p_ea; 		p_ea = TRUE;		// use space from all windows 		split_ret = win_split(0, WSP_ROOM | WSP_BELOW); 		p_ea = p_ea_save; 		if (split_ret == FAIL) 		    continue; 	    } 	    else    // first window: do autocmd for leaving this buffer 		--autocmd_no_leave;  	    // edit file ""i"" 	    curwin->w_arg_idx = i; 	    if (i == 0) 	    { 		new_curwin = curwin; 		new_curtab = curtab; 	    } 	    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL, 		      ECMD_ONE, 		      ((buf_hide(curwin->w_buffer) 			   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0) 						       + ECMD_OLDBUF, curwin); 	    if (tab_drop_empty_window && i == count - 1) 		++autocmd_no_enter; 	    if (use_firstwin) 		++autocmd_no_leave; 	    use_firstwin = FALSE; 	} 	ui_breakcheck();  	// When "":tab"" was used open a new tab for a new window repeatedly. 	if (had_tab > 0 && tabpage_index(NULL) <= p_tpm) 	    cmdmod.cmod_tab = 9999;     }      // Remove the ""lock"" on the argument list.     alist_unlink(alist);      --autocmd_no_enter;      // restore last referenced tabpage's curwin     if (last_curtab != new_curtab)     { 	if (valid_tabpage(last_curtab)) 	    goto_tabpage_tp(last_curtab, TRUE, TRUE); 	if (win_valid(last_curwin)) 	    win_enter(last_curwin, FALSE);     }     // to window with first arg     if (valid_tabpage(new_curtab)) 	goto_tabpage_tp(new_curtab, TRUE, TRUE);     if (win_valid(new_curwin)) 	win_enter(new_curwin, FALSE);      --autocmd_no_leave;     vim_free(opened); }"
"210420_CWE-119.c","CWE-119","fill_threshhold_buffer(byte *dest_strip, byte *src_strip, int src_width,                        int left_offset, int left_width, int num_tiles,                        int right_width) {     byte *ptr_out_temp = dest_strip;     int ii;      /* Left part */     memcpy(dest_strip, src_strip + left_offset, left_width);     ptr_out_temp += left_width;     /* Now the full parts */     for (ii = 0; ii < num_tiles; ii++){         memcpy(ptr_out_temp, src_strip, src_width);         ptr_out_temp += src_width;     }     /* Now the remainder */     memcpy(ptr_out_temp, src_strip, right_width); #ifdef PACIFY_VALGRIND     ptr_out_temp += right_width;     ii = (dest_strip-ptr_out_temp) % (LAND_BITS-1);     if (ii > 0)         memset(ptr_out_temp, 0, ii); #endif }"
"210453_CWE-120.c","CWE-120","jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream) { #define DATA_SIZE (LINE_SIZE * 8)      unsigned int cnt_2prn;     unsigned int count,tempcnt;     unsigned char vtp,cntc1,cntc2;     int line_size_color_plane;      byte data[DATA_SIZE];     byte plane_data[LINE_SIZE * 3];      /* Set initial condition for printer */     gp_fputs(""\033@"",prn_stream);      /* Send each scan line in turn */     {         int lnum;         int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);         int num_blank_lines = 0;          if (line_size > DATA_SIZE) {             emprintf2(pdev->memory, ""invalid resolution and/or width gives line_size = %d, max. is %d\n"",                       line_size, DATA_SIZE);             return_error(gs_error_rangecheck);         }          for ( lnum = 0; lnum < pdev->height; lnum++ ) {             byte *end_data = data + line_size;             gdev_prn_copy_scan_lines(pdev, lnum,                                      (byte *)data, line_size);             /* Remove trailing 0s. */             while ( end_data > data && end_data[-1] == 0 )                 end_data--;             if ( end_data == data ) {                 /* Blank line */                 num_blank_lines++;             } else {                 int i;                 byte *odp;                 byte *row;                  /* Pad with 0s to fill out the last */                 /* block of 8 bytes. */                 memset(end_data, 0, 7);                  /* Transpose the data to get pixel planes. */                 for ( i = 0, odp = plane_data; i < DATA_SIZE;                       i += 8, odp++                     ) { /* The following is for 16-bit machines */ #define spread3(c)\  { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }                     static ulong spr40[8] = spread3(0x40);                     static ulong spr8[8] = spread3(8);                     static ulong spr2[8] = spread3(2);                     register byte *dp = data + i;                     register ulong pword =                                      (spr40[dp[0]] << 1) +                                      (spr40[dp[1]]) +                                      (spr40[dp[2]] >> 1) +                                      (spr8[dp[3]] << 1) +                                      (spr8[dp[4]]) +                                      (spr8[dp[5]] >> 1) +                                      (spr2[dp[6]]) +                                      (spr2[dp[7]] >> 1);                     odp[0] = (byte)(pword >> 16);                     odp[LINE_SIZE] = (byte)(pword >> 8);                     odp[LINE_SIZE*2] = (byte)(pword);                 }                 /* Skip blank lines if any */                 if ( num_blank_lines > 0 ) {                     /* Do ""dot skips"" */                     while(num_blank_lines > 255) {                         gp_fputs(""\033e\377"",prn_stream);                         num_blank_lines -= 255;                     }                     vtp = num_blank_lines;                     gp_fprintf(prn_stream,""\033e%c"",vtp);                     num_blank_lines = 0;                 }                  /* Transfer raster graphics in the order R, G, B. */                 /* Apparently it is stored in B, G, R */                 /* Calculate the amount of data to send by what */                 /* Ghostscript tells us the scan line_size in (bytes) */                  count = line_size / 3;                 line_size_color_plane = count / 3;                 cnt_2prn = line_size_color_plane * 3 + 5;                 tempcnt = cnt_2prn;                 cntc1 = (tempcnt & 0xFF00) >> 8;                 cntc2 = (tempcnt & 0x00FF);                 gp_fprintf(prn_stream, ""\033[O%c%c\200\037"",cntc2,cntc1);                 gp_fputc('\000',prn_stream);                 gp_fputs(""\124\124"",prn_stream);                  for ( row = plane_data + LINE_SIZE * 2, i = 0;                       i < 3; row -= LINE_SIZE, i++ ) {                     int jj;                     byte ctemp;                     odp = row;                     /* Complement bytes */                     for (jj=0; jj< line_size_color_plane; jj++) {                         ctemp = *odp;                         *odp++ = ~ctemp;                     }                     gp_fwrite(row, sizeof(byte),                               line_size_color_plane, prn_stream);                 }             }         }     }      /* eject page */     gp_fputs(""\014"", prn_stream);      return 0; }"
"210484_CWE-125.c","CWE-125","static int io_read(struct io_kiocb *req, unsigned int issue_flags) { 	struct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs; 	struct kiocb *kiocb = &req->rw.kiocb; 	struct iov_iter __iter, *iter = &__iter; 	struct io_async_rw *rw = req->async_data; 	ssize_t io_size, ret, ret2; 	bool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;  	if (rw) { 		iter = &rw->iter; 		iovec = NULL; 	} else { 		ret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock); 		if (ret < 0) 			return ret; 	} 	io_size = iov_iter_count(iter); 	req->result = io_size;  	/* Ensure we clear previously set non-block flag */ 	if (!force_nonblock) 		kiocb->ki_flags &= ~IOCB_NOWAIT; 	else 		kiocb->ki_flags |= IOCB_NOWAIT;  	/* If the file doesn't support async, just async punt */ 	if (force_nonblock && !io_file_supports_async(req, READ)) { 		ret = io_setup_async_rw(req, iovec, inline_vecs, iter, true); 		return ret ?: -EAGAIN; 	}  	ret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size); 	if (unlikely(ret)) { 		kfree(iovec); 		return ret; 	}  	ret = io_iter_do_read(req, iter);  	if (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) { 		req->flags &= ~REQ_F_REISSUE; 		/* IOPOLL retry should happen for io-wq threads */ 		if (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL)) 			goto done; 		/* no retry on NONBLOCK nor RWF_NOWAIT */ 		if (req->flags & REQ_F_NOWAIT) 			goto done; 		/* some cases will consume bytes even on error returns */ 		iov_iter_revert(iter, io_size - iov_iter_count(iter)); 		ret = 0; 	} else if (ret == -EIOCBQUEUED) { 		goto out_free; 	} else if (ret <= 0 || ret == io_size || !force_nonblock || 		   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) { 		/* read all, failed, already did sync or don't want to retry */ 		goto done; 	}  	ret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true); 	if (ret2) 		return ret2;  	iovec = NULL; 	rw = req->async_data; 	/* now use our persistent iterator, if we aren't already */ 	iter = &rw->iter;  	do { 		io_size -= ret; 		rw->bytes_done += ret; 		/* if we can retry, do so with the callbacks armed */ 		if (!io_rw_should_retry(req)) { 			kiocb->ki_flags &= ~IOCB_WAITQ; 			return -EAGAIN; 		}  		/* 		 * Now retry read with the IOCB_WAITQ parts set in the iocb. If 		 * we get -EIOCBQUEUED, then we'll get a notification when the 		 * desired page gets unlocked. We can also get a partial read 		 * here, and if we do, then just retry at the new offset. 		 */ 		ret = io_iter_do_read(req, iter); 		if (ret == -EIOCBQUEUED) 			return 0; 		/* we got some bytes, but not all. retry. */ 		kiocb->ki_flags &= ~IOCB_WAITQ; 	} while (ret > 0 && ret < io_size); done: 	kiocb_done(kiocb, ret, issue_flags); out_free: 	/* it's faster to check here then delegate to kfree */ 	if (iovec) 		kfree(iovec); 	return 0; }"
"210511_CWE-787.c","CWE-787","win_close(win_T *win, int free_buf) {     win_T	*wp;     int		other_buffer = FALSE;     int		close_curwin = FALSE;     int		dir;     int		help_window = FALSE;     tabpage_T   *prev_curtab = curtab;     frame_T	*win_frame = win->w_frame->fr_parent; #ifdef FEAT_DIFF     int		had_diffmode = win->w_p_diff; #endif #ifdef MESSAGE_QUEUE     int		did_decrement = FALSE; #endif  #if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)     // Can close a popup window with a terminal if the job has finished.     if (may_close_term_popup() == OK) 	return OK; #endif     if (ERROR_IF_ANY_POPUP_WINDOW) 	return FAIL;      if (last_window())     { 	emsg(_(e_cannot_close_last_window)); 	return FAIL;     }      if (win->w_closing || (win->w_buffer != NULL 					       && win->w_buffer->b_locked > 0)) 	return FAIL; // window is already being closed     if (win_unlisted(win))     { 	emsg(_(e_cannot_close_autocmd_or_popup_window)); 	return FAIL;     }     if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())     { 	emsg(_(e_cannot_close_window_only_autocmd_window_would_remain)); 	return FAIL;     }      // When closing the last window in a tab page first go to another tab page     // and then close the window and the tab page to avoid that curwin and     // curtab are invalid while we are freeing memory.     if (close_last_window_tabpage(win, free_buf, prev_curtab))       return FAIL;      // When closing the help window, try restoring a snapshot after closing     // the window.  Otherwise clear the snapshot, it's now invalid.     if (bt_help(win->w_buffer)) 	help_window = TRUE;     else 	clear_snapshot(curtab, SNAP_HELP_IDX);      if (win == curwin)     { #ifdef FEAT_JOB_CHANNEL 	leaving_window(curwin); #endif 	/* 	 * Guess which window is going to be the new current window. 	 * This may change because of the autocommands (sigh). 	 */ 	wp = frame2win(win_altframe(win, NULL));  	/* 	 * Be careful: If autocommands delete the window or cause this window 	 * to be the last one left, return now. 	 */ 	if (wp->w_buffer != curbuf) 	{ 	    other_buffer = TRUE; 	    win->w_closing = TRUE; 	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf); 	    if (!win_valid(win)) 		return FAIL; 	    win->w_closing = FALSE; 	    if (last_window()) 		return FAIL; 	} 	win->w_closing = TRUE; 	apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf); 	if (!win_valid(win)) 	    return FAIL; 	win->w_closing = FALSE; 	if (last_window()) 	    return FAIL; #ifdef FEAT_EVAL 	// autocmds may abort script processing 	if (aborting()) 	    return FAIL; #endif     }  #ifdef FEAT_GUI     // Avoid trouble with scrollbars that are going to be deleted in     // win_free().     if (gui.in_use) 	out_flush(); #endif  #ifdef FEAT_PROP_POPUP     if (popup_win_closed(win) && !win_valid(win)) 	return FAIL; #endif      // Trigger WinClosed just before starting to free window-related resources.     trigger_winclosed(win);     // autocmd may have freed the window already.     if (!win_valid_any_tab(win)) 	return OK;      win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);      if (only_one_window() && win_valid(win) && win->w_buffer == NULL 	    && (last_window() || curtab != prev_curtab 		|| close_last_window_tabpage(win, free_buf, prev_curtab)))     { 	// Autocommands have closed all windows, quit now.  Restore 	// curwin->w_buffer, otherwise writing viminfo may fail. 	if (curwin->w_buffer == NULL) 	    curwin->w_buffer = curbuf; 	getout(0);     }      // Autocommands may have moved to another tab page.     if (curtab != prev_curtab && win_valid_any_tab(win) 						      && win->w_buffer == NULL)     { 	// Need to close the window anyway, since the buffer is NULL. 	win_close_othertab(win, FALSE, prev_curtab); 	return FAIL;     }      // Autocommands may have closed the window already or closed the only     // other window.     if (!win_valid(win) || last_window() 	    || close_last_window_tabpage(win, free_buf, prev_curtab)) 	return FAIL;      // Now we are really going to close the window.  Disallow any autocommand     // to split a window to avoid trouble.     // Also bail out of parse_queued_messages() to avoid it tries to update the     // screen.     ++split_disallowed; #ifdef MESSAGE_QUEUE     ++dont_parse_messages; #endif      // Free the memory used for the window and get the window that received     // the screen space.     wp = win_free_mem(win, &dir, NULL);      if (help_window)     { 	// Closing the help window moves the cursor back to the current window 	// of the snapshot. 	win_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);  	if (win_valid(prev_win)) 	    wp = prev_win;     }      // Make sure curwin isn't invalid.  It can cause severe trouble when     // printing an error message.  For win_equal() curbuf needs to be valid     // too.     if (win == curwin)     { 	curwin = wp; #ifdef FEAT_QUICKFIX 	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer)) 	{ 	    /* 	     * If the cursor goes to the preview or the quickfix window, try 	     * finding another window to go to. 	     */ 	    for (;;) 	    { 		if (wp->w_next == NULL) 		    wp = firstwin; 		else 		    wp = wp->w_next; 		if (wp == curwin) 		    break; 		if (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer)) 		{ 		    curwin = wp; 		    break; 		} 	    } 	} #endif 	curbuf = curwin->w_buffer; 	close_curwin = TRUE;  	// The cursor position may be invalid if the buffer changed after last 	// using the window. 	check_cursor();     }     if (p_ea && (*p_ead == 'b' || *p_ead == dir)) 	// If the frame of the closed window contains the new current window, 	// only resize that frame.  Otherwise resize all windows. 	win_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);     else 	win_comp_pos();     if (close_curwin)     { 	// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages 	// before autocommands. #ifdef MESSAGE_QUEUE 	did_decrement = #else 	(void) #endif 	    win_enter_ext(wp, 		WEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS 		      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES); 	if (other_buffer) 	    // careful: after this wp and win may be invalid! 	    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);     }      --split_disallowed; #ifdef MESSAGE_QUEUE     if (!did_decrement) 	--dont_parse_messages; #endif      /*      * If last window has a status line now and we don't want one,      * remove the status line.      */     last_status(FALSE);      // After closing the help window, try restoring the window layout from     // before it was opened.     if (help_window) 	restore_snapshot(SNAP_HELP_IDX, close_curwin);  #ifdef FEAT_DIFF     // If the window had 'diff' set and now there is only one window left in     // the tab page with 'diff' set, and ""closeoff"" is in 'diffopt', then     // execute "":diffoff!"".     if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)     { 	int	diffcount = 0; 	win_T	*dwin;  	FOR_ALL_WINDOWS(dwin) 	    if (dwin->w_p_diff) 		++diffcount; 	if (diffcount == 1) 	    do_cmdline_cmd((char_u *)""diffoff!"");     } #endif  #if defined(FEAT_GUI)     // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.     if (gui.in_use && !win_hasvertsplit()) 	gui_init_which_components(NULL); #endif      redraw_all_later(NOT_VALID);     return OK; }"
"210520_CWE-125.c","CWE-125","get_lisp_indent(void) {     pos_T	*pos, realpos, paren;     int		amount;     char_u	*that;     colnr_T	col;     colnr_T	firsttry;     int		parencount, quotecount;     int		vi_lisp;      // Set vi_lisp to use the vi-compatible method     vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);      realpos = curwin->w_cursor;     curwin->w_cursor.col = 0;      if ((pos = findmatch(NULL, '(')) == NULL) 	pos = findmatch(NULL, '[');     else     { 	paren = *pos; 	pos = findmatch(NULL, '['); 	if (pos == NULL || LT_POSP(pos, &paren)) 	    pos = &paren;     }     if (pos != NULL)     { 	// Extra trick: Take the indent of the first previous non-white 	// line that is at the same () level. 	amount = -1; 	parencount = 0;  	while (--curwin->w_cursor.lnum >= pos->lnum) 	{ 	    if (linewhite(curwin->w_cursor.lnum)) 		continue; 	    for (that = ml_get_curline(); *that != NUL; ++that) 	    { 		if (*that == ';') 		{ 		    while (*(that + 1) != NUL) 			++that; 		    continue; 		} 		if (*that == '\\') 		{ 		    if (*(that + 1) != NUL) 			++that; 		    continue; 		} 		if (*that == '""' && *(that + 1) != NUL) 		{ 		    while (*++that && *that != '""') 		    { 			// skipping escaped characters in the string 			if (*that == '\\') 			{ 			    if (*++that == NUL) 				break; 			    if (that[1] == NUL) 			    { 				++that; 				break; 			    } 			} 		    } 		    if (*that == NUL) 			break; 		} 		if (*that == '(' || *that == '[') 		    ++parencount; 		else if (*that == ')' || *that == ']') 		    --parencount; 	    } 	    if (parencount == 0) 	    { 		amount = get_indent(); 		break; 	    } 	}  	if (amount == -1) 	{ 	    curwin->w_cursor.lnum = pos->lnum; 	    curwin->w_cursor.col = pos->col; 	    col = pos->col;  	    that = ml_get_curline();  	    if (vi_lisp && get_indent() == 0) 		amount = 2; 	    else 	    { 		char_u *line = that;  		amount = 0; 		while (*that && col) 		{ 		    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); 		    col--; 		}  		// Some keywords require ""body"" indenting rules (the 		// non-standard-lisp ones are Scheme special forms): 		// 		// (let ((a 1))    instead    (let ((a 1)) 		//   (...))	      of	   (...))  		if (!vi_lisp && (*that == '(' || *that == '[') 						      && lisp_match(that + 1)) 		    amount += 2; 		else 		{ 		    that++; 		    amount++; 		    firsttry = amount;  		    while (VIM_ISWHITE(*that)) 		    { 			amount += lbr_chartabsize(line, that, (colnr_T)amount); 			++that; 		    }  		    if (*that && *that != ';') // not a comment line 		    { 			// test *that != '(' to accommodate first let/do 			// argument if it is more than one line 			if (!vi_lisp && *that != '(' && *that != '[') 			    firsttry++;  			parencount = 0; 			quotecount = 0;  			if (vi_lisp 				|| (*that != '""' 				    && *that != '\'' 				    && *that != '#' 				    && (*that < '0' || *that > '9'))) 			{ 			    while (*that 				    && (!VIM_ISWHITE(*that) 					|| quotecount 					|| parencount) 				    && (!((*that == '(' || *that == '[') 					    && !quotecount 					    && !parencount 					    && vi_lisp))) 			    { 				if (*that == '""') 				    quotecount = !quotecount; 				if ((*that == '(' || *that == '[') 							       && !quotecount) 				    ++parencount; 				if ((*that == ')' || *that == ']') 							       && !quotecount) 				    --parencount; 				if (*that == '\\' && *(that+1) != NUL) 				    amount += lbr_chartabsize_adv( 						line, &that, (colnr_T)amount); 				amount += lbr_chartabsize_adv( 						line, &that, (colnr_T)amount); 			    } 			} 			while (VIM_ISWHITE(*that)) 			{ 			    amount += lbr_chartabsize( 						 line, that, (colnr_T)amount); 			    that++; 			} 			if (!*that || *that == ';') 			    amount = firsttry; 		    } 		} 	    } 	}     }     else 	amount = 0;	// no matching '(' or '[' found, use zero indent      curwin->w_cursor = realpos;      return amount; }"
"210527_CWE-415.c","CWE-415","static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb, 				       struct net_device *netdev) { 	struct mcba_priv *priv = netdev_priv(netdev); 	struct can_frame *cf = (struct can_frame *)skb->data; 	struct mcba_usb_ctx *ctx = NULL; 	struct net_device_stats *stats = &priv->netdev->stats; 	u16 sid; 	int err; 	struct mcba_usb_msg_can usb_msg = { 		.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV 	};  	if (can_dropped_invalid_skb(netdev, skb)) 		return NETDEV_TX_OK;  	ctx = mcba_usb_get_free_ctx(priv, cf); 	if (!ctx) 		return NETDEV_TX_BUSY;  	if (cf->can_id & CAN_EFF_FLAG) { 		/* SIDH    | SIDL                 | EIDH   | EIDL 		 * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0 		 */ 		sid = MCBA_SIDL_EXID_MASK; 		/* store 28-18 bits */ 		sid |= (cf->can_id & 0x1ffc0000) >> 13; 		/* store 17-16 bits */ 		sid |= (cf->can_id & 0x30000) >> 16; 		put_unaligned_be16(sid, &usb_msg.sid);  		/* store 15-0 bits */ 		put_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid); 	} else { 		/* SIDH   | SIDL 		 * 10 - 3 | 2 1 0 x x x x x 		 */ 		put_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5, 				   &usb_msg.sid); 		usb_msg.eid = 0; 	}  	usb_msg.dlc = cf->len;  	memcpy(usb_msg.data, cf->data, usb_msg.dlc);  	if (cf->can_id & CAN_RTR_FLAG) 		usb_msg.dlc |= MCBA_DLC_RTR_MASK;  	can_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);  	err = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx); 	if (err) 		goto xmit_failed;  	return NETDEV_TX_OK;  xmit_failed: 	can_free_echo_skb(priv->netdev, ctx->ndx, NULL); 	mcba_usb_free_ctx(ctx); 	dev_kfree_skb(skb); 	stats->tx_dropped++;  	return NETDEV_TX_OK; }"
"210551_CWE-125.c","CWE-125","expand_case_fold_string(Node* node, regex_t* reg) { #define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8    int r, n, len, alt_num;   UChar *start, *end, *p;   Node *top_root, *root, *snode, *prev_node;   OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];   StrNode* sn = STR_(node);    if (NODE_STRING_IS_AMBIG(node)) return 0;    start = sn->s;   end   = sn->end;   if (start >= end) return 0;    r = 0;   top_root = root = prev_node = snode = NULL_NODE;   alt_num = 1;   p = start;   while (p < end) {     n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag, p, end,                                            items);     if (n < 0) {       r = n;       goto err;     }      len = enclen(reg->enc, p);      if (n == 0) {       if (IS_NULL(snode)) {         if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {           top_root = root = onig_node_list_add(NULL_NODE, prev_node);           if (IS_NULL(root)) {             onig_node_free(prev_node);             goto mem_err;           }         }          prev_node = snode = onig_node_new_str(NULL, NULL);         if (IS_NULL(snode)) goto mem_err;         if (IS_NOT_NULL(root)) {           if (IS_NULL(onig_node_list_add(root, snode))) {             onig_node_free(snode);             goto mem_err;           }         }       }        r = onig_node_str_cat(snode, p, p + len);       if (r != 0) goto err;     }     else {       alt_num *= (n + 1);       if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {         top_root = root = onig_node_list_add(NULL_NODE, prev_node);         if (IS_NULL(root)) {           onig_node_free(prev_node);           goto mem_err;         }       }        r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);       if (r < 0) goto mem_err;       if (r == 1) {         if (IS_NULL(root)) {           top_root = prev_node;         }         else {           if (IS_NULL(onig_node_list_add(root, prev_node))) {             onig_node_free(prev_node);             goto mem_err;           }         }          root = NODE_CAR(prev_node);       }       else { /* r == 0 */         if (IS_NOT_NULL(root)) {           if (IS_NULL(onig_node_list_add(root, prev_node))) {             onig_node_free(prev_node);             goto mem_err;           }         }       }        snode = NULL_NODE;     }      p += len;   }    if (p < end) {     Node *srem;      r = expand_case_fold_make_rem_string(&srem, p, end, reg);     if (r != 0) goto mem_err;      if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {       top_root = root = onig_node_list_add(NULL_NODE, prev_node);       if (IS_NULL(root)) {         onig_node_free(srem);         onig_node_free(prev_node);         goto mem_err;       }     }      if (IS_NULL(root)) {       prev_node = srem;     }     else {       if (IS_NULL(onig_node_list_add(root, srem))) {         onig_node_free(srem);         goto mem_err;       }     }   }    /* ending */   top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);   swap_node(node, top_root);   onig_node_free(top_root);   return 0;   mem_err:   r = ONIGERR_MEMORY;   err:   onig_node_free(top_root);   return r; }"
"210555_CWE-190.c","CWE-190","vhost_backend_cleanup(struct virtio_net *dev) { 	if (dev->mem) { 		free_mem_region(dev); 		rte_free(dev->mem); 		dev->mem = NULL; 	}  	free(dev->guest_pages); 	dev->guest_pages = NULL;  	if (dev->log_addr) { 		munmap((void *)(uintptr_t)dev->log_addr, dev->log_size); 		dev->log_addr = 0; 	}  	if (dev->slave_req_fd >= 0) { 		close(dev->slave_req_fd); 		dev->slave_req_fd = -1; 	}  	if (dev->postcopy_ufd >= 0) { 		close(dev->postcopy_ufd); 		dev->postcopy_ufd = -1; 	}  	dev->postcopy_listening = 0; }"
"210570_CWE-787.c","CWE-787","static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) { 	D eprintf (""Dragons at 0x%x\n"", off); 	ut64 size = r_buf_size (buf); 	if (off >= size) { 		return NULL; 	} 	size -= off; 	if (!size) { 		return NULL; 	} 	ut8 *b = malloc (size); 	if (!b) { 		return NULL; 	} 	int available = r_buf_read_at (buf, off, b, size); 	if (available != size) { 		eprintf (""Warning: r_buf_read_at failed\n""); 		return NULL; 	} #if 0 	// after the list of sections, there's a bunch of unknown 	// data, brobably dwords, and then the same section list again 	// this function aims to parse it. 	0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..                          n_segments ----.          .--- how many sections ? 	0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U.......... 	             .---- how many symbols? 0xc7 	0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................ 	0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U.. 	0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F.. 	0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............ 	0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................ 	0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT.. 	0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................ 	0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA.. 	0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................ 	0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM.. 	0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................ 	0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED 	0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i.. #endif 	// eprintf (""Dragon's magic:\n""); 	int magicCombo = 0; 	if (!memcmp (""\x1a\x2b\xb2\xa1"", b, 4)) { // 0x130  ? 		magicCombo++; 	} 	if (!memcmp (""\x1a\x2b\xb2\xa1"", b + 8, 4)) { 		magicCombo++; 	} 	if (magicCombo != 2) { 		// hack for C22F7494 		available = r_buf_read_at (buf, off - 8, b, size); 		if (available != size) { 			eprintf (""Warning: r_buf_read_at failed\n""); 			return NULL; 		} 		if (!memcmp (""\x1a\x2b\xb2\xa1"", b, 4)) { // 0x130  ? 			off -= 8; 		} else { 			eprintf (""0x%08x  parsing error: invalid magic retry\n"", off); 		} 	} 	D eprintf (""0x%08x  magic  OK\n"", off); 	D { 		const int e0ss = r_read_le32 (b + 12); 		eprintf (""0x%08x  eoss   0x%x\n"", off + 12, e0ss); 	} 	free (b); 	return r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name); }"
"210571_CWE-401.c","CWE-401","int cx23888_ir_probe(struct cx23885_dev *dev) { 	struct cx23888_ir_state *state; 	struct v4l2_subdev *sd; 	struct v4l2_subdev_ir_parameters default_params; 	int ret;  	state = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL); 	if (state == NULL) 		return -ENOMEM;  	spin_lock_init(&state->rx_kfifo_lock); 	if (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL)) 		return -ENOMEM;  	state->dev = dev; 	sd = &state->sd;  	v4l2_subdev_init(sd, &cx23888_ir_controller_ops); 	v4l2_set_subdevdata(sd, state); 	/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */ 	snprintf(sd->name, sizeof(sd->name), ""%s/888-ir"", dev->name); 	sd->grp_id = CX23885_HW_888_IR;  	ret = v4l2_device_register_subdev(&dev->v4l2_dev, sd); 	if (ret == 0) { 		/* 		 * Ensure no interrupts arrive from '888 specific conditions, 		 * since we ignore them in this driver to have commonality with 		 * similar IR controller cores. 		 */ 		cx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);  		mutex_init(&state->rx_params_lock); 		default_params = default_rx_params; 		v4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);  		mutex_init(&state->tx_params_lock); 		default_params = default_tx_params; 		v4l2_subdev_call(sd, ir, tx_s_parameters, &default_params); 	} else { 		kfifo_free(&state->rx_kfifo); 	} 	return ret; }"
"210619_CWE-787.c","CWE-787","u_undo_end(     int		did_undo,	// just did an undo     int		absolute)	// used "":undo N"" {     char	*msgstr;     u_header_T	*uhp;     char_u	msgbuf[80];  #ifdef FEAT_FOLDING     if ((fdo_flags & FDO_UNDO) && KeyTyped) 	foldOpenCursor(); #endif      if (global_busy	    // no messages now, wait until global is finished 	    || !messaging())  // 'lazyredraw' set, don't do messages now 	return;      if (curbuf->b_ml.ml_flags & ML_EMPTY) 	--u_newcount;      u_oldcount -= u_newcount;     if (u_oldcount == -1) 	msgstr = N_(""more line"");     else if (u_oldcount < 0) 	msgstr = N_(""more lines"");     else if (u_oldcount == 1) 	msgstr = N_(""line less"");     else if (u_oldcount > 1) 	msgstr = N_(""fewer lines"");     else     { 	u_oldcount = u_newcount; 	if (u_newcount == 1) 	    msgstr = N_(""change""); 	else 	    msgstr = N_(""changes"");     }      if (curbuf->b_u_curhead != NULL)     { 	// For "":undo N"" we prefer a ""after #N"" message. 	if (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL) 	{ 	    uhp = curbuf->b_u_curhead->uh_next.ptr; 	    did_undo = FALSE; 	} 	else if (did_undo) 	    uhp = curbuf->b_u_curhead; 	else 	    uhp = curbuf->b_u_curhead->uh_next.ptr;     }     else 	uhp = curbuf->b_u_newhead;      if (uhp == NULL) 	*msgbuf = NUL;     else 	add_time(msgbuf, sizeof(msgbuf), uhp->uh_time);  #ifdef FEAT_CONCEAL     { 	win_T	*wp;  	FOR_ALL_WINDOWS(wp) 	{ 	    if (wp->w_buffer == curbuf && wp->w_p_cole > 0) 		redraw_win_later(wp, NOT_VALID); 	}     } #endif      smsg_attr_keep(0, _(""%ld %s; %s #%ld  %s""), 	    u_oldcount < 0 ? -u_oldcount : u_oldcount, 	    _(msgstr), 	    did_undo ? _(""before"") : _(""after""), 	    uhp == NULL ? 0L : uhp->uh_seq, 	    msgbuf); }"
"210620_CWE-415.c","CWE-415","static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev) { 	struct virtproc_info *vrp = vdev->priv; 	struct virtio_rpmsg_channel *vch; 	struct rpmsg_device *rpdev_ctrl; 	int err = 0;  	vch = kzalloc(sizeof(*vch), GFP_KERNEL); 	if (!vch) 		return ERR_PTR(-ENOMEM);  	/* Link the channel to the vrp */ 	vch->vrp = vrp;  	/* Assign public information to the rpmsg_device */ 	rpdev_ctrl = &vch->rpdev; 	rpdev_ctrl->ops = &virtio_rpmsg_ops;  	rpdev_ctrl->dev.parent = &vrp->vdev->dev; 	rpdev_ctrl->dev.release = virtio_rpmsg_release_device; 	rpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);  	err = rpmsg_ctrldev_register_device(rpdev_ctrl); 	if (err) { 		kfree(vch); 		return ERR_PTR(err); 	}  	return rpdev_ctrl; }"
"210636_CWE-416.c","CWE-416","static void mkiss_close(struct tty_struct *tty) { 	struct mkiss *ax;  	write_lock_irq(&disc_data_lock); 	ax = tty->disc_data; 	tty->disc_data = NULL; 	write_unlock_irq(&disc_data_lock);  	if (!ax) 		return;  	/* 	 * We have now ensured that nobody can start using ap from now on, but 	 * we have to wait for all existing users to finish. 	 */ 	if (!refcount_dec_and_test(&ax->refcnt)) 		wait_for_completion(&ax->dead); 	/* 	 * Halt the transmit queue so that a new transmit cannot scribble 	 * on our buffers 	 */ 	netif_stop_queue(ax->dev);  	ax->tty = NULL;  	unregister_netdev(ax->dev);  	/* Free all AX25 frame buffers after unreg. */ 	kfree(ax->rbuff); 	kfree(ax->xbuff);  	free_netdev(ax->dev); }"
"210669_CWE-401.c","CWE-401","static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception) {   BMPInfo     bmp_info;    Image     *image;    IndexPacket     index;    MagickBooleanType     status;    MagickOffsetType     offset,     start_position;    MemoryInfo     *pixel_info;    register IndexPacket     *indexes;    register PixelPacket     *q;    register ssize_t     i,     x;    register unsigned char     *p;    size_t     bit,     bytes_per_line,     length;    ssize_t     count,     y;    unsigned char     magick[12],     *pixels;    unsigned int     blue,     green,     offset_bits,     red;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Determine if this a BMP file.   */   (void) memset(&bmp_info,0,sizeof(bmp_info));   bmp_info.ba_offset=0;   start_position=0;   offset_bits=0;   count=ReadBlob(image,2,magick);   if (count != 2)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   do   {     LongPixelPacket       shift;      PixelPacket       quantum_bits;      /*       Verify BMP identifier.     */     if (bmp_info.ba_offset == 0)       start_position=TellBlob(image)-2;     bmp_info.ba_offset=0;     while (LocaleNCompare((char *) magick,""BA"",2) == 0)     {       bmp_info.file_size=ReadBlobLSBLong(image);       bmp_info.ba_offset=ReadBlobLSBLong(image);       bmp_info.offset_bits=ReadBlobLSBLong(image);       count=ReadBlob(image,2,magick);       if (count != 2)         break;     }     if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Magick: %c%c"",         magick[0],magick[1]);     if ((count != 2) || ((LocaleNCompare((char *) magick,""BM"",2) != 0) &&         (LocaleNCompare((char *) magick,""CI"",2) != 0)))       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     bmp_info.file_size=ReadBlobLSBLong(image);     (void) ReadBlobLSBLong(image);      if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),          ""  File_size in header:  %u bytes"",bmp_info.file_size);      bmp_info.offset_bits=ReadBlobLSBLong(image);     bmp_info.size=ReadBlobLSBLong(image);     if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  BMP size: %u"",         bmp_info.size);     if (bmp_info.size == 12)       {         /*           OS/2 BMP image file.         */         (void) CopyMagickString(image->magick,""BMP2"",MaxTextExtent);         bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));         bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));         bmp_info.planes=ReadBlobLSBShort(image);         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);         bmp_info.x_pixels=0;         bmp_info.y_pixels=0;         bmp_info.number_colors=0;         bmp_info.compression=BI_RGB;         bmp_info.image_size=0;         bmp_info.alpha_mask=0;         if (image->debug != MagickFalse)           {             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Format: OS/2 Bitmap"");             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)               bmp_info.height);           }       }     else       {         /*           Microsoft Windows BMP image file.         */         if (bmp_info.size < 40)           ThrowReaderException(CorruptImageError,""NonOS2HeaderSizeError"");         bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);         bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);         bmp_info.planes=ReadBlobLSBShort(image);         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);         bmp_info.compression=ReadBlobLSBLong(image);         bmp_info.image_size=ReadBlobLSBLong(image);         bmp_info.x_pixels=ReadBlobLSBLong(image);         bmp_info.y_pixels=ReadBlobLSBLong(image);         bmp_info.number_colors=ReadBlobLSBLong(image);         bmp_info.colors_important=ReadBlobLSBLong(image);         if (image->debug != MagickFalse)           {             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Format: MS Windows bitmap"");             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)               bmp_info.height);             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Bits per pixel: %.20g"",(double) bmp_info.bits_per_pixel);             switch (bmp_info.compression)             {               case BI_RGB:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RGB"");                 break;               }               case BI_RLE4:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RLE4"");                 break;               }               case BI_RLE8:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RLE8"");                 break;               }               case BI_BITFIELDS:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_BITFIELDS"");                 break;               }               case BI_PNG:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_PNG"");                 break;               }               case BI_JPEG:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_JPEG"");                 break;               }               default:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: UNKNOWN (%u)"",bmp_info.compression);               }             }             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Number of colors: %u"",bmp_info.number_colors);           }         bmp_info.red_mask=ReadBlobLSBLong(image);         bmp_info.green_mask=ReadBlobLSBLong(image);         bmp_info.blue_mask=ReadBlobLSBLong(image);         if (bmp_info.size > 40)           {             double               gamma;              /*               Read color management information.             */             bmp_info.alpha_mask=ReadBlobLSBLong(image);             bmp_info.colorspace=ReadBlobLSBSignedLong(image);             /*               Decode 2^30 fixed point formatted CIE primaries.             */ #           define BMP_DENOM ((double) 0x40000000)             bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;              gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+               bmp_info.red_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.red_primary.x*=gamma;             bmp_info.red_primary.y*=gamma;             image->chromaticity.red_primary.x=bmp_info.red_primary.x;             image->chromaticity.red_primary.y=bmp_info.red_primary.y;              gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+               bmp_info.green_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.green_primary.x*=gamma;             bmp_info.green_primary.y*=gamma;             image->chromaticity.green_primary.x=bmp_info.green_primary.x;             image->chromaticity.green_primary.y=bmp_info.green_primary.y;              gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+               bmp_info.blue_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.blue_primary.x*=gamma;             bmp_info.blue_primary.y*=gamma;             image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;             image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;              /*               Decode 16^16 fixed point formatted gamma_scales.             */             bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;             bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;             bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;             /*               Compute a single gamma from the BMP 3-channel gamma.             */             image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+               bmp_info.gamma_scale.z)/3.0;           }         else           (void) CopyMagickString(image->magick,""BMP3"",MaxTextExtent);          if (bmp_info.size > 108)           {             size_t               intent;              /*               Read BMP Version 5 color management information.             */             intent=ReadBlobLSBLong(image);             switch ((int) intent)             {               case LCS_GM_BUSINESS:               {                 image->rendering_intent=SaturationIntent;                 break;               }               case LCS_GM_GRAPHICS:               {                 image->rendering_intent=RelativeIntent;                 break;               }               case LCS_GM_IMAGES:               {                 image->rendering_intent=PerceptualIntent;                 break;               }               case LCS_GM_ABS_COLORIMETRIC:               {                 image->rendering_intent=AbsoluteIntent;                 break;               }             }             (void) ReadBlobLSBLong(image);  /* Profile data */             (void) ReadBlobLSBLong(image);  /* Profile size */             (void) ReadBlobLSBLong(image);  /* Reserved byte */           }       }     if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,         ""LengthAndFilesizeDoNotMatch"",""`%s'"",image->filename);     else       if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))         (void) ThrowMagickException(exception,GetMagickModule(),           CorruptImageWarning,""LengthAndFilesizeDoNotMatch"",""`%s'"",           image->filename);     if (bmp_info.width <= 0)       ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");     if (bmp_info.height == 0)       ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");     if (bmp_info.planes != 1)       ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");     if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&         (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&         (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if (bmp_info.bits_per_pixel < 16 &&         bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))       ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");     if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     switch (bmp_info.compression)     {       case BI_RGB:         image->compression=NoCompression;         break;       case BI_RLE8:       case BI_RLE4:         image->compression=RLECompression;         break;       case BI_BITFIELDS:         break;       case BI_JPEG:         ThrowReaderException(CoderError,""JPEGCompressNotSupported"");       case BI_PNG:         ThrowReaderException(CoderError,""PNGCompressNotSupported"");       default:         ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");     }     image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);     image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);     image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;     image->matte=((bmp_info.alpha_mask != 0) &&       (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;     if (bmp_info.bits_per_pixel < 16)       {         size_t           one;          image->storage_class=PseudoClass;         image->colors=bmp_info.number_colors;         one=1;         if (image->colors == 0)           image->colors=one << bmp_info.bits_per_pixel;       }     image->x_resolution=(double) bmp_info.x_pixels/100.0;     image->y_resolution=(double) bmp_info.y_pixels/100.0;     image->units=PixelsPerCentimeterResolution;     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     status=SetImageExtent(image,image->columns,image->rows);     if (status == MagickFalse)       {         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     if (image->storage_class == PseudoClass)       {         unsigned char           *bmp_colormap;          size_t           packet_size;          /*           Read BMP raster colormap.         */         if (image->debug != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Reading colormap of %.20g colors"",(double) image->colors);         if (AcquireImageColormap(image,image->colors) == MagickFalse)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)           image->colors,4*sizeof(*bmp_colormap));         if (bmp_colormap == (unsigned char *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         if ((bmp_info.size == 12) || (bmp_info.size == 64))           packet_size=3;         else           packet_size=4;         offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);         if (offset < 0)           {             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");           }         count=ReadBlob(image,packet_size*image->colors,bmp_colormap);         if (count != (ssize_t) (packet_size*image->colors))           {             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);             ThrowReaderException(CorruptImageError,               ""InsufficientImageDataInFile"");           }         p=bmp_colormap;         for (i=0; i < (ssize_t) image->colors; i++)         {           image->colormap[i].blue=ScaleCharToQuantum(*p++);           image->colormap[i].green=ScaleCharToQuantum(*p++);           image->colormap[i].red=ScaleCharToQuantum(*p++);           if (packet_size == 4)             p++;         }         bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);       }     /*       Read image data.     */     if (bmp_info.offset_bits == offset_bits)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     offset_bits=bmp_info.offset_bits;     offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);     if (offset < 0)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     if (bmp_info.compression == BI_RLE4)       bmp_info.bits_per_pixel<<=1;     bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);     length=(size_t) bytes_per_line*image->rows;     if (((MagickSizeType) length/8) > GetBlobSize(image))       ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");     if ((bmp_info.compression == BI_RGB) ||         (bmp_info.compression == BI_BITFIELDS))       {         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,           image->columns+256UL)*sizeof(*pixels));         if (pixel_info == (MemoryInfo *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);         if (image->debug != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Reading pixels (%.20g bytes)"",(double) length);         count=ReadBlob(image,length,pixels);         if (count != (ssize_t) length)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""InsufficientImageDataInFile"");           }       }     else       {         /*           Convert run-length encoded raster pixels.         */         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,           image->columns+256UL)*sizeof(*pixels));         if (pixel_info == (MemoryInfo *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);         status=DecodeImage(image,bmp_info.compression,pixels,           image->columns*image->rows);         if (status == MagickFalse)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnableToRunlengthDecodeImage"");           }       }     /*       Convert BMP raster image to pixel packets.     */     if (bmp_info.compression == BI_RGB)       {         /*           We should ignore the alpha value in BMP3 files but there have been           reports about 32 bit files with alpha. We do a quick check to see if           the alpha channel contains a value that is not zero (default value).           If we find a non zero value we asume the program that wrote the file           wants to use the alpha channel.         */         if ((image->matte == MagickFalse) && (bmp_info.size == 40) &&             (bmp_info.bits_per_pixel == 32))           {             bytes_per_line=4*(image->columns);             for (y=(ssize_t) image->rows-1; y >= 0; y--)             {               p=pixels+(image->rows-y-1)*bytes_per_line;               for (x=0; x < (ssize_t) image->columns; x++)               {                 if (*(p+3) != 0)                   {                     image->matte=MagickTrue;                     y=-1;                     break;                   }                 p+=4;               }             }           }         bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;         bmp_info.red_mask=0x00ff0000U;         bmp_info.green_mask=0x0000ff00U;         bmp_info.blue_mask=0x000000ffU;         if (bmp_info.bits_per_pixel == 16)           {             /*               RGB555.             */             bmp_info.red_mask=0x00007c00U;             bmp_info.green_mask=0x000003e0U;             bmp_info.blue_mask=0x0000001fU;           }       }     (void) memset(&shift,0,sizeof(shift));     (void) memset(&quantum_bits,0,sizeof(quantum_bits));     if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))       {         register size_t           sample;          /*           Get shift and quantum bits info from bitfield masks.         */         if (bmp_info.red_mask != 0)           while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)           {             shift.red++;             if (shift.red > 32U)               break;           }         if (bmp_info.green_mask != 0)           while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)           {             shift.green++;             if (shift.green > 32U)               break;           }         if (bmp_info.blue_mask != 0)           while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)           {             shift.blue++;             if (shift.blue > 32U)               break;           }         if (bmp_info.alpha_mask != 0)           while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)           {             shift.opacity++;             if (shift.opacity > 32U)               break;           }         sample=shift.red;         while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);         sample=shift.green;         while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);         sample=shift.blue;         while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);         sample=shift.opacity;         while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-           shift.opacity);       }     switch (bmp_info.bits_per_pixel)     {       case 1:       {         /*           Convert bitmap scanline.         */         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=0; x < ((ssize_t) image->columns-7); x+=8)           {             for (bit=0; bit < 8; bit++)             {               index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);               SetPixelIndex(indexes+x+bit,index);               q++;             }             p++;           }           if ((image->columns % 8) != 0)             {               for (bit=0; bit < (image->columns % 8); bit++)               {                 index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);                 SetPixelIndex(indexes+x+bit,index);               }               p++;             }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 4:       {         /*           Convert PseudoColor scanline.         */         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=0; x < ((ssize_t) image->columns-1); x+=2)           {             (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),               &index,exception);             SetPixelIndex(indexes+x,index);             (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,               exception);             SetPixelIndex(indexes+x+1,index);             p++;           }           if ((image->columns % 2) != 0)             {               (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0xf),                 &index,exception);               SetPixelIndex(indexes+(x++),index);               p++;             }           if (x < (ssize_t) image->columns)             break;           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 8:       {         /*           Convert PseudoColor scanline.         */         if ((bmp_info.compression == BI_RLE8) ||             (bmp_info.compression == BI_RLE4))           bytes_per_line=image->columns;         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=(ssize_t) image->columns; x != 0; --x)           {             (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);             SetPixelIndex(indexes,index);             indexes++;             p++;             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 16:       {         unsigned int           alpha,           pixel;          /*           Convert bitfield encoded 16-bit PseudoColor scanline.         */         if (bmp_info.compression != BI_RGB &&             bmp_info.compression != BI_BITFIELDS)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnrecognizedImageCompression"");           }         bytes_per_line=2*(image->columns+image->columns % 2);         image->storage_class=DirectClass;         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             pixel=(unsigned int) (*p++);             pixel|=(*p++) << 8;             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;             if (quantum_bits.red == 5)               red|=((red & 0xe000) >> 5);             if (quantum_bits.red <= 8)               red|=((red & 0xff00) >> 8);             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;             if (quantum_bits.green == 5)               green|=((green & 0xe000) >> 5);             if (quantum_bits.green == 6)               green|=((green & 0xc000) >> 6);             if (quantum_bits.green <= 8)               green|=((green & 0xff00) >> 8);             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;             if (quantum_bits.blue == 5)               blue|=((blue & 0xe000) >> 5);             if (quantum_bits.blue <= 8)               blue|=((blue & 0xff00) >> 8);             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));             SetPixelOpacity(q,OpaqueOpacity);             if (image->matte != MagickFalse)               {                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;                 if (quantum_bits.opacity <= 8)                   alpha|=((alpha & 0xff00) >> 8);                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));               }             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case 24:       {         /*           Convert DirectColor scanline.         */         bytes_per_line=4*((image->columns*24+31)/32);         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             SetPixelBlue(q,ScaleCharToQuantum(*p++));             SetPixelGreen(q,ScaleCharToQuantum(*p++));             SetPixelRed(q,ScaleCharToQuantum(*p++));             SetPixelOpacity(q,OpaqueOpacity);             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case 32:       {         /*           Convert bitfield encoded DirectColor scanline.         */         if ((bmp_info.compression != BI_RGB) &&             (bmp_info.compression != BI_BITFIELDS))           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnrecognizedImageCompression"");           }         bytes_per_line=4*(image->columns);         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           unsigned int             alpha,             pixel;            p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             pixel=(unsigned int) (*p++);             pixel|=((unsigned int) *p++ << 8);             pixel|=((unsigned int) *p++ << 16);             pixel|=((unsigned int) *p++ << 24);             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;             if (quantum_bits.red == 8)               red|=(red >> 8);             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;             if (quantum_bits.green == 8)               green|=(green >> 8);             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;             if (quantum_bits.blue == 8)               blue|=(blue >> 8);             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));             SetPixelAlpha(q,OpaqueOpacity);             if (image->matte != MagickFalse)               {                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;                 if (quantum_bits.opacity == 8)                   alpha|=(alpha >> 8);                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));               }             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       default:       {         pixel_info=RelinquishVirtualMemory(pixel_info);         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     }     pixel_info=RelinquishVirtualMemory(pixel_info);     if (y > 0)       break;     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }     if (bmp_info.height < 0)       {         Image           *flipped_image;          /*           Correct image orientation.         */         flipped_image=FlipImage(image,exception);         if (flipped_image != (Image *) NULL)           {             DuplicateBlob(flipped_image,image);             ReplaceImageInList(&image, flipped_image);             image=flipped_image;           }       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     *magick='\0';     if (bmp_info.ba_offset != 0)       {         offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);         if (offset < 0)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     count=ReadBlob(image,2,magick);     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))       {         /*           Acquire next image structure.         */         AcquireNextImage(image_info,image);         if (GetNextImageInList(image) == (Image *) NULL)           {             image=DestroyImageList(image);             return((Image *) NULL);           }         image=SyncNextImageInList(image);         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),           GetBlobSize(image));         if (status == MagickFalse)           break;       }   } while (IsBMP(magick,2) != MagickFalse);   (void) CloseBlob(image);   return(GetFirstImageInList(image)); }"
"210692_CWE-835.c","CWE-835","static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception) {   BMPInfo     bmp_info;    Image     *image;    IndexPacket     index;    MagickBooleanType     status;    MagickOffsetType     offset,     start_position;    MemoryInfo     *pixel_info;    register IndexPacket     *indexes;    register PixelPacket     *q;    register ssize_t     i,     x;    register unsigned char     *p;    size_t     bit,     bytes_per_line,     length;    ssize_t     count,     y;    unsigned char     magick[12],     *pixels;    unsigned int     blue,     green,     offset_bits,     red;    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   if (image_info->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   image=AcquireImage(image_info);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Determine if this a BMP file.   */   (void) memset(&bmp_info,0,sizeof(bmp_info));   bmp_info.ba_offset=0;   start_position=0;   offset_bits=0;   count=ReadBlob(image,2,magick);   if (count != 2)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   do   {     LongPixelPacket       shift;      PixelPacket       quantum_bits;      /*       Verify BMP identifier.     */     if (bmp_info.ba_offset == 0)       start_position=TellBlob(image)-2;     bmp_info.ba_offset=0;     while (LocaleNCompare((char *) magick,""BA"",2) == 0)     {       bmp_info.file_size=ReadBlobLSBLong(image);       bmp_info.ba_offset=ReadBlobLSBLong(image);       bmp_info.offset_bits=ReadBlobLSBLong(image);       count=ReadBlob(image,2,magick);       if (count != 2)         break;     }     if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Magick: %c%c"",         magick[0],magick[1]);     if ((count != 2) || ((LocaleNCompare((char *) magick,""BM"",2) != 0) &&         (LocaleNCompare((char *) magick,""CI"",2) != 0)))       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     bmp_info.file_size=ReadBlobLSBLong(image);     (void) ReadBlobLSBLong(image);      if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),          ""  File_size in header:  %u bytes"",bmp_info.file_size);      bmp_info.offset_bits=ReadBlobLSBLong(image);     bmp_info.size=ReadBlobLSBLong(image);     if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  BMP size: %u"",         bmp_info.size);     if (bmp_info.size == 12)       {         /*           OS/2 BMP image file.         */         (void) CopyMagickString(image->magick,""BMP2"",MaxTextExtent);         bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));         bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));         bmp_info.planes=ReadBlobLSBShort(image);         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);         bmp_info.x_pixels=0;         bmp_info.y_pixels=0;         bmp_info.number_colors=0;         bmp_info.compression=BI_RGB;         bmp_info.image_size=0;         bmp_info.alpha_mask=0;         if (image->debug != MagickFalse)           {             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Format: OS/2 Bitmap"");             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)               bmp_info.height);           }       }     else       {         /*           Microsoft Windows BMP image file.         */         if (bmp_info.size < 40)           ThrowReaderException(CorruptImageError,""NonOS2HeaderSizeError"");         bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);         bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);         bmp_info.planes=ReadBlobLSBShort(image);         bmp_info.bits_per_pixel=ReadBlobLSBShort(image);         bmp_info.compression=ReadBlobLSBLong(image);         bmp_info.image_size=ReadBlobLSBLong(image);         bmp_info.x_pixels=ReadBlobLSBLong(image);         bmp_info.y_pixels=ReadBlobLSBLong(image);         bmp_info.number_colors=ReadBlobLSBLong(image);         if (bmp_info.number_colors > GetBlobSize(image))           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");         bmp_info.colors_important=ReadBlobLSBLong(image);         if (image->debug != MagickFalse)           {             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Format: MS Windows bitmap"");             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)               bmp_info.height);             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Bits per pixel: %.20g"",(double) bmp_info.bits_per_pixel);             switch (bmp_info.compression)             {               case BI_RGB:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RGB"");                 break;               }               case BI_RLE4:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RLE4"");                 break;               }               case BI_RLE8:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_RLE8"");                 break;               }               case BI_BITFIELDS:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_BITFIELDS"");                 break;               }               case BI_PNG:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_PNG"");                 break;               }               case BI_JPEG:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: BI_JPEG"");                 break;               }               default:               {                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),                   ""  Compression: UNKNOWN (%u)"",bmp_info.compression);               }             }             (void) LogMagickEvent(CoderEvent,GetMagickModule(),               ""  Number of colors: %u"",bmp_info.number_colors);           }         bmp_info.red_mask=ReadBlobLSBLong(image);         bmp_info.green_mask=ReadBlobLSBLong(image);         bmp_info.blue_mask=ReadBlobLSBLong(image);         if (bmp_info.size > 40)           {             double               gamma;              /*               Read color management information.             */             bmp_info.alpha_mask=ReadBlobLSBLong(image);             bmp_info.colorspace=ReadBlobLSBSignedLong(image);             /*               Decode 2^30 fixed point formatted CIE primaries.             */ #           define BMP_DENOM ((double) 0x40000000)             bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;             bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;              gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+               bmp_info.red_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.red_primary.x*=gamma;             bmp_info.red_primary.y*=gamma;             image->chromaticity.red_primary.x=bmp_info.red_primary.x;             image->chromaticity.red_primary.y=bmp_info.red_primary.y;              gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+               bmp_info.green_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.green_primary.x*=gamma;             bmp_info.green_primary.y*=gamma;             image->chromaticity.green_primary.x=bmp_info.green_primary.x;             image->chromaticity.green_primary.y=bmp_info.green_primary.y;              gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+               bmp_info.blue_primary.z;             gamma=PerceptibleReciprocal(gamma);             bmp_info.blue_primary.x*=gamma;             bmp_info.blue_primary.y*=gamma;             image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;             image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;              /*               Decode 16^16 fixed point formatted gamma_scales.             */             bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;             bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;             bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;             /*               Compute a single gamma from the BMP 3-channel gamma.             */             image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+               bmp_info.gamma_scale.z)/3.0;           }         else           (void) CopyMagickString(image->magick,""BMP3"",MaxTextExtent);          if (bmp_info.size > 108)           {             size_t               intent;              /*               Read BMP Version 5 color management information.             */             intent=ReadBlobLSBLong(image);             switch ((int) intent)             {               case LCS_GM_BUSINESS:               {                 image->rendering_intent=SaturationIntent;                 break;               }               case LCS_GM_GRAPHICS:               {                 image->rendering_intent=RelativeIntent;                 break;               }               case LCS_GM_IMAGES:               {                 image->rendering_intent=PerceptualIntent;                 break;               }               case LCS_GM_ABS_COLORIMETRIC:               {                 image->rendering_intent=AbsoluteIntent;                 break;               }             }             (void) ReadBlobLSBLong(image);  /* Profile data */             (void) ReadBlobLSBLong(image);  /* Profile size */             (void) ReadBlobLSBLong(image);  /* Reserved byte */           }       }     if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,         ""LengthAndFilesizeDoNotMatch"",""`%s'"",image->filename);     else       if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))         (void) ThrowMagickException(exception,GetMagickModule(),           CorruptImageWarning,""LengthAndFilesizeDoNotMatch"",""`%s'"",           image->filename);     if (bmp_info.width <= 0)       ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");     if (bmp_info.height == 0)       ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");     if (bmp_info.planes != 1)       ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");     if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&         (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&         (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if (bmp_info.bits_per_pixel < 16 &&         bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))       ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");     if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))       ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");     switch (bmp_info.compression)     {       case BI_RGB:         image->compression=NoCompression;         break;       case BI_RLE8:       case BI_RLE4:         image->compression=RLECompression;         break;       case BI_BITFIELDS:         break;       case BI_JPEG:         ThrowReaderException(CoderError,""JPEGCompressNotSupported"");       case BI_PNG:         ThrowReaderException(CoderError,""PNGCompressNotSupported"");       default:         ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");     }     image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);     image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);     image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;     image->matte=((bmp_info.alpha_mask != 0) &&       (bmp_info.compression == BI_BITFIELDS)) ? MagickTrue : MagickFalse;     if (bmp_info.bits_per_pixel < 16)       {         size_t           one;          image->storage_class=PseudoClass;         image->colors=bmp_info.number_colors;         one=1;         if (image->colors == 0)           image->colors=one << bmp_info.bits_per_pixel;       }     image->x_resolution=(double) bmp_info.x_pixels/100.0;     image->y_resolution=(double) bmp_info.y_pixels/100.0;     image->units=PixelsPerCentimeterResolution;     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     status=SetImageExtent(image,image->columns,image->rows);     if (status == MagickFalse)       {         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     if (image->storage_class == PseudoClass)       {         unsigned char           *bmp_colormap;          size_t           packet_size;          /*           Read BMP raster colormap.         */         if (image->debug != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Reading colormap of %.20g colors"",(double) image->colors);         if (AcquireImageColormap(image,image->colors) == MagickFalse)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)           image->colors,4*sizeof(*bmp_colormap));         if (bmp_colormap == (unsigned char *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         if ((bmp_info.size == 12) || (bmp_info.size == 64))           packet_size=3;         else           packet_size=4;         offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);         if (offset < 0)           {             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");           }         count=ReadBlob(image,packet_size*image->colors,bmp_colormap);         if (count != (ssize_t) (packet_size*image->colors))           {             bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);             ThrowReaderException(CorruptImageError,               ""InsufficientImageDataInFile"");           }         p=bmp_colormap;         for (i=0; i < (ssize_t) image->colors; i++)         {           image->colormap[i].blue=ScaleCharToQuantum(*p++);           image->colormap[i].green=ScaleCharToQuantum(*p++);           image->colormap[i].red=ScaleCharToQuantum(*p++);           if (packet_size == 4)             p++;         }         bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);       }     /*       Read image data.     */     if (bmp_info.offset_bits == offset_bits)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     offset_bits=bmp_info.offset_bits;     offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);     if (offset < 0)       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");     if (bmp_info.compression == BI_RLE4)       bmp_info.bits_per_pixel<<=1;     bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);     length=(size_t) bytes_per_line*image->rows;     if (((MagickSizeType) length/8) > GetBlobSize(image))       ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");     if ((bmp_info.compression == BI_RGB) ||         (bmp_info.compression == BI_BITFIELDS))       {         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,           image->columns+256UL)*sizeof(*pixels));         if (pixel_info == (MemoryInfo *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);         if (image->debug != MagickFalse)           (void) LogMagickEvent(CoderEvent,GetMagickModule(),             ""  Reading pixels (%.20g bytes)"",(double) length);         count=ReadBlob(image,length,pixels);         if (count != (ssize_t) length)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""InsufficientImageDataInFile"");           }       }     else       {         /*           Convert run-length encoded raster pixels.         */         pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,           image->columns+256UL)*sizeof(*pixels));         if (pixel_info == (MemoryInfo *) NULL)           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");         pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);         status=DecodeImage(image,bmp_info.compression,pixels,           image->columns*image->rows);         if (status == MagickFalse)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnableToRunlengthDecodeImage"");           }       }     /*       Convert BMP raster image to pixel packets.     */     if (bmp_info.compression == BI_RGB)       {         /*           We should ignore the alpha value in BMP3 files but there have been           reports about 32 bit files with alpha. We do a quick check to see if           the alpha channel contains a value that is not zero (default value).           If we find a non zero value we asume the program that wrote the file           wants to use the alpha channel.         */         if ((image->matte == MagickFalse) && (bmp_info.size == 40) &&             (bmp_info.bits_per_pixel == 32))           {             bytes_per_line=4*(image->columns);             for (y=(ssize_t) image->rows-1; y >= 0; y--)             {               p=pixels+(image->rows-y-1)*bytes_per_line;               for (x=0; x < (ssize_t) image->columns; x++)               {                 if (*(p+3) != 0)                   {                     image->matte=MagickTrue;                     y=-1;                     break;                   }                 p+=4;               }             }           }         bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;         bmp_info.red_mask=0x00ff0000U;         bmp_info.green_mask=0x0000ff00U;         bmp_info.blue_mask=0x000000ffU;         if (bmp_info.bits_per_pixel == 16)           {             /*               RGB555.             */             bmp_info.red_mask=0x00007c00U;             bmp_info.green_mask=0x000003e0U;             bmp_info.blue_mask=0x0000001fU;           }       }     (void) memset(&shift,0,sizeof(shift));     (void) memset(&quantum_bits,0,sizeof(quantum_bits));     if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))       {         register size_t           sample;          /*           Get shift and quantum bits info from bitfield masks.         */         if (bmp_info.red_mask != 0)           while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)           {             shift.red++;             if (shift.red > 32U)               break;           }         if (bmp_info.green_mask != 0)           while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)           {             shift.green++;             if (shift.green > 32U)               break;           }         if (bmp_info.blue_mask != 0)           while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)           {             shift.blue++;             if (shift.blue > 32U)               break;           }         if (bmp_info.alpha_mask != 0)           while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)           {             shift.opacity++;             if (shift.opacity > 32U)               break;           }         sample=shift.red;         while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);         sample=shift.green;         while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);         sample=shift.blue;         while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);         sample=shift.opacity;         while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)         {           sample++;           if (sample > 32U)             break;         }         quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-           shift.opacity);       }     switch (bmp_info.bits_per_pixel)     {       case 1:       {         /*           Convert bitmap scanline.         */         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=0; x < ((ssize_t) image->columns-7); x+=8)           {             for (bit=0; bit < 8; bit++)             {               index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);               SetPixelIndex(indexes+x+bit,index);               q++;             }             p++;           }           if ((image->columns % 8) != 0)             {               for (bit=0; bit < (image->columns % 8); bit++)               {                 index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);                 SetPixelIndex(indexes+x+bit,index);               }               p++;             }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 4:       {         /*           Convert PseudoColor scanline.         */         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=0; x < ((ssize_t) image->columns-1); x+=2)           {             (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0x0f),               &index,exception);             SetPixelIndex(indexes+x,index);             (void) IsValidColormapIndex(image,(ssize_t) (*p & 0x0f),&index,               exception);             SetPixelIndex(indexes+x+1,index);             p++;           }           if ((image->columns % 2) != 0)             {               (void) IsValidColormapIndex(image,(ssize_t) ((*p >> 4) & 0xf),                 &index,exception);               SetPixelIndex(indexes+(x++),index);               p++;             }           if (x < (ssize_t) image->columns)             break;           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 8:       {         /*           Convert PseudoColor scanline.         */         if ((bmp_info.compression == BI_RLE8) ||             (bmp_info.compression == BI_RLE4))           bytes_per_line=image->columns;         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           for (x=(ssize_t) image->columns; x != 0; --x)           {             (void) IsValidColormapIndex(image,(ssize_t) *p,&index,exception);             SetPixelIndex(indexes,index);             indexes++;             p++;             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         (void) SyncImage(image);         break;       }       case 16:       {         unsigned int           alpha,           pixel;          /*           Convert bitfield encoded 16-bit PseudoColor scanline.         */         if (bmp_info.compression != BI_RGB &&             bmp_info.compression != BI_BITFIELDS)           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnrecognizedImageCompression"");           }         bytes_per_line=2*(image->columns+image->columns % 2);         image->storage_class=DirectClass;         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             pixel=(unsigned int) (*p++);             pixel|=(*p++) << 8;             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;             if (quantum_bits.red == 5)               red|=((red & 0xe000) >> 5);             if (quantum_bits.red <= 8)               red|=((red & 0xff00) >> 8);             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;             if (quantum_bits.green == 5)               green|=((green & 0xe000) >> 5);             if (quantum_bits.green == 6)               green|=((green & 0xc000) >> 6);             if (quantum_bits.green <= 8)               green|=((green & 0xff00) >> 8);             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;             if (quantum_bits.blue == 5)               blue|=((blue & 0xe000) >> 5);             if (quantum_bits.blue <= 8)               blue|=((blue & 0xff00) >> 8);             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));             SetPixelOpacity(q,OpaqueOpacity);             if (image->matte != MagickFalse)               {                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;                 if (quantum_bits.opacity <= 8)                   alpha|=((alpha & 0xff00) >> 8);                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));               }             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case 24:       {         /*           Convert DirectColor scanline.         */         bytes_per_line=4*((image->columns*24+31)/32);         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             SetPixelBlue(q,ScaleCharToQuantum(*p++));             SetPixelGreen(q,ScaleCharToQuantum(*p++));             SetPixelRed(q,ScaleCharToQuantum(*p++));             SetPixelOpacity(q,OpaqueOpacity);             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case 32:       {         /*           Convert bitfield encoded DirectColor scanline.         */         if ((bmp_info.compression != BI_RGB) &&             (bmp_info.compression != BI_BITFIELDS))           {             pixel_info=RelinquishVirtualMemory(pixel_info);             ThrowReaderException(CorruptImageError,               ""UnrecognizedImageCompression"");           }         bytes_per_line=4*(image->columns);         for (y=(ssize_t) image->rows-1; y >= 0; y--)         {           unsigned int             alpha,             pixel;            p=pixels+(image->rows-y-1)*bytes_per_line;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           for (x=0; x < (ssize_t) image->columns; x++)           {             pixel=(unsigned int) (*p++);             pixel|=((unsigned int) *p++ << 8);             pixel|=((unsigned int) *p++ << 16);             pixel|=((unsigned int) *p++ << 24);             red=((pixel & bmp_info.red_mask) << shift.red) >> 16;             if (quantum_bits.red == 8)               red|=(red >> 8);             green=((pixel & bmp_info.green_mask) << shift.green) >> 16;             if (quantum_bits.green == 8)               green|=(green >> 8);             blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;             if (quantum_bits.blue == 8)               blue|=(blue >> 8);             SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));             SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));             SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));             SetPixelAlpha(q,OpaqueOpacity);             if (image->matte != MagickFalse)               {                 alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;                 if (quantum_bits.opacity == 8)                   alpha|=(alpha >> 8);                 SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));               }             q++;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           offset=(MagickOffsetType) (image->rows-y-1);           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)                 (image->rows-y),image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       default:       {         pixel_info=RelinquishVirtualMemory(pixel_info);         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     }     pixel_info=RelinquishVirtualMemory(pixel_info);     if (y > 0)       break;     if (EOFBlob(image) != MagickFalse)       {         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",           image->filename);         break;       }     if (bmp_info.height < 0)       {         Image           *flipped_image;          /*           Correct image orientation.         */         flipped_image=FlipImage(image,exception);         if (flipped_image != (Image *) NULL)           {             DuplicateBlob(flipped_image,image);             ReplaceImageInList(&image, flipped_image);             image=flipped_image;           }       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     *magick='\0';     if (bmp_info.ba_offset != 0)       {         offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);         if (offset < 0)           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     count=ReadBlob(image,2,magick);     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))       {         /*           Acquire next image structure.         */         AcquireNextImage(image_info,image);         if (GetNextImageInList(image) == (Image *) NULL)           {             status=MagickFalse;             break;           }         image=SyncNextImageInList(image);         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),           GetBlobSize(image));         if (status == MagickFalse)           break;       }   } while (IsBMP(magick,2) != MagickFalse);   (void) CloseBlob(image);   if (status == MagickFalse)     return(DestroyImageList(image));   return(GetFirstImageInList(image)); }"
"210700_CWE-22.cpp","CWE-22","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	squashfs_dir_header_2 dirh; 	char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; 	long long start; 	int bytes; 	int dir_count, size; 	struct dir_ent *new_dir; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n"");  	dir->dir_count = 0; 	dir->cur_entry = 0; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 0) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir; 		 	start = sBlk.s.directory_table_start + (*i)->start; 	bytes = lookup_entry(directory_table_hash, start); 	if(bytes == -1) 		EXIT_UNSQUASH(""squashfs_opendir: directory block %d not "" 			""found!\n"", block_start);  	bytes += (*i)->offset; 	size = (*i)->data + bytes;  	while(bytes < size) {			 		if(swap) { 			squashfs_dir_header_2 sdirh; 			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh)); 			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); 		} else 			memcpy(&dirh, directory_table + bytes, sizeof(dirh)); 	 		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			if(swap) { 				squashfs_dir_entry_2 sdire; 				memcpy(&sdire, directory_table + bytes, 					sizeof(sdire)); 				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); 			} else 				memcpy(dire, directory_table + bytes, 					sizeof(*dire)); 			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			memcpy(dire->name, directory_table + bytes, 				dire->size + 1); 			dire->name[dire->size + 1] = '\0'; 			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type); 			if((dir->dir_count % DIR_ENT_SIZE) == 0) { 				new_dir = realloc(dir->dirs, (dir->dir_count + 					DIR_ENT_SIZE) * sizeof(struct dir_ent)); 				if(new_dir == NULL) 					EXIT_UNSQUASH(""squashfs_opendir: "" 						""realloc failed!\n""); 				dir->dirs = new_dir; 			} 			strcpy(dir->dirs[dir->dir_count].name, dire->name); 			dir->dirs[dir->dir_count].start_block = 				dirh.start_block; 			dir->dirs[dir->dir_count].offset = dire->offset; 			dir->dirs[dir->dir_count].type = dire->type; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	free(dir->dirs); 	free(dir); 	return NULL; }"
"210701_CWE-22.cpp","CWE-22","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	squashfs_dir_header_3 dirh; 	char buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	squashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer; 	long long start; 	int bytes; 	int dir_count, size; 	struct dir_ent *new_dir; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n"");  	dir->dir_count = 0; 	dir->cur_entry = 0; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 3) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir;  	start = sBlk.s.directory_table_start + (*i)->start; 	bytes = lookup_entry(directory_table_hash, start);  	if(bytes == -1) 		EXIT_UNSQUASH(""squashfs_opendir: directory block %d not "" 			""found!\n"", block_start);  	bytes += (*i)->offset; 	size = (*i)->data + bytes - 3;  	while(bytes < size) {			 		if(swap) { 			squashfs_dir_header_3 sdirh; 			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh)); 			SQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh); 		} else 			memcpy(&dirh, directory_table + bytes, sizeof(dirh)); 	 		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			if(swap) { 				squashfs_dir_entry_3 sdire; 				memcpy(&sdire, directory_table + bytes, 					sizeof(sdire)); 				SQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire); 			} else 				memcpy(dire, directory_table + bytes, 					sizeof(*dire)); 			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			memcpy(dire->name, directory_table + bytes, 				dire->size + 1); 			dire->name[dire->size + 1] = '\0'; 			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type); 			if((dir->dir_count % DIR_ENT_SIZE) == 0) { 				new_dir = realloc(dir->dirs, (dir->dir_count + 					DIR_ENT_SIZE) * sizeof(struct dir_ent)); 				if(new_dir == NULL) 					EXIT_UNSQUASH(""squashfs_opendir: "" 						""realloc failed!\n""); 				dir->dirs = new_dir; 			} 			strcpy(dir->dirs[dir->dir_count].name, dire->name); 			dir->dirs[dir->dir_count].start_block = 				dirh.start_block; 			dir->dirs[dir->dir_count].offset = dire->offset; 			dir->dirs[dir->dir_count].type = dire->type; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	free(dir->dirs); 	free(dir); 	return NULL; }"
"210702_CWE-22.cpp","CWE-22","static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, 	struct inode **i) { 	struct squashfs_dir_header dirh; 	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1] 		__attribute__((aligned)); 	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer; 	long long start; 	long long bytes; 	int dir_count, size; 	struct dir_ent *new_dir; 	struct dir *dir;  	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", 		block_start, offset);  	*i = read_inode(block_start, offset);  	dir = malloc(sizeof(struct dir)); 	if(dir == NULL) 		EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n"");  	dir->dir_count = 0; 	dir->cur_entry = 0; 	dir->mode = (*i)->mode; 	dir->uid = (*i)->uid; 	dir->guid = (*i)->gid; 	dir->mtime = (*i)->time; 	dir->xattr = (*i)->xattr; 	dir->dirs = NULL;  	if ((*i)->data == 3) 		/* 		 * if the directory is empty, skip the unnecessary 		 * lookup_entry, this fixes the corner case with 		 * completely empty filesystems where lookup_entry correctly 		 * returning -1 is incorrectly treated as an error 		 */ 		return dir;  	start = sBlk.s.directory_table_start + (*i)->start; 	bytes = lookup_entry(directory_table_hash, start);  	if(bytes == -1) 		EXIT_UNSQUASH(""squashfs_opendir: directory block %lld not "" 			""found!\n"", start);  	bytes += (*i)->offset; 	size = (*i)->data + bytes - 3;  	while(bytes < size) {			 		SQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh); 	 		dir_count = dirh.count + 1; 		TRACE(""squashfs_opendir: Read directory header @ byte position "" 			""%d, %d directory entries\n"", bytes, dir_count); 		bytes += sizeof(dirh);  		/* dir_count should never be larger than SQUASHFS_DIR_COUNT */ 		if(dir_count > SQUASHFS_DIR_COUNT) { 			ERROR(""File system corrupted: too many entries in directory\n""); 			goto corrupted; 		}  		while(dir_count--) { 			SQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);  			bytes += sizeof(*dire);  			/* size should never be SQUASHFS_NAME_LEN or larger */ 			if(dire->size >= SQUASHFS_NAME_LEN) { 				ERROR(""File system corrupted: filename too long\n""); 				goto corrupted; 			}  			memcpy(dire->name, directory_table + bytes, 				dire->size + 1); 			dire->name[dire->size + 1] = '\0'; 			TRACE(""squashfs_opendir: directory entry %s, inode "" 				""%d:%d, type %d\n"", dire->name, 				dirh.start_block, dire->offset, dire->type); 			if((dir->dir_count % DIR_ENT_SIZE) == 0) { 				new_dir = realloc(dir->dirs, (dir->dir_count + 					DIR_ENT_SIZE) * sizeof(struct dir_ent)); 				if(new_dir == NULL) 					EXIT_UNSQUASH(""squashfs_opendir: "" 						""realloc failed!\n""); 				dir->dirs = new_dir; 			} 			strcpy(dir->dirs[dir->dir_count].name, dire->name); 			dir->dirs[dir->dir_count].start_block = 				dirh.start_block; 			dir->dirs[dir->dir_count].offset = dire->offset; 			dir->dirs[dir->dir_count].type = dire->type; 			dir->dir_count ++; 			bytes += dire->size + 1; 		} 	}  	return dir;  corrupted: 	free(dir->dirs); 	free(dir); 	return NULL; }"
"210814_CWE-787.c","CWE-787","ins_compl_add(     char_u	*str,     int		len,     char_u	*fname,     char_u	**cptext,	    // extra text for popup menu or NULL     typval_T	*user_data UNUSED,  // ""user_data"" entry or NULL     int		cdir,     int		flags_arg,     int		adup)		// accept duplicate match {     compl_T	*match;     int		dir = (cdir == 0 ? compl_direction : cdir);     int		flags = flags_arg;      if (flags & CP_FAST) 	fast_breakcheck();     else 	ui_breakcheck();     if (got_int) 	return FAIL;     if (len < 0) 	len = (int)STRLEN(str);      // If the same match is already present, don't add it.     if (compl_first_match != NULL && !adup)     { 	match = compl_first_match; 	do 	{ 	    if (!match_at_original_text(match) 		    && STRNCMP(match->cp_str, str, len) == 0 		    && match->cp_str[len] == NUL) 		return NOTDONE; 	    match = match->cp_next; 	} while (match != NULL && !is_first_match(match));     }      // Remove any popup menu before changing the list of matches.     ins_compl_del_pum();      // Allocate a new match structure.     // Copy the values to the new match structure.     match = ALLOC_CLEAR_ONE(compl_T);     if (match == NULL) 	return FAIL;     match->cp_number = -1;     if (flags & CP_ORIGINAL_TEXT) 	match->cp_number = 0;     if ((match->cp_str = vim_strnsave(str, len)) == NULL)     { 	vim_free(match); 	return FAIL;     }      // match-fname is:     // - compl_curr_match->cp_fname if it is a string equal to fname.     // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.     // - NULL otherwise.	--Acevedo     if (fname != NULL 	    && compl_curr_match != NULL 	    && compl_curr_match->cp_fname != NULL 	    && STRCMP(fname, compl_curr_match->cp_fname) == 0) 	match->cp_fname = compl_curr_match->cp_fname;     else if (fname != NULL)     { 	match->cp_fname = vim_strsave(fname); 	flags |= CP_FREE_FNAME;     }     else 	match->cp_fname = NULL;     match->cp_flags = flags;      if (cptext != NULL)     { 	int i;  	for (i = 0; i < CPT_COUNT; ++i) 	    if (cptext[i] != NULL && *cptext[i] != NUL) 		match->cp_text[i] = vim_strsave(cptext[i]);     } #ifdef FEAT_EVAL     if (user_data != NULL) 	match->cp_user_data = *user_data; #endif      // Link the new match structure after (FORWARD) or before (BACKWARD) the     // current match in the list of matches .     if (compl_first_match == NULL) 	match->cp_next = match->cp_prev = NULL;     else if (dir == FORWARD)     { 	match->cp_next = compl_curr_match->cp_next; 	match->cp_prev = compl_curr_match;     }     else	// BACKWARD     { 	match->cp_next = compl_curr_match; 	match->cp_prev = compl_curr_match->cp_prev;     }     if (match->cp_next) 	match->cp_next->cp_prev = match;     if (match->cp_prev) 	match->cp_prev->cp_next = match;     else	// if there's nothing before, it is the first match 	compl_first_match = match;     compl_curr_match = match;      // Find the longest common string if still doing that.     if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0) 	ins_compl_longest_match(match);      return OK; }"
"210834_CWE-863.c","CWE-863","LogFilePrep(const char *fname, const char *backup, const char *idstring) {     char *logFileName = NULL;      if (asprintf(&logFileName, fname, idstring) == -1)         FatalError(""Cannot allocate space for the log file name\n"");      if (backup && *backup) {         struct stat buf;          if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {             char *suffix;             char *oldLog;              if ((asprintf(&suffix, backup, idstring) == -1) ||                 (asprintf(&oldLog, ""%s%s"", logFileName, suffix) == -1)) {                 FatalError(""Cannot allocate space for the log file name\n"");             }             free(suffix);              if (rename(logFileName, oldLog) == -1) {                 FatalError(""Cannot move old log file \""%s\"" to \""%s\""\n"",                            logFileName, oldLog);             }             free(oldLog);         }     }     else {         if (remove(logFileName) != 0 && errno != ENOENT) {             FatalError(""Cannot remove old log file \""%s\"": %s\n"",                        logFileName, strerror(errno));         }     }      return logFileName; }"
"210866_CWE-191.c","CWE-191","SProcXkbSelectEvents(ClientPtr client) {     REQUEST(xkbSelectEventsReq);      swaps(&stuff->length);     REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);     swaps(&stuff->deviceSpec);     swaps(&stuff->affectWhich);     swaps(&stuff->clear);     swaps(&stuff->selectAll);     swaps(&stuff->affectMap);     swaps(&stuff->map);     if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {         union {             BOOL *b;             CARD8 *c8;             CARD16 *c16;             CARD32 *c32;         } from;         register unsigned bit, ndx, maskLeft, dataLeft, size;          from.c8 = (CARD8 *) &stuff[1];         dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);         maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));         for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {             if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))                 continue;             maskLeft &= ~bit;             if ((stuff->selectAll & bit) || (stuff->clear & bit))                 continue;             switch (ndx) {             case XkbNewKeyboardNotify:             case XkbStateNotify:             case XkbNamesNotify:             case XkbAccessXNotify:             case XkbExtensionDeviceNotify:                 size = 2;                 break;             case XkbControlsNotify:             case XkbIndicatorStateNotify:             case XkbIndicatorMapNotify:                 size = 4;                 break;             case XkbBellNotify:             case XkbActionMessage:             case XkbCompatMapNotify:                 size = 1;                 break;             default:                 client->errorValue = _XkbErrCode2(0x1, bit);                 return BadValue;             }             if (dataLeft < (size * 2))                 return BadLength;             if (size == 2) {                 swaps(&from.c16[0]);                 swaps(&from.c16[1]);             }             else if (size == 4) {                 swapl(&from.c32[0]);                 swapl(&from.c32[1]);             }             else {                 size = 2;             }             from.c8 += (size * 2);             dataLeft -= (size * 2);         }         if (dataLeft > 2) {             ErrorF(""[xkb] Extra data (%d bytes) after SelectEvents\n"",                    dataLeft);             return BadLength;         }     }     return ProcXkbSelectEvents(client); }"
"210887_CWE-835.c","CWE-835","e1000_send_packet(E1000State *s, const uint8_t *buf, int size) {     static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,                                     PTC1023, PTC1522 };      NetClientState *nc = qemu_get_queue(s->nic);     if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {         nc->info->receive(nc, buf, size);     } else {         qemu_send_packet(nc, buf, size);     }     inc_tx_bcast_or_mcast_count(s, buf);     e1000x_increase_size_stats(s->mac_reg, PTCregs, size); }"
"210896_CWE-193.c","CWE-193","void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,                        int group_id) {     int slot_id;     int generation;     unsigned long h_virt;      MemSlot *slot;      if (group_id > info->num_memslots_groups) {         spice_critical(""group_id too big"");         return NULL;     }      slot_id = memslot_get_id(info, addr);     if (slot_id > info->num_memslots) {         print_memslots(info);         spice_critical(""slot_id %d too big, addr=%"" PRIx64, slot_id, addr);         return NULL;     }      slot = &info->mem_slots[group_id][slot_id];      generation = memslot_get_generation(info, addr);     if (generation != slot->generation) {         print_memslots(info);         spice_critical(""address generation is not valid, group_id %d, slot_id %d, ""                        ""gen %d, slot_gen %d"",                        group_id, slot_id,                        generation, slot->generation);         return NULL;     }      h_virt = __get_clean_virt(info, addr);     h_virt += slot->address_delta;      if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {         return NULL;     }      return (void*)(uintptr_t)h_virt; }"
"210904_CWE-125.c","CWE-125","static void warnf(struct Configurable *config, const char *fmt, ...) {   if(!(config->conf & CONF_MUTE)) {     va_list ap;     int len;     char *ptr;     char print_buffer[256];      va_start(ap, fmt);     va_start(ap, fmt);     len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);     va_end(ap);      ptr = print_buffer;     while(len > 0) {       fputs(WARN_PREFIX, config->errors);        if(len > (int)WARN_TEXTWIDTH) {         int cut = WARN_TEXTWIDTH-1;          while(!ISSPACE(ptr[cut]) && cut) {           cut--;         }          fwrite(ptr, cut + 1, 1, config->errors);         fputs(""\n"", config->errors);         ptr += cut+1; /* skip the space too */         len -= cut;       }       else {         fputs(ptr, config->errors);         len = 0;       }     }   } }"
"210910_CWE-200.c","CWE-200","win_redr_status(win_T *wp, int ignore_pum UNUSED) {     int		row;     char_u	*p;     int		len;     int		fillchar;     int		attr;     int		this_ru_col;     static int  busy = FALSE;      // It's possible to get here recursively when 'statusline' (indirectly)     // invokes "":redrawstatus"".  Simply ignore the call then.     if (busy) 	return;     busy = TRUE;      row = statusline_row(wp);      wp->w_redr_status = FALSE;     if (wp->w_status_height == 0)     { 	// no status line, can only be last window 	redraw_cmdline = TRUE;     }     else if (!redrawing() 	    // don't update status line when popup menu is visible and may be 	    // drawn over it, unless it will be redrawn later 	    || (!ignore_pum && pum_visible()))     { 	// Don't redraw right now, do it later. 	wp->w_redr_status = TRUE;     } #ifdef FEAT_STL_OPT     else if (*p_stl != NUL || *wp->w_p_stl != NUL)     { 	// redraw custom status line 	redraw_custom_statusline(wp);     } #endif     else     { 	fillchar = fillchar_status(&attr, wp);  	get_trans_bufname(wp->w_buffer); 	p = NameBuff; 	len = (int)STRLEN(p);  	if (bt_help(wp->w_buffer) #ifdef FEAT_QUICKFIX 		|| wp->w_p_pvw #endif 		|| bufIsChanged(wp->w_buffer) 		|| wp->w_buffer->b_p_ro) 	    *(p + len++) = ' '; 	if (bt_help(wp->w_buffer)) 	{ 	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]"")); 	    len += (int)STRLEN(p + len); 	} #ifdef FEAT_QUICKFIX 	if (wp->w_p_pvw) 	{ 	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]"")); 	    len += (int)STRLEN(p + len); 	} #endif 	if (bufIsChanged(wp->w_buffer) #ifdef FEAT_TERMINAL 		&& !bt_terminal(wp->w_buffer) #endif 		) 	{ 	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]""); 	    len += (int)STRLEN(p + len); 	} 	if (wp->w_buffer->b_p_ro) 	{ 	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]"")); 	    len += (int)STRLEN(p + len); 	}  	this_ru_col = ru_col - (Columns - wp->w_width); 	if (this_ru_col < (wp->w_width + 1) / 2) 	    this_ru_col = (wp->w_width + 1) / 2; 	if (this_ru_col <= 1) 	{ 	    p = (char_u *)""<"";		// No room for file name! 	    len = 1; 	} 	else if (has_mbyte) 	{ 	    int	clen = 0, i;  	    // Count total number of display cells. 	    clen = mb_string2cells(p, -1);  	    // Find first character that will fit. 	    // Going from start to end is much faster for DBCS. 	    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1; 		    i += (*mb_ptr2len)(p + i)) 		clen -= (*mb_ptr2cells)(p + i); 	    len = clen; 	    if (i > 0) 	    { 		p = p + i - 1; 		*p = '<'; 		++len; 	    }  	} 	else if (len > this_ru_col - 1) 	{ 	    p += len - (this_ru_col - 1); 	    *p = '<'; 	    len = this_ru_col - 1; 	}  	screen_puts(p, row, wp->w_wincol, attr); 	screen_fill(row, row + 1, len + wp->w_wincol, 			this_ru_col + wp->w_wincol, fillchar, fillchar, attr);  	if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL) 		&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1)) 	    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff) 						   - 1 + wp->w_wincol), attr);  #ifdef FEAT_CMDL_INFO 	win_redr_ruler(wp, TRUE, ignore_pum); #endif     }      /*      * May need to draw the character below the vertical separator.      */     if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())     { 	if (stl_connected(wp)) 	    fillchar = fillchar_status(&attr, wp); 	else 	    fillchar = fillchar_vsep(&attr); 	screen_putchar(fillchar, row, W_ENDCOL(wp), attr);     }     busy = FALSE; }"
"210928_CWE-476.c","CWE-476","void jfs_evict_inode(struct inode *inode) { 	struct jfs_inode_info *ji = JFS_IP(inode);  	jfs_info(""In jfs_evict_inode, inode = 0x%p"", inode);  	if (!inode->i_nlink && !is_bad_inode(inode)) { 		dquot_initialize(inode);  		if (JFS_IP(inode)->fileset == FILESYSTEM_I) { 			truncate_inode_pages_final(&inode->i_data);  			if (test_cflag(COMMIT_Freewmap, inode)) 				jfs_free_zero_link(inode);  			if (JFS_SBI(inode->i_sb)->ipimap) 				diFree(inode);  			/* 			 * Free the inode from the quota allocation. 			 */ 			dquot_free_inode(inode); 		} 	} else { 		truncate_inode_pages_final(&inode->i_data); 	} 	clear_inode(inode); 	dquot_drop(inode);  	BUG_ON(!list_empty(&ji->anon_inode_list));  	spin_lock_irq(&ji->ag_lock); 	if (ji->active_ag != -1) { 		struct bmap *bmap = JFS_SBI(inode->i_sb)->bmap; 		atomic_dec(&bmap->db_active[ji->active_ag]); 		ji->active_ag = -1; 	} 	spin_unlock_irq(&ji->ag_lock); }"
"210944_CWE-416.c","CWE-416","do_cmdline(     char_u	*cmdline,     char_u	*(*fgetline)(int, void *, int, getline_opt_T),     void	*cookie,		// argument for fgetline()     int		flags) {     char_u	*next_cmdline;		// next cmd to execute     char_u	*cmdline_copy = NULL;	// copy of cmd line     int		used_getline = FALSE;	// used ""fgetline"" to obtain command     static int	recursive = 0;		// recursive depth     int		msg_didout_before_start = 0;     int		count = 0;		// line number count     int		did_inc = FALSE;	// incremented RedrawingDisabled     int		retval = OK; #ifdef FEAT_EVAL     cstack_T	cstack;			// conditional stack     garray_T	lines_ga;		// keep lines for "":while""/"":for""     int		current_line = 0;	// active line in lines_ga     int		current_line_before = 0;     char_u	*fname = NULL;		// function or script name     linenr_T	*breakpoint = NULL;	// ptr to breakpoint field in cookie     int		*dbg_tick = NULL;	// ptr to dbg_tick field in cookie     struct dbg_stuff debug_saved;	// saved things for debug mode     int		initial_trylevel;     msglist_T	**saved_msg_list = NULL;     msglist_T	*private_msg_list = NULL;      // ""fgetline"" and ""cookie"" passed to do_one_cmd()     char_u	*(*cmd_getline)(int, void *, int, getline_opt_T);     void	*cmd_cookie;     struct loop_cookie cmd_loop_cookie;     void	*real_cookie;     int		getline_is_func; #else # define cmd_getline fgetline # define cmd_cookie cookie #endif     static int	call_depth = 0;		// recursiveness #ifdef FEAT_EVAL     // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory     // location for storing error messages to be converted to an exception.     // This ensures that the do_errthrow() call in do_one_cmd() does not     // combine the messages stored by an earlier invocation of do_one_cmd()     // with the command name of the later one.  This would happen when     // BufWritePost autocommands are executed after a write error.     saved_msg_list = msg_list;     msg_list = &private_msg_list; #endif      // It's possible to create an endless loop with "":execute"", catch that     // here.  The value of 200 allows nested function calls, "":source"", etc.     // Allow 200 or 'maxfuncdepth', whatever is larger.     if (call_depth >= 200 #ifdef FEAT_EVAL 	    && call_depth >= p_mfd #endif 	    )     { 	emsg(_(e_command_too_recursive)); #ifdef FEAT_EVAL 	// When converting to an exception, we do not include the command name 	// since this is not an error of the specific command. 	do_errthrow((cstack_T *)NULL, (char_u *)NULL); 	msg_list = saved_msg_list; #endif 	return FAIL;     }     ++call_depth;  #ifdef FEAT_EVAL     CLEAR_FIELD(cstack);     cstack.cs_idx = -1;     ga_init2(&lines_ga, sizeof(wcmd_T), 10);      real_cookie = getline_cookie(fgetline, cookie);      // Inside a function use a higher nesting level.     getline_is_func = getline_equal(fgetline, cookie, get_func_line);     if (getline_is_func && ex_nesting_level == func_level(real_cookie)) 	++ex_nesting_level;      // Get the function or script name and the address where the next breakpoint     // line and the debug tick for a function or script are stored.     if (getline_is_func)     { 	fname = func_name(real_cookie); 	breakpoint = func_breakpoint(real_cookie); 	dbg_tick = func_dbg_tick(real_cookie);     }     else if (getline_equal(fgetline, cookie, getsourceline))     { 	fname = SOURCING_NAME; 	breakpoint = source_breakpoint(real_cookie); 	dbg_tick = source_dbg_tick(real_cookie);     }      /*      * Initialize ""force_abort""  and ""suppress_errthrow"" at the top level.      */     if (!recursive)     { 	force_abort = FALSE; 	suppress_errthrow = FALSE;     }      /*      * If requested, store and reset the global values controlling the      * exception handling (used when debugging).  Otherwise clear it to avoid      * a bogus compiler warning when the optimizer uses inline functions...      */     if (flags & DOCMD_EXCRESET) 	save_dbg_stuff(&debug_saved);     else 	CLEAR_FIELD(debug_saved);      initial_trylevel = trylevel;      /*      * ""did_throw"" will be set to TRUE when an exception is being thrown.      */     did_throw = FALSE; #endif     /*      * ""did_emsg"" will be set to TRUE when emsg() is used, in which case we      * cancel the whole command line, and any if/endif or loop.      * If force_abort is set, we cancel everything.      */ #ifdef FEAT_EVAL     did_emsg_cumul += did_emsg; #endif     did_emsg = FALSE;      /*      * KeyTyped is only set when calling vgetc().  Reset it here when not      * calling vgetc() (sourced command lines).      */     if (!(flags & DOCMD_KEYTYPED) 			       && !getline_equal(fgetline, cookie, getexline)) 	KeyTyped = FALSE;      /*      * Continue executing command lines:      * - when inside an "":if"", "":while"" or "":for""      * - for multiple commands on one line, separated with '|'      * - when repeating until there are no more lines (for "":source"")      */     next_cmdline = cmdline;     do     { #ifdef FEAT_EVAL 	getline_is_func = getline_equal(fgetline, cookie, get_func_line); #endif  	// stop skipping cmds for an error msg after all endif/while/for 	if (next_cmdline == NULL #ifdef FEAT_EVAL 		&& !force_abort 		&& cstack.cs_idx < 0 		&& !(getline_is_func && func_has_abort(real_cookie)) #endif 							) 	{ #ifdef FEAT_EVAL 	    did_emsg_cumul += did_emsg; #endif 	    did_emsg = FALSE; 	}  	/* 	 * 1. If repeating a line in a loop, get a line from lines_ga. 	 * 2. If no line given: Get an allocated line with fgetline(). 	 * 3. If a line is given: Make a copy, so we can mess with it. 	 */  #ifdef FEAT_EVAL 	// 1. If repeating, get a previous line from lines_ga. 	if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) 	{ 	    // Each '|' separated command is stored separately in lines_ga, to 	    // be able to jump to it.  Don't use next_cmdline now. 	    VIM_CLEAR(cmdline_copy);  	    // Check if a function has returned or, unless it has an unclosed 	    // try conditional, aborted. 	    if (getline_is_func) 	    { # ifdef FEAT_PROFILE 		if (do_profiling == PROF_YES) 		    func_line_end(real_cookie); # endif 		if (func_has_ended(real_cookie)) 		{ 		    retval = FAIL; 		    break; 		} 	    } #ifdef FEAT_PROFILE 	    else if (do_profiling == PROF_YES 			    && getline_equal(fgetline, cookie, getsourceline)) 		script_line_end(); #endif  	    // Check if a sourced file hit a "":finish"" command. 	    if (source_finished(fgetline, cookie)) 	    { 		retval = FAIL; 		break; 	    }  	    // If breakpoints have been added/deleted need to check for it. 	    if (breakpoint != NULL && dbg_tick != NULL 						   && *dbg_tick != debug_tick) 	    { 		*breakpoint = dbg_find_breakpoint( 				getline_equal(fgetline, cookie, getsourceline), 							fname, SOURCING_LNUM); 		*dbg_tick = debug_tick; 	    }  	    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line; 	    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;  	    // Did we encounter a breakpoint? 	    if (breakpoint != NULL && *breakpoint != 0 					      && *breakpoint <= SOURCING_LNUM) 	    { 		dbg_breakpoint(fname, SOURCING_LNUM); 		// Find next breakpoint. 		*breakpoint = dbg_find_breakpoint( 			       getline_equal(fgetline, cookie, getsourceline), 							fname, SOURCING_LNUM); 		*dbg_tick = debug_tick; 	    } # ifdef FEAT_PROFILE 	    if (do_profiling == PROF_YES) 	    { 		if (getline_is_func) 		    func_line_start(real_cookie, SOURCING_LNUM); 		else if (getline_equal(fgetline, cookie, getsourceline)) 		    script_line_start(); 	    } # endif 	} #endif  	// 2. If no line given, get an allocated line with fgetline(). 	if (next_cmdline == NULL) 	{ 	    /* 	     * Need to set msg_didout for the first line after an "":if"", 	     * otherwise the "":if"" will be overwritten. 	     */ 	    if (count == 1 && getline_equal(fgetline, cookie, getexline)) 		msg_didout = TRUE; 	    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie, #ifdef FEAT_EVAL 		    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2 #else 		    0 #endif 		    , in_vim9script() ? GETLINE_CONCAT_CONTBAR 					       : GETLINE_CONCAT_CONT)) == NULL) 	    { 		// Don't call wait_return() for aborted command line.  The NULL 		// returned for the end of a sourced file or executed function 		// doesn't do this. 		if (KeyTyped && !(flags & DOCMD_REPEAT)) 		    need_wait_return = FALSE; 		retval = FAIL; 		break; 	    } 	    used_getline = TRUE;  	    /* 	     * Keep the first typed line.  Clear it when more lines are typed. 	     */ 	    if (flags & DOCMD_KEEPLINE) 	    { 		vim_free(repeat_cmdline); 		if (count == 0) 		    repeat_cmdline = vim_strsave(next_cmdline); 		else 		    repeat_cmdline = NULL; 	    } 	}  	// 3. Make a copy of the command so we can mess with it. 	else if (cmdline_copy == NULL) 	{ 	    next_cmdline = vim_strsave(next_cmdline); 	    if (next_cmdline == NULL) 	    { 		emsg(_(e_out_of_memory)); 		retval = FAIL; 		break; 	    } 	} 	cmdline_copy = next_cmdline;  #ifdef FEAT_EVAL 	/* 	 * Inside a while/for loop, and when the command looks like a "":while"" 	 * or "":for"", the line is stored, because we may need it later when 	 * looping. 	 * 	 * When there is a '|' and another command, it is stored separately, 	 * because we need to be able to jump back to it from an 	 * :endwhile/:endfor. 	 * 	 * Pass a different ""fgetline"" function to do_one_cmd() below, 	 * that it stores lines in or reads them from ""lines_ga"".  Makes it 	 * possible to define a function inside a while/for loop and handles 	 * line continuation. 	 */ 	if ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline))) 	{ 	    cmd_getline = get_loop_line; 	    cmd_cookie = (void *)&cmd_loop_cookie; 	    cmd_loop_cookie.lines_gap = &lines_ga; 	    cmd_loop_cookie.current_line = current_line; 	    cmd_loop_cookie.getline = fgetline; 	    cmd_loop_cookie.cookie = cookie; 	    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);  	    // Save the current line when encountering it the first time. 	    if (current_line == lines_ga.ga_len 		    && store_loop_line(&lines_ga, next_cmdline) == FAIL) 	    { 		retval = FAIL; 		break; 	    } 	    current_line_before = current_line; 	} 	else 	{ 	    cmd_getline = fgetline; 	    cmd_cookie = cookie; 	}  	did_endif = FALSE; #endif  	if (count++ == 0) 	{ 	    /* 	     * All output from the commands is put below each other, without 	     * waiting for a return. Don't do this when executing commands 	     * from a script or when being called recursive (e.g. for "":e 	     * +command file""). 	     */ 	    if (!(flags & DOCMD_NOWAIT) && !recursive) 	    { 		msg_didout_before_start = msg_didout; 		msg_didany = FALSE; // no output yet 		msg_start(); 		msg_scroll = TRUE;  // put messages below each other 		++no_wait_return;   // don't wait for return until finished 		++RedrawingDisabled; 		did_inc = TRUE; 	    } 	}  	if ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16) 	    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);  	/* 	 * 2. Execute one '|' separated command. 	 *    do_one_cmd() will return NULL if there is no trailing '|'. 	 *    ""cmdline_copy"" can change, e.g. for '%' and '#' expansion. 	 */ 	++recursive; 	next_cmdline = do_one_cmd(&cmdline_copy, flags, #ifdef FEAT_EVAL 				&cstack, #endif 				cmd_getline, cmd_cookie); 	--recursive;  #ifdef FEAT_EVAL 	if (cmd_cookie == (void *)&cmd_loop_cookie) 	    // Use ""current_line"" from ""cmd_loop_cookie"", it may have been 	    // incremented when defining a function. 	    current_line = cmd_loop_cookie.current_line; #endif  	if (next_cmdline == NULL) 	{ 	    VIM_CLEAR(cmdline_copy);  	    /* 	     * If the command was typed, remember it for the ':' register. 	     * Do this AFTER executing the command to make :@: work. 	     */ 	    if (getline_equal(fgetline, cookie, getexline) 						  && new_last_cmdline != NULL) 	    { 		vim_free(last_cmdline); 		last_cmdline = new_last_cmdline; 		new_last_cmdline = NULL; 	    } 	} 	else 	{ 	    // need to copy the command after the '|' to cmdline_copy, for the 	    // next do_one_cmd() 	    STRMOVE(cmdline_copy, next_cmdline); 	    next_cmdline = cmdline_copy; 	}   #ifdef FEAT_EVAL 	// reset did_emsg for a function that is not aborted by an error 	if (did_emsg && !force_abort 		&& getline_equal(fgetline, cookie, get_func_line) 					      && !func_has_abort(real_cookie)) 	{ 	    // did_emsg_cumul is not set here 	    did_emsg = FALSE; 	}  	if (cstack.cs_looplevel > 0) 	{ 	    ++current_line;  	    /* 	     * An "":endwhile"", "":endfor"" and "":continue"" is handled here. 	     * If we were executing commands, jump back to the "":while"" or 	     * "":for"". 	     * If we were not executing commands, decrement cs_looplevel. 	     */ 	    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) 	    { 		cstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);  		// Jump back to the matching "":while"" or "":for"".  Be careful 		// not to use a cs_line[] from an entry that isn't a "":while"" 		// or "":for"": It would make ""current_line"" invalid and can 		// cause a crash. 		if (!did_emsg && !got_int && !did_throw 			&& cstack.cs_idx >= 0 			&& (cstack.cs_flags[cstack.cs_idx] 						      & (CSF_WHILE | CSF_FOR)) 			&& cstack.cs_line[cstack.cs_idx] >= 0 			&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE)) 		{ 		    current_line = cstack.cs_line[cstack.cs_idx]; 						// remember we jumped there 		    cstack.cs_lflags |= CSL_HAD_LOOP; 		    line_breakcheck();		// check if CTRL-C typed  		    // Check for the next breakpoint at or after the "":while"" 		    // or "":for"". 		    if (breakpoint != NULL) 		    { 			*breakpoint = dbg_find_breakpoint( 			       getline_equal(fgetline, cookie, getsourceline), 									fname, 			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1); 			*dbg_tick = debug_tick; 		    } 		} 		else 		{ 		    // can only get here with "":endwhile"" or "":endfor"" 		    if (cstack.cs_idx >= 0) 			rewind_conditionals(&cstack, cstack.cs_idx - 1, 				   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel); 		} 	    }  	    /* 	     * For a "":while"" or "":for"" we need to remember the line number. 	     */ 	    else if (cstack.cs_lflags & CSL_HAD_LOOP) 	    { 		cstack.cs_lflags &= ~CSL_HAD_LOOP; 		cstack.cs_line[cstack.cs_idx] = current_line_before; 	    } 	}  	// Check for the next breakpoint after a watchexpression 	if (breakpoint != NULL && has_watchexpr()) 	{ 	    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM); 	    *dbg_tick = debug_tick; 	}  	/* 	 * When not inside any "":while"" loop, clear remembered lines. 	 */ 	if (cstack.cs_looplevel == 0) 	{ 	    if (lines_ga.ga_len > 0) 	    { 		SOURCING_LNUM = 		       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum; 		free_cmdlines(&lines_ga); 	    } 	    current_line = 0; 	}  	/* 	 * A "":finally"" makes did_emsg, got_int, and did_throw pending for 	 * being restored at the "":endtry"".  Reset them here and set the 	 * ACTIVE and FINALLY flags, so that the finally clause gets executed. 	 * This includes the case where a missing "":endif"", "":endwhile"" or 	 * "":endfor"" was detected by the "":finally"" itself. 	 */ 	if (cstack.cs_lflags & CSL_HAD_FINA) 	{ 	    cstack.cs_lflags &= ~CSL_HAD_FINA; 	    report_make_pending(cstack.cs_pending[cstack.cs_idx] 		    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW), 		    did_throw ? (void *)current_exception : NULL); 	    did_emsg = got_int = did_throw = FALSE; 	    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY; 	}  	// Update global ""trylevel"" for recursive calls to do_cmdline() from 	// within this loop. 	trylevel = initial_trylevel + cstack.cs_trylevel;  	/* 	 * If the outermost try conditional (across function calls and sourced 	 * files) is aborted because of an error, an interrupt, or an uncaught 	 * exception, cancel everything.  If it is left normally, reset 	 * force_abort to get the non-EH compatible abortion behavior for 	 * the rest of the script. 	 */ 	if (trylevel == 0 && !did_emsg && !got_int && !did_throw) 	    force_abort = FALSE;  	// Convert an interrupt to an exception if appropriate. 	(void)do_intthrow(&cstack); #endif // FEAT_EVAL      }     /*      * Continue executing command lines when:      * - no CTRL-C typed, no aborting error, no exception thrown or try      *   conditionals need to be checked for executing finally clauses or      *   catching an interrupt exception      * - didn't get an error message or lines are not typed      * - there is a command after '|', inside a :if, :while, :for or :try, or      *   looping for "":source"" command or function call.      */     while (!((got_int #ifdef FEAT_EVAL 		    || (did_emsg && (force_abort || in_vim9script())) 		    || did_throw #endif 	     ) #ifdef FEAT_EVAL 		&& cstack.cs_trylevel == 0 #endif 	    ) 	    && !(did_emsg #ifdef FEAT_EVAL 		// Keep going when inside try/catch, so that the error can be 		// deal with, except when it is a syntax error, it may cause 		// the :endtry to be missed. 		&& (cstack.cs_trylevel == 0 || did_emsg_syntax) #endif 		&& used_getline 			    && (getline_equal(fgetline, cookie, getexmodeline) 			       || getline_equal(fgetline, cookie, getexline))) 	    && (next_cmdline != NULL #ifdef FEAT_EVAL 			|| cstack.cs_idx >= 0 #endif 			|| (flags & DOCMD_REPEAT)));      vim_free(cmdline_copy);     did_emsg_syntax = FALSE; #ifdef FEAT_EVAL     free_cmdlines(&lines_ga);     ga_clear(&lines_ga);      if (cstack.cs_idx >= 0)     { 	/* 	 * If a sourced file or executed function ran to its end, report the 	 * unclosed conditional. 	 * In Vim9 script do not give a second error, executing aborts after 	 * the first one. 	 */ 	if (!got_int && !did_throw && !aborting() 		&& !(did_emsg && in_vim9script()) 		&& ((getline_equal(fgetline, cookie, getsourceline) 			&& !source_finished(fgetline, cookie)) 		    || (getline_equal(fgetline, cookie, get_func_line) 					    && !func_has_ended(real_cookie)))) 	{ 	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY) 		emsg(_(e_missing_endtry)); 	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE) 		emsg(_(e_missing_endwhile)); 	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR) 		emsg(_(e_missing_endfor)); 	    else 		emsg(_(e_missing_endif)); 	}  	/* 	 * Reset ""trylevel"" in case of a "":finish"" or "":return"" or a missing 	 * "":endtry"" in a sourced file or executed function.  If the try 	 * conditional is in its finally clause, ignore anything pending. 	 * If it is in a catch clause, finish the caught exception. 	 * Also cleanup any ""cs_forinfo"" structures. 	 */ 	do 	{ 	    int idx = cleanup_conditionals(&cstack, 0, TRUE);  	    if (idx >= 0) 		--idx;	    // remove try block not in its finally clause 	    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR, 							&cstack.cs_looplevel); 	} 	while (cstack.cs_idx >= 0); 	trylevel = initial_trylevel;     }      // If a missing "":endtry"", "":endwhile"", "":endfor"", or "":endif"" or a memory     // lack was reported above and the error message is to be converted to an     // exception, do this now after rewinding the cstack.     do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line) 				  ? (char_u *)""endfunction"" : (char_u *)NULL);      if (trylevel == 0)     { 	// Just in case did_throw got set but current_exception wasn't. 	if (current_exception == NULL) 	    did_throw = FALSE;  	/* 	 * When an exception is being thrown out of the outermost try 	 * conditional, discard the uncaught exception, disable the conversion 	 * of interrupts or errors to exceptions, and ensure that no more 	 * commands are executed. 	 */ 	if (did_throw) 	    handle_did_throw();  	/* 	 * On an interrupt or an aborting error not converted to an exception, 	 * disable the conversion of errors to exceptions.  (Interrupts are not 	 * converted anymore, here.) This enables also the interrupt message 	 * when force_abort is set and did_emsg unset in case of an interrupt 	 * from a finally clause after an error. 	 */ 	else if (got_int || (did_emsg && force_abort)) 	    suppress_errthrow = TRUE;     }      /*      * The current cstack will be freed when do_cmdline() returns.  An uncaught      * exception will have to be rethrown in the previous cstack.  If a function      * has just returned or a script file was just finished and the previous      * cstack belongs to the same function or, respectively, script file, it      * will have to be checked for finally clauses to be executed due to the      * "":return"" or "":finish"".  This is done in do_one_cmd().      */     if (did_throw) 	need_rethrow = TRUE;     if ((getline_equal(fgetline, cookie, getsourceline) 		&& ex_nesting_level > source_level(real_cookie)) 	    || (getline_equal(fgetline, cookie, get_func_line) 		&& ex_nesting_level > func_level(real_cookie) + 1))     { 	if (!did_throw) 	    check_cstack = TRUE;     }     else     { 	// When leaving a function, reduce nesting level. 	if (getline_equal(fgetline, cookie, get_func_line)) 	    --ex_nesting_level; 	/* 	 * Go to debug mode when returning from a function in which we are 	 * single-stepping. 	 */ 	if ((getline_equal(fgetline, cookie, getsourceline) 		    || getline_equal(fgetline, cookie, get_func_line)) 		&& ex_nesting_level + 1 <= debug_break_level) 	    do_debug(getline_equal(fgetline, cookie, getsourceline) 		    ? (char_u *)_(""End of sourced file"") 		    : (char_u *)_(""End of function""));     }      /*      * Restore the exception environment (done after returning from the      * debugger).      */     if (flags & DOCMD_EXCRESET) 	restore_dbg_stuff(&debug_saved);      msg_list = saved_msg_list;      // Cleanup if ""cs_emsg_silent_list"" remains.     if (cstack.cs_emsg_silent_list != NULL)     { 	eslist_T *elem, *temp;  	for (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp) 	{ 	    temp = elem->next; 	    vim_free(elem); 	}     } #endif // FEAT_EVAL      /*      * If there was too much output to fit on the command line, ask the user to      * hit return before redrawing the screen. With the "":global"" command we do      * this only once after the command is finished.      */     if (did_inc)     { 	--RedrawingDisabled; 	--no_wait_return; 	msg_scroll = FALSE;  	/* 	 * When just finished an "":if""-"":else"" which was typed, no need to 	 * wait for hit-return.  Also for an error situation. 	 */ 	if (retval == FAIL #ifdef FEAT_EVAL 		|| (did_endif && KeyTyped && !did_emsg) #endif 					    ) 	{ 	    need_wait_return = FALSE; 	    msg_didany = FALSE;		// don't wait when restarting edit 	} 	else if (need_wait_return) 	{ 	    /* 	     * The msg_start() above clears msg_didout. The wait_return() we do 	     * here should not overwrite the command that may be shown before 	     * doing that. 	     */ 	    msg_didout |= msg_didout_before_start; 	    wait_return(FALSE); 	}     }  #ifdef FEAT_EVAL     did_endif = FALSE;  // in case do_cmdline used recursively #else     /*      * Reset if_level, in case a sourced script file contains more "":if"" than      * "":endif"" (could be "":if x | foo | endif"").      */     if_level = 0; #endif      --call_depth;     return retval; }"
"210961_CWE-121.c","CWE-121","static int nft_set_desc_concat_parse(const struct nlattr *attr, 				     struct nft_set_desc *desc) { 	struct nlattr *tb[NFTA_SET_FIELD_MAX + 1]; 	u32 len; 	int err;  	err = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr, 					  nft_concat_policy, NULL); 	if (err < 0) 		return err;  	if (!tb[NFTA_SET_FIELD_LEN]) 		return -EINVAL;  	len = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));  	if (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT) 		return -E2BIG;  	desc->field_len[desc->field_count++] = len;  	return 0; }"
"211090_CWE-20.c","CWE-20","add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype) { 	int rc = 0; 	uid_t uid; 	char *mount_user = NULL; 	struct mntent mountent; 	FILE *pmntfile; 	sigset_t mask, oldmask;  	uid = getuid(); 	if (uid != 0) 		mount_user = getusername(uid);  	/* 	 * Set the real uid to the effective uid. This prevents unprivileged 	 * users from sending signals to this process, though ^c on controlling 	 * terminal should still work. 	 */ 	rc = setreuid(geteuid(), -1); 	if (rc != 0) { 		fprintf(stderr, ""Unable to set real uid to effective uid: %s\n"", 				strerror(errno)); 		return EX_FILEIO; 	}  	rc = sigfillset(&mask); 	if (rc) { 		fprintf(stderr, ""Unable to set filled signal mask\n""); 		return EX_FILEIO; 	}  	rc = sigprocmask(SIG_SETMASK, &mask, &oldmask); 	if (rc) { 		fprintf(stderr, ""Unable to make process ignore signals\n""); 		return EX_FILEIO; 	}  	rc = toggle_dac_capability(1, 1); 	if (rc) 		return EX_FILEIO;  	atexit(unlock_mtab); 	rc = lock_mtab(); 	if (rc) { 		fprintf(stderr, ""cannot lock mtab""); 		rc = EX_FILEIO; 		goto add_mtab_exit; 	}  	pmntfile = setmntent(MOUNTED, ""a+""); 	if (!pmntfile) { 		fprintf(stderr, ""could not update mount table\n""); 		unlock_mtab(); 		rc = EX_FILEIO; 		goto add_mtab_exit; 	}  	mountent.mnt_fsname = devname; 	mountent.mnt_dir = mountpoint; 	mountent.mnt_type = (char *)(void *)fstype; 	mountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1); 	if (mountent.mnt_opts) { 		if (flags & MS_RDONLY) 			strlcat(mountent.mnt_opts, ""ro"", MTAB_OPTIONS_LEN); 		else 			strlcat(mountent.mnt_opts, ""rw"", MTAB_OPTIONS_LEN);  		if (flags & MS_MANDLOCK) 			strlcat(mountent.mnt_opts, "",mand"", MTAB_OPTIONS_LEN); 		if (flags & MS_NOEXEC) 			strlcat(mountent.mnt_opts, "",noexec"", MTAB_OPTIONS_LEN); 		if (flags & MS_NOSUID) 			strlcat(mountent.mnt_opts, "",nosuid"", MTAB_OPTIONS_LEN); 		if (flags & MS_NODEV) 			strlcat(mountent.mnt_opts, "",nodev"", MTAB_OPTIONS_LEN); 		if (flags & MS_SYNCHRONOUS) 			strlcat(mountent.mnt_opts, "",sync"", MTAB_OPTIONS_LEN); 		if (mount_user) { 			strlcat(mountent.mnt_opts, "",user="", MTAB_OPTIONS_LEN); 			strlcat(mountent.mnt_opts, mount_user, 				MTAB_OPTIONS_LEN); 		} 	} 	mountent.mnt_freq = 0; 	mountent.mnt_passno = 0; 	rc = addmntent(pmntfile, &mountent); 	if (rc) { 		fprintf(stderr, ""unable to add mount entry to mtab\n""); 		rc = EX_FILEIO; 	} 	endmntent(pmntfile); 	unlock_mtab(); 	SAFE_FREE(mountent.mnt_opts); add_mtab_exit: 	toggle_dac_capability(1, 0); 	sigprocmask(SIG_SETMASK, &oldmask, NULL);  	return rc; }"
"211102_CWE-22.cpp","CWE-22","extract_archive_thread (GSimpleAsyncResult *result, 			GObject            *object, 			GCancellable       *cancellable) { 	ExtractData          *extract_data; 	LoadData             *load_data; 	GHashTable           *checked_folders; 	struct archive       *a; 	struct archive_entry *entry; 	int                   r;  	extract_data = g_simple_async_result_get_op_res_gpointer (result); 	load_data = LOAD_DATA (extract_data);  	checked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL); 	fr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);  	a = archive_read_new (); 	archive_read_support_filter_all (a); 	archive_read_support_format_all (a); 	archive_read_open (a, load_data, load_data_open, load_data_read, load_data_close); 	while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) { 		const char    *pathname; 		char          *fullpath; 		GFile         *file; 		GFile         *parent; 		GOutputStream *ostream; 		const void    *buffer; 		size_t         buffer_size; 		int64_t        offset; 		GError        *local_error = NULL; 		__LA_MODE_T    filetype;  		if (g_cancellable_is_cancelled (cancellable)) 			break;  		pathname = archive_entry_pathname (entry); 		if (! extract_data_get_extraction_requested (extract_data, pathname)) { 			archive_read_data_skip (a); 			continue; 		}  		fullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (""/"", pathname, NULL); 		file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));  		/* honor the skip_older and overwrite options */  		if (extract_data->skip_older || ! extract_data->overwrite) { 			GFileInfo *info;  			info = g_file_query_info (file, 						  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "","" G_FILE_ATTRIBUTE_TIME_MODIFIED, 						  G_FILE_QUERY_INFO_NONE, 						  cancellable, 						  &local_error); 			if (info != NULL) { 				gboolean skip = FALSE;  				if (! extract_data->overwrite) { 					skip = TRUE; 				} 				else if (extract_data->skip_older) { 					GTimeVal modification_time;  					g_file_info_get_modification_time (info, &modification_time); 					if (archive_entry_mtime (entry) < modification_time.tv_sec) 						skip = TRUE; 				}  				g_object_unref (info);  				if (skip) { 					g_object_unref (file);  					archive_read_data_skip (a); 					fr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);  					if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { 						r = ARCHIVE_EOF; 						break; 					}  					continue; 				} 			} 			else { 				if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) { 					load_data->error = local_error; 					g_object_unref (info); 					break; 				} 				g_error_free (local_error); 			} 		}  		fr_archive_progress_inc_completed_files (load_data->archive, 1);  		/* create the file parents */  		parent = g_file_get_parent (file);  		if ((parent != NULL) 		    && (g_hash_table_lookup (checked_folders, parent) == NULL) 		    && ! g_file_query_exists (parent, cancellable)) 		{ 			if (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) { 				GFile *grandparent;  				grandparent = g_object_ref (parent); 				while (grandparent != NULL) { 					if (g_hash_table_lookup (checked_folders, grandparent) == NULL) 						g_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1)); 					grandparent = g_file_get_parent (grandparent); 				} 			} 		} 		g_object_unref (parent);  		/* create the file */  		filetype = archive_entry_filetype (entry);  		if (load_data->error == NULL) { 			const char  *linkname;  			linkname = archive_entry_hardlink (entry); 			if (linkname != NULL) { 				char  *link_fullpath; 				GFile *link_file; 				char  *oldname; 				char  *newname; 				int    r;  				link_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (""/"", linkname, NULL); 				link_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths)); 				oldname = g_file_get_path (link_file); 				newname = g_file_get_path (file);  				if ((oldname != NULL) && (newname != NULL)) 					r = link (oldname, newname); 				else 					r = -1;  				if (r == 0) { 					__LA_INT64_T filesize;  					if (archive_entry_size_is_set (entry)) 						filesize = archive_entry_size (entry); 					else 						filesize = -1;  					if (filesize > 0) 						filetype = AE_IFREG; /* treat as a regular file to save the data */ 				} 				else { 					char *uri; 					char *msg;  					uri = g_file_get_uri (file); 					msg = g_strdup_printf (""Could not create the hard link %s"", uri); 					load_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);  					g_free (msg); 					g_free (uri); 				}  				g_free (newname); 				g_free (oldname); 				g_object_unref (link_file); 				g_free (link_fullpath); 			} 		}  		if (load_data->error == NULL) { 			switch (filetype) { 			case AE_IFDIR: 				if (! g_file_make_directory (file, cancellable, &local_error)) { 					if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) 						load_data->error = g_error_copy (local_error); 					g_error_free (local_error); 				} 				else 					_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable); 				archive_read_data_skip (a); 				break;  			case AE_IFREG: 				ostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error); 				if (ostream == NULL) 					break;  				while ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) { 					if (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1) 						break; 					fr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size); 				} 				_g_object_unref (ostream);  				if (r != ARCHIVE_EOF) 					load_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a)); 				else 					_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable); 				break;  			case AE_IFLNK: 				if (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) { 					if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) 						load_data->error = g_error_copy (local_error); 					g_error_free (local_error); 				} 				archive_read_data_skip (a); 				break;  			default: 				archive_read_data_skip (a); 				break; 			} 		}  		g_object_unref (file); 		g_free (fullpath);  		if (load_data->error != NULL) 			break;  		if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { 			r = ARCHIVE_EOF; 			break; 		} 	}  	if ((load_data->error == NULL) && (r != ARCHIVE_EOF)) 		load_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a)); 	if (load_data->error == NULL) 		g_cancellable_set_error_if_cancelled (cancellable, &load_data->error); 	if (load_data->error != NULL) 		g_simple_async_result_set_from_error (result, load_data->error);  	g_hash_table_unref (checked_folders); 	archive_read_free (a); 	extract_data_free (extract_data); }"
"211103_CWE-22.c","CWE-22","_fr_window_ask_overwrite_dialog (OverwriteData *odata) { 	if ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) { 		const char *base_name; 		GFile      *destination;  		base_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths); 		destination = g_file_get_child (odata->edata->destination, base_name); 		g_file_query_info_async (destination, 					 G_FILE_ATTRIBUTE_STANDARD_TYPE "","" G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME, 					 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, 					 G_PRIORITY_DEFAULT, 					 odata->window->priv->cancellable, 					 query_info_ready_for_overwrite_dialog_cb, 					 odata);  		g_object_unref (destination);  		return; 	}  	if (odata->edata->file_list != NULL) { 		/* speed optimization: passing NULL when extracting all the 		 * files is faster if the command supports the 		 * propCanExtractAll property. */ 		if (odata->extract_all) { 			_g_string_list_free (odata->edata->file_list); 			odata->edata->file_list = NULL; 		} 		odata->edata->overwrite = FR_OVERWRITE_YES; 		_fr_window_archive_extract_from_edata (odata->window, odata->edata); 	} 	else { 		GtkWidget *d;  		d = _gtk_message_dialog_new (GTK_WINDOW (odata->window), 					     0, 					     GTK_STOCK_DIALOG_WARNING, 					     _(""Extraction not performed""), 					     NULL, 					     GTK_STOCK_OK, GTK_RESPONSE_OK, 					     NULL); 		gtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK); 		fr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(""Extraction not performed""));  		fr_window_stop_batch (odata->window); 	}  	g_free (odata); }"
"211110_CWE-787.c","CWE-787","LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { 	static const char module[] = ""LZWDecodeCompat""; 	LZWCodecState *sp = DecoderState(tif); 	char *op = (char*) op0; 	long occ = (long) occ0; 	char *tp; 	unsigned char *bp; 	int code, nbits; 	long nextbits, nextdata, nbitsmask; 	code_t *codep, *free_entp, *maxcodep, *oldcodep;  	(void) s; 	assert(sp != NULL);  	/* 	  Fail if value does not fit in long. 	*/ 	if ((tmsize_t) occ != occ0) 	        return (0);  	/* 	 * Restart interrupted output operation. 	 */ 	if (sp->dec_restart) { 		long residue;  		codep = sp->dec_codep; 		residue = codep->length - sp->dec_restart; 		if (residue > occ) { 			/* 			 * Residue from previous decode is sufficient 			 * to satisfy decode request.  Skip to the 			 * start of the decoded string, place decoded 			 * values in the output buffer, and return. 			 */ 			sp->dec_restart += occ; 			do { 				codep = codep->next; 			} while (--residue > occ); 			tp = op + occ; 			do { 				*--tp = codep->value; 				codep = codep->next; 			} while (--occ); 			return (1); 		} 		/* 		 * Residue satisfies only part of the decode request. 		 */ 		op += residue; 		occ -= residue; 		tp = op; 		do { 			*--tp = codep->value; 			codep = codep->next; 		} while (--residue); 		sp->dec_restart = 0; 	}  	bp = (unsigned char *)tif->tif_rawcp; #ifdef LZW_CHECKEOS 	sp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3); #endif 	nbits = sp->lzw_nbits; 	nextdata = sp->lzw_nextdata; 	nextbits = sp->lzw_nextbits; 	nbitsmask = sp->dec_nbitsmask; 	oldcodep = sp->dec_oldcodep; 	free_entp = sp->dec_free_entp; 	maxcodep = sp->dec_maxcodep;  	while (occ > 0) { 		NextCode(tif, sp, bp, code, GetNextCodeCompat); 		if (code == CODE_EOI) 			break; 		if (code == CODE_CLEAR) { 			do { 				free_entp = sp->dec_codetab + CODE_FIRST; 				_TIFFmemset(free_entp, 0, 					    (CSIZE - CODE_FIRST) * sizeof (code_t)); 				nbits = BITS_MIN; 				nbitsmask = MAXCODE(BITS_MIN); 				maxcodep = sp->dec_codetab + nbitsmask; 				NextCode(tif, sp, bp, code, GetNextCodeCompat); 			} while (code == CODE_CLEAR);	/* consecutive CODE_CLEAR codes */ 			if (code == CODE_EOI) 				break; 			if (code > CODE_CLEAR) { 				TIFFErrorExt(tif->tif_clientdata, tif->tif_name, 				""LZWDecode: Corrupted LZW table at scanline %d"", 					     tif->tif_row); 				return (0); 			} 			*op++ = (char)code; 			occ--; 			oldcodep = sp->dec_codetab + code; 			continue; 		} 		codep = sp->dec_codetab + code;  		/* 		 * Add the new entry to the code table. 		 */ 		if (free_entp < &sp->dec_codetab[0] || 		    free_entp >= &sp->dec_codetab[CSIZE]) { 			TIFFErrorExt(tif->tif_clientdata, module, 			    ""Corrupted LZW table at scanline %d"", tif->tif_row); 			return (0); 		}  		free_entp->next = oldcodep; 		if (free_entp->next < &sp->dec_codetab[0] || 		    free_entp->next >= &sp->dec_codetab[CSIZE]) { 			TIFFErrorExt(tif->tif_clientdata, module, 			    ""Corrupted LZW table at scanline %d"", tif->tif_row); 			return (0); 		} 		free_entp->firstchar = free_entp->next->firstchar; 		free_entp->length = free_entp->next->length+1; 		free_entp->value = (codep < free_entp) ? 		    codep->firstchar : free_entp->firstchar; 		if (++free_entp > maxcodep) { 			if (++nbits > BITS_MAX)		/* should not happen */ 				nbits = BITS_MAX; 			nbitsmask = MAXCODE(nbits); 			maxcodep = sp->dec_codetab + nbitsmask; 		} 		oldcodep = codep; 		if (code >= 256) { 			/* 			 * Code maps to a string, copy string 			 * value to output (written in reverse). 			 */ 			if(codep->length == 0) { 				TIFFErrorExt(tif->tif_clientdata, module, 				    ""Wrong length of decoded "" 				    ""string: data probably corrupted at scanline %d"", 				    tif->tif_row); 				return (0); 			} 			if (codep->length > occ) { 				/* 				 * String is too long for decode buffer, 				 * locate portion that will fit, copy to 				 * the decode buffer, and setup restart 				 * logic for the next decoding call. 				 */ 				sp->dec_codep = codep; 				do { 					codep = codep->next; 				} while (codep->length > occ); 				sp->dec_restart = occ; 				tp = op + occ; 				do  { 					*--tp = codep->value; 					codep = codep->next; 				}  while (--occ); 				break; 			} 			assert(occ >= codep->length); 			op += codep->length; 			occ -= codep->length; 			tp = op; 			do { 				*--tp = codep->value; 			} while( (codep = codep->next) != NULL ); 		} else { 			*op++ = (char)code; 			occ--; 		} 	}  	tif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp ); 	tif->tif_rawcp = (uint8*) bp; 	sp->lzw_nbits = (unsigned short)nbits; 	sp->lzw_nextdata = nextdata; 	sp->lzw_nextbits = nextbits; 	sp->dec_nbitsmask = nbitsmask; 	sp->dec_oldcodep = oldcodep; 	sp->dec_free_entp = free_entp; 	sp->dec_maxcodep = maxcodep;  	if (occ > 0) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) 		TIFFErrorExt(tif->tif_clientdata, module, 			""Not enough data at scanline %d (short %I64d bytes)"", 			     tif->tif_row, (unsigned __int64) occ); #else 		TIFFErrorExt(tif->tif_clientdata, module, 			""Not enough data at scanline %d (short %llu bytes)"", 			     tif->tif_row, (unsigned long long) occ); #endif 		return (0); 	} 	return (1); }"
"211113_CWE-416.c","CWE-416","static void atusb_disconnect(struct usb_interface *interface) { 	struct atusb *atusb = usb_get_intfdata(interface);  	dev_dbg(&atusb->usb_dev->dev, ""%s\n"", __func__);  	atusb->shutdown = 1; 	cancel_delayed_work_sync(&atusb->work);  	usb_kill_anchored_urbs(&atusb->rx_urbs); 	atusb_free_urbs(atusb); 	usb_kill_urb(atusb->tx_urb); 	usb_free_urb(atusb->tx_urb);  	ieee802154_unregister_hw(atusb->hw);  	ieee802154_free_hw(atusb->hw);  	usb_set_intfdata(interface, NULL); 	usb_put_dev(atusb->usb_dev);  	pr_debug(""%s done\n"", __func__); }"
"211126_CWE-125.c","CWE-125","static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {     if (indx == NULL) {         debug_print(""%s"", ""INDX structure not initialized\n"");         return MOBI_INIT_FAILED;     }     const size_t entry_offset = indx->entries_count;     const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];     mobi_buffer_setpos(buf, idxt.offsets[curr_number]);     size_t entry_number = curr_number + entry_offset;     if (entry_number >= indx->total_entries_count) {         debug_print(""Entry number beyond array: %zu\n"", entry_number);         return MOBI_DATA_CORRUPT;     }     /* save original record maxlen */     const size_t buf_maxlen = buf->maxlen;     if (buf->offset + entry_length >= buf_maxlen) {         debug_print(""Entry length too long: %zu\n"", entry_length);         return MOBI_DATA_CORRUPT;     }     buf->maxlen = buf->offset + entry_length;     size_t label_length = mobi_buffer_get8(buf);     if (label_length > entry_length) {         debug_print(""Label length too long: %zu\n"", label_length);         return MOBI_DATA_CORRUPT;     }     char text[INDX_LABEL_SIZEMAX];     /* FIXME: what is ORDT1 for? */     if (ordt->ordt2) {         label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);     } else {         label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);     }     indx->entries[entry_number].label = malloc(label_length + 1);     if (indx->entries[entry_number].label == NULL) {         debug_print(""Memory allocation failed (%zu bytes)\n"", label_length);         return MOBI_MALLOC_FAILED;     }     strncpy(indx->entries[entry_number].label, text, label_length + 1);     //debug_print(""tag label[%zu]: %s\n"", entry_number, indx->entries[entry_number].label);     unsigned char *control_bytes;     control_bytes = buf->data + buf->offset;     mobi_buffer_seek(buf, (int) tagx->control_byte_count);     indx->entries[entry_number].tags_count = 0;     indx->entries[entry_number].tags = NULL;     if (tagx->tags_count > 0) {         typedef struct {             uint8_t tag;             uint8_t tag_value_count;             uint32_t value_count;             uint32_t value_bytes;         } MOBIPtagx;         MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));         if (ptagx == NULL) {             debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIPtagx));             return MOBI_MALLOC_FAILED;         }         uint32_t ptagx_count = 0;         size_t len;         size_t i = 0;         while (i < tagx->tags_count) {             if (tagx->tags[i].control_byte == 1) {                 control_bytes++;                 i++;                 continue;             }             uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;             if (value != 0) {                 /* FIXME: is it safe to use MOBI_NOTSET? */                 uint32_t value_count = MOBI_NOTSET;                 uint32_t value_bytes = MOBI_NOTSET;                 /* all bits of masked value are set */                 if (value == tagx->tags[i].bitmask) {                     /* more than 1 bit set */                     if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {                         /* read value bytes from entry */                         len = 0;                         value_bytes = mobi_buffer_get_varlen(buf, &len);                     } else {                         value_count = 1;                     }                 } else {                     uint8_t mask = tagx->tags[i].bitmask;                     while ((mask & 1) == 0) {                         mask >>= 1;                         value >>= 1;                     }                     value_count = value;                 }                 ptagx[ptagx_count].tag = tagx->tags[i].tag;                 ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;                 ptagx[ptagx_count].value_count = value_count;                 ptagx[ptagx_count].value_bytes = value_bytes;                 ptagx_count++;             }             i++;         }         indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));         if (indx->entries[entry_number].tags == NULL) {             debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIIndexTag));             free(ptagx);             return MOBI_MALLOC_FAILED;         }         i = 0;         while (i < ptagx_count) {             uint32_t tagvalues_count = 0;             /* FIXME: is it safe to use MOBI_NOTSET? */             /* value count is set */             uint32_t tagvalues[INDX_TAGVALUES_MAX];             if (ptagx[i].value_count != MOBI_NOTSET) {                 size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;                 while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {                     len = 0;                     const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);                     tagvalues[tagvalues_count++] = value_bytes;                 }             /* value count is not set */             } else {                 /* read value_bytes bytes */                 len = 0;                 while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {                     const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);                     tagvalues[tagvalues_count++] = value_bytes;                 }             }             if (tagvalues_count) {                 const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);                 indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);                 if (indx->entries[entry_number].tags[i].tagvalues == NULL) {                     debug_print(""Memory allocation failed (%zu bytes)\n"", arr_size);                     free(ptagx);                     return MOBI_MALLOC_FAILED;                 }                 memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);             } else {                 indx->entries[entry_number].tags[i].tagvalues = NULL;             }             indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;             indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;             indx->entries[entry_number].tags_count++;             i++;         }         free(ptagx);     }     /* restore buffer maxlen */     buf->maxlen = buf_maxlen;     return MOBI_SUCCESS; }"
"211136_CWE-787.c","CWE-787","static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) { 	RzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos); 	if (!result) { 		return NULL; 	}  	if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) { 		ut32 total_slide_infos = 0; 		ut32 n_slide_infos[MAX_N_HDR];  		ut32 i; 		for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) { 			ut64 hdr_offset = cache->hdr_offset[i]; 			if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) { 				goto beach; 			} 			total_slide_infos += n_slide_infos[i]; 		}  		if (!total_slide_infos) { 			goto beach; 		}  		RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos); 		if (!infos) { 			goto beach; 		}  		ut32 k = 0; 		for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) { 			ut64 hdr_offset = cache->hdr_offset[i]; 			if (!n_slide_infos[i]) { 				continue; 			} 			ut32 sio; 			if (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) { 				continue; 			} 			ut64 slide_infos_offset = sio; 			if (!slide_infos_offset) { 				continue; 			} 			slide_infos_offset += hdr_offset;  			ut32 j; 			RzDyldRebaseInfo *prev_info = NULL; 			for (j = 0; j < n_slide_infos[i]; j++) { 				ut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide); 				cache_mapping_slide entry; 				if (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, ""6lii"", 1) != sizeof(cache_mapping_slide)) { 					break; 				}  				if (entry.slideInfoOffset && entry.slideInfoSize) { 					infos[k].start = entry.fileOffset + hdr_offset; 					infos[k].end = infos[k].start + entry.size; 					ut64 slide = prev_info ? prev_info->slide : UT64_MAX; 					infos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide); 					prev_info = infos[k].info; 					k++; 				} 			} 		}  		if (!k) { 			free(infos); 			goto beach; 		}  		if (k < total_slide_infos) { 			RzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k); 			if (!pruned_infos) { 				free(infos); 				goto beach; 			}  			memcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k); 			free(infos); 			infos = pruned_infos; 		}  		result->entries = infos; 		result->length = k; 		return result; 	}  	if (cache->hdr->mappingCount > 1) { 		RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1); 		if (!infos) { 			goto beach; 		}  		infos[0].start = cache->maps[1].fileOffset; 		infos[0].end = infos[0].start + cache->maps[1].size; 		infos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);  		result->entries = infos; 		result->length = 1; 		return result; 	}  beach: 	free(result); 	return NULL; }"
"211155_CWE-787.c","CWE-787","int tcp_emu(struct socket *so, struct mbuf *m) {     Slirp *slirp = so->slirp;     unsigned n1, n2, n3, n4, n5, n6;     char buff[257];     uint32_t laddr;     unsigned lport;     char *bptr;      DEBUG_CALL(""tcp_emu"");     DEBUG_ARG(""so = %p"", so);     DEBUG_ARG(""m = %p"", m);      switch (so->so_emu) {         int x, i;          /* TODO: IPv6 */     case EMU_IDENT:         /*          * Identification protocol as per rfc-1413          */          {             struct socket *tmpso;             struct sockaddr_in addr;             socklen_t addrlen = sizeof(struct sockaddr_in);             char *eol = g_strstr_len(m->m_data, m->m_len, ""\r\n"");              if (!eol) {                 return 1;             }              *eol = '\0';             if (sscanf(m->m_data, ""%u%*[ ,]%u"", &n1, &n2) == 2) {                 HTONS(n1);                 HTONS(n2);                 /* n2 is the one on our host */                 for (tmpso = slirp->tcb.so_next; tmpso != &slirp->tcb;                      tmpso = tmpso->so_next) {                     if (tmpso->so_laddr.s_addr == so->so_laddr.s_addr &&                         tmpso->so_lport == n2 &&                         tmpso->so_faddr.s_addr == so->so_faddr.s_addr &&                         tmpso->so_fport == n1) {                         if (getsockname(tmpso->s, (struct sockaddr *)&addr,                                         &addrlen) == 0)                             n2 = addr.sin_port;                         break;                     }                 }                 NTOHS(n1);                 NTOHS(n2);                 m_inc(m, snprintf(NULL, 0, ""%d,%d\r\n"", n1, n2) + 1);                 m->m_len = snprintf(m->m_data, M_ROOM(m), ""%d,%d\r\n"", n1, n2);                 assert(m->m_len < M_ROOM(m));             } else {                 *eol = '\r';             }              return 1;         }      case EMU_FTP: /* ftp */         m_inc(m, m->m_len + 1);         *(m->m_data + m->m_len) = 0; /* NUL terminate for strstr */         if ((bptr = (char *)strstr(m->m_data, ""ORT"")) != NULL) {             /*              * Need to emulate the PORT command              */             x = sscanf(bptr, ""ORT %u,%u,%u,%u,%u,%u\r\n%256[^\177]"", &n1, &n2,                        &n3, &n4, &n5, &n6, buff);             if (x < 6)                 return 1;              laddr = htonl((n1 << 24) | (n2 << 16) | (n3 << 8) | (n4));             lport = htons((n5 << 8) | (n6));              if ((so = tcp_listen(slirp, INADDR_ANY, 0, laddr, lport,                                  SS_FACCEPTONCE)) == NULL) {                 return 1;             }             n6 = ntohs(so->so_fport);              n5 = (n6 >> 8) & 0xff;             n6 &= 0xff;              laddr = ntohl(so->so_faddr.s_addr);              n1 = ((laddr >> 24) & 0xff);             n2 = ((laddr >> 16) & 0xff);             n3 = ((laddr >> 8) & 0xff);             n4 = (laddr & 0xff);              m->m_len = bptr - m->m_data; /* Adjust length */             m->m_len += snprintf(bptr, m->m_size - m->m_len,                                  ""ORT %d,%d,%d,%d,%d,%d\r\n%s"", n1, n2, n3, n4,                                  n5, n6, x == 7 ? buff : """");             return 1;         } else if ((bptr = (char *)strstr(m->m_data, ""27 Entering"")) != NULL) {             /*              * Need to emulate the PASV response              */             x = sscanf(                 bptr,                 ""27 Entering Passive Mode (%u,%u,%u,%u,%u,%u)\r\n%256[^\177]"",                 &n1, &n2, &n3, &n4, &n5, &n6, buff);             if (x < 6)                 return 1;              laddr = htonl((n1 << 24) | (n2 << 16) | (n3 << 8) | (n4));             lport = htons((n5 << 8) | (n6));              if ((so = tcp_listen(slirp, INADDR_ANY, 0, laddr, lport,                                  SS_FACCEPTONCE)) == NULL) {                 return 1;             }             n6 = ntohs(so->so_fport);              n5 = (n6 >> 8) & 0xff;             n6 &= 0xff;              laddr = ntohl(so->so_faddr.s_addr);              n1 = ((laddr >> 24) & 0xff);             n2 = ((laddr >> 16) & 0xff);             n3 = ((laddr >> 8) & 0xff);             n4 = (laddr & 0xff);              m->m_len = bptr - m->m_data; /* Adjust length */             m->m_len +=                 snprintf(bptr, m->m_size - m->m_len,                          ""27 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n%s"",                          n1, n2, n3, n4, n5, n6, x == 7 ? buff : """");              return 1;         }          return 1;      case EMU_KSH:         /*          * The kshell (Kerberos rsh) and shell services both pass          * a local port port number to carry signals to the server          * and stderr to the client.  It is passed at the beginning          * of the connection as a NUL-terminated decimal ASCII string.          */         so->so_emu = 0;         for (lport = 0, i = 0; i < m->m_len - 1; ++i) {             if (m->m_data[i] < '0' || m->m_data[i] > '9')                 return 1; /* invalid number */             lport *= 10;             lport += m->m_data[i] - '0';         }         if (m->m_data[m->m_len - 1] == '\0' && lport != 0 &&             (so = tcp_listen(slirp, INADDR_ANY, 0, so->so_laddr.s_addr,                              htons(lport), SS_FACCEPTONCE)) != NULL)             m->m_len =                 snprintf(m->m_data, m->m_size, ""%d"", ntohs(so->so_fport)) + 1;         return 1;      case EMU_IRC:         /*          * Need to emulate DCC CHAT, DCC SEND and DCC MOVE          */         m_inc(m, m->m_len + 1);         *(m->m_data + m->m_len) = 0; /* NULL terminate the string for strstr */         if ((bptr = (char *)strstr(m->m_data, ""DCC"")) == NULL)             return 1;          /* The %256s is for the broken mIRC */         if (sscanf(bptr, ""DCC CHAT %256s %u %u"", buff, &laddr, &lport) == 3) {             if ((so = tcp_listen(slirp, INADDR_ANY, 0, htonl(laddr),                                  htons(lport), SS_FACCEPTONCE)) == NULL) {                 return 1;             }             m->m_len = bptr - m->m_data; /* Adjust length */             m->m_len += snprintf(bptr, m->m_size, ""DCC CHAT chat %lu %u%c\n"",                                  (unsigned long)ntohl(so->so_faddr.s_addr),                                  ntohs(so->so_fport), 1);         } else if (sscanf(bptr, ""DCC SEND %256s %u %u %u"", buff, &laddr, &lport,                           &n1) == 4) {             if ((so = tcp_listen(slirp, INADDR_ANY, 0, htonl(laddr),                                  htons(lport), SS_FACCEPTONCE)) == NULL) {                 return 1;             }             m->m_len = bptr - m->m_data; /* Adjust length */             m->m_len +=                 snprintf(bptr, m->m_size, ""DCC SEND %s %lu %u %u%c\n"", buff,                          (unsigned long)ntohl(so->so_faddr.s_addr),                          ntohs(so->so_fport), n1, 1);         } else if (sscanf(bptr, ""DCC MOVE %256s %u %u %u"", buff, &laddr, &lport,                           &n1) == 4) {             if ((so = tcp_listen(slirp, INADDR_ANY, 0, htonl(laddr),                                  htons(lport), SS_FACCEPTONCE)) == NULL) {                 return 1;             }             m->m_len = bptr - m->m_data; /* Adjust length */             m->m_len +=                 snprintf(bptr, m->m_size, ""DCC MOVE %s %lu %u %u%c\n"", buff,                          (unsigned long)ntohl(so->so_faddr.s_addr),                          ntohs(so->so_fport), n1, 1);         }         return 1;      case EMU_REALAUDIO:         /*          * RealAudio emulation - JP. We must try to parse the incoming          * data and try to find the two characters that contain the          * port number. Then we redirect an udp port and replace the          * number with the real port we got.          *          * The 1.0 beta versions of the player are not supported          * any more.          *          * A typical packet for player version 1.0 (release version):          *          * 0000:50 4E 41 00 05          * 0000:00 01 00 02 1B D7 00 00 67 E6 6C DC 63 00 12 50 ........g.l.c..P          * 0010:4E 43 4C 49 45 4E 54 20 31 30 31 20 41 4C 50 48 NCLIENT 101 ALPH          * 0020:41 6C 00 00 52 00 17 72 61 66 69 6C 65 73 2F 76 Al..R..rafiles/v          * 0030:6F 61 2F 65 6E 67 6C 69 73 68 5F 2E 72 61 79 42 oa/english_.rayB          *          * Now the port number 0x1BD7 is found at offset 0x04 of the          * Now the port number 0x1BD7 is found at offset 0x04 of the          * second packet. This time we received five bytes first and          * then the rest. You never know how many bytes you get.          *          * A typical packet for player version 2.0 (beta):          *          * 0000:50 4E 41 00 06 00 02 00 00 00 01 00 02 1B C1 00 PNA.............          * 0010:00 67 75 78 F5 63 00 0A 57 69 6E 32 2E 30 2E 30 .gux.c..Win2.0.0          * 0020:2E 35 6C 00 00 52 00 1C 72 61 66 69 6C 65 73 2F .5l..R..rafiles/          * 0030:77 65 62 73 69 74 65 2F 32 30 72 65 6C 65 61 73 website/20releas          * 0040:65 2E 72 61 79 53 00 00 06 36 42                e.rayS...6B          *          * Port number 0x1BC1 is found at offset 0x0d.          *          * This is just a horrible switch statement. Variable ra tells          * us where we're going.          */          bptr = m->m_data;         while (bptr < m->m_data + m->m_len) {             uint16_t p;             static int ra = 0;             char ra_tbl[4];              ra_tbl[0] = 0x50;             ra_tbl[1] = 0x4e;             ra_tbl[2] = 0x41;             ra_tbl[3] = 0;              switch (ra) {             case 0:             case 2:             case 3:                 if (*bptr++ != ra_tbl[ra]) {                     ra = 0;                     continue;                 }                 break;              case 1:                 /*                  * We may get 0x50 several times, ignore them                  */                 if (*bptr == 0x50) {                     ra = 1;                     bptr++;                     continue;                 } else if (*bptr++ != ra_tbl[ra]) {                     ra = 0;                     continue;                 }                 break;              case 4:                 /*                  * skip version number                  */                 bptr++;                 break;              case 5:                 /*                  * The difference between versions 1.0 and                  * 2.0 is here. For future versions of                  * the player this may need to be modified.                  */                 if (*(bptr + 1) == 0x02)                     bptr += 8;                 else                     bptr += 4;                 break;              case 6:                 /* This is the field containing the port                  * number that RA-player is listening to.                  */                 lport = (((uint8_t *)bptr)[0] << 8) + ((uint8_t *)bptr)[1];                 if (lport < 6970)                     lport += 256; /* don't know why */                 if (lport < 6970 || lport > 7170)                     return 1; /* failed */                  /* try to get udp port between 6970 - 7170 */                 for (p = 6970; p < 7071; p++) {                     if (udp_listen(slirp, INADDR_ANY, htons(p),                                    so->so_laddr.s_addr, htons(lport),                                    SS_FACCEPTONCE)) {                         break;                     }                 }                 if (p == 7071)                     p = 0;                 *(uint8_t *)bptr++ = (p >> 8) & 0xff;                 *(uint8_t *)bptr = p & 0xff;                 ra = 0;                 return 1; /* port redirected, we're done */                 break;              default:                 ra = 0;             }             ra++;         }         return 1;      default:         /* Ooops, not emulated, won't call tcp_emu again */         so->so_emu = 0;         return 1;     } }"
"211179_CWE-125.cpp","CWE-125","    void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)     {         depth++;         bool bFirst  = true  ;          // buffer         const size_t dirSize = 32;         DataBuf  dir(dirSize);         bool bPrint = option == kpsBasic || option == kpsRecursive;          do {             // Read top of directory             io.seek(start,BasicIo::beg);             io.read(dir.pData_, 2);             uint16_t   dirLength = byteSwap2(dir,0,bSwap);              bool tooBig = dirLength > 500;             if ( tooBig ) throw Error(55);              if ( bFirst && bPrint ) {                 out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF TIFF FILE (%c%c): "",c,c) << io.path() << std::endl;                 if ( tooBig ) out << Internal::indent(depth) << ""dirLength = "" << dirLength << std::endl;             }              // Read the dictionary             for ( int i = 0 ; i < dirLength ; i ++ ) {                 if ( bFirst && bPrint ) {                     out << Internal::indent(depth)                         << "" address |    tag                              |     ""                         << "" type |    count |    offset | value\n"";                 }                 bFirst = false;                  io.read(dir.pData_, 12);                 uint16_t tag    = byteSwap2(dir,0,bSwap);                 uint16_t type   = byteSwap2(dir,2,bSwap);                 uint32_t count  = byteSwap4(dir,4,bSwap);                 uint32_t offset = byteSwap4(dir,8,bSwap);                  // Break for unknown tag types else we may segfault.                 if ( !typeValid(type) ) {                     std::cerr << ""invalid type value detected in Image::printIFDStructure:  "" << type << std::endl;                     start = 0; // break from do loop                     throw Error(56);                     break; // break from for loop                 }                  std::string sp  = """" ; // output spacer                  //prepare to print the value                 uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data                                 : isPrintICC(tag,option) ? count // ditto                                 : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays                                 : count > 5              ? 5                                 : count                                 ;                 uint32_t pad    = isStringType(type) ? 1 : 0;                 uint32_t size   = isStringType(type) ? 1                                 : is2ByteType(type)  ? 2                                 : is4ByteType(type)  ? 4                                 : is8ByteType(type)  ? 8                                 : 1                                 ;                  // if ( offset > io.size() ) offset = 0; // Denial of service?                 DataBuf  buf(size*count + pad+20);  // allocate a buffer                 std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)                 const bool bOffsetIsPointer = count*size > 4;                  if ( bOffsetIsPointer ) {         // read into buffer                     size_t   restore = io.tell();  // save                     io.seek(offset,BasicIo::beg);  // position                     io.read(buf.pData_,count*size);// read                     io.seek(restore,BasicIo::beg); // restore                 }                  if ( bPrint ) {                     const uint32_t address = start + 2 + i*12 ;                     const std::string offsetString = bOffsetIsPointer?                         Internal::stringFormat(""%10u"", offset):                         """";                      out << Internal::indent(depth)                     << Internal::stringFormat(""%8u | %#06x %-28s |%10s |%9u |%10s | ""                                               ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());                     if ( isShortType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             out << sp << byteSwap2(buf,k*size,bSwap);                             sp = "" "";                         }                     } else if ( isLongType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             out << sp << byteSwap4(buf,k*size,bSwap);                             sp = "" "";                         }                      } else if ( isRationalType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             uint32_t a = byteSwap4(buf,k*size+0,bSwap);                             uint32_t b = byteSwap4(buf,k*size+4,bSwap);                             out << sp << a << ""/"" << b;                             sp = "" "";                         }                     } else if ( isStringType(type) ) {                         out << sp << Internal::binaryToString(buf, kount);                     }                      sp = kount == count ? """" : "" ..."";                     out << sp << std::endl;                      if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {                         for ( size_t k = 0 ; k < count ; k++ ) {                             size_t   restore = io.tell();                             uint32_t offset = byteSwap4(buf,k*size,bSwap);                             printIFDStructure(io,out,option,offset,bSwap,c,depth);                             io.seek(restore,BasicIo::beg);                         }                     } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {                         size_t   restore = io.tell();  // save                         io.seek(offset,BasicIo::beg);  // position                         byte* bytes=new byte[count] ;  // allocate memory                         io.read(bytes,count)        ;  // read                         io.seek(restore,BasicIo::beg); // restore                         IptcData::printStructure(out,bytes,count,depth);                         delete[] bytes;                // free                     }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {                         size_t   restore = io.tell();  // save                          uint32_t jump= 10           ;                         byte     bytes[20]          ;                         const char* chars = (const char*) &bytes[0] ;                         io.seek(offset,BasicIo::beg);  // position                         io.read(bytes,jump    )     ;  // read                         bytes[jump]=0               ;                         if ( ::strcmp(""Nikon"",chars) == 0 ) {                             // tag is an embedded tiff                             byte* bytes=new byte[count-jump] ;  // allocate memory                             io.read(bytes,count-jump)        ;  // read                             MemIo memIo(bytes,count-jump)    ;  // create a file                             printTiffStructure(memIo,out,option,depth);                             delete[] bytes                   ;  // free                         } else {                             // tag is an IFD                             io.seek(0,BasicIo::beg);  // position                             printIFDStructure(io,out,option,offset,bSwap,c,depth);                         }                          io.seek(restore,BasicIo::beg); // restore                     }                 }                  if ( isPrintXMP(tag,option) ) {                     buf.pData_[count]=0;                     out << (char*) buf.pData_;                 }                 if ( isPrintICC(tag,option) ) {                     out.write((const char*)buf.pData_,count);                 }             }             if ( start ) {                 io.read(dir.pData_, 4);                 start = tooBig ? 0 : byteSwap4(dir,0,bSwap);             }         } while (start) ;          if ( bPrint ) {             out << Internal::indent(depth) << ""END "" << io.path() << std::endl;         }         out.flush();         depth--;     }"
"211181_CWE-17.c","CWE-17","apprentice_load(struct magic_set *ms, const char *fn, int action) { 	int errs = 0; 	uint32_t i, j; 	size_t files = 0, maxfiles = 0; 	char **filearr = NULL; 	struct stat st; 	struct magic_map *map; 	struct magic_entry_set mset[MAGIC_SETS]; 	php_stream *dir; 	php_stream_dirent d;   	TSRMLS_FETCH();  	memset(mset, 0, sizeof(mset)); 	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */   	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL) 	{ 		file_oomem(ms, sizeof(*map)); 		return NULL; 	}  	/* print silly verbose header for USG compat. */ 	if (action == FILE_CHECK) 		(void)fprintf(stderr, ""%s\n"", usg_hdr);  	/* load directory or file */ 	/* FIXME: Read file names and sort them to prevent 	   non-determinism. See Debian bug #488562. */ 	if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) { 		int mflen; 		char mfn[MAXPATHLEN];  		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL); 		if (!dir) { 			errs++; 			goto out; 		} 		while (php_stream_readdir(dir, &d)) { 			if ((mflen = snprintf(mfn, sizeof(mfn), ""%s/%s"", fn, d.d_name)) < 0) { 				file_oomem(ms, 				strlen(fn) + strlen(d.d_name) + 2); 				errs++; 				php_stream_closedir(dir); 				goto out; 			} 			if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) { 				continue; 			} 			if (files >= maxfiles) { 				size_t mlen; 				maxfiles = (maxfiles + 1) * 2; 				mlen = maxfiles * sizeof(*filearr); 				if ((filearr = CAST(char **, 				    erealloc(filearr, mlen))) == NULL) { 					file_oomem(ms, mlen); 					efree(mfn); 					php_stream_closedir(dir); 					errs++; 					goto out; 				} 			} 			filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen); 		} 		php_stream_closedir(dir); 		qsort(filearr, files, sizeof(*filearr), cmpstrp); 		for (i = 0; i < files; i++) { 			load_1(ms, action, filearr[i], &errs, mset); 			efree(filearr[i]); 		} 		efree(filearr); 	} else 		load_1(ms, action, fn, &errs, mset); 	if (errs) 		goto out;  	for (j = 0; j < MAGIC_SETS; j++) { 		/* Set types of tests */ 		for (i = 0; i < mset[j].count; ) { 			if (mset[j].me[i].mp->cont_level != 0) { 				i++; 				continue; 			} 			i = set_text_binary(ms, mset[j].me, mset[j].count, i); 		} 		qsort(mset[j].me, mset[j].count, sizeof(*mset[j].me), 		    apprentice_sort);  		/* 		 * Make sure that any level 0 ""default"" line is last 		 * (if one exists). 		 */ 		set_last_default(ms, mset[j].me, mset[j].count);  		/* coalesce per file arrays into a single one */ 		if (coalesce_entries(ms, mset[j].me, mset[j].count, 		    &map->magic[j], &map->nmagic[j]) == -1) { 			errs++; 			goto out; 		} 	}  out: 	for (j = 0; j < MAGIC_SETS; j++) 		magic_entry_free(mset[j].me, mset[j].count);  	if (errs) { 		for (j = 0; j < MAGIC_SETS; j++) { 			if (map->magic[j]) 				efree(map->magic[j]); 		} 		efree(map); 		return NULL; 	} 	return map; }"
"211461_CWE-284.c","CWE-284","parse_cmd_address(exarg_T *eap, char **errormsg, int silent) {     int		address_count = 1;     linenr_T	lnum;     int		need_check_cursor = FALSE;     int		ret = FAIL;      // Repeat for all ',' or ';' separated addresses.     for (;;)     { 	eap->line1 = eap->line2; 	eap->line2 = default_address(eap); 	eap->cmd = skipwhite(eap->cmd); 	lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent, 					eap->addr_count == 0, address_count++); 	if (eap->cmd == NULL)	// error detected 	    goto theend; 	if (lnum == MAXLNUM) 	{ 	    if (*eap->cmd == '%')   // '%' - all lines 	    { 		++eap->cmd; 		switch (eap->addr_type) 		{ 		    case ADDR_LINES: 		    case ADDR_OTHER: 			eap->line1 = 1; 			eap->line2 = curbuf->b_ml.ml_line_count; 			break; 		    case ADDR_LOADED_BUFFERS: 			{ 			    buf_T	*buf = firstbuf;  			    while (buf->b_next != NULL 						  && buf->b_ml.ml_mfp == NULL) 				buf = buf->b_next; 			    eap->line1 = buf->b_fnum; 			    buf = lastbuf; 			    while (buf->b_prev != NULL 						  && buf->b_ml.ml_mfp == NULL) 				buf = buf->b_prev; 			    eap->line2 = buf->b_fnum; 			    break; 			} 		    case ADDR_BUFFERS: 			eap->line1 = firstbuf->b_fnum; 			eap->line2 = lastbuf->b_fnum; 			break; 		    case ADDR_WINDOWS: 		    case ADDR_TABS: 			if (IS_USER_CMDIDX(eap->cmdidx)) 			{ 			    eap->line1 = 1; 			    eap->line2 = eap->addr_type == ADDR_WINDOWS 						  ? LAST_WIN_NR : LAST_TAB_NR; 			} 			else 			{ 			    // there is no Vim command which uses '%' and 			    // ADDR_WINDOWS or ADDR_TABS 			    *errormsg = _(e_invalid_range); 			    goto theend; 			} 			break; 		    case ADDR_TABS_RELATIVE: 		    case ADDR_UNSIGNED: 		    case ADDR_QUICKFIX: 			*errormsg = _(e_invalid_range); 			goto theend; 		    case ADDR_ARGUMENTS: 			if (ARGCOUNT == 0) 			    eap->line1 = eap->line2 = 0; 			else 			{ 			    eap->line1 = 1; 			    eap->line2 = ARGCOUNT; 			} 			break; 		    case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX 			eap->line1 = 1; 			eap->line2 = qf_get_valid_size(eap); 			if (eap->line2 == 0) 			    eap->line2 = 1; #endif 			break; 		    case ADDR_NONE: 			// Will give an error later if a range is found. 			break; 		} 		++eap->addr_count; 	    } 	    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL) 	    { 		pos_T	    *fp;  		// '*' - visual area 		if (eap->addr_type != ADDR_LINES) 		{ 		    *errormsg = _(e_invalid_range); 		    goto theend; 		}  		++eap->cmd; 		if (!eap->skip) 		{ 		    fp = getmark('<', FALSE); 		    if (check_mark(fp) == FAIL) 			goto theend; 		    eap->line1 = fp->lnum; 		    fp = getmark('>', FALSE); 		    if (check_mark(fp) == FAIL) 			goto theend; 		    eap->line2 = fp->lnum; 		    ++eap->addr_count; 		} 	    } 	} 	else 	    eap->line2 = lnum; 	eap->addr_count++;  	if (*eap->cmd == ';') 	{ 	    if (!eap->skip) 	    { 		curwin->w_cursor.lnum = eap->line2;  		// Don't leave the cursor on an illegal line or column, but do 		// accept zero as address, so 0;/PATTERN/ works correctly. 		// Check the cursor position before returning. 		if (eap->line2 > 0) 		    check_cursor(); 		need_check_cursor = TRUE; 	    } 	} 	else if (*eap->cmd != ',') 	    break; 	++eap->cmd;     }      // One address given: set start and end lines.     if (eap->addr_count == 1)     { 	eap->line1 = eap->line2; 	// ... but only implicit: really no address given 	if (lnum == MAXLNUM) 	    eap->addr_count = 0;     }     ret = OK;  theend:     if (need_check_cursor) 	check_cursor();     return ret; }"
"211471_CWE-125.c","CWE-125","static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt, 				    bgp_size_t length) { 	uint8_t *end; 	struct capability_mp_data mpc; 	struct capability_header *hdr; 	uint8_t action; 	iana_afi_t pkt_afi; 	afi_t afi; 	iana_safi_t pkt_safi; 	safi_t safi;  	end = pnt + length;  	while (pnt < end) { 		/* We need at least action, capability code and capability 		 * length. */ 		if (pnt + 3 > end) { 			zlog_info(""%s Capability length error"", peer->host); 			bgp_notify_send(peer, BGP_NOTIFY_CEASE, 					BGP_NOTIFY_SUBCODE_UNSPECIFIC); 			return BGP_Stop; 		} 		action = *pnt; 		hdr = (struct capability_header *)(pnt + 1);  		/* Action value check.  */ 		if (action != CAPABILITY_ACTION_SET 		    && action != CAPABILITY_ACTION_UNSET) { 			zlog_info(""%s Capability Action Value error %d"", 				  peer->host, action); 			bgp_notify_send(peer, BGP_NOTIFY_CEASE, 					BGP_NOTIFY_SUBCODE_UNSPECIFIC); 			return BGP_Stop; 		}  		if (bgp_debug_neighbor_events(peer)) 			zlog_debug( 				""%s CAPABILITY has action: %d, code: %u, length %u"", 				peer->host, action, hdr->code, hdr->length);  		/* Capability length check. */ 		if ((pnt + hdr->length + 3) > end) { 			zlog_info(""%s Capability length error"", peer->host); 			bgp_notify_send(peer, BGP_NOTIFY_CEASE, 					BGP_NOTIFY_SUBCODE_UNSPECIFIC); 			return BGP_Stop; 		}  		/* Fetch structure to the byte stream. */ 		memcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data)); 		pnt += hdr->length + 3;  		/* We know MP Capability Code. */ 		if (hdr->code == CAPABILITY_CODE_MP) { 			pkt_afi = ntohs(mpc.afi); 			pkt_safi = mpc.safi;  			/* Ignore capability when override-capability is set. */ 			if (CHECK_FLAG(peer->flags, 				       PEER_FLAG_OVERRIDE_CAPABILITY)) 				continue;  			/* Convert AFI, SAFI to internal values. */ 			if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, 						      &safi)) { 				if (bgp_debug_neighbor_events(peer)) 					zlog_debug( 						""%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)"", 						peer->host, 						iana_afi2str(pkt_afi), 						iana_safi2str(pkt_safi)); 				continue; 			}  			/* Address family check.  */ 			if (bgp_debug_neighbor_events(peer)) 				zlog_debug( 					""%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s"", 					peer->host, 					action == CAPABILITY_ACTION_SET 						? ""Advertising"" 						: ""Removing"", 					iana_afi2str(pkt_afi), 					iana_safi2str(pkt_safi));  			if (action == CAPABILITY_ACTION_SET) { 				peer->afc_recv[afi][safi] = 1; 				if (peer->afc[afi][safi]) { 					peer->afc_nego[afi][safi] = 1; 					bgp_announce_route(peer, afi, safi, 							   false); 				} 			} else { 				peer->afc_recv[afi][safi] = 0; 				peer->afc_nego[afi][safi] = 0;  				if (peer_active_nego(peer)) 					bgp_clear_route(peer, afi, safi); 				else 					return BGP_Stop; 			} 		} else { 			flog_warn( 				EC_BGP_UNRECOGNIZED_CAPABILITY, 				""%s unrecognized capability code: %d - ignored"", 				peer->host, hdr->code); 		} 	}  	/* No FSM action necessary */ 	return BGP_PACKET_NOOP; }"
"211473_CWE-189.c","CWE-189","read_bitmap_file_data (FILE    *fstream, 		       guint   *width,  		       guint   *height, 		       guchar **data, 		       int     *x_hot,  		       int     *y_hot) { 	guchar *bits = NULL;		/* working variable */ 	char line[MAX_SIZE];		/* input line from file */ 	int size;			/* number of bytes of data */ 	char name_and_type[MAX_SIZE];	/* an input line */ 	char *type;			/* for parsing */ 	int value;			/* from an input line */ 	int version10p;			/* boolean, old format */ 	int padding;			/* to handle alignment */ 	int bytes_per_line;		/* per scanline of data */ 	guint ww = 0;			/* width */ 	guint hh = 0;			/* height */ 	int hx = -1;			/* x hotspot */ 	int hy = -1;			/* y hotspot */  	/* first time initialization */ 	if (!initialized) { 		init_hex_table (); 	}  	/* error cleanup and return macro */ #define	RETURN(code) { g_free (bits); return code; }  	while (fgets (line, MAX_SIZE, fstream)) { 		if (strlen (line) == MAX_SIZE-1) 			RETURN (FALSE); 		if (sscanf (line,""#define %s %d"",name_and_type,&value) == 2) { 			if (!(type = strrchr (name_and_type, '_'))) 				type = name_and_type; 			else { 				type++; 			}  			if (!strcmp (""width"", type)) 				ww = (unsigned int) value; 			if (!strcmp (""height"", type)) 				hh = (unsigned int) value; 			if (!strcmp (""hot"", type)) { 				if (type-- == name_and_type 				    || type-- == name_and_type) 					continue; 				if (!strcmp (""x_hot"", type)) 					hx = value; 				if (!strcmp (""y_hot"", type)) 					hy = value; 			} 			continue; 		}      		if (sscanf (line, ""static short %s = {"", name_and_type) == 1) 			version10p = 1; 		else if (sscanf (line,""static const unsigned char %s = {"",name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line,""static unsigned char %s = {"",name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line, ""static const char %s = {"", name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line, ""static char %s = {"", name_and_type) == 1) 			version10p = 0; 		else 			continue;  		if (!(type = strrchr (name_and_type, '_'))) 			type = name_and_type; 		else 			type++;  		if (strcmp (""bits[]"", type)) 			continue;      		if (!ww || !hh) 			RETURN (FALSE);  		if ((ww % 16) && ((ww % 16) < 9) && version10p) 			padding = 1; 		else 			padding = 0;  		bytes_per_line = (ww+7)/8 + padding;  		size = bytes_per_line * hh; 		bits = g_malloc (size);  		if (version10p) { 			unsigned char *ptr; 			int bytes;  			for (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) { 				if ((value = next_int (fstream)) < 0) 					RETURN (FALSE); 				*(ptr++) = value; 				if (!padding || ((bytes+2) % bytes_per_line)) 					*(ptr++) = value >> 8; 			} 		} else { 			unsigned char *ptr; 			int bytes;  			for (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) { 				if ((value = next_int (fstream)) < 0)  					RETURN (FALSE); 				*ptr=value; 			} 		} 		break; 	}  	if (!bits) 		RETURN (FALSE);  	*data = bits; 	*width = ww; 	*height = hh; 	if (x_hot) 		*x_hot = hx; 	if (y_hot) 		*y_hot = hy;  	return TRUE; }"
"211506_CWE-787.c","CWE-787","int ZEXPORT inflate(strm, flush) z_streamp strm; int flush; {     struct inflate_state FAR *state;     z_const unsigned char FAR *next;    /* next input */     unsigned char FAR *put;     /* next output */     unsigned have, left;        /* available input and output */     unsigned long hold;         /* bit buffer */     unsigned bits;              /* bits in bit buffer */     unsigned in, out;           /* save starting available input and output */     unsigned copy;              /* number of stored or match bytes to copy */     unsigned char FAR *from;    /* where to copy match bytes from */     code here;                  /* current decoding table entry */     code last;                  /* parent table entry */     unsigned len;               /* length to copy for repeats, bits to drop */     int ret;                    /* return code */ #ifdef GUNZIP     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */ #endif     static const unsigned short order[19] = /* permutation of code lengths */         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};      if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||         (strm->next_in == Z_NULL && strm->avail_in != 0))         return Z_STREAM_ERROR;      state = (struct inflate_state FAR *)strm->state;     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */     LOAD();     in = have;     out = left;     ret = Z_OK;     for (;;)         switch (state->mode) {         case HEAD:             if (state->wrap == 0) {                 state->mode = TYPEDO;                 break;             }             NEEDBITS(16); #ifdef GUNZIP             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */                 if (state->wbits == 0)                     state->wbits = 15;                 state->check = crc32(0L, Z_NULL, 0);                 CRC2(state->check, hold);                 INITBITS();                 state->mode = FLAGS;                 break;             }             if (state->head != Z_NULL)                 state->head->done = -1;             if (!(state->wrap & 1) ||   /* check if zlib header allowed */ #else             if ( #endif                 ((BITS(8) << 8) + (hold >> 8)) % 31) {                 strm->msg = (char *)""incorrect header check"";                 state->mode = BAD;                 break;             }             if (BITS(4) != Z_DEFLATED) {                 strm->msg = (char *)""unknown compression method"";                 state->mode = BAD;                 break;             }             DROPBITS(4);             len = BITS(4) + 8;             if (state->wbits == 0)                 state->wbits = len;             if (len > 15 || len > state->wbits) {                 strm->msg = (char *)""invalid window size"";                 state->mode = BAD;                 break;             }             state->dmax = 1U << len;             state->flags = 0;               /* indicate zlib header */             Tracev((stderr, ""inflate:   zlib header ok\n""));             strm->adler = state->check = adler32(0L, Z_NULL, 0);             state->mode = hold & 0x200 ? DICTID : TYPE;             INITBITS();             break; #ifdef GUNZIP         case FLAGS:             NEEDBITS(16);             state->flags = (int)(hold);             if ((state->flags & 0xff) != Z_DEFLATED) {                 strm->msg = (char *)""unknown compression method"";                 state->mode = BAD;                 break;             }             if (state->flags & 0xe000) {                 strm->msg = (char *)""unknown header flags set"";                 state->mode = BAD;                 break;             }             if (state->head != Z_NULL)                 state->head->text = (int)((hold >> 8) & 1);             if ((state->flags & 0x0200) && (state->wrap & 4))                 CRC2(state->check, hold);             INITBITS();             state->mode = TIME;                 /* fallthrough */         case TIME:             NEEDBITS(32);             if (state->head != Z_NULL)                 state->head->time = hold;             if ((state->flags & 0x0200) && (state->wrap & 4))                 CRC4(state->check, hold);             INITBITS();             state->mode = OS;                 /* fallthrough */         case OS:             NEEDBITS(16);             if (state->head != Z_NULL) {                 state->head->xflags = (int)(hold & 0xff);                 state->head->os = (int)(hold >> 8);             }             if ((state->flags & 0x0200) && (state->wrap & 4))                 CRC2(state->check, hold);             INITBITS();             state->mode = EXLEN;                 /* fallthrough */         case EXLEN:             if (state->flags & 0x0400) {                 NEEDBITS(16);                 state->length = (unsigned)(hold);                 if (state->head != Z_NULL)                     state->head->extra_len = (unsigned)hold;                 if ((state->flags & 0x0200) && (state->wrap & 4))                     CRC2(state->check, hold);                 INITBITS();             }             else if (state->head != Z_NULL)                 state->head->extra = Z_NULL;             state->mode = EXTRA;                 /* fallthrough */         case EXTRA:             if (state->flags & 0x0400) {                 copy = state->length;                 if (copy > have) copy = have;                 if (copy) {                     if (state->head != Z_NULL &&                         state->head->extra != Z_NULL) {                         len = state->head->extra_len - state->length;                         zmemcpy(state->head->extra + len, next,                                 len + copy > state->head->extra_max ?                                 state->head->extra_max - len : copy);                     }                     if ((state->flags & 0x0200) && (state->wrap & 4))                         state->check = crc32(state->check, next, copy);                     have -= copy;                     next += copy;                     state->length -= copy;                 }                 if (state->length) goto inf_leave;             }             state->length = 0;             state->mode = NAME;                 /* fallthrough */         case NAME:             if (state->flags & 0x0800) {                 if (have == 0) goto inf_leave;                 copy = 0;                 do {                     len = (unsigned)(next[copy++]);                     if (state->head != Z_NULL &&                             state->head->name != Z_NULL &&                             state->length < state->head->name_max)                         state->head->name[state->length++] = (Bytef)len;                 } while (len && copy < have);                 if ((state->flags & 0x0200) && (state->wrap & 4))                     state->check = crc32(state->check, next, copy);                 have -= copy;                 next += copy;                 if (len) goto inf_leave;             }             else if (state->head != Z_NULL)                 state->head->name = Z_NULL;             state->length = 0;             state->mode = COMMENT;                 /* fallthrough */         case COMMENT:             if (state->flags & 0x1000) {                 if (have == 0) goto inf_leave;                 copy = 0;                 do {                     len = (unsigned)(next[copy++]);                     if (state->head != Z_NULL &&                             state->head->comment != Z_NULL &&                             state->length < state->head->comm_max)                         state->head->comment[state->length++] = (Bytef)len;                 } while (len && copy < have);                 if ((state->flags & 0x0200) && (state->wrap & 4))                     state->check = crc32(state->check, next, copy);                 have -= copy;                 next += copy;                 if (len) goto inf_leave;             }             else if (state->head != Z_NULL)                 state->head->comment = Z_NULL;             state->mode = HCRC;                 /* fallthrough */         case HCRC:             if (state->flags & 0x0200) {                 NEEDBITS(16);                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {                     strm->msg = (char *)""header crc mismatch"";                     state->mode = BAD;                     break;                 }                 INITBITS();             }             if (state->head != Z_NULL) {                 state->head->hcrc = (int)((state->flags >> 9) & 1);                 state->head->done = 1;             }             strm->adler = state->check = crc32(0L, Z_NULL, 0);             state->mode = TYPE;             break; #endif         case DICTID:             NEEDBITS(32);             strm->adler = state->check = ZSWAP32(hold);             INITBITS();             state->mode = DICT;                 /* fallthrough */         case DICT:             if (state->havedict == 0) {                 RESTORE();                 return Z_NEED_DICT;             }             strm->adler = state->check = adler32(0L, Z_NULL, 0);             state->mode = TYPE;                 /* fallthrough */         case TYPE:             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;                 /* fallthrough */         case TYPEDO:             if (state->last) {                 BYTEBITS();                 state->mode = CHECK;                 break;             }             NEEDBITS(3);             state->last = BITS(1);             DROPBITS(1);             switch (BITS(2)) {             case 0:                             /* stored block */                 Tracev((stderr, ""inflate:     stored block%s\n"",                         state->last ? "" (last)"" : """"));                 state->mode = STORED;                 break;             case 1:                             /* fixed block */                 fixedtables(state);                 Tracev((stderr, ""inflate:     fixed codes block%s\n"",                         state->last ? "" (last)"" : """"));                 state->mode = LEN_;             /* decode codes */                 if (flush == Z_TREES) {                     DROPBITS(2);                     goto inf_leave;                 }                 break;             case 2:                             /* dynamic block */                 Tracev((stderr, ""inflate:     dynamic codes block%s\n"",                         state->last ? "" (last)"" : """"));                 state->mode = TABLE;                 break;             case 3:                 strm->msg = (char *)""invalid block type"";                 state->mode = BAD;             }             DROPBITS(2);             break;         case STORED:             BYTEBITS();                         /* go to byte boundary */             NEEDBITS(32);             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {                 strm->msg = (char *)""invalid stored block lengths"";                 state->mode = BAD;                 break;             }             state->length = (unsigned)hold & 0xffff;             Tracev((stderr, ""inflate:       stored length %u\n"",                     state->length));             INITBITS();             state->mode = COPY_;             if (flush == Z_TREES) goto inf_leave;                 /* fallthrough */         case COPY_:             state->mode = COPY;                 /* fallthrough */         case COPY:             copy = state->length;             if (copy) {                 if (copy > have) copy = have;                 if (copy > left) copy = left;                 if (copy == 0) goto inf_leave;                 zmemcpy(put, next, copy);                 have -= copy;                 next += copy;                 left -= copy;                 put += copy;                 state->length -= copy;                 break;             }             Tracev((stderr, ""inflate:       stored end\n""));             state->mode = TYPE;             break;         case TABLE:             NEEDBITS(14);             state->nlen = BITS(5) + 257;             DROPBITS(5);             state->ndist = BITS(5) + 1;             DROPBITS(5);             state->ncode = BITS(4) + 4;             DROPBITS(4); #ifndef PKZIP_BUG_WORKAROUND             if (state->nlen > 286 || state->ndist > 30) {                 strm->msg = (char *)""too many length or distance symbols"";                 state->mode = BAD;                 break;             } #endif             Tracev((stderr, ""inflate:       table sizes ok\n""));             state->have = 0;             state->mode = LENLENS;                 /* fallthrough */         case LENLENS:             while (state->have < state->ncode) {                 NEEDBITS(3);                 state->lens[order[state->have++]] = (unsigned short)BITS(3);                 DROPBITS(3);             }             while (state->have < 19)                 state->lens[order[state->have++]] = 0;             state->next = state->codes;             state->lencode = (const code FAR *)(state->next);             state->lenbits = 7;             ret = inflate_table(CODES, state->lens, 19, &(state->next),                                 &(state->lenbits), state->work);             if (ret) {                 strm->msg = (char *)""invalid code lengths set"";                 state->mode = BAD;                 break;             }             Tracev((stderr, ""inflate:       code lengths ok\n""));             state->have = 0;             state->mode = CODELENS;                 /* fallthrough */         case CODELENS:             while (state->have < state->nlen + state->ndist) {                 for (;;) {                     here = state->lencode[BITS(state->lenbits)];                     if ((unsigned)(here.bits) <= bits) break;                     PULLBYTE();                 }                 if (here.val < 16) {                     DROPBITS(here.bits);                     state->lens[state->have++] = here.val;                 }                 else {                     if (here.val == 16) {                         NEEDBITS(here.bits + 2);                         DROPBITS(here.bits);                         if (state->have == 0) {                             strm->msg = (char *)""invalid bit length repeat"";                             state->mode = BAD;                             break;                         }                         len = state->lens[state->have - 1];                         copy = 3 + BITS(2);                         DROPBITS(2);                     }                     else if (here.val == 17) {                         NEEDBITS(here.bits + 3);                         DROPBITS(here.bits);                         len = 0;                         copy = 3 + BITS(3);                         DROPBITS(3);                     }                     else {                         NEEDBITS(here.bits + 7);                         DROPBITS(here.bits);                         len = 0;                         copy = 11 + BITS(7);                         DROPBITS(7);                     }                     if (state->have + copy > state->nlen + state->ndist) {                         strm->msg = (char *)""invalid bit length repeat"";                         state->mode = BAD;                         break;                     }                     while (copy--)                         state->lens[state->have++] = (unsigned short)len;                 }             }              /* handle error breaks in while */             if (state->mode == BAD) break;              /* check for end-of-block code (better have one) */             if (state->lens[256] == 0) {                 strm->msg = (char *)""invalid code -- missing end-of-block"";                 state->mode = BAD;                 break;             }              /* build code tables -- note: do not change the lenbits or distbits                values here (9 and 6) without reading the comments in inftrees.h                concerning the ENOUGH constants, which depend on those values */             state->next = state->codes;             state->lencode = (const code FAR *)(state->next);             state->lenbits = 9;             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),                                 &(state->lenbits), state->work);             if (ret) {                 strm->msg = (char *)""invalid literal/lengths set"";                 state->mode = BAD;                 break;             }             state->distcode = (const code FAR *)(state->next);             state->distbits = 6;             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,                             &(state->next), &(state->distbits), state->work);             if (ret) {                 strm->msg = (char *)""invalid distances set"";                 state->mode = BAD;                 break;             }             Tracev((stderr, ""inflate:       codes ok\n""));             state->mode = LEN_;             if (flush == Z_TREES) goto inf_leave;                 /* fallthrough */         case LEN_:             state->mode = LEN;                 /* fallthrough */         case LEN:             if (have >= 6 && left >= 258) {                 RESTORE();                 inflate_fast(strm, out);                 LOAD();                 if (state->mode == TYPE)                     state->back = -1;                 break;             }             state->back = 0;             for (;;) {                 here = state->lencode[BITS(state->lenbits)];                 if ((unsigned)(here.bits) <= bits) break;                 PULLBYTE();             }             if (here.op && (here.op & 0xf0) == 0) {                 last = here;                 for (;;) {                     here = state->lencode[last.val +                             (BITS(last.bits + last.op) >> last.bits)];                     if ((unsigned)(last.bits + here.bits) <= bits) break;                     PULLBYTE();                 }                 DROPBITS(last.bits);                 state->back += last.bits;             }             DROPBITS(here.bits);             state->back += here.bits;             state->length = (unsigned)here.val;             if ((int)(here.op) == 0) {                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?                         ""inflate:         literal '%c'\n"" :                         ""inflate:         literal 0x%02x\n"", here.val));                 state->mode = LIT;                 break;             }             if (here.op & 32) {                 Tracevv((stderr, ""inflate:         end of block\n""));                 state->back = -1;                 state->mode = TYPE;                 break;             }             if (here.op & 64) {                 strm->msg = (char *)""invalid literal/length code"";                 state->mode = BAD;                 break;             }             state->extra = (unsigned)(here.op) & 15;             state->mode = LENEXT;                 /* fallthrough */         case LENEXT:             if (state->extra) {                 NEEDBITS(state->extra);                 state->length += BITS(state->extra);                 DROPBITS(state->extra);                 state->back += state->extra;             }             Tracevv((stderr, ""inflate:         length %u\n"", state->length));             state->was = state->length;             state->mode = DIST;                 /* fallthrough */         case DIST:             for (;;) {                 here = state->distcode[BITS(state->distbits)];                 if ((unsigned)(here.bits) <= bits) break;                 PULLBYTE();             }             if ((here.op & 0xf0) == 0) {                 last = here;                 for (;;) {                     here = state->distcode[last.val +                             (BITS(last.bits + last.op) >> last.bits)];                     if ((unsigned)(last.bits + here.bits) <= bits) break;                     PULLBYTE();                 }                 DROPBITS(last.bits);                 state->back += last.bits;             }             DROPBITS(here.bits);             state->back += here.bits;             if (here.op & 64) {                 strm->msg = (char *)""invalid distance code"";                 state->mode = BAD;                 break;             }             state->offset = (unsigned)here.val;             state->extra = (unsigned)(here.op) & 15;             state->mode = DISTEXT;                 /* fallthrough */         case DISTEXT:             if (state->extra) {                 NEEDBITS(state->extra);                 state->offset += BITS(state->extra);                 DROPBITS(state->extra);                 state->back += state->extra;             } #ifdef INFLATE_STRICT             if (state->offset > state->dmax) {                 strm->msg = (char *)""invalid distance too far back"";                 state->mode = BAD;                 break;             } #endif             Tracevv((stderr, ""inflate:         distance %u\n"", state->offset));             state->mode = MATCH;                 /* fallthrough */         case MATCH:             if (left == 0) goto inf_leave;             copy = out - left;             if (state->offset > copy) {         /* copy from window */                 copy = state->offset - copy;                 if (copy > state->whave) {                     if (state->sane) {                         strm->msg = (char *)""invalid distance too far back"";                         state->mode = BAD;                         break;                     } #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR                     Trace((stderr, ""inflate.c too far\n""));                     copy -= state->whave;                     if (copy > state->length) copy = state->length;                     if (copy > left) copy = left;                     left -= copy;                     state->length -= copy;                     do {                         *put++ = 0;                     } while (--copy);                     if (state->length == 0) state->mode = LEN;                     break; #endif                 }                 if (copy > state->wnext) {                     copy -= state->wnext;                     from = state->window + (state->wsize - copy);                 }                 else                     from = state->window + (state->wnext - copy);                 if (copy > state->length) copy = state->length;             }             else {                              /* copy from output */                 from = put - state->offset;                 copy = state->length;             }             if (copy > left) copy = left;             left -= copy;             state->length -= copy;             do {                 *put++ = *from++;             } while (--copy);             if (state->length == 0) state->mode = LEN;             break;         case LIT:             if (left == 0) goto inf_leave;             *put++ = (unsigned char)(state->length);             left--;             state->mode = LEN;             break;         case CHECK:             if (state->wrap) {                 NEEDBITS(32);                 out -= left;                 strm->total_out += out;                 state->total += out;                 if ((state->wrap & 4) && out)                     strm->adler = state->check =                         UPDATE_CHECK(state->check, put - out, out);                 out = left;                 if ((state->wrap & 4) && ( #ifdef GUNZIP                      state->flags ? hold : #endif                      ZSWAP32(hold)) != state->check) {                     strm->msg = (char *)""incorrect data check"";                     state->mode = BAD;                     break;                 }                 INITBITS();                 Tracev((stderr, ""inflate:   check matches trailer\n""));             } #ifdef GUNZIP             state->mode = LENGTH;                 /* fallthrough */         case LENGTH:             if (state->wrap && state->flags) {                 NEEDBITS(32);                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {                     strm->msg = (char *)""incorrect length check"";                     state->mode = BAD;                     break;                 }                 INITBITS();                 Tracev((stderr, ""inflate:   length matches trailer\n""));             } #endif             state->mode = DONE;                 /* fallthrough */         case DONE:             ret = Z_STREAM_END;             goto inf_leave;         case BAD:             ret = Z_DATA_ERROR;             goto inf_leave;         case MEM:             return Z_MEM_ERROR;         case SYNC:                 /* fallthrough */         default:             return Z_STREAM_ERROR;         }      /*        Return from inflate(), updating the total counts and the check value.        If there was no progress during the inflate() call, return a buffer        error.  Call updatewindow() to create and/or update the window state.        Note: a memory error from inflate() is non-recoverable.      */   inf_leave:     RESTORE();     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&             (state->mode < CHECK || flush != Z_FINISH)))         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {             state->mode = MEM;             return Z_MEM_ERROR;         }     in -= strm->avail_in;     out -= strm->avail_out;     strm->total_in += in;     strm->total_out += out;     state->total += out;     if ((state->wrap & 4) && out)         strm->adler = state->check =             UPDATE_CHECK(state->check, strm->next_out - out, out);     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +                       (state->mode == TYPE ? 128 : 0) +                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)         ret = Z_BUF_ERROR;     return ret; }"
"211522_CWE-703.c","CWE-703","parse_cmd_address(exarg_T *eap, char **errormsg, int silent) {     int		address_count = 1;     linenr_T	lnum;      // Repeat for all ',' or ';' separated addresses.     for (;;)     { 	eap->line1 = eap->line2; 	eap->line2 = default_address(eap); 	eap->cmd = skipwhite(eap->cmd); 	lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent, 					eap->addr_count == 0, address_count++); 	if (eap->cmd == NULL)	// error detected 	    return FAIL; 	if (lnum == MAXLNUM) 	{ 	    if (*eap->cmd == '%')   // '%' - all lines 	    { 		++eap->cmd; 		switch (eap->addr_type) 		{ 		    case ADDR_LINES: 		    case ADDR_OTHER: 			eap->line1 = 1; 			eap->line2 = curbuf->b_ml.ml_line_count; 			break; 		    case ADDR_LOADED_BUFFERS: 			{ 			    buf_T	*buf = firstbuf;  			    while (buf->b_next != NULL 						  && buf->b_ml.ml_mfp == NULL) 				buf = buf->b_next; 			    eap->line1 = buf->b_fnum; 			    buf = lastbuf; 			    while (buf->b_prev != NULL 						  && buf->b_ml.ml_mfp == NULL) 				buf = buf->b_prev; 			    eap->line2 = buf->b_fnum; 			    break; 			} 		    case ADDR_BUFFERS: 			eap->line1 = firstbuf->b_fnum; 			eap->line2 = lastbuf->b_fnum; 			break; 		    case ADDR_WINDOWS: 		    case ADDR_TABS: 			if (IS_USER_CMDIDX(eap->cmdidx)) 			{ 			    eap->line1 = 1; 			    eap->line2 = eap->addr_type == ADDR_WINDOWS 						  ? LAST_WIN_NR : LAST_TAB_NR; 			} 			else 			{ 			    // there is no Vim command which uses '%' and 			    // ADDR_WINDOWS or ADDR_TABS 			    *errormsg = _(e_invalid_range); 			    return FAIL; 			} 			break; 		    case ADDR_TABS_RELATIVE: 		    case ADDR_UNSIGNED: 		    case ADDR_QUICKFIX: 			*errormsg = _(e_invalid_range); 			return FAIL; 		    case ADDR_ARGUMENTS: 			if (ARGCOUNT == 0) 			    eap->line1 = eap->line2 = 0; 			else 			{ 			    eap->line1 = 1; 			    eap->line2 = ARGCOUNT; 			} 			break; 		    case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX 			eap->line1 = 1; 			eap->line2 = qf_get_valid_size(eap); 			if (eap->line2 == 0) 			    eap->line2 = 1; #endif 			break; 		    case ADDR_NONE: 			// Will give an error later if a range is found. 			break; 		} 		++eap->addr_count; 	    } 	    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL) 	    { 		pos_T	    *fp;  		// '*' - visual area 		if (eap->addr_type != ADDR_LINES) 		{ 		    *errormsg = _(e_invalid_range); 		    return FAIL; 		}  		++eap->cmd; 		if (!eap->skip) 		{ 		    fp = getmark('<', FALSE); 		    if (check_mark(fp) == FAIL) 			return FAIL; 		    eap->line1 = fp->lnum; 		    fp = getmark('>', FALSE); 		    if (check_mark(fp) == FAIL) 			return FAIL; 		    eap->line2 = fp->lnum; 		    ++eap->addr_count; 		} 	    } 	} 	else 	    eap->line2 = lnum; 	eap->addr_count++;  	if (*eap->cmd == ';') 	{ 	    if (!eap->skip) 	    { 		curwin->w_cursor.lnum = eap->line2; 		// Don't leave the cursor on an illegal line or column, but do 		// accept zero as address, so 0;/PATTERN/ works correctly. 		if (eap->line2 > 0) 		    check_cursor(); 	    } 	} 	else if (*eap->cmd != ',') 	    break; 	++eap->cmd;     }      // One address given: set start and end lines.     if (eap->addr_count == 1)     { 	eap->line1 = eap->line2; 	// ... but only implicit: really no address given 	if (lnum == MAXLNUM) 	    eap->addr_count = 0;     }     return OK; }"
"211563_CWE-122.c","CWE-122","n_start_visual_mode(int c) { #ifdef FEAT_CONCEAL     int cursor_line_was_concealed = curwin->w_p_cole > 0 						&& conceal_cursor_line(curwin); #endif      VIsual_mode = c;     VIsual_active = TRUE;     VIsual_reselect = TRUE;     trigger_modechanged();      // Corner case: the 0 position in a tab may change when going into     // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.     if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)     { 	validate_virtcol(); 	coladvance(curwin->w_virtcol);     }     VIsual = curwin->w_cursor;  #ifdef FEAT_FOLDING     foldAdjustVisual(); #endif      setmouse(); #ifdef FEAT_CONCEAL     // Check if redraw is needed after changing the state.     conceal_check_cursor_line(cursor_line_was_concealed); #endif      if (p_smd && msg_silent == 0) 	redraw_cmdline = TRUE;	// show visual mode later #ifdef FEAT_CLIPBOARD     // Make sure the clipboard gets updated.  Needed because start and     // end may still be the same, and the selection needs to be owned     clip_star.vmode = NUL; #endif      // Only need to redraw this line, unless still need to redraw an old     // Visual area (when 'lazyredraw' is set).     if (curwin->w_redr_type < INVERTED)     { 	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum; 	curwin->w_old_visual_lnum = curwin->w_cursor.lnum;     } }"
"211567_CWE-189.c","CWE-189","static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {   char *name;   uint32_t i;    if (!len) return NULL;   if (len>400) len=400;   name = cli_malloc(len);   if (!name) {     cli_dbgmsg(""SIS: OOM\n"");     return NULL;   }   fseek(f, ptr, SEEK_SET);   if (fread(name, len, 1, f)!=1) {     cli_dbgmsg(""SIS: Unable to read string\n"");     free(name);     return NULL;   }   for (i = 0 ; i < len; i+=2) name[i/2] = name[i];   name[i/2]='\0';   return name; }"
"211594_CWE-400.c","CWE-400","static Image *ReadWPGImage(const ImageInfo *image_info,   ExceptionInfo *exception) {   typedef struct   {     size_t FileId;     MagickOffsetType DataOffset;     unsigned int ProductType;     unsigned int FileType;     unsigned char MajorVersion;     unsigned char MinorVersion;     unsigned int EncryptKey;     unsigned int Reserved;   } WPGHeader;    typedef struct   {     unsigned char RecType;     size_t RecordLength;   } WPGRecord;    typedef struct   {     unsigned char Class;     unsigned char RecType;     size_t Extension;     size_t RecordLength;   } WPG2Record;    typedef struct   {     unsigned  HorizontalUnits;     unsigned  VerticalUnits;     unsigned char PosSizePrecision;   } WPG2Start;    typedef struct   {     unsigned int Width;     unsigned int Height;     unsigned int Depth;     unsigned int HorzRes;     unsigned int VertRes;   } WPGBitmapType1;    typedef struct   {     unsigned int Width;     unsigned int Height;     unsigned char Depth;     unsigned char Compression;   } WPG2BitmapType1;    typedef struct   {     unsigned int RotAngle;     unsigned int LowLeftX;     unsigned int LowLeftY;     unsigned int UpRightX;     unsigned int UpRightY;     unsigned int Width;     unsigned int Height;     unsigned int Depth;     unsigned int HorzRes;     unsigned int VertRes;   } WPGBitmapType2;    typedef struct   {     unsigned int StartIndex;     unsigned int NumOfEntries;   } WPGColorMapRec;    /*   typedef struct {     size_t PS_unknown1;     unsigned int PS_unknown2;     unsigned int PS_unknown3;   } WPGPSl1Record;     */    Image     *image;    unsigned int     status;    WPGHeader     Header;    WPGRecord     Rec;    WPG2Record     Rec2;    WPG2Start StartWPG;    WPGBitmapType1     BitmapHeader1;    WPG2BitmapType1     Bitmap2Header1;    WPGBitmapType2     BitmapHeader2;    WPGColorMapRec     WPG_Palette;    int     i,     bpp,     WPG2Flags;    ssize_t     ldblk;    size_t     one;    unsigned char     *BImgBuff;    tCTM CTM;         /*current transform matrix*/    /*     Open image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   one=1;   image=AcquireImage(image_info,exception);   image->depth=8;   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   /*     Read WPG image.   */   Header.FileId=ReadBlobLSBLong(image);   Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);   Header.ProductType=ReadBlobLSBShort(image);   Header.FileType=ReadBlobLSBShort(image);   Header.MajorVersion=ReadBlobByte(image);   Header.MinorVersion=ReadBlobByte(image);   Header.EncryptKey=ReadBlobLSBShort(image);   Header.Reserved=ReadBlobLSBShort(image);    if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");   if (Header.EncryptKey!=0)     ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");    image->columns = 1;   image->rows = 1;   image->colors = 0;   bpp=0;   BitmapHeader2.RotAngle=0;   Rec2.RecordLength=0;    switch(Header.FileType)     {     case 1:     /* WPG level 1 */       while(!EOFBlob(image)) /* object parser loop */         {           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);           if(EOFBlob(image))             break;            Rec.RecType=(i=ReadBlobByte(image));           if(i==EOF)             break;           Rd_WP_DWORD(image,&Rec.RecordLength);           if (Rec.RecordLength > GetBlobSize(image))             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");           if(EOFBlob(image))             break;            Header.DataOffset=TellBlob(image)+Rec.RecordLength;            switch(Rec.RecType)             {             case 0x0B: /* bitmap type 1 */               BitmapHeader1.Width=ReadBlobLSBShort(image);               BitmapHeader1.Height=ReadBlobLSBShort(image);               if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");               BitmapHeader1.Depth=ReadBlobLSBShort(image);               BitmapHeader1.HorzRes=ReadBlobLSBShort(image);               BitmapHeader1.VertRes=ReadBlobLSBShort(image);                if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)                 {                   image->units=PixelsPerCentimeterResolution;                   image->resolution.x=BitmapHeader1.HorzRes/470.0;                   image->resolution.y=BitmapHeader1.VertRes/470.0;                 }               image->columns=BitmapHeader1.Width;               image->rows=BitmapHeader1.Height;               bpp=BitmapHeader1.Depth;                goto UnpackRaster;              case 0x0E:  /*Color palette */               WPG_Palette.StartIndex=ReadBlobLSBShort(image);               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >                   (Rec2.RecordLength-2-2) / 3)                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");               image->colors=WPG_Palette.NumOfEntries;               if (!AcquireImageColormap(image,image->colors,exception))                 goto NoMemory;               for (i=WPG_Palette.StartIndex;                    i < (int)WPG_Palette.NumOfEntries; i++)                 {                   image->colormap[i].red=ScaleCharToQuantum((unsigned char)                     ReadBlobByte(image));                   image->colormap[i].green=ScaleCharToQuantum((unsigned char)                     ReadBlobByte(image));                   image->colormap[i].blue=ScaleCharToQuantum((unsigned char)                     ReadBlobByte(image));                 }               break;                   case 0x11:  /* Start PS l1 */               if(Rec.RecordLength > 8)                 image=ExtractPostscript(image,image_info,                   TellBlob(image)+8,   /* skip PS header in the wpg */                   (ssize_t) Rec.RecordLength-8,exception);               break;                   case 0x14:  /* bitmap type 2 */               BitmapHeader2.RotAngle=ReadBlobLSBShort(image);               BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);               BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);               BitmapHeader2.UpRightX=ReadBlobLSBShort(image);               BitmapHeader2.UpRightY=ReadBlobLSBShort(image);               BitmapHeader2.Width=ReadBlobLSBShort(image);               BitmapHeader2.Height=ReadBlobLSBShort(image);               if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");               BitmapHeader2.Depth=ReadBlobLSBShort(image);               BitmapHeader2.HorzRes=ReadBlobLSBShort(image);               BitmapHeader2.VertRes=ReadBlobLSBShort(image);                image->units=PixelsPerCentimeterResolution;               image->page.width=(unsigned int)                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);               image->page.height=(unsigned int)                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);               image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);               image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);               if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)                 {                   image->resolution.x=BitmapHeader2.HorzRes/470.0;                   image->resolution.y=BitmapHeader2.VertRes/470.0;                 }               image->columns=BitmapHeader2.Width;               image->rows=BitmapHeader2.Height;               bpp=BitmapHeader2.Depth;              UnpackRaster:                     status=SetImageExtent(image,image->columns,image->rows,exception);               if (status == MagickFalse)                 break;               if ((image->colors == 0) && (bpp != 24))                 {                   image->colors=one << bpp;                   if (!AcquireImageColormap(image,image->colors,exception))                     {                     NoMemory:                       ThrowReaderException(ResourceLimitError,                         ""MemoryAllocationFailed"");                     }                   /* printf(""Load default colormap \n""); */                   for (i=0; (i < (int) image->colors) && (i < 256); i++)                     {                                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);                       image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);                       image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);                     }                 }               else                 {                   if (bpp < 24)                     if ( (image->colors < (one << bpp)) && (bpp != 24) )                       image->colormap=(PixelInfo *) ResizeQuantumMemory(                         image->colormap,(size_t) (one << bpp),                         sizeof(*image->colormap));                 }                          if (bpp == 1)                 {                   if(image->colormap[0].red==0 &&                      image->colormap[0].green==0 &&                      image->colormap[0].blue==0 &&                      image->colormap[1].red==0 &&                      image->colormap[1].green==0 &&                      image->colormap[1].blue==0)                     {  /* fix crippled monochrome palette */                       image->colormap[1].red =                         image->colormap[1].green =                         image->colormap[1].blue = QuantumRange;                     }                 }                      if(UnpackWPGRaster(image,bpp,exception) < 0)                 /* The raster cannot be unpacked */                 {                 DecompressionFailed:                   ThrowReaderException(CoderError,""UnableToDecompressImage"");                     }                if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)                 {                     /* flop command */                   if(BitmapHeader2.RotAngle & 0x8000)                     {                       Image                         *flop_image;                        flop_image = FlopImage(image, exception);                       if (flop_image != (Image *) NULL) {                         DuplicateBlob(flop_image,image);                         ReplaceImageInList(&image,flop_image);                       }                     }                   /* flip command */                   if(BitmapHeader2.RotAngle & 0x2000)                     {                       Image                         *flip_image;                        flip_image = FlipImage(image, exception);                       if (flip_image != (Image *) NULL) {                         DuplicateBlob(flip_image,image);                         ReplaceImageInList(&image,flip_image);                       }                     }                   /* rotate command */                   if(BitmapHeader2.RotAngle & 0x0FFF)                     {                       Image                         *rotate_image;                        rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &                         0x0FFF), exception);                       if (rotate_image != (Image *) NULL) {                         DuplicateBlob(rotate_image,image);                         ReplaceImageInList(&image,rotate_image);                       }                     }                 }                /* Allocate next image structure. */               AcquireNextImage(image_info,image,exception);               image->depth=8;               if (image->next == (Image *) NULL)                 goto Finish;               image=SyncNextImageInList(image);               image->columns=image->rows=1;               image->colors=0;               break;              case 0x1B:  /* Postscript l2 */               if(Rec.RecordLength>0x3C)                 image=ExtractPostscript(image,image_info,                   TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */                   (ssize_t) Rec.RecordLength-0x3C,exception);               break;             }         }       break;      case 2:  /* WPG level 2 */       (void) memset(CTM,0,sizeof(CTM));       StartWPG.PosSizePrecision = 0;       while(!EOFBlob(image)) /* object parser loop */         {           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);           if(EOFBlob(image))             break;            Rec2.Class=(i=ReadBlobByte(image));           if(i==EOF)             break;           Rec2.RecType=(i=ReadBlobByte(image));           if(i==EOF)             break;           Rd_WP_DWORD(image,&Rec2.Extension);           Rd_WP_DWORD(image,&Rec2.RecordLength);           if(EOFBlob(image))             break;            Header.DataOffset=TellBlob(image)+Rec2.RecordLength;            switch(Rec2.RecType)             {       case 1:               StartWPG.HorizontalUnits=ReadBlobLSBShort(image);               StartWPG.VerticalUnits=ReadBlobLSBShort(image);               StartWPG.PosSizePrecision=ReadBlobByte(image);               break;             case 0x0C:    /* Color palette */               WPG_Palette.StartIndex=ReadBlobLSBShort(image);               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >                   (Rec2.RecordLength-2-2) / 3)                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");               image->colors=WPG_Palette.NumOfEntries;               if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)                 ThrowReaderException(ResourceLimitError,                   ""MemoryAllocationFailed"");               for (i=WPG_Palette.StartIndex;                    i < (int)WPG_Palette.NumOfEntries; i++)                 {                   image->colormap[i].red=ScaleCharToQuantum((char)                     ReadBlobByte(image));                   image->colormap[i].green=ScaleCharToQuantum((char)                     ReadBlobByte(image));                   image->colormap[i].blue=ScaleCharToQuantum((char)                     ReadBlobByte(image));                   (void) ReadBlobByte(image);   /*Opacity??*/                 }               break;             case 0x0E:               Bitmap2Header1.Width=ReadBlobLSBShort(image);               Bitmap2Header1.Height=ReadBlobLSBShort(image);               if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");               Bitmap2Header1.Depth=ReadBlobByte(image);               Bitmap2Header1.Compression=ReadBlobByte(image);                if(Bitmap2Header1.Compression > 1)                 continue; /*Unknown compression method */               switch(Bitmap2Header1.Depth)                 {                 case 1:                   bpp=1;                   break;                 case 2:                   bpp=2;                   break;                 case 3:                   bpp=4;                   break;                 case 4:                   bpp=8;                   break;                 case 8:                   bpp=24;                   break;                 default:                   continue;  /*Ignore raster with unknown depth*/                 }               image->columns=Bitmap2Header1.Width;               image->rows=Bitmap2Header1.Height;               status=SetImageExtent(image,image->columns,image->rows,exception);               if (status == MagickFalse)                 break;               if ((image->colors == 0) && (bpp != 24))                 {                   image->colors=one << bpp;                   if (!AcquireImageColormap(image,image->colors,exception))                     goto NoMemory;                 }               else                 {                   if(bpp < 24)                     if( image->colors<(one << bpp) && bpp!=24 )                       image->colormap=(PixelInfo *) ResizeQuantumMemory(                        image->colormap,(size_t) (one << bpp),                        sizeof(*image->colormap));                 }                 switch(Bitmap2Header1.Compression)                 {                 case 0:    /*Uncompressed raster*/                   {                     ldblk=(ssize_t) ((bpp*image->columns+7)/8);                     BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)                       ldblk+1,sizeof(*BImgBuff));                     if (BImgBuff == (unsigned char *) NULL)                       goto NoMemory;                      for(i=0; i< (ssize_t) image->rows; i++)                       {                         (void) ReadBlob(image,ldblk,BImgBuff);                         InsertRow(image,BImgBuff,i,bpp,exception);                       }                      if(BImgBuff)                       BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);                     break;                   }                 case 1:    /*RLE for WPG2 */                   {                     if( UnpackWPG2Raster(image,bpp,exception) < 0)                       goto DecompressionFailed;                     break;                   }                    }                if(CTM[0][0]<0 && !image_info->ping)                 {    /*?? RotAngle=360-RotAngle;*/                   Image                     *flop_image;                    flop_image = FlopImage(image, exception);                   if (flop_image != (Image *) NULL) {                     DuplicateBlob(flop_image,image);                     ReplaceImageInList(&image,flop_image);                   }                   /* Try to change CTM according to Flip - I am not sure, must be checked.                      Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;                      Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;                      Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);                      Tx(1,2)=0;   Tx(2,2)=1; */                 }               if(CTM[1][1]<0 && !image_info->ping)                 {    /*?? RotAngle=360-RotAngle;*/                   Image                     *flip_image;                     flip_image = FlipImage(image, exception);                    if (flip_image != (Image *) NULL) {                      DuplicateBlob(flip_image,image);                      ReplaceImageInList(&image,flip_image);                     }                   /* Try to change CTM according to Flip - I am not sure, must be checked.                      float_matrix Tx(3,3);                      Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;                      Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;                      Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);                      Tx(2,2)=1; */               }                 /* Allocate next image structure. */               AcquireNextImage(image_info,image,exception);               image->depth=8;               if (image->next == (Image *) NULL)                 goto Finish;               image=SyncNextImageInList(image);               image->columns=image->rows=1;               image->colors=0;               break;              case 0x12:  /* Postscript WPG2*/         i=ReadBlobLSBShort(image);               if(Rec2.RecordLength > (unsigned int) i)                 image=ExtractPostscript(image,image_info,                   TellBlob(image)+i,    /*skip PS header in the wpg2*/                   (ssize_t) (Rec2.RecordLength-i-2),exception);               break;        case 0x1B:          /*bitmap rectangle*/               WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);               (void) WPG2Flags;               break;             }         }        break;      default:       {          ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");       }    }   Finish:   (void) CloseBlob(image);    {     Image       *p;      ssize_t       scene=0;      /*       Rewind list, removing any empty images while rewinding.     */     p=image;     image=NULL;     while (p != (Image *) NULL)       {         Image *tmp=p;         if ((p->rows == 0) || (p->columns == 0)) {           p=p->previous;           DeleteImageFromList(&tmp);         } else {           image=p;           p=p->previous;         }       }     /*       Fix scene numbers.     */     for (p=image; p != (Image *) NULL; p=p->next)       p->scene=(size_t) scene++;   }   if (image == (Image *) NULL)     ThrowReaderException(CorruptImageError,       ""ImageFileDoesNotContainAnyImageData"");   return(image); }"
"211650_CWE-763.c","CWE-763","dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr) { 	struct dev_data		*dev = fd->private_data; 	ssize_t			value, length = len; 	unsigned		total; 	u32			tag; 	char			*kbuf;  	spin_lock_irq(&dev->lock); 	if (dev->state > STATE_DEV_OPENED) { 		value = ep0_write(fd, buf, len, ptr); 		spin_unlock_irq(&dev->lock); 		return value; 	} 	spin_unlock_irq(&dev->lock);  	if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) || 	    (len > PAGE_SIZE * 4)) 		return -EINVAL;  	/* we might need to change message format someday */ 	if (copy_from_user (&tag, buf, 4)) 		return -EFAULT; 	if (tag != 0) 		return -EINVAL; 	buf += 4; 	length -= 4;  	kbuf = memdup_user(buf, length); 	if (IS_ERR(kbuf)) 		return PTR_ERR(kbuf);  	spin_lock_irq (&dev->lock); 	value = -EINVAL; 	if (dev->buf) { 		kfree(kbuf); 		goto fail; 	} 	dev->buf = kbuf;  	/* full or low speed config */ 	dev->config = (void *) kbuf; 	total = le16_to_cpu(dev->config->wTotalLength); 	if (!is_valid_config(dev->config, total) || 			total > length - USB_DT_DEVICE_SIZE) 		goto fail; 	kbuf += total; 	length -= total;  	/* optional high speed config */ 	if (kbuf [1] == USB_DT_CONFIG) { 		dev->hs_config = (void *) kbuf; 		total = le16_to_cpu(dev->hs_config->wTotalLength); 		if (!is_valid_config(dev->hs_config, total) || 				total > length - USB_DT_DEVICE_SIZE) 			goto fail; 		kbuf += total; 		length -= total; 	} else { 		dev->hs_config = NULL; 	}  	/* could support multiple configs, using another encoding! */  	/* device descriptor (tweaked for paranoia) */ 	if (length != USB_DT_DEVICE_SIZE) 		goto fail; 	dev->dev = (void *)kbuf; 	if (dev->dev->bLength != USB_DT_DEVICE_SIZE 			|| dev->dev->bDescriptorType != USB_DT_DEVICE 			|| dev->dev->bNumConfigurations != 1) 		goto fail; 	dev->dev->bcdUSB = cpu_to_le16 (0x0200);  	/* triggers gadgetfs_bind(); then we can enumerate. */ 	spin_unlock_irq (&dev->lock); 	if (dev->hs_config) 		gadgetfs_driver.max_speed = USB_SPEED_HIGH; 	else 		gadgetfs_driver.max_speed = USB_SPEED_FULL;  	value = usb_gadget_probe_driver(&gadgetfs_driver); 	if (value != 0) { 		kfree (dev->buf); 		dev->buf = NULL; 	} else { 		/* at this point ""good"" hardware has for the first time 		 * let the USB the host see us.  alternatively, if users 		 * unplug/replug that will clear all the error state. 		 * 		 * note:  everything running before here was guaranteed 		 * to choke driver model style diagnostics.  from here 		 * on, they can work ... except in cleanup paths that 		 * kick in after the ep0 descriptor is closed. 		 */ 		value = len; 		dev->gadget_registered = true; 	} 	return value;  fail: 	spin_unlock_irq (&dev->lock); 	pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev); 	kfree (dev->buf); 	dev->buf = NULL; 	return value; }"
"211695_CWE-416.c","CWE-416","reg_match_visual(void) {     pos_T	top, bot;     linenr_T    lnum;     colnr_T	col;     win_T	*wp = rex.reg_win == NULL ? curwin : rex.reg_win;     int		mode;     colnr_T	start, end;     colnr_T	start2, end2;     colnr_T	cols;     colnr_T	curswant;      // Check if the buffer is the current buffer.     if (rex.reg_buf != curbuf || VIsual.lnum == 0) 	return FALSE;      if (VIsual_active)     { 	if (LT_POS(VIsual, wp->w_cursor)) 	{ 	    top = VIsual; 	    bot = wp->w_cursor; 	} 	else 	{ 	    top = wp->w_cursor; 	    bot = VIsual; 	} 	mode = VIsual_mode; 	curswant = wp->w_curswant;     }     else     { 	if (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end)) 	{ 	    top = curbuf->b_visual.vi_start; 	    bot = curbuf->b_visual.vi_end; 	} 	else 	{ 	    top = curbuf->b_visual.vi_end; 	    bot = curbuf->b_visual.vi_start; 	} 	mode = curbuf->b_visual.vi_mode; 	curswant = curbuf->b_visual.vi_curswant;     }     lnum = rex.lnum + rex.reg_firstlnum;     if (lnum < top.lnum || lnum > bot.lnum) 	return FALSE;      if (mode == 'v')     { 	col = (colnr_T)(rex.input - rex.line); 	if ((lnum == top.lnum && col < top.col) 		|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e'))) 	    return FALSE;     }     else if (mode == Ctrl_V)     { 	getvvcol(wp, &top, &start, NULL, &end); 	getvvcol(wp, &bot, &start2, NULL, &end2); 	if (start2 < start) 	    start = start2; 	if (end2 > end) 	    end = end2; 	if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL) 	    end = MAXCOL; 	cols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line)); 	if (cols < start || cols > end - (*p_sel == 'e')) 	    return FALSE;     }     return TRUE; }"
"211699_CWE-119.c","CWE-119","glob (const char *pattern, int flags, int (*errfunc) (const char *, int),       glob_t *pglob) {   const char *filename;   char *dirname = NULL;   size_t dirlen;   int status;   size_t oldcount;   int meta;   int dirname_modified;   int malloc_dirname = 0;   glob_t dirs;   int retval = 0;   size_t alloca_used = 0;    if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)     {       __set_errno (EINVAL);       return -1;     }    /* POSIX requires all slashes to be matched.  This means that with      a trailing slash we must match only directories.  */   if (pattern[0] && pattern[strlen (pattern) - 1] == '/')     flags |= GLOB_ONLYDIR;    if (!(flags & GLOB_DOOFFS))     /* Have to do this so 'globfree' knows where to start freeing.  It        also makes all the code that uses gl_offs simpler. */     pglob->gl_offs = 0;    if (!(flags & GLOB_APPEND))     {       pglob->gl_pathc = 0;       if (!(flags & GLOB_DOOFFS))         pglob->gl_pathv = NULL;       else         {           size_t i;            if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))             return GLOB_NOSPACE;            pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)                                               * sizeof (char *));           if (pglob->gl_pathv == NULL)             return GLOB_NOSPACE;            for (i = 0; i <= pglob->gl_offs; ++i)             pglob->gl_pathv[i] = NULL;         }     }    if (flags & GLOB_BRACE)     {       const char *begin;        if (flags & GLOB_NOESCAPE)         begin = strchr (pattern, '{');       else         {           begin = pattern;           while (1)             {               if (*begin == '\0')                 {                   begin = NULL;                   break;                 }                if (*begin == '\\' && begin[1] != '\0')                 ++begin;               else if (*begin == '{')                 break;                ++begin;             }         }        if (begin != NULL)         {           /* Allocate working buffer large enough for our work.  Note that              we have at least an opening and closing brace.  */           size_t firstc;           char *alt_start;           const char *p;           const char *next;           const char *rest;           size_t rest_len;           char *onealt;           size_t pattern_len = strlen (pattern) - 1;           int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);           if (alloca_onealt)             onealt = alloca_account (pattern_len, alloca_used);           else             {               onealt = malloc (pattern_len);               if (onealt == NULL)                 return GLOB_NOSPACE;             }            /* We know the prefix for all sub-patterns.  */           alt_start = mempcpy (onealt, pattern, begin - pattern);            /* Find the first sub-pattern and at the same time find the              rest after the closing brace.  */           next = next_brace_sub (begin + 1, flags);           if (next == NULL)             {               /* It is an invalid expression.  */             illegal_brace:               if (__glibc_unlikely (!alloca_onealt))                 free (onealt);               flags &= ~GLOB_BRACE;               goto no_brace;             }            /* Now find the end of the whole brace expression.  */           rest = next;           while (*rest != '}')             {               rest = next_brace_sub (rest + 1, flags);               if (rest == NULL)                 /* It is an illegal expression.  */                 goto illegal_brace;             }           /* Please note that we now can be sure the brace expression              is well-formed.  */           rest_len = strlen (++rest) + 1;            /* We have a brace expression.  BEGIN points to the opening {,              NEXT points past the terminator of the first element, and END              points past the final }.  We will accumulate result names from              recursive runs for each brace alternative in the buffer using              GLOB_APPEND.  */           firstc = pglob->gl_pathc;            p = begin + 1;           while (1)             {               int result;                /* Construct the new glob expression.  */               mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);                result = glob (onealt,                              ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))                               | GLOB_APPEND), errfunc, pglob);                /* If we got an error, return it.  */               if (result && result != GLOB_NOMATCH)                 {                   if (__glibc_unlikely (!alloca_onealt))                     free (onealt);                   if (!(flags & GLOB_APPEND))                     {                       globfree (pglob);                       pglob->gl_pathc = 0;                     }                   return result;                 }                if (*next == '}')                 /* We saw the last entry.  */                 break;                p = next + 1;               next = next_brace_sub (p, flags);               assert (next != NULL);             }            if (__glibc_unlikely (!alloca_onealt))             free (onealt);            if (pglob->gl_pathc != firstc)             /* We found some entries.  */             return 0;           else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))             return GLOB_NOMATCH;         }     }   no_brace:   oldcount = pglob->gl_pathc + pglob->gl_offs;    /* Find the filename.  */   filename = strrchr (pattern, '/');  #if defined __MSDOS__ || defined WINDOWS32   /* The case of ""d:pattern"".  Since ':' is not allowed in      file names, we can safely assume that wherever it      happens in pattern, it signals the filename part.  This      is so we could some day support patterns like ""[a-z]:foo"".  */   if (filename == NULL)     filename = strchr (pattern, ':'); #endif /* __MSDOS__ || WINDOWS32 */    dirname_modified = 0;   if (filename == NULL)     {       /* This can mean two things: a simple name or ""~name"".  The latter          case is nothing but a notation for a directory.  */       if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')         {           dirname = (char *) pattern;           dirlen = strlen (pattern);            /* Set FILENAME to NULL as a special flag.  This is ugly but              other solutions would require much more code.  We test for              this special case below.  */           filename = NULL;         }       else         {           if (__glibc_unlikely (pattern[0] == '\0'))             {               dirs.gl_pathv = NULL;               goto no_matches;             }            filename = pattern;           dirname = (char *) ""."";           dirlen = 0;         }     }   else if (filename == pattern            || (filename == pattern + 1 && pattern[0] == '\\'                && (flags & GLOB_NOESCAPE) == 0))     {       /* ""/pattern"" or ""\\/pattern"".  */       dirname = (char *) ""/"";       dirlen = 1;       ++filename;     }   else     {       char *newp;       dirlen = filename - pattern;  #if defined __MSDOS__ || defined WINDOWS32       if (*filename == ':'           || (filename > pattern + 1 && filename[-1] == ':'))         {           char *drive_spec;            ++dirlen;           drive_spec = __alloca (dirlen + 1);           *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';           /* For now, disallow wildcards in the drive spec, to              prevent infinite recursion in glob.  */           if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))             return GLOB_NOMATCH;           /* If this is ""d:pattern"", we need to copy ':' to DIRNAME              as well.  If it's ""d:/pattern"", don't remove the slash              from ""d:/"", since ""d:"" and ""d:/"" are not the same.*/         } #endif        if (glob_use_alloca (alloca_used, dirlen + 1))         newp = alloca_account (dirlen + 1, alloca_used);       else         {           newp = malloc (dirlen + 1);           if (newp == NULL)             return GLOB_NOSPACE;           malloc_dirname = 1;         }       *((char *) mempcpy (newp, pattern, dirlen)) = '\0';       dirname = newp;       ++filename;  #if defined __MSDOS__ || defined WINDOWS32       bool drive_root = (dirlen > 1                          && (dirname[dirlen - 1] == ':'                              || (dirlen > 2 && dirname[dirlen - 2] == ':'                                  && dirname[dirlen - 1] == '/'))); #else       bool drive_root = false; #endif        if (filename[0] == '\0' && dirlen > 1 && !drive_root)         /* ""pattern/"".  Expand ""pattern"", appending slashes.  */         {           int orig_flags = flags;           if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\')             {               /* ""pattern\\/"".  Remove the final backslash if it hasn't                  been quoted.  */               char *p = (char *) &dirname[dirlen - 1];                while (p > dirname && p[-1] == '\\') --p;               if ((&dirname[dirlen] - p) & 1)                 {                   *(char *) &dirname[--dirlen] = '\0';                   flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);                 }             }           int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);           if (val == 0)             pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)                                | (flags & GLOB_MARK));           else if (val == GLOB_NOMATCH && flags != orig_flags)             {               /* Make sure globfree (&dirs); is a nop.  */               dirs.gl_pathv = NULL;               flags = orig_flags;               oldcount = pglob->gl_pathc + pglob->gl_offs;               goto no_matches;             }           retval = val;           goto out;         }     }    if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')     {       if (dirname[1] == '\0' || dirname[1] == '/'           || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\'               && (dirname[2] == '\0' || dirname[2] == '/')))         {           /* Look up home directory.  */           char *home_dir = getenv (""HOME"");           int malloc_home_dir = 0;           if (home_dir == NULL || home_dir[0] == '\0')             { #ifdef WINDOWS32               /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give                  preference to HOME, because the user can change HOME.  */               const char *home_drive = getenv (""HOMEDRIVE"");               const char *home_path = getenv (""HOMEPATH"");                if (home_drive != NULL && home_path != NULL)                 {                   size_t home_drive_len = strlen (home_drive);                   size_t home_path_len = strlen (home_path);                   char *mem = alloca (home_drive_len + home_path_len + 1);                    memcpy (mem, home_drive, home_drive_len);                   memcpy (mem + home_drive_len, home_path, home_path_len + 1);                   home_dir = mem;                 }               else                 home_dir = ""c:/users/default""; /* poor default */ #else               int err;               struct passwd *p;               struct passwd pwbuf;               struct scratch_buffer s;               scratch_buffer_init (&s);               while (true)                 {                   p = NULL;                   err = __getlogin_r (s.data, s.length);                   if (err == 0)                     { # if defined HAVE_GETPWNAM_R || defined _LIBC                       size_t ssize = strlen (s.data) + 1;                       err = getpwnam_r (s.data, &pwbuf, s.data + ssize,                                         s.length - ssize, &p); # else                       p = getpwnam (s.data);                       if (p == NULL)                         err = errno; # endif                     }                   if (err != ERANGE)                     break;                   if (!scratch_buffer_grow (&s))                     {                       retval = GLOB_NOSPACE;                       goto out;                     }                 }               if (err == 0)                 {                   home_dir = strdup (p->pw_dir);                   malloc_home_dir = 1;                 }               scratch_buffer_free (&s);               if (err == 0 && home_dir == NULL)                 {                   retval = GLOB_NOSPACE;                   goto out;                 } #endif /* WINDOWS32 */             }           if (home_dir == NULL || home_dir[0] == '\0')             {               if (__glibc_unlikely (malloc_home_dir))                 free (home_dir);               if (flags & GLOB_TILDE_CHECK)                 {                   retval = GLOB_NOMATCH;                   goto out;                 }               else                 {                   home_dir = (char *) ""~""; /* No luck.  */                   malloc_home_dir = 0;                 }             }           /* Now construct the full directory.  */           if (dirname[1] == '\0')             {               if (__glibc_unlikely (malloc_dirname))                 free (dirname);                dirname = home_dir;               dirlen = strlen (dirname);               malloc_dirname = malloc_home_dir;             }           else             {               char *newp;               size_t home_len = strlen (home_dir);               int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);               if (use_alloca)                 newp = alloca_account (home_len + dirlen, alloca_used);               else                 {                   newp = malloc (home_len + dirlen);                   if (newp == NULL)                     {                       if (__glibc_unlikely (malloc_home_dir))                         free (home_dir);                       retval = GLOB_NOSPACE;                       goto out;                     }                 }                mempcpy (mempcpy (newp, home_dir, home_len),                        &dirname[1], dirlen);                if (__glibc_unlikely (malloc_dirname))                 free (dirname);                dirname = newp;               dirlen += home_len - 1;               malloc_dirname = !use_alloca;                if (__glibc_unlikely (malloc_home_dir))                 free (home_dir);             }           dirname_modified = 1;         }       else         { #ifndef WINDOWS32           char *end_name = strchr (dirname, '/');           char *user_name;           int malloc_user_name = 0;           char *unescape = NULL;            if (!(flags & GLOB_NOESCAPE))             {               if (end_name == NULL)                 {                   unescape = strchr (dirname, '\\');                   if (unescape)                     end_name = strchr (unescape, '\0');                 }               else                 unescape = memchr (dirname, '\\', end_name - dirname);             }           if (end_name == NULL)             user_name = dirname + 1;           else             {               char *newp;               if (glob_use_alloca (alloca_used, end_name - dirname))                 newp = alloca_account (end_name - dirname, alloca_used);               else                 {                   newp = malloc (end_name - dirname);                   if (newp == NULL)                     {                       retval = GLOB_NOSPACE;                       goto out;                     }                   malloc_user_name = 1;                 }               if (unescape != NULL)                 {                   char *p = mempcpy (newp, dirname + 1,                                      unescape - dirname - 1);                   char *q = unescape;                   while (*q != '\0')                     {                       if (*q == '\\')                         {                           if (q[1] == '\0')                             {                               /* ""~fo\\o\\"" unescape to user_name ""foo\\"",                                  but ""~fo\\o\\/"" unescape to user_name                                  ""foo"".  */                               if (filename == NULL)                                 *p++ = '\\';                               break;                             }                           ++q;                         }                       *p++ = *q++;                     }                   *p = '\0';                 }               else                 *((char *) mempcpy (newp, dirname + 1, end_name - dirname))                   = '\0';               user_name = newp;             }            /* Look up specific user's home directory.  */           {             struct passwd *p;             struct scratch_buffer pwtmpbuf;             scratch_buffer_init (&pwtmpbuf);  #  if defined HAVE_GETPWNAM_R || defined _LIBC             struct passwd pwbuf;              while (getpwnam_r (user_name, &pwbuf,                                pwtmpbuf.data, pwtmpbuf.length, &p)                    == ERANGE)               {                 if (!scratch_buffer_grow (&pwtmpbuf))                   {                     retval = GLOB_NOSPACE;                     goto out;                   }               } #  else             p = getpwnam (user_name); #  endif              if (__glibc_unlikely (malloc_user_name))               free (user_name);              /* If we found a home directory use this.  */             if (p != NULL)               {                 size_t home_len = strlen (p->pw_dir);                 size_t rest_len = end_name == NULL ? 0 : strlen (end_name);                 char *d;                  if (__glibc_unlikely (malloc_dirname))                   free (dirname);                 malloc_dirname = 0;                  if (glob_use_alloca (alloca_used, home_len + rest_len + 1))                   dirname = alloca_account (home_len + rest_len + 1,                                             alloca_used);                 else                   {                     dirname = malloc (home_len + rest_len + 1);                     if (dirname == NULL)                       {                         scratch_buffer_free (&pwtmpbuf);                         retval = GLOB_NOSPACE;                         goto out;                       }                     malloc_dirname = 1;                   }                 d = mempcpy (dirname, p->pw_dir, home_len);                 if (end_name != NULL)                   d = mempcpy (d, end_name, rest_len);                 *d = '\0';                  dirlen = home_len + rest_len;                 dirname_modified = 1;               }             else               {                 if (flags & GLOB_TILDE_CHECK)                   {                     /* We have to regard it as an error if we cannot find the                        home directory.  */                     retval = GLOB_NOMATCH;                     goto out;                   }               }             scratch_buffer_free (&pwtmpbuf);           } #endif /* !WINDOWS32 */         }     }    /* Now test whether we looked for ""~"" or ""~NAME"".  In this case we      can give the answer now.  */   if (filename == NULL)     {       size_t newcount = pglob->gl_pathc + pglob->gl_offs;       char **new_gl_pathv;        if (newcount > SIZE_MAX / sizeof (char *) - 2)         {         nospace:           free (pglob->gl_pathv);           pglob->gl_pathv = NULL;           pglob->gl_pathc = 0;           retval = GLOB_NOSPACE;           goto out;         }        new_gl_pathv = realloc (pglob->gl_pathv,                               (newcount + 2) * sizeof (char *));       if (new_gl_pathv == NULL)         goto nospace;       pglob->gl_pathv = new_gl_pathv;        if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))         {           char *p;           pglob->gl_pathv[newcount] = malloc (dirlen + 2);           if (pglob->gl_pathv[newcount] == NULL)             goto nospace;           p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);           p[0] = '/';           p[1] = '\0';           if (__glibc_unlikely (malloc_dirname))             free (dirname);         }       else         {           if (__glibc_unlikely (malloc_dirname))             pglob->gl_pathv[newcount] = dirname;           else             {               pglob->gl_pathv[newcount] = strdup (dirname);               if (pglob->gl_pathv[newcount] == NULL)                 goto nospace;             }         }       pglob->gl_pathv[++newcount] = NULL;       ++pglob->gl_pathc;       pglob->gl_flags = flags;        return 0;     }    meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));   /* meta is 1 if correct glob pattern containing metacharacters.      If meta has bit (1 << 2) set, it means there was an unterminated      [ which we handle the same, using fnmatch.  Broken unterminated      pattern bracket expressions ought to be rare enough that it is      not worth special casing them, fnmatch will do the right thing.  */   if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))     {       /* The directory name contains metacharacters, so we          have to glob for the directory, and then glob for          the pattern in each directory found.  */       size_t i;        if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\')         {           /* ""foo\\/bar"".  Remove the final backslash from dirname              if it has not been quoted.  */           char *p = (char *) &dirname[dirlen - 1];            while (p > dirname && p[-1] == '\\') --p;           if ((&dirname[dirlen] - p) & 1)             *(char *) &dirname[--dirlen] = '\0';         }        if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))         {           /* Use the alternative access functions also in the recursive              call.  */           dirs.gl_opendir = pglob->gl_opendir;           dirs.gl_readdir = pglob->gl_readdir;           dirs.gl_closedir = pglob->gl_closedir;           dirs.gl_stat = pglob->gl_stat;           dirs.gl_lstat = pglob->gl_lstat;         }        status = glob (dirname,                      ((flags & (GLOB_ERR | GLOB_NOESCAPE                                 | GLOB_ALTDIRFUNC))                       | GLOB_NOSORT | GLOB_ONLYDIR),                      errfunc, &dirs);       if (status != 0)         {           if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)             {               retval = status;               goto out;             }           goto no_matches;         }        /* We have successfully globbed the preceding directory name.          For each name we found, call glob_in_dir on it and FILENAME,          appending the results to PGLOB.  */       for (i = 0; i < dirs.gl_pathc; ++i)         {           size_t old_pathc;            old_pathc = pglob->gl_pathc;           status = glob_in_dir (filename, dirs.gl_pathv[i],                                 ((flags | GLOB_APPEND)                                  & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),                                 errfunc, pglob, alloca_used);           if (status == GLOB_NOMATCH)             /* No matches in this directory.  Try the next.  */             continue;            if (status != 0)             {               globfree (&dirs);               globfree (pglob);               pglob->gl_pathc = 0;               retval = status;               goto out;             }            /* Stick the directory on the front of each name.  */           if (prefix_array (dirs.gl_pathv[i],                             &pglob->gl_pathv[old_pathc + pglob->gl_offs],                             pglob->gl_pathc - old_pathc))             {               globfree (&dirs);               globfree (pglob);               pglob->gl_pathc = 0;               retval = GLOB_NOSPACE;               goto out;             }         }        flags |= GLOB_MAGCHAR;        /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.          But if we have not found any matching entry and the GLOB_NOCHECK          flag was set we must return the input pattern itself.  */       if (pglob->gl_pathc + pglob->gl_offs == oldcount)         {         no_matches:           /* No matches.  */           if (flags & GLOB_NOCHECK)             {               size_t newcount = pglob->gl_pathc + pglob->gl_offs;               char **new_gl_pathv;                if (newcount > SIZE_MAX / sizeof (char *) - 2)                 {                 nospace2:                   globfree (&dirs);                   retval = GLOB_NOSPACE;                   goto out;                 }                new_gl_pathv = realloc (pglob->gl_pathv,                                       (newcount + 2) * sizeof (char *));               if (new_gl_pathv == NULL)                 goto nospace2;               pglob->gl_pathv = new_gl_pathv;                pglob->gl_pathv[newcount] = strdup (pattern);               if (pglob->gl_pathv[newcount] == NULL)                 {                   globfree (&dirs);                   globfree (pglob);                   pglob->gl_pathc = 0;                   retval = GLOB_NOSPACE;                   goto out;                 }                ++pglob->gl_pathc;               ++newcount;                pglob->gl_pathv[newcount] = NULL;               pglob->gl_flags = flags;             }           else             {               globfree (&dirs);               retval = GLOB_NOMATCH;               goto out;             }         }        globfree (&dirs);     }   else     {       size_t old_pathc = pglob->gl_pathc;       int orig_flags = flags;        if (meta & GLOBPAT_BACKSLASH)         {           char *p = strchr (dirname, '\\'), *q;           /* We need to unescape the dirname string.  It is certainly              allocated by alloca, as otherwise filename would be NULL              or dirname wouldn't contain backslashes.  */           q = p;           do             {               if (*p == '\\')                 {                   *q = *++p;                   --dirlen;                 }               else                 *q = *p;               ++q;             }           while (*p++ != '\0');           dirname_modified = 1;         }       if (dirname_modified)         flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);       status = glob_in_dir (filename, dirname, flags, errfunc, pglob,                             alloca_used);       if (status != 0)         {           if (status == GLOB_NOMATCH && flags != orig_flags               && pglob->gl_pathc + pglob->gl_offs == oldcount)             {               /* Make sure globfree (&dirs); is a nop.  */               dirs.gl_pathv = NULL;               flags = orig_flags;               goto no_matches;             }           retval = status;           goto out;         }        if (dirlen > 0)         {           /* Stick the directory on the front of each name.  */           if (prefix_array (dirname,                             &pglob->gl_pathv[old_pathc + pglob->gl_offs],                             pglob->gl_pathc - old_pathc))             {               globfree (pglob);               pglob->gl_pathc = 0;               retval = GLOB_NOSPACE;               goto out;             }         }     }    if (flags & GLOB_MARK)     {       /* Append slashes to directory names.  */       size_t i;        for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)         if (is_dir (pglob->gl_pathv[i], flags, pglob))           {             size_t len = strlen (pglob->gl_pathv[i]) + 2;             char *new = realloc (pglob->gl_pathv[i], len);             if (new == NULL)               {                 globfree (pglob);                 pglob->gl_pathc = 0;                 retval = GLOB_NOSPACE;                 goto out;               }             strcpy (&new[len - 2], ""/"");             pglob->gl_pathv[i] = new;           }     }    if (!(flags & GLOB_NOSORT))     {       /* Sort the vector.  */       qsort (&pglob->gl_pathv[oldcount],              pglob->gl_pathc + pglob->gl_offs - oldcount,              sizeof (char *), collated_compare);     }   out:   if (__glibc_unlikely (malloc_dirname))     free (dirname);    return retval; }"
"211700_CWE-120.c","CWE-120","int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host, 				u8 event, struct sk_buff *skb) { 	int r = 0; 	struct device *dev = &hdev->ndev->dev; 	struct nfc_evt_transaction *transaction;  	pr_debug(""connectivity gate event: %x\n"", event);  	switch (event) { 	case ST21NFCA_EVT_CONNECTIVITY: 		r = nfc_se_connectivity(hdev->ndev, host); 	break; 	case ST21NFCA_EVT_TRANSACTION: 		/* 		 * According to specification etsi 102 622 		 * 11.2.2.4 EVT_TRANSACTION Table 52 		 * Description	Tag	Length 		 * AID		81	5 to 16 		 * PARAMETERS	82	0 to 255 		 */ 		if (skb->len < NFC_MIN_AID_LENGTH + 2 && 		    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG) 			return -EPROTO;  		transaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL); 		if (!transaction) 			return -ENOMEM;  		transaction->aid_len = skb->data[1]; 		memcpy(transaction->aid, &skb->data[2], 		       transaction->aid_len);  		/* Check next byte is PARAMETERS tag (82) */ 		if (skb->data[transaction->aid_len + 2] != 		    NFC_EVT_TRANSACTION_PARAMS_TAG) 			return -EPROTO;  		transaction->params_len = skb->data[transaction->aid_len + 3]; 		memcpy(transaction->params, skb->data + 		       transaction->aid_len + 4, transaction->params_len);  		r = nfc_se_transaction(hdev->ndev, host, transaction); 	break; 	default: 		nfc_err(&hdev->ndev->dev, ""Unexpected event on connectivity gate\n""); 		return 1; 	} 	kfree_skb(skb); 	return r; }"
"211773_CWE-20.c","CWE-20","cookedprint( 	int datatype, 	int length, 	const char *data, 	int status, 	int quiet, 	FILE *fp 	) { 	char *name; 	char *value; 	char output_raw; 	int fmt; 	l_fp lfp; 	sockaddr_u hval; 	u_long uval; 	int narr; 	size_t len; 	l_fp lfparr[8]; 	char b[12]; 	char bn[2 * MAXVARLEN]; 	char bv[2 * MAXVALLEN];  	UNUSED_ARG(datatype);  	if (!quiet) 		fprintf(fp, ""status=%04x %s,\n"", status, 			statustoa(datatype, status));  	startoutput(); 	while (nextvar(&length, &data, &name, &value)) { 		fmt = varfmt(name); 		output_raw = 0; 		switch (fmt) {  		case PADDING: 			output_raw = '*'; 			break;  		case TS: 			if (!decodets(value, &lfp)) 				output_raw = '?'; 			else 				output(fp, name, prettydate(&lfp)); 			break;  		case HA:	/* fallthru */ 		case NA: 			if (!decodenetnum(value, &hval)) { 				output_raw = '?'; 			} else if (fmt == HA){ 				output(fp, name, nntohost(&hval)); 			} else { 				output(fp, name, stoa(&hval)); 			} 			break;  		case RF: 			if (decodenetnum(value, &hval)) { 				if (ISREFCLOCKADR(&hval)) 					output(fp, name, 					       refnumtoa(&hval)); 				else 					output(fp, name, stoa(&hval)); 			} else if (strlen(value) <= 4) { 				output(fp, name, value); 			} else { 				output_raw = '?'; 			} 			break;  		case LP: 			if (!decodeuint(value, &uval) || uval > 3) { 				output_raw = '?'; 			} else { 				b[0] = (0x2 & uval) 					   ? '1' 					   : '0'; 				b[1] = (0x1 & uval) 					   ? '1' 					   : '0'; 				b[2] = '\0'; 				output(fp, name, b); 			} 			break;  		case OC: 			if (!decodeuint(value, &uval)) { 				output_raw = '?'; 			} else { 				snprintf(b, sizeof(b), ""%03lo"", uval); 				output(fp, name, b); 			} 			break;  		case AR: 			if (!decodearr(value, &narr, lfparr)) 				output_raw = '?'; 			else 				outputarr(fp, name, narr, lfparr); 			break;  		case FX: 			if (!decodeuint(value, &uval)) 				output_raw = '?'; 			else 				output(fp, name, tstflags(uval)); 			break;  		default: 			fprintf(stderr, ""Internal error in cookedprint, %s=%s, fmt %d\n"", 				name, value, fmt); 			output_raw = '?'; 			break; 		}  		if (output_raw != 0) { 			atoascii(name, MAXVARLEN, bn, sizeof(bn)); 			atoascii(value, MAXVALLEN, bv, sizeof(bv)); 			if (output_raw != '*') { 				len = strlen(bv); 				bv[len] = output_raw; 				bv[len+1] = '\0'; 			} 			output(fp, bn, bv); 		} 	} 	endoutput(fp); }"
"211785_CWE-20.c","CWE-20","static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image) { 	jpc_enc_cp_t *cp; 	jas_tvparser_t *tvp; 	int ret; 	int numilyrrates; 	double *ilyrrates; 	int i; 	int tagid; 	jpc_enc_tcp_t *tcp; 	jpc_enc_tccp_t *tccp; 	jpc_enc_ccp_t *ccp; 	uint_fast16_t rlvlno; 	uint_fast16_t prcwidthexpn; 	uint_fast16_t prcheightexpn; 	bool enablemct; 	uint_fast32_t jp2overhead; 	uint_fast16_t lyrno; 	uint_fast32_t hsteplcm; 	uint_fast32_t vsteplcm; 	bool mctvalid;  	tvp = 0; 	cp = 0; 	ilyrrates = 0; 	numilyrrates = 0;  	if (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) { 		goto error; 	}  	prcwidthexpn = 15; 	prcheightexpn = 15; 	enablemct = true; 	jp2overhead = 0;  	cp->ccps = 0; 	cp->debug = 0; 	cp->imgareatlx = UINT_FAST32_MAX; 	cp->imgareatly = UINT_FAST32_MAX; 	cp->refgrdwidth = 0; 	cp->refgrdheight = 0; 	cp->tilegrdoffx = UINT_FAST32_MAX; 	cp->tilegrdoffy = UINT_FAST32_MAX; 	cp->tilewidth = 0; 	cp->tileheight = 0; 	cp->numcmpts = jas_image_numcmpts(image);  	hsteplcm = 1; 	vsteplcm = 1; 	for (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) { 		if (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <= 		  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) + 		  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) { 			jas_eprintf(""unsupported image type\n""); 			goto error; 		} 		/* Note: We ought to be calculating the LCMs here.  Fix some day. */ 		hsteplcm *= jas_image_cmpthstep(image, cmptno); 		vsteplcm *= jas_image_cmptvstep(image, cmptno); 	}  	if (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) { 		goto error; 	} 	unsigned cmptno; 	for (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno, 	  ++ccp) { 		ccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno); 		ccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno); 		/* XXX - this isn't quite correct for more general image */ 		ccp->sampgrdsubstepx = 0; 		ccp->sampgrdsubstepx = 0; 		ccp->prec = jas_image_cmptprec(image, cmptno); 		ccp->sgnd = jas_image_cmptsgnd(image, cmptno); 		ccp->numstepsizes = 0; 		memset(ccp->stepsizes, 0, sizeof(ccp->stepsizes)); 	}  	cp->rawsize = jas_image_rawsize(image); 	if (cp->rawsize == 0) { 		/* prevent division by zero in cp_create() */ 		goto error; 	} 	cp->totalsize = UINT_FAST32_MAX;  	tcp = &cp->tcp; 	tcp->csty = 0; 	tcp->intmode = true; 	tcp->prg = JPC_COD_LRCPPRG; 	tcp->numlyrs = 1; 	tcp->ilyrrates = 0;  	tccp = &cp->tccp; 	tccp->csty = 0; 	tccp->maxrlvls = 6; 	tccp->cblkwidthexpn = 6; 	tccp->cblkheightexpn = 6; 	tccp->cblksty = 0; 	tccp->numgbits = 2;  	if (!(tvp = jas_tvparser_create(optstr ? optstr : """"))) { 		goto error; 	}  	while (!(ret = jas_tvparser_next(tvp))) { 		switch (jas_taginfo_nonull(jas_taginfos_lookup(encopts, 		  jas_tvparser_gettag(tvp)))->id) { 		case OPT_DEBUG: 			cp->debug = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_IMGAREAOFFX: 			cp->imgareatlx = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_IMGAREAOFFY: 			cp->imgareatly = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEGRDOFFX: 			cp->tilegrdoffx = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEGRDOFFY: 			cp->tilegrdoffy = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEWIDTH: 			cp->tilewidth = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEHEIGHT: 			cp->tileheight = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_PRCWIDTH: 			prcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_PRCHEIGHT: 			prcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_CBLKWIDTH: 			tccp->cblkwidthexpn = 			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_CBLKHEIGHT: 			tccp->cblkheightexpn = 			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_MODE: 			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab, 			  jas_tvparser_getval(tvp)))->id) < 0) { 				jas_eprintf(""ignoring invalid mode %s\n"", 				  jas_tvparser_getval(tvp)); 			} else { 				tcp->intmode = (tagid == MODE_INT); 			} 			break; 		case OPT_PRG: 			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab, 			  jas_tvparser_getval(tvp)))->id) < 0) { 				jas_eprintf(""ignoring invalid progression order %s\n"", 				  jas_tvparser_getval(tvp)); 			} else { 				tcp->prg = tagid; 			} 			break; 		case OPT_NOMCT: 			enablemct = false; 			break; 		case OPT_MAXRLVLS: 			tccp->maxrlvls = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_SOP: 			cp->tcp.csty |= JPC_COD_SOP; 			break; 		case OPT_EPH: 			cp->tcp.csty |= JPC_COD_EPH; 			break; 		case OPT_LAZY: 			tccp->cblksty |= JPC_COX_LAZY; 			break; 		case OPT_TERMALL: 			tccp->cblksty |= JPC_COX_TERMALL; 			break; 		case OPT_SEGSYM: 			tccp->cblksty |= JPC_COX_SEGSYM; 			break; 		case OPT_VCAUSAL: 			tccp->cblksty |= JPC_COX_VSC; 			break; 		case OPT_RESET: 			tccp->cblksty |= JPC_COX_RESET; 			break; 		case OPT_PTERM: 			tccp->cblksty |= JPC_COX_PTERM; 			break; 		case OPT_NUMGBITS: 			cp->tccp.numgbits = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_RATE: 			if (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize, 			  &cp->totalsize)) { 				jas_eprintf(""ignoring bad rate specifier %s\n"", 				  jas_tvparser_getval(tvp)); 			} 			break; 		case OPT_ILYRRATES: 			if (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates, 			  &ilyrrates)) { 				jas_eprintf(""warning: invalid intermediate layer rates specifier ignored (%s)\n"", 				  jas_tvparser_getval(tvp)); 			} 			break;  		case OPT_JP2OVERHEAD: 			jp2overhead = atoi(jas_tvparser_getval(tvp)); 			break; 		default: 			jas_eprintf(""warning: ignoring invalid option %s\n"", 			 jas_tvparser_gettag(tvp)); 			break; 		} 	}  	jas_tvparser_destroy(tvp); 	tvp = 0;  	if (cp->totalsize != UINT_FAST32_MAX) { 		cp->totalsize = (cp->totalsize > jp2overhead) ? 		  (cp->totalsize - jp2overhead) : 0; 	}  	if (cp->imgareatlx == UINT_FAST32_MAX) { 		cp->imgareatlx = 0; 	} else { 		if (hsteplcm != 1) { 			jas_eprintf(""warning: overriding imgareatlx value\n""); 		} 		cp->imgareatlx *= hsteplcm; 	} 	if (cp->imgareatly == UINT_FAST32_MAX) { 		cp->imgareatly = 0; 	} else { 		if (vsteplcm != 1) { 			jas_eprintf(""warning: overriding imgareatly value\n""); 		} 		cp->imgareatly *= vsteplcm; 	} 	cp->refgrdwidth = cp->imgareatlx + jas_image_width(image); 	cp->refgrdheight = cp->imgareatly + jas_image_height(image); 	if (cp->tilegrdoffx == UINT_FAST32_MAX) { 		cp->tilegrdoffx = cp->imgareatlx; 	} 	if (cp->tilegrdoffy == UINT_FAST32_MAX) { 		cp->tilegrdoffy = cp->imgareatly; 	} 	if (!cp->tilewidth) { 		cp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx; 	} 	if (!cp->tileheight) { 		cp->tileheight = cp->refgrdheight - cp->tilegrdoffy; 	}  	if (cp->numcmpts == 3) { 		mctvalid = true; 		for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) { 			if (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) || 			  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) || 			  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) || 			  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) { 				mctvalid = false; 			} 		} 	} else { 		mctvalid = false; 	} 	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) { 		jas_eprintf(""warning: color space apparently not RGB\n""); 	} 	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) { 		tcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT); 	} else { 		tcp->mctid = JPC_MCT_NONE; 	} 	tccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);  	for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) { 		tccp->prcwidthexpns[rlvlno] = prcwidthexpn; 		tccp->prcheightexpns[rlvlno] = prcheightexpn; 	} 	if (prcwidthexpn != 15 || prcheightexpn != 15) { 		tccp->csty |= JPC_COX_PRT; 	}  	/* Ensure that the tile width and height is valid. */ 	if (!cp->tilewidth) { 		jas_eprintf(""invalid tile width %lu\n"", (unsigned long) 		  cp->tilewidth); 		goto error; 	} 	if (!cp->tileheight) { 		jas_eprintf(""invalid tile height %lu\n"", (unsigned long) 		  cp->tileheight); 		goto error; 	}  	/* Ensure that the tile grid offset is valid. */ 	if (cp->tilegrdoffx > cp->imgareatlx || 	  cp->tilegrdoffy > cp->imgareatly || 	  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx || 	  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) { 		jas_eprintf(""invalid tile grid offset (%lu, %lu)\n"", 		  (unsigned long) cp->tilegrdoffx, (unsigned long) 		  cp->tilegrdoffy); 		goto error; 	}  	cp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx, 	  cp->tilewidth); 	cp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy, 	  cp->tileheight); 	cp->numtiles = cp->numhtiles * cp->numvtiles;  	if (ilyrrates && numilyrrates > 0) { 		tcp->numlyrs = numilyrrates + 1; 		if (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1), 		  sizeof(jpc_fix_t)))) { 			goto error; 		} 		for (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) { 			tcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]); 		} 	}  	/* Ensure that the integer mode is used in the case of lossless 	  coding. */ 	if (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) { 		jas_eprintf(""cannot use real mode for lossless coding\n""); 		goto error; 	}  	/* Ensure that the precinct width is valid. */ 	if (prcwidthexpn > 15) { 		jas_eprintf(""invalid precinct width\n""); 		goto error; 	}  	/* Ensure that the precinct height is valid. */ 	if (prcheightexpn > 15) { 		jas_eprintf(""invalid precinct height\n""); 		goto error; 	}  	/* Ensure that the code block width is valid. */ 	if (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) { 		jas_eprintf(""invalid code block width %d\n"", 		  JPC_POW2(cp->tccp.cblkwidthexpn)); 		goto error; 	}  	/* Ensure that the code block height is valid. */ 	if (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) { 		jas_eprintf(""invalid code block height %d\n"", 		  JPC_POW2(cp->tccp.cblkheightexpn)); 		goto error; 	}  	/* Ensure that the code block size is not too large. */ 	if (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) { 		jas_eprintf(""code block size too large\n""); 		goto error; 	}  	/* Ensure that the number of layers is valid. */ 	if (cp->tcp.numlyrs > 16384) { 		jas_eprintf(""too many layers\n""); 		goto error; 	}  	/* There must be at least one resolution level. */ 	if (cp->tccp.maxrlvls < 1) { 		jas_eprintf(""must be at least one resolution level\n""); 		goto error; 	}  	/* Ensure that the number of guard bits is valid. */ 	if (cp->tccp.numgbits > 8) { 		jas_eprintf(""invalid number of guard bits\n""); 		goto error; 	}  	/* Ensure that the rate is within the legal range. */ 	if (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) { 		jas_eprintf(""warning: specified rate is unreasonably large (%lu > %lu)\n"", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize); 	}  	/* Ensure that the intermediate layer rates are valid. */ 	if (tcp->numlyrs > 1) { 		/* The intermediate layers rates must increase monotonically. */ 		for (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) { 			if (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) { 				jas_eprintf(""intermediate layer rates must increase monotonically\n""); 				goto error; 			} 		} 		/* The intermediate layer rates must be less than the overall rate. */ 		if (cp->totalsize != UINT_FAST32_MAX) { 			for (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) { 				if (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize) 				  / cp->rawsize) { 					jas_eprintf(""warning: intermediate layer rates must be less than overall rate\n""); 					goto error; 				} 			} 		} 	}  	if (ilyrrates) { 		jas_free(ilyrrates); 	}  	return cp;  error:  	if (ilyrrates) { 		jas_free(ilyrrates); 	} 	if (tvp) { 		jas_tvparser_destroy(tvp); 	} 	if (cp) { 		jpc_enc_cp_destroy(cp); 	} 	return 0; }"
"211832_CWE-362.c","CWE-362","doit (struct query *z, int state) {     char key[257];     char misc[20], header[12];     char *buf = 0, *cached = 0;     const char *whichserver = 0;      unsigned int rcode = 0;     unsigned int posanswers = 0;     unsigned int len = 0, cachedlen = 0;      uint16 numanswers = 0;     uint16 numauthority = 0;     unsigned int posauthority = 0;      uint16 numglue = 0;     unsigned int posglue = 0;     unsigned int pos = 0, pos2 = 0;      uint16 datalen = 0;     char *control = 0, *d = 0;      const char *dtype = 0;     unsigned int dlen = 0;      int flagout = 0, flagcname = 0;     int flagreferral = 0, flagsoa = 0;      int i = 0, j = 0, k = 0, p = 0, q = 0;     uint32 ttl = 0, soattl = 0, cnamettl = 0;      errno = error_io;     if (state == 1)         goto HAVEPACKET;     if (state == -1)     {         if (debug_level > 1)             log_servfail (z->name[z->level]);         goto SERVFAIL;     }   NEWNAME:     if (++z->loop == 100)         goto DIE;     d = z->name[z->level];     dtype = z->level ? DNS_T_A : z->type;     dlen = dns_domain_length (d);      if (globalip (d, misc))     {         if (z->level)         {             for (k = 0; k < 64; k += 4)             {                 if (byte_equal (z->servers[z->level - 1] + k, 4, ""\0\0\0\0""))                 {                     byte_copy (z->servers[z->level - 1] + k, 4, misc);                     break;                 }             }             goto LOWERLEVEL;         }         if (!rqa (z))             goto DIE;         if (typematch (DNS_T_A, dtype))         {             if (!response_rstart (d, DNS_T_A, 655360))                 goto DIE;             if (!response_addbytes (misc, 4))                 goto DIE;             response_rfinish (RESPONSE_ANSWER);         }         cleanup (z);          return 1;     }      if (dns_domain_equal (d, ""\0011\0010\0010\003127\7in-addr\4arpa\0""))     {         if (z->level)             goto LOWERLEVEL;         if (!rqa (z))             goto DIE;         if (typematch (DNS_T_PTR, dtype))         {             if (!response_rstart (d, DNS_T_PTR, 655360))                 goto DIE;             if (!response_addname (""\011localhost\0""))                 goto DIE;              response_rfinish (RESPONSE_ANSWER);         }         cleanup (z);         if (debug_level > 2)             log_stats ();          return 1;     }      if (dlen <= 255)     {         byte_copy (key, 2, DNS_T_ANY);         byte_copy (key + 2, dlen, d);         case_lowerb (key + 2, dlen);         cached = cache_get (key, dlen + 2, &cachedlen, &ttl);         if (cached)         {             if (debug_level > 2)                 log_cachednxdomain (d);             goto NXDOMAIN;         }          byte_copy (key, 2, DNS_T_CNAME);         cached = cache_get (key, dlen + 2, &cachedlen, &ttl);         if (cached)         {             if (typematch (DNS_T_CNAME, dtype))             {                 if (debug_level > 2)                     log_cachedanswer (d, DNS_T_CNAME);                  if (!rqa (z))                     goto DIE;                 if (!response_cname (z->name[0], cached, ttl))                     goto DIE;                 cleanup (z);                  return 1;             }             if (debug_level > 2)                 log_cachedcname (d, cached);              if (!dns_domain_copy (&cname, cached))                 goto DIE;              goto CNAME;         }          if (typematch (DNS_T_NS, dtype))         {             byte_copy (key, 2, DNS_T_NS);             cached = cache_get (key, dlen + 2, &cachedlen, &ttl);             if (cached && (cachedlen || byte_diff (dtype, 2, DNS_T_ANY)))             {                 if (debug_level > 2)                     log_cachedanswer (d, DNS_T_NS);                 if (!rqa (z))                     goto DIE;                  pos = 0;                 while ((pos=dns_packet_getname (cached, cachedlen, pos, &t2)))                 {                     if (!response_rstart (d, DNS_T_NS, ttl))                         goto DIE;                     if (!response_addname (t2))                         goto DIE;                      response_rfinish (RESPONSE_ANSWER);                 }                 cleanup (z);                  return 1;             }         }          if (typematch (DNS_T_PTR, dtype))         {             byte_copy (key, 2, DNS_T_PTR);             cached = cache_get (key, dlen + 2, &cachedlen, &ttl);             if (cached && (cachedlen || byte_diff(dtype, 2, DNS_T_ANY)))             {                 if (debug_level > 2)                     log_cachedanswer (d, DNS_T_PTR);                 if (!rqa (z))                     goto DIE;                  pos = 0;                 while ((pos=dns_packet_getname (cached, cachedlen, pos, &t2)))                 {                     if (!response_rstart (d, DNS_T_PTR, ttl))                         goto DIE;                     if (!response_addname (t2))                         goto DIE;                      response_rfinish (RESPONSE_ANSWER);                 }                 cleanup(z);                  return 1;             }         }          if (typematch (DNS_T_MX, dtype))         {             byte_copy (key, 2, DNS_T_MX);             cached = cache_get (key, dlen + 2, &cachedlen, &ttl);             if (cached && (cachedlen || byte_diff (dtype, 2, DNS_T_ANY)))             {                 if (debug_level > 2)                     log_cachedanswer (d, DNS_T_MX);                 if (!rqa (z))                     goto DIE;                  pos = 0;                 while ((pos=dns_packet_copy (cached, cachedlen, pos, misc, 2)))                 {                     pos = dns_packet_getname (cached, cachedlen, pos, &t2);                     if (!pos)                         break;                     if (!response_rstart (d, DNS_T_MX, ttl))                         goto DIE;                     if (!response_addbytes (misc, 2))                         goto DIE;                     if (!response_addname (t2))                         goto DIE;                      response_rfinish (RESPONSE_ANSWER);                 }                 cleanup (z);                  return 1;             }         }          if (typematch (DNS_T_A, dtype))         {             byte_copy (key,2,DNS_T_A);             cached = cache_get (key, dlen + 2, &cachedlen, &ttl);             if (cached && (cachedlen || byte_diff (dtype, 2, DNS_T_ANY)))             {                 if (z->level)                 {                     if (debug_level > 2)                         log_cachedanswer (d, DNS_T_A);                     while (cachedlen >= 4)                     {                         for (k = 0; k < 64; k += 4)                         {                             if (byte_equal (z->servers[z->level - 1] + k,                                             4, ""\0\0\0\0""))                             {                                 byte_copy (z->servers[z->level - 1] + k,                                             4, cached);                                 break;                             }                         }                         cached += 4;                         cachedlen -= 4;                     }                     goto LOWERLEVEL;                 }                  if (debug_level > 2)                     log_cachedanswer (d, DNS_T_A);                 if (!rqa (z))                     goto DIE;                 while (cachedlen >= 4)                 {                     if (!response_rstart (d, DNS_T_A, ttl))                         goto DIE;                     if (!response_addbytes (cached, 4))                         goto DIE;                     response_rfinish (RESPONSE_ANSWER);                     cached += 4;                     cachedlen -= 4;                 }                 cleanup (z);                  return 1;             }         }          if (!typematch (DNS_T_ANY, dtype)             && !typematch (DNS_T_AXFR, dtype)             && !typematch (DNS_T_CNAME, dtype)             && !typematch (DNS_T_NS, dtype)             && !typematch (DNS_T_PTR, dtype)             && !typematch (DNS_T_A, dtype)             && !typematch (DNS_T_MX, dtype))         {             byte_copy (key, 2, dtype);             cached = cache_get (key, dlen + 2, &cachedlen, &ttl);             if (cached && (cachedlen || byte_diff (dtype, 2, DNS_T_ANY)))             {                 if (debug_level > 2)                     log_cachedanswer (d, dtype);                 if (!rqa (z))                     goto DIE;                 while (cachedlen >= 2)                 {                     uint16_unpack_big (cached, &datalen);                     cached += 2;                     cachedlen -= 2;                     if (datalen > cachedlen)                         goto DIE;                     if (!response_rstart (d, dtype, ttl))                         goto DIE;                     if (!response_addbytes (cached, datalen))                         goto DIE;                     response_rfinish (RESPONSE_ANSWER);                     cached += datalen;                     cachedlen -= datalen;                 }                 cleanup (z);                  return 1;             }         }     }      for (;;)     {         if (roots (z->servers[z->level], d))         {             for (j = 0; j < QUERY_MAXNS; ++j)                 dns_domain_free (&z->ns[z->level][j]);             z->control[z->level] = d;             break;         }          if (!flagforwardonly && (z->level < 2))         {             if (dlen < 255)             {                 byte_copy (key,2,DNS_T_NS);                 byte_copy (key + 2,dlen,d);                 case_lowerb (key + 2,dlen);                 cached = cache_get (key, dlen + 2, &cachedlen, &ttl);                 if (cached && cachedlen)                 {                     z->control[z->level] = d;                     byte_zero (z->servers[z->level],64);                     for (j = 0; j < QUERY_MAXNS; ++j)                         dns_domain_free (&z->ns[z->level][j]);                      j = pos = 0;                     pos = dns_packet_getname (cached, cachedlen, pos, &t1);                     while (pos)                     {                         if (debug_level > 2)                             log_cachedns (d, t1);                         if (j < QUERY_MAXNS)                             if (!dns_domain_copy (&z->ns[z->level][j++], t1))                                 goto DIE;                          pos = dns_packet_getname (cached, cachedlen, pos, &t1);                     }                     break;                 }             }         }          if (!*d)             goto DIE;         j = 1 + (unsigned int) (unsigned char) *d;         dlen -= j;         d += j;     }   HAVENS:     for (j = 0; j < QUERY_MAXNS; ++j)     {         if (z->ns[z->level][j])         {             if (z->level + 1 < QUERY_MAXLEVEL)             {                 int dc = dns_domain_copy (&z->name[z->level + 1],                                                     z->ns[z->level][j]);                 if (!dc)                     goto DIE;                  dns_domain_free (&z->ns[z->level][j]);                 ++z->level;                 goto NEWNAME;             }             dns_domain_free (&z->ns[z->level][j]);         }     }      for (j = 0; j < 64; j += 4)         if (byte_diff (z->servers[z->level] + j, 4, ""\0\0\0\0""))             break;     if (j == 64)         goto SERVFAIL;      dns_sortip (z->servers[z->level], 64);     if (z->level)     {         if (debug_level > 2)             log_tx (z->name[z->level], DNS_T_A,                         z->control[z->level], z->servers[z->level],z->level);          if (dns_transmit_start (&z->dt, z->servers[z->level], flagforwardonly,                                 z->name[z->level], DNS_T_A,z->localip) == -1)             goto DIE;     }     else     {         if (debug_level > 2)             log_tx (z->name[0], z->type, z->control[0], z->servers[0], 0);          if (dns_transmit_start (&z->dt, z->servers[0], flagforwardonly,                                 z->name[0], z->type, z->localip) == -1)             goto DIE;     }     return 0;   LOWERLEVEL:     dns_domain_free (&z->name[z->level]);     for (j = 0; j < QUERY_MAXNS; ++j)         dns_domain_free (&z->ns[z->level][j]);     --z->level;     goto HAVENS;   HAVEPACKET:     if (++z->loop == 100)         goto DIE;     buf = z->dt.packet;     len = z->dt.packetlen;      whichserver = z->dt.servers + 4 * z->dt.curserver;     control = z->control[z->level];     d = z->name[z->level];     dtype = z->level ? DNS_T_A : z->type;      if (!(pos = dns_packet_copy (buf, len, 0, header, 12)))         goto DIE;     if (!(pos = dns_packet_skipname (buf, len, pos)))         goto DIE;     pos += 4;     posanswers = pos;      uint16_unpack_big (header + 6, &numanswers);     uint16_unpack_big (header + 8, &numauthority);     uint16_unpack_big (header + 10, &numglue);      rcode = header[3] & 15;     if (rcode && (rcode != 3))         goto DIE; /* impossible; see irrelevant() */      flagsoa = soattl = cnamettl = 0;     flagout = flagcname = flagreferral = 0;     for (j = 0; j < numanswers; ++j)     {         pos = dns_packet_getname (buf, len, pos, &t1);         if (!pos)             goto DIE;         pos = dns_packet_copy (buf, len, pos, header, 10);         if (!pos)             goto DIE;          if (dns_domain_equal (t1, d))         {             if (byte_equal (header + 2, 2, DNS_C_IN))             {                 /* should always be true */                 if (typematch (header, dtype))                     flagout = 1;                 else if (typematch (header, DNS_T_CNAME))                 {                     if (!dns_packet_getname (buf, len, pos, &cname))                         goto DIE;                     flagcname = 1;                     cnamettl = ttlget (header + 4);                 }             }         }         uint16_unpack_big (header + 8, &datalen);         pos += datalen;     }     posauthority = pos;      for (j = 0; j < numauthority; ++j)     {         pos = dns_packet_getname (buf, len, pos, &t1);         if (!pos)             goto DIE;         pos = dns_packet_copy (buf, len, pos, header, 10);         if (!pos)             goto DIE;          if (typematch (header, DNS_T_SOA))         {             flagsoa = 1;             soattl = ttlget (header + 4);             if (soattl > 3600)                 soattl = 3600;         }         else if (typematch (header, DNS_T_NS))         {             flagreferral = 1;             if (!dns_domain_copy (&referral, t1))                 goto DIE;         }          uint16_unpack_big (header + 8, &datalen);         pos += datalen;     }     posglue = pos;      if (!flagcname && !rcode && !flagout && flagreferral && !flagsoa)     {         if (dns_domain_equal (referral, control)             || !dns_domain_suffix (referral, control))         {             if (debug_level > 2)                 log_lame (whichserver, control, referral);             byte_zero (whichserver, 4);              goto HAVENS;         }     }      if (records)     {         alloc_free (records);         records = 0;     }      k = numanswers + numauthority + numglue;     records = (unsigned int *) alloc (k * sizeof (unsigned int));     if (!records)         goto DIE;      pos = posanswers;     for (j = 0; j < k; ++j)     {         records[j] = pos;         pos = dns_packet_getname (buf, len, pos, &t1);         if (!pos)             goto DIE;         pos = dns_packet_copy (buf, len, pos, header, 10);         if (!pos)             goto DIE;         uint16_unpack_big (header + 8, &datalen);         pos += datalen;     }      i = j = k;     while (j > 1)     {         if (i > 1)         {             --i;             pos = records[i - 1];         }         else         {             pos = records[j - 1];             records[j - 1] = records[i - 1];             --j;         }          q = i;         while ((p = q * 2) < j)         {             if (!smaller (buf, len, records[p], records[p - 1]))                 ++p;             records[q - 1] = records[p - 1];             q = p;         }         if (p == j)         {             records[q - 1] = records[p - 1];             q = p;         }         while ((q > i) && smaller (buf, len, records[(p = q/2) - 1], pos))         {             records[q - 1] = records[p - 1];             q = p;         }         records[q - 1] = pos;     }      i = 0;     while (i < k)     {         char type[2];          if (!(pos = dns_packet_getname (buf, len, records[i], &t1)))             goto DIE;         if (!(pos = dns_packet_copy (buf, len, pos, header, 10)))             goto DIE;         ttl = ttlget (header + 4);          byte_copy (type, 2, header);         if (byte_diff (header + 2, 2, DNS_C_IN))         {             ++i;             continue;         }          for (j = i + 1; j < k; ++j)         {             pos = dns_packet_getname (buf, len, records[j], &t2);             if (!pos)                 goto DIE;             pos = dns_packet_copy (buf, len, pos, header, 10);             if (!pos)                 goto DIE;             if (!dns_domain_equal (t1, t2))                 break;             if (byte_diff (header, 2, type))                 break;             if (byte_diff (header + 2, 2, DNS_C_IN))                 break;         }          if (!dns_domain_suffix (t1, control))         {             i = j;             continue;         }         if (!roots_same (t1, control))         {             i = j;             continue;         }         if (byte_equal (type, 2, DNS_T_ANY))             ;         else if (byte_equal(type, 2, DNS_T_AXFR))             ;         else if (byte_equal (type, 2, DNS_T_SOA))         {             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_getname (buf, len, pos + 10, &t2);                 if (!pos)                     goto DIE;                 pos = dns_packet_getname (buf, len, pos, &t3);                 if (!pos)                     goto DIE;                 pos = dns_packet_copy (buf, len, pos, misc, 20);                 if (!pos)                     goto DIE;                 if (records[i] < posauthority && debug_level > 2)                       log_rrsoa (whichserver, t1, t2, t3, misc, ttl);                 ++i;             }         }         else if (byte_equal (type, 2, DNS_T_CNAME))         {             pos = dns_packet_skipname (buf, len, records[j - 1]);             if (!pos)                 goto DIE;             pos = dns_packet_getname (buf, len, pos + 10, &t2);             if (!pos)                 goto DIE;              if (debug_level > 2)                 log_rrcname (whichserver, t1, t2, ttl);              cachegeneric (DNS_T_CNAME, t1, t2, dns_domain_length (t2), ttl);         }         else if (byte_equal (type, 2, DNS_T_PTR))         {             save_start ();             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_getname (buf, len, pos + 10, &t2);                 if (!pos)                     goto DIE;                 if (debug_level > 2)                     log_rrptr (whichserver, t1, t2, ttl);                  save_data (t2, dns_domain_length (t2));                 ++i;             }             save_finish (DNS_T_PTR, t1, ttl);         }         else if (byte_equal (type, 2, DNS_T_NS))         {             save_start ();             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_getname (buf, len, pos + 10, &t2);                 if (!pos)                     goto DIE;                 if (debug_level > 2)                     log_rrns (whichserver, t1, t2, ttl);                 save_data (t2, dns_domain_length (t2));                 ++i;             }             save_finish (DNS_T_NS, t1, ttl);         }         else if (byte_equal (type, 2, DNS_T_MX))         {             save_start ();             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_copy (buf, len, pos + 10, misc, 2);                 if (!pos)                     goto DIE;                 pos = dns_packet_getname (buf, len, pos, &t2);                 if (!pos)                     goto DIE;                 if (debug_level > 2)                     log_rrmx (whichserver, t1, t2, misc, ttl);                 save_data (misc, 2);                 save_data (t2, dns_domain_length (t2));                 ++i;             }             save_finish (DNS_T_MX, t1, ttl);         }         else if (byte_equal (type, 2, DNS_T_A))         {             save_start ();             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_copy (buf, len, pos, header, 10);                 if (!pos)                     goto DIE;                 if (byte_equal (header + 8, 2, ""\0\4""))                 {                     pos = dns_packet_copy (buf, len, pos, header, 4);                     if (!pos)                         goto DIE;                     save_data (header, 4);                      if (debug_level > 2)                         log_rr (whichserver, t1, DNS_T_A, header, 4, ttl);                 }                 ++i;             }             save_finish (DNS_T_A, t1, ttl);         }         else         {             save_start ();             while (i < j)             {                 pos = dns_packet_skipname (buf, len, records[i]);                 if (!pos)                     goto DIE;                 pos = dns_packet_copy (buf, len, pos, header, 10);                 if (!pos)                     goto DIE;                 uint16_unpack_big (header + 8, &datalen);                 if (datalen > len - pos)                     goto DIE;                 save_data (header + 8, 2);                 save_data (buf + pos, datalen);                  if (debug_level > 2)                     log_rr (whichserver, t1, type, buf + pos, datalen, ttl);                  ++i;             }             save_finish (type, t1, ttl);         }         i = j;     }     alloc_free (records);     records = 0;      if (flagcname)     {         ttl = cnamettl; CNAME:         if (!z->level)         {             if (z->alias[QUERY_MAXALIAS - 1])                 goto DIE;              for (j = QUERY_MAXALIAS - 1; j > 0; --j)                 z->alias[j] = z->alias[j - 1];             for (j = QUERY_MAXALIAS - 1; j > 0; --j)                 z->aliasttl[j] = z->aliasttl[j - 1];              z->alias[0] = z->name[0];             z->aliasttl[0] = ttl;             z->name[0] = 0;         }         if (!dns_domain_copy (&z->name[z->level], cname))             goto DIE;          goto NEWNAME;     }      if (rcode == 3)     {         if (debug_level > 2)             log_nxdomain (whichserver, d, soattl);         cachegeneric (DNS_T_ANY, d, """", 0, soattl);  NXDOMAIN:         if (z->level)             goto LOWERLEVEL;         if (!rqa (z))             goto DIE;          response_nxdomain ();         cleanup (z);          return 1;     }      if (!flagout && flagsoa)         if (byte_diff (DNS_T_ANY, 2, dtype))             if (byte_diff (DNS_T_AXFR, 2, dtype))                 if (byte_diff (DNS_T_CNAME, 2, dtype))                 {                     save_start ();                     save_finish (dtype, d, soattl);                     if (debug_level > 2)                         log_nodata (whichserver, d, dtype, soattl);                 }      if (debug_level > 2)         log_stats ();      if (flagout || flagsoa || !flagreferral)     {         if (z->level)         {             pos = posanswers;             for (j = 0; j < numanswers; ++j)             {                 pos = dns_packet_getname (buf, len, pos, &t1);                 if (!pos)                     goto DIE;                 pos = dns_packet_copy (buf, len, pos, header, 10);                 if (!pos)                     goto DIE;                 uint16_unpack_big (header + 8, &datalen);                 if (dns_domain_equal (t1, d))                     if (typematch (header, DNS_T_A))                         if (byte_equal (header + 2, 2, DNS_C_IN))                             /* should always be true */                             if (datalen == 4)                                 for (k = 0; k < 64; k += 4)                                 {                                     if (byte_equal (z->servers[z->level - 1]                                                      + k, 4, ""\0\0\0\0""))                                     {                                         if (!dns_packet_copy (buf, len, pos,                                              z->servers[z->level - 1] + k, 4))                                             goto DIE;                                         break;                                     }                                 }                 pos += datalen;             }             goto LOWERLEVEL;         }          if (!rqa (z))             goto DIE;          pos = posanswers;         for (j = 0; j < numanswers; ++j)         {             pos = dns_packet_getname (buf, len, pos, &t1);             if (!pos)                 goto DIE;             pos = dns_packet_copy (buf, len, pos, header, 10);             if (!pos)                 goto DIE;             ttl = ttlget (header + 4);             uint16_unpack_big (header + 8, &datalen);             if (dns_domain_equal (t1, d))             {                 if (byte_equal (header + 2, 2, DNS_C_IN))                 {   /* should always be true */                     if (typematch (header, dtype))                     {                         if (!response_rstart (t1, header, ttl))                             goto DIE;                          if (typematch (header, DNS_T_NS)                             || typematch (header, DNS_T_CNAME)                             || typematch (header, DNS_T_PTR))                         {                             if (!dns_packet_getname (buf, len, pos, &t2))                                 goto DIE;                             if (!response_addname (t2))                                 goto DIE;                         }                         else if (typematch (header, DNS_T_MX))                         {                             pos2 = dns_packet_copy (buf, len, pos, misc, 2);                             if (!pos2)                                 goto DIE;                             if (!response_addbytes (misc, 2))                                 goto DIE;                             if (!dns_packet_getname (buf, len, pos2, &t2))                                 goto DIE;                             if (!response_addname (t2))                                 goto DIE;                         }                         else if (typematch (header, DNS_T_SOA))                         {                             pos2 = dns_packet_getname (buf, len, pos, &t2);                             if (!pos2)                                 goto DIE;                             if (!response_addname (t2))                                 goto DIE;                             pos2 = dns_packet_getname (buf, len, pos2, &t3);                             if (!pos2)                                 goto DIE;                             if (!response_addname (t3))                                 goto DIE;                             pos2 = dns_packet_copy (buf, len, pos2, misc, 20);                             if (!pos2)                                 goto DIE;                             if (!response_addbytes (misc, 20))                                 goto DIE;                         }                         else                         {                             if (pos + datalen > len)                                 goto DIE;                             if (!response_addbytes (buf + pos, datalen))                                 goto DIE;                         }                         response_rfinish(RESPONSE_ANSWER);                     }                 }             }             pos += datalen;         }         cleanup (z);          return 1;     }      if (!dns_domain_suffix (d, referral))         goto DIE;     control = d + dns_domain_suffixpos (d, referral);     z->control[z->level] = control;     byte_zero (z->servers[z->level], 64);     for (j = 0; j < QUERY_MAXNS; ++j)         dns_domain_free (&z->ns[z->level][j]);     k = 0;      pos = posauthority;     for (j = 0; j < numauthority; ++j)     {         pos = dns_packet_getname (buf, len, pos, &t1);         if (!pos)             goto DIE;         pos = dns_packet_copy (buf, len, pos, header, 10);         if (!pos)             goto DIE;          uint16_unpack_big (header + 8, &datalen);         if (dns_domain_equal (referral, t1))    /* should always be true */             if (typematch (header, DNS_T_NS))   /* should always be true */                 /* should always be true */                 if (byte_equal (header + 2, 2, DNS_C_IN))                     if (k < QUERY_MAXNS)                         if (!dns_packet_getname (buf, len, pos,                                                  &z->ns[z->level][k++]))                             goto DIE;         pos += datalen;     }      goto HAVENS;   SERVFAIL:     if (z->level)         goto LOWERLEVEL;     if (!rqa (z))         goto DIE;     response_servfail ();     cleanup (z);      return 1;   DIE:     cleanup (z);     if (records)     {         alloc_free (records);         records = 0;     }      return -1; }"
"211839_CWE-823.c","CWE-823","do_buffer_ext(     int		action,     int		start,     int		dir,		// FORWARD or BACKWARD     int		count,		// buffer number or number of buffers     int		flags)		// DOBUF_FORCEIT etc. {     buf_T	*buf;     buf_T	*bp;     int		unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL 			|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);      switch (start)     { 	case DOBUF_FIRST:   buf = firstbuf; break; 	case DOBUF_LAST:    buf = lastbuf;  break; 	default:	    buf = curbuf;   break;     }     if (start == DOBUF_MOD)	    // find next modified buffer     { 	while (count-- > 0) 	{ 	    do 	    { 		buf = buf->b_next; 		if (buf == NULL) 		    buf = firstbuf; 	    } 	    while (buf != curbuf && !bufIsChanged(buf)); 	} 	if (!bufIsChanged(buf)) 	{ 	    emsg(_(e_no_modified_buffer_found)); 	    return FAIL; 	}     }     else if (start == DOBUF_FIRST && count) // find specified buffer number     { 	while (buf != NULL && buf->b_fnum != count) 	    buf = buf->b_next;     }     else     { 	bp = NULL; 	while (count > 0 || (!unload && !buf->b_p_bl && bp != buf)) 	{ 	    // remember the buffer where we start, we come back there when all 	    // buffers are unlisted. 	    if (bp == NULL) 		bp = buf; 	    if (dir == FORWARD) 	    { 		buf = buf->b_next; 		if (buf == NULL) 		    buf = firstbuf; 	    } 	    else 	    { 		buf = buf->b_prev; 		if (buf == NULL) 		    buf = lastbuf; 	    } 	    // don't count unlisted buffers 	    if (unload || buf->b_p_bl) 	    { 		 --count; 		 bp = NULL;	// use this buffer as new starting point 	    } 	    if (bp == buf) 	    { 		// back where we started, didn't find anything. 		emsg(_(e_there_is_no_listed_buffer)); 		return FAIL; 	    } 	}     }      if (buf == NULL)	    // could not find it     { 	if (start == DOBUF_FIRST) 	{ 	    // don't warn when deleting 	    if (!unload) 		semsg(_(e_buffer_nr_does_not_exist), count); 	} 	else if (dir == FORWARD) 	    emsg(_(e_cannot_go_beyond_last_buffer)); 	else 	    emsg(_(e_cannot_go_before_first_buffer)); 	return FAIL;     } #ifdef FEAT_PROP_POPUP     if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) # ifdef FEAT_TERMINAL 				&& !bt_terminal(buf) #endif        ) 	return OK; #endif  #ifdef FEAT_GUI     need_mouse_correct = TRUE; #endif      /*      * delete buffer ""buf"" from memory and/or the list      */     if (unload)     { 	int	forward; 	bufref_T bufref;  	if (!can_unload_buffer(buf)) 	    return FAIL;  	set_bufref(&bufref, buf);  	// When unloading or deleting a buffer that's already unloaded and 	// unlisted: fail silently. 	if (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE 				   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl) 	    return FAIL;  	if ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf)) 	{ #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) 	    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write) 	    { 		dialog_changed(buf, FALSE); 		if (!bufref_valid(&bufref)) 		    // Autocommand deleted buffer, oops!  It's not changed 		    // now. 		    return FAIL; 		// If it's still changed fail silently, the dialog already 		// mentioned why it fails. 		if (bufIsChanged(buf)) 		    return FAIL; 	    } 	    else #endif 	    { 		semsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override), 								 buf->b_fnum); 		return FAIL; 	    } 	}  	// When closing the current buffer stop Visual mode. 	if (buf == curbuf && VIsual_active) 	    end_visual_mode();  	// If deleting the last (listed) buffer, make it empty. 	// The last (listed) buffer cannot be unloaded. 	FOR_ALL_BUFFERS(bp) 	    if (bp->b_p_bl && bp != buf) 		break; 	if (bp == NULL && buf == curbuf) 	    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);  	// If the deleted buffer is the current one, close the current window 	// (unless it's the only window).  Repeat this so long as we end up in 	// a window with this buffer. 	while (buf == curbuf 		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0) 		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL)) 	{ 	    if (win_close(curwin, FALSE) == FAIL) 		break; 	}  	// If the buffer to be deleted is not the current one, delete it here. 	if (buf != curbuf) 	{ 	    close_windows(buf, FALSE); 	    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0) 		    close_buffer(NULL, buf, action, FALSE, FALSE); 	    return OK; 	}  	/* 	 * Deleting the current buffer: Need to find another buffer to go to. 	 * There should be another, otherwise it would have been handled 	 * above.  However, autocommands may have deleted all buffers. 	 * First use au_new_curbuf.br_buf, if it is valid. 	 * Then prefer the buffer we most recently visited. 	 * Else try to find one that is loaded, after the current buffer, 	 * then before the current buffer. 	 * Finally use any buffer. 	 */ 	buf = NULL;	// selected buffer 	bp = NULL;	// used when no loaded buffer found 	if (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf)) 	    buf = au_new_curbuf.br_buf; 	else if (curwin->w_jumplistlen > 0) 	{ 	    int     jumpidx;  	    jumpidx = curwin->w_jumplistidx - 1; 	    if (jumpidx < 0) 		jumpidx = curwin->w_jumplistlen - 1;  	    forward = jumpidx; 	    while (jumpidx != curwin->w_jumplistidx) 	    { 		buf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum); 		if (buf != NULL) 		{ 		    if (buf == curbuf || !buf->b_p_bl) 			buf = NULL;	// skip current and unlisted bufs 		    else if (buf->b_ml.ml_mfp == NULL) 		    { 			// skip unloaded buf, but may keep it for later 			if (bp == NULL) 			    bp = buf; 			buf = NULL; 		    } 		} 		if (buf != NULL)   // found a valid buffer: stop searching 		    break; 		// advance to older entry in jump list 		if (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen) 		    break; 		if (--jumpidx < 0) 		    jumpidx = curwin->w_jumplistlen - 1; 		if (jumpidx == forward)		// List exhausted for sure 		    break; 	    } 	}  	if (buf == NULL)	// No previous buffer, Try 2'nd approach 	{ 	    forward = TRUE; 	    buf = curbuf->b_next; 	    for (;;) 	    { 		if (buf == NULL) 		{ 		    if (!forward)	// tried both directions 			break; 		    buf = curbuf->b_prev; 		    forward = FALSE; 		    continue; 		} 		// in non-help buffer, try to skip help buffers, and vv 		if (buf->b_help == curbuf->b_help && buf->b_p_bl) 		{ 		    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer 			break; 		    if (bp == NULL)	// remember unloaded buf for later 			bp = buf; 		} 		if (forward) 		    buf = buf->b_next; 		else 		    buf = buf->b_prev; 	    } 	} 	if (buf == NULL)	// No loaded buffer, use unloaded one 	    buf = bp; 	if (buf == NULL)	// No loaded buffer, find listed one 	{ 	    FOR_ALL_BUFFERS(buf) 		if (buf->b_p_bl && buf != curbuf) 		    break; 	} 	if (buf == NULL)	// Still no buffer, just take one 	{ 	    if (curbuf->b_next != NULL) 		buf = curbuf->b_next; 	    else 		buf = curbuf->b_prev; 	}     }      if (buf == NULL)     { 	// Autocommands must have wiped out all other buffers.  Only option 	// now is to make the current buffer empty. 	return empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);     }      /*      * make ""buf"" the current buffer      */     if (action == DOBUF_SPLIT)	    // split window first     { 	// If 'switchbuf' contains ""useopen"": jump to first window containing 	// ""buf"" if one exists 	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf)) 	    return OK; 	// If 'switchbuf' contains ""usetab"": jump to first window in any tab 	// page containing ""buf"" if one exists 	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf)) 	    return OK; 	if (win_split(0, 0) == FAIL) 	    return FAIL;     }      // go to current buffer - nothing to do     if (buf == curbuf) 	return OK;      // Check if the current buffer may be abandoned.     if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))     { #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) 	if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write) 	{ 	    bufref_T bufref;  	    set_bufref(&bufref, buf); 	    dialog_changed(curbuf, FALSE); 	    if (!bufref_valid(&bufref)) 		// Autocommand deleted buffer, oops! 		return FAIL; 	} 	if (bufIsChanged(curbuf)) #endif 	{ 	    no_write_message(); 	    return FAIL; 	}     }      // Go to the other buffer.     set_curbuf(buf, action);      if (action == DOBUF_SPLIT) 	RESET_BINDING(curwin);	// reset 'scrollbind' and 'cursorbind'  #if defined(FEAT_EVAL)     if (aborting())	    // autocmds may abort script processing 	return FAIL; #endif      return OK; }"
"211842_CWE-787.c","CWE-787","change_indent(     int		type,     int		amount,     int		round,     int		replaced,	// replaced character, put on replace stack     int		call_changed_bytes)	// call changed_bytes() {     int		vcol;     int		last_vcol;     int		insstart_less;		// reduction for Insstart.col     int		new_cursor_col;     int		i;     char_u	*ptr;     int		save_p_list;     int		start_col;     colnr_T	vc;     colnr_T	orig_col = 0;		// init for GCC     char_u	*new_line, *orig_line = NULL;	// init for GCC      // VREPLACE mode needs to know what the line was like before changing     if (State & VREPLACE_FLAG)     { 	orig_line = vim_strsave(ml_get_curline());  // Deal with NULL below 	orig_col = curwin->w_cursor.col;     }      // for the following tricks we don't want list mode     save_p_list = curwin->w_p_list;     curwin->w_p_list = FALSE;     vc = getvcol_nolist(&curwin->w_cursor);     vcol = vc;      // For Replace mode we need to fix the replace stack later, which is only     // possible when the cursor is in the indent.  Remember the number of     // characters before the cursor if it's possible.     start_col = curwin->w_cursor.col;      // determine offset from first non-blank     new_cursor_col = curwin->w_cursor.col;     beginline(BL_WHITE);     new_cursor_col -= curwin->w_cursor.col;      insstart_less = curwin->w_cursor.col;      // If the cursor is in the indent, compute how many screen columns the     // cursor is to the left of the first non-blank.     if (new_cursor_col < 0) 	vcol = get_indent() - vcol;      if (new_cursor_col > 0)	    // can't fix replace stack 	start_col = -1;      // Set the new indent.  The cursor will be put on the first non-blank.     if (type == INDENT_SET) 	(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);     else     { 	int	save_State = State;  	// Avoid being called recursively. 	if (State & VREPLACE_FLAG) 	    State = INSERT; 	shift_line(type == INDENT_DEC, round, 1, call_changed_bytes); 	State = save_State;     }     insstart_less -= curwin->w_cursor.col;      // Try to put cursor on same character.     // If the cursor is at or after the first non-blank in the line,     // compute the cursor column relative to the column of the first     // non-blank character.     // If we are not in insert mode, leave the cursor on the first non-blank.     // If the cursor is before the first non-blank, position it relative     // to the first non-blank, counted in screen columns.     if (new_cursor_col >= 0)     { 	// When changing the indent while the cursor is touching it, reset 	// Insstart_col to 0. 	if (new_cursor_col == 0) 	    insstart_less = MAXCOL; 	new_cursor_col += curwin->w_cursor.col;     }     else if (!(State & INSERT)) 	new_cursor_col = curwin->w_cursor.col;     else     { 	// Compute the screen column where the cursor should be. 	vcol = get_indent() - vcol; 	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);  	// Advance the cursor until we reach the right screen column. 	vcol = last_vcol = 0; 	new_cursor_col = -1; 	ptr = ml_get_curline(); 	while (vcol <= (int)curwin->w_virtcol) 	{ 	    last_vcol = vcol; 	    if (has_mbyte && new_cursor_col >= 0) 		new_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col); 	    else 		++new_cursor_col; 	    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol); 	} 	vcol = last_vcol;  	// May need to insert spaces to be able to position the cursor on 	// the right screen column. 	if (vcol != (int)curwin->w_virtcol) 	{ 	    curwin->w_cursor.col = (colnr_T)new_cursor_col; 	    i = (int)curwin->w_virtcol - vcol; 	    ptr = alloc(i + 1); 	    if (ptr != NULL) 	    { 		new_cursor_col += i; 		ptr[i] = NUL; 		while (--i >= 0) 		    ptr[i] = ' '; 		ins_str(ptr); 		vim_free(ptr); 	    } 	}  	// When changing the indent while the cursor is in it, reset 	// Insstart_col to 0. 	insstart_less = MAXCOL;     }      curwin->w_p_list = save_p_list;      if (new_cursor_col <= 0) 	curwin->w_cursor.col = 0;     else 	curwin->w_cursor.col = (colnr_T)new_cursor_col;     curwin->w_set_curswant = TRUE;     changed_cline_bef_curs();      // May have to adjust the start of the insert.     if (State & INSERT)     { 	if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0) 	{ 	    if ((int)Insstart.col <= insstart_less) 		Insstart.col = 0; 	    else 		Insstart.col -= insstart_less; 	} 	if ((int)ai_col <= insstart_less) 	    ai_col = 0; 	else 	    ai_col -= insstart_less;     }      // For REPLACE mode, may have to fix the replace stack, if it's possible.     // If the number of characters before the cursor decreased, need to pop a     // few characters from the replace stack.     // If the number of characters before the cursor increased, need to push a     // few NULs onto the replace stack.     if (REPLACE_NORMAL(State) && start_col >= 0)     { 	while (start_col > (int)curwin->w_cursor.col) 	{ 	    replace_join(0);	    // remove a NUL from the replace stack 	    --start_col; 	} 	while (start_col < (int)curwin->w_cursor.col || replaced) 	{ 	    replace_push(NUL); 	    if (replaced) 	    { 		replace_push(replaced); 		replaced = NUL; 	    } 	    ++start_col; 	}     }      // For VREPLACE mode, we also have to fix the replace stack.  In this case     // it is always possible because we backspace over the whole line and then     // put it back again the way we wanted it.     if (State & VREPLACE_FLAG)     { 	// If orig_line didn't allocate, just return.  At least we did the job, 	// even if you can't backspace. 	if (orig_line == NULL) 	    return;  	// Save new line 	new_line = vim_strsave(ml_get_curline()); 	if (new_line == NULL) 	    return;  	// We only put back the new line up to the cursor 	new_line[curwin->w_cursor.col] = NUL;  	// Put back original line 	ml_replace(curwin->w_cursor.lnum, orig_line, FALSE); 	curwin->w_cursor.col = orig_col;  	// Backspace from cursor to start of line 	backspace_until_column(0);  	// Insert new stuff into line again 	ins_bytes(new_line);  	vim_free(new_line);     } }"
"211845_CWE-787.c","CWE-787","static Image *ReadTIFFImage(const ImageInfo *image_info,   ExceptionInfo *exception) { #define MaxPixelChannels  32 #define ThrowTIFFException(severity,message) \ { \   if (pixel_info != (MemoryInfo *) NULL) \     pixel_info=RelinquishVirtualMemory(pixel_info); \   if (quantum_info != (QuantumInfo *) NULL) \     quantum_info=DestroyQuantumInfo(quantum_info); \   TIFFClose(tiff); \   ThrowReaderException(severity,message); \ }    const char     *option;    float     *chromaticity = (float *) NULL,     x_position,     y_position,     x_resolution,     y_resolution;    Image     *image;    int     tiff_status = 0;    MagickBooleanType     more_frames;    MagickStatusType     status;    MemoryInfo     *pixel_info = (MemoryInfo *) NULL;    QuantumInfo     *quantum_info;    QuantumType     quantum_type;    size_t     number_pixels;    ssize_t     i,     scanline_size,     y;    TIFF     *tiff;    TIFFMethodType     method;    uint16     compress_tag = 0,     bits_per_sample = 0,     endian = 0,     extra_samples = 0,     interlace = 0,     max_sample_value = 0,     min_sample_value = 0,     orientation = 0,     pages = 0,     photometric = 0,     *sample_info = NULL,     sample_format = 0,     samples_per_pixel = 0,     units = 0,     value = 0;    uint32     height,     rows_per_strip,     width;    unsigned char     *pixels;    void     *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };    /*     Open image.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(exception != (ExceptionInfo *) NULL);   assert(exception->signature == MagickCoreSignature);   if (IsEventLogging() != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",       image_info->filename);   image=AcquireImage(image_info);   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);   if (status == MagickFalse)     {       image=DestroyImageList(image);       return((Image *) NULL);     }   (void) SetMagickThreadValue(tiff_exception,exception);   tiff=TIFFClientOpen(image->filename,""rb"",(thandle_t) image,TIFFReadBlob,     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,     TIFFUnmapBlob);   if (tiff == (TIFF *) NULL)     {       if (exception->severity == UndefinedException)         ThrowReaderException(CorruptImageError,""UnableToReadImageData"");       image=DestroyImageList(image);       return((Image *) NULL);     }   if (exception->severity > ErrorException)     {       TIFFClose(tiff);       image=DestroyImageList(image);       return((Image *) NULL);     }   if (image_info->number_scenes != 0)     {       /*         Generate blank images for subimage specification (e.g. image.tif[4].         We need to check the number of directores because it is possible that         the subimage(s) are stored in the photoshop profile.       */       if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))         {           for (i=0; i < (ssize_t) image_info->scene; i++)           {             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;             if (status == MagickFalse)               {                 TIFFClose(tiff);                 image=DestroyImageList(image);                 return((Image *) NULL);               }             AcquireNextImage(image_info,image);             if (GetNextImageInList(image) == (Image *) NULL)               {                 TIFFClose(tiff);                 image=DestroyImageList(image);                 return((Image *) NULL);               }             image=SyncNextImageInList(image);           }         }     }   more_frames=MagickTrue;   do   {     /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */     photometric=PHOTOMETRIC_RGB;     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))       {         TIFFClose(tiff);         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");       }     if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&         ((bits_per_sample <= 0) || (bits_per_sample > 32)))       {         TIFFClose(tiff);         ThrowReaderException(CorruptImageError,""UnsupportedBitsPerPixel"");       }     if (samples_per_pixel > MaxPixelChannels)       {         TIFFClose(tiff);         ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded"");       }     if (sample_format == SAMPLEFORMAT_IEEEFP)       (void) SetImageProperty(image,""quantum:format"",""floating-point"");     switch (photometric)     {       case PHOTOMETRIC_MINISBLACK:       {         (void) SetImageProperty(image,""tiff:photometric"",""min-is-black"");         break;       }       case PHOTOMETRIC_MINISWHITE:       {         (void) SetImageProperty(image,""tiff:photometric"",""min-is-white"");         break;       }       case PHOTOMETRIC_PALETTE:       {         (void) SetImageProperty(image,""tiff:photometric"",""palette"");         break;       }       case PHOTOMETRIC_RGB:       {         (void) SetImageProperty(image,""tiff:photometric"",""RGB"");         break;       }       case PHOTOMETRIC_CIELAB:       {         (void) SetImageProperty(image,""tiff:photometric"",""CIELAB"");         break;       }       case PHOTOMETRIC_LOGL:       {         (void) SetImageProperty(image,""tiff:photometric"",""CIE Log2(L)"");         break;       }       case PHOTOMETRIC_LOGLUV:       {         (void) SetImageProperty(image,""tiff:photometric"",""LOGLUV"");         break;       } #if defined(PHOTOMETRIC_MASK)       case PHOTOMETRIC_MASK:       {         (void) SetImageProperty(image,""tiff:photometric"",""MASK"");         break;       } #endif       case PHOTOMETRIC_SEPARATED:       {         (void) SetImageProperty(image,""tiff:photometric"",""separated"");         break;       }       case PHOTOMETRIC_YCBCR:       {         (void) SetImageProperty(image,""tiff:photometric"",""YCBCR"");         break;       }       default:       {         (void) SetImageProperty(image,""tiff:photometric"",""unknown"");         break;       }     }     if (image->debug != MagickFalse)       {         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %ux%u"",           (unsigned int) width,(unsigned int) height);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Interlace: %u"",           interlace);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""Bits per sample: %u"",bits_per_sample);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""Min sample value: %u"",min_sample_value);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),           ""Max sample value: %u"",max_sample_value);         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Photometric ""           ""interpretation: %s"",GetImageProperty(image,""tiff:photometric""));       }     image->columns=(size_t) width;     image->rows=(size_t) height;     image->depth=(size_t) bits_per_sample;     if (image->debug != MagickFalse)       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Image depth: %.20g"",         (double) image->depth);     image->endian=MSBEndian;     if (endian == FILLORDER_LSB2MSB)       image->endian=LSBEndian; #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)     if (TIFFIsBigEndian(tiff) == 0)       {         (void) SetImageProperty(image,""tiff:endian"",""lsb"");         image->endian=LSBEndian;       }     else       {         (void) SetImageProperty(image,""tiff:endian"",""msb"");         image->endian=MSBEndian;       } #endif     if ((photometric == PHOTOMETRIC_MINISBLACK) ||         (photometric == PHOTOMETRIC_MINISWHITE))       image->colorspace=GRAYColorspace;     if (photometric == PHOTOMETRIC_SEPARATED)       image->colorspace=CMYKColorspace;     if (photometric == PHOTOMETRIC_CIELAB)       image->colorspace=LabColorspace;     if ((photometric == PHOTOMETRIC_YCBCR) &&         (compress_tag != COMPRESSION_OJPEG) &&         (compress_tag != COMPRESSION_JPEG))       image->colorspace=YCbCrColorspace;     status=TIFFGetProfiles(tiff,image);     if (status == MagickFalse)       {         TIFFClose(tiff);         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     status=TIFFGetProperties(tiff,image);     if (status == MagickFalse)       {         TIFFClose(tiff);         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     option=GetImageOption(image_info,""tiff:exif-properties"");     if ((option == (const char *) NULL) ||         (IsMagickTrue(option) != MagickFalse))       (void) TIFFGetEXIFProperties(tiff,image);     option=GetImageOption(image_info,""tiff:gps-properties"");     if ((option == (const char *) NULL) ||         (IsMagickTrue(option) != MagickFalse))       (void) TIFFGetGPSProperties(tiff,image);     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))       {         image->x_resolution=x_resolution;         image->y_resolution=y_resolution;       }     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)       {         if (units == RESUNIT_INCH)           image->units=PixelsPerInchResolution;         if (units == RESUNIT_CENTIMETER)           image->units=PixelsPerCentimeterResolution;       }     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))       {         image->page.x=CastDoubleToLong(ceil(x_position*           image->x_resolution-0.5));         image->page.y=CastDoubleToLong(ceil(y_position*           image->y_resolution-0.5));       }     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)       image->orientation=(OrientationType) orientation;     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)       {         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))           {             image->chromaticity.white_point.x=chromaticity[0];             image->chromaticity.white_point.y=chromaticity[1];           }       }     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)       {         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))           {             image->chromaticity.red_primary.x=chromaticity[0];             image->chromaticity.red_primary.y=chromaticity[1];             image->chromaticity.green_primary.x=chromaticity[2];             image->chromaticity.green_primary.y=chromaticity[3];             image->chromaticity.blue_primary.x=chromaticity[4];             image->chromaticity.blue_primary.y=chromaticity[5];           }       } #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)     if ((compress_tag != COMPRESSION_NONE) &&         (TIFFIsCODECConfigured(compress_tag) == 0))       {         TIFFClose(tiff);         ThrowReaderException(CoderError,""CompressNotSupported"");       } #endif     switch (compress_tag)     {       case COMPRESSION_NONE: image->compression=NoCompression; break;       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;       case COMPRESSION_JPEG:       {          image->compression=JPEGCompression; #if defined(JPEG_SUPPORT)          {            char              sampling_factor[MaxTextExtent];             int              tiff_status;             uint16              horizontal,              vertical;             tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,              &vertical);            if (tiff_status == 1)              {                (void) FormatLocaleString(sampling_factor,MaxTextExtent,""%dx%d"",                  horizontal,vertical);                (void) SetImageProperty(image,""jpeg:sampling-factor"",                  sampling_factor);                (void) LogMagickEvent(CoderEvent,GetMagickModule(),                  ""Sampling Factors: %s"",sampling_factor);              }          } #endif         break;       }       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break; #if defined(COMPRESSION_LZMA)       case COMPRESSION_LZMA: image->compression=LZMACompression; break; #endif       case COMPRESSION_LZW: image->compression=LZWCompression; break;       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break; #if defined(COMPRESSION_WEBP)       case COMPRESSION_WEBP: image->compression=WebPCompression; break; #endif #if defined(COMPRESSION_ZSTD)       case COMPRESSION_ZSTD: image->compression=ZstdCompression; break; #endif       default: image->compression=RLECompression; break;     }     quantum_info=(QuantumInfo *) NULL;     if ((photometric == PHOTOMETRIC_PALETTE) &&         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))       {         size_t           colors;          colors=(size_t) GetQuantumRange(bits_per_sample)+1;         if (AcquireImageColormap(image,colors) == MagickFalse)           {             TIFFClose(tiff);             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");           }       }     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)       image->scene=value;     if (image->storage_class == PseudoClass)       {         int           tiff_status;          size_t           range;          uint16           *blue_colormap = (uint16 *) NULL,           *green_colormap = (uint16 *) NULL,           *red_colormap = (uint16 *) NULL;          /*           Initialize colormap.         */         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,           &green_colormap,&blue_colormap);         if (tiff_status == 1)           {             if ((red_colormap != (uint16 *) NULL) &&                 (green_colormap != (uint16 *) NULL) &&                 (blue_colormap != (uint16 *) NULL))               {                 range=255;  /* might be old style 8-bit colormap */                 for (i=0; i < (ssize_t) image->colors; i++)                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||                       (blue_colormap[i] >= 256))                     {                       range=65535;                       break;                     }                 for (i=0; i < (ssize_t) image->colors; i++)                 {                   image->colormap[i].red=ClampToQuantum(((double)                     QuantumRange*red_colormap[i])/range);                   image->colormap[i].green=ClampToQuantum(((double)                     QuantumRange*green_colormap[i])/range);                   image->colormap[i].blue=ClampToQuantum(((double)                     QuantumRange*blue_colormap[i])/range);                 }               }           }       }     if (image_info->ping != MagickFalse)       {         if (image_info->number_scenes != 0)           if (image->scene >= (image_info->scene+image_info->number_scenes-1))             break;         goto next_tiff_frame;       }     status=SetImageExtent(image,image->columns,image->rows);     if (status == MagickFalse)       {         TIFFClose(tiff);         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     status=SetImageColorspace(image,image->colorspace);     status&=ResetImagePixels(image,exception);     if (status == MagickFalse)       {         TIFFClose(tiff);         InheritException(exception,&image->exception);         return(DestroyImageList(image));       }     /*       Allocate memory for the image and pixel buffer.     */     quantum_info=AcquireQuantumInfo(image_info,image);     if (quantum_info == (QuantumInfo *) NULL)       ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");     if (sample_format == SAMPLEFORMAT_UINT)       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);     if (sample_format == SAMPLEFORMAT_INT)       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);     if (sample_format == SAMPLEFORMAT_IEEEFP)       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);     if (status == MagickFalse)       ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");     status=MagickTrue;     switch (photometric)     {       case PHOTOMETRIC_MINISBLACK:       {         quantum_info->min_is_white=MagickFalse;         break;       }       case PHOTOMETRIC_MINISWHITE:       {         quantum_info->min_is_white=MagickTrue;         break;       }       default:         break;     }     extra_samples=0;     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,       &sample_info,sans);     if (tiff_status == 1)       {         (void) SetImageProperty(image,""tiff:alpha"",""unspecified"");         if (extra_samples == 0)           {             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))               image->matte=MagickTrue;           }         else           for (i=0; i < extra_samples; i++)           {             image->matte=MagickTrue;             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)               {                 SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);                 (void) SetImageProperty(image,""tiff:alpha"",""associated"");               }             else               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)                 {                   SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);                   (void) SetImageProperty(image,""tiff:alpha"",""unassociated"");                 }           }       }     if (image->matte != MagickFalse)       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);     method=ReadGenericMethod;     rows_per_strip=(uint32) image->rows;     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)       {         char           value[MaxTextExtent];          (void) FormatLocaleString(value,MaxTextExtent,""%u"",(unsigned int)           rows_per_strip);         (void) SetImageProperty(image,""tiff:rows-per-strip"",value);         method=ReadStripMethod;         if (rows_per_strip > (uint32) image->rows)           rows_per_strip=(uint32) image->rows;       }     if (TIFFIsTiled(tiff) != MagickFalse)       {         uint32           columns,           rows;          if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))           ThrowTIFFException(CoderError,""ImageIsNotTiled"");         if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||             (AcquireMagickResource(HeightResource,rows) == MagickFalse))           ThrowTIFFException(ImageError,""WidthOrHeightExceedsLimit"");         method=ReadTileMethod;       }     if ((photometric == PHOTOMETRIC_LOGLUV) ||         (compress_tag == COMPRESSION_CCITTFAX3))       method=ReadGenericMethod;     if (image->compression == JPEGCompression)       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,         samples_per_pixel);     quantum_info->endian=LSBEndian;     scanline_size=TIFFScanlineSize(tiff);     if (scanline_size <= 0)       ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");     number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*       pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*       rows_per_strip);     if ((double) scanline_size > 1.5*number_pixels)       ThrowTIFFException(CorruptImageError,""CorruptImage"");     number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);     pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));     if (pixel_info == (MemoryInfo *) NULL)       ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);     (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));     quantum_type=GrayQuantum;     if (image->storage_class == PseudoClass)       quantum_type=IndexQuantum;     if (interlace != PLANARCONFIG_SEPARATE)       {         size_t           pad;          pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);         if (image->matte != MagickFalse)           {             if (image->storage_class == PseudoClass)               quantum_type=IndexAlphaQuantum;             else               quantum_type=samples_per_pixel == 1 ? AlphaQuantum :                 GrayAlphaQuantum;           }         if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))           {             quantum_type=RGBQuantum;             pad=(size_t) MagickMax((ssize_t) samples_per_pixel+               extra_samples-3,0);             if (image->matte != MagickFalse)               {                 quantum_type=RGBAQuantum;                 pad=(size_t) MagickMax((ssize_t) samples_per_pixel+                   extra_samples-4,0);               }             if (image->colorspace == CMYKColorspace)               {                 quantum_type=CMYKQuantum;                 pad=(size_t) MagickMax((ssize_t) samples_per_pixel+                   extra_samples-4,0);                 if (image->matte != MagickFalse)                   {                     quantum_type=CMYKAQuantum;                     pad=(size_t) MagickMax((ssize_t) samples_per_pixel+                       extra_samples-5,0);                   }               }             status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>               3));             if (status == MagickFalse)               ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");           }       }     switch (method)     {       case ReadYCCKMethod:       {         /*           Convert YCC TIFF image.         */         for (y=0; y < (ssize_t) image->rows; y++)         {           int             status;            IndexPacket             *indexes;            PixelPacket             *magick_restrict q;            ssize_t             x;            unsigned char             *p;            status=TIFFReadPixels(tiff,0,y,(char *) pixels);           if (status == -1)             break;           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           indexes=GetAuthenticIndexQueue(image);           p=pixels;           for (x=0; x < (ssize_t) image->columns; x++)           {             SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+               (1.402*(double) *(p+2))-179.456)));             SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+               135.45984)));             SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+               (1.772*(double) *(p+1))-226.816)));             SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));             q++;             p+=4;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         break;       }       case ReadStripMethod:       {         unsigned char           *p;          size_t           extent;          ssize_t           stride,           strip_id;          tsize_t           strip_size;          unsigned char           *strip_pixels;          /*           Convert stripped TIFF image.         */         extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);         strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,           sizeof(*strip_pixels));         if (strip_pixels == (unsigned char *) NULL)           ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");         (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));         stride=TIFFVStripSize(tiff,1);         strip_id=0;         p=strip_pixels;         for (i=0; i < (ssize_t) samples_per_pixel; i++)         {           size_t             rows_remaining;            switch (i)           {             case 0: break;             case 1: quantum_type=GreenQuantum; break;             case 2: quantum_type=BlueQuantum; break;             case 3:             {               quantum_type=AlphaQuantum;               if (image->colorspace == CMYKColorspace)                 quantum_type=BlackQuantum;               break;             }             case 4: quantum_type=AlphaQuantum; break;             default: break;           }           rows_remaining=0;           for (y=0; y < (ssize_t) image->rows; y++)           {             PixelPacket               *magick_restrict q;              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);             if (q == (PixelPacket *) NULL)               break;             if (rows_remaining == 0)               {                 strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,                   TIFFStripSize(tiff));                 if (strip_size == -1)                   break;                 rows_remaining=rows_per_strip;                 if ((y+rows_per_strip) > (ssize_t) image->rows)                   rows_remaining=(rows_per_strip-(y+rows_per_strip-                     image->rows));                 p=strip_pixels;                 strip_id++;               }             (void) ImportQuantumPixels(image,(CacheView *) NULL,               quantum_info,quantum_type,p,exception);             p+=stride;             rows_remaining--;             if (SyncAuthenticPixels(image,exception) == MagickFalse)               break;             if (image->previous == (Image *) NULL)               {                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                   image->rows);                 if (status == MagickFalse)                   break;               }           }          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))             break;         }         strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);         break;       }       case ReadTileMethod:       {         unsigned char           *p;          size_t           extent;          uint32           columns,           rows;          unsigned char           *tile_pixels;          /*           Convert tiled TIFF image.         */         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))           ThrowTIFFException(CoderError,""ImageIsNotTiled"");         number_pixels=(MagickSizeType) columns*rows;         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)           ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");         extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),           TIFFTileSize(tiff));         tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,           sizeof(*tile_pixels));         if (tile_pixels == (unsigned char *) NULL)           ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");         (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));         for (i=0; i < (ssize_t) samples_per_pixel; i++)         {           switch (i)           {             case 0: break;             case 1: quantum_type=GreenQuantum; break;             case 2: quantum_type=BlueQuantum; break;             case 3:             {               quantum_type=AlphaQuantum;               if (image->colorspace == CMYKColorspace)                 quantum_type=BlackQuantum;               break;             }             case 4: quantum_type=AlphaQuantum; break;             default: break;           }           for (y=0; y < (ssize_t) image->rows; y+=rows)           {             ssize_t               x;              size_t               rows_remaining;              rows_remaining=image->rows-y;             if ((ssize_t) (y+rows) < (ssize_t) image->rows)               rows_remaining=rows;             for (x=0; x < (ssize_t) image->columns; x+=columns)             {               size_t                 columns_remaining,                 row;                columns_remaining=image->columns-x;               if ((ssize_t) (x+columns) < (ssize_t) image->columns)                 columns_remaining=columns;               tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,                 0,i);               if (tiff_status == -1)                 break;               p=tile_pixels;               for (row=0; row < rows_remaining; row++)               {                 PixelPacket                   *magick_restrict q;                  q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,                   exception);                 if (q == (PixelPacket *) NULL)                   break;                 (void) ImportQuantumPixels(image,(CacheView *) NULL,                   quantum_info,quantum_type,p,exception);                 p+=TIFFTileRowSize(tiff);                 if (SyncAuthenticPixels(image,exception) == MagickFalse)                   break;               }             }           }           if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,                 samples_per_pixel);               if (status == MagickFalse)                 break;             }         }         tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);         break;       }       case ReadGenericMethod:       default:       {         MemoryInfo           *generic_info = (MemoryInfo *) NULL;          uint32           *p;          uint32           *pixels;          /*           Convert generic TIFF image.         */         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)           ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");         number_pixels=(MagickSizeType) image->columns*image->rows;         generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));         if (generic_info == (MemoryInfo *) NULL)           ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");         pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);         tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)           image->rows,(uint32 *) pixels,0);         if (tiff_status == -1)           {             generic_info=RelinquishVirtualMemory(generic_info);             break;           }         p=pixels+(image->columns*image->rows)-1;         for (y=0; y < (ssize_t) image->rows; y++)         {           ssize_t             x;            PixelPacket             *magick_restrict q;            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);           if (q == (PixelPacket *) NULL)             break;           q+=image->columns-1;           for (x=0; x < (ssize_t) image->columns; x++)           {             SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));             SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));             SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));             if (image->matte == MagickFalse)               SetPixelOpacity(q,OpaqueOpacity);             else               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));             p--;             q--;           }           if (SyncAuthenticPixels(image,exception) == MagickFalse)             break;           if (image->previous == (Image *) NULL)             {               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,                 image->rows);               if (status == MagickFalse)                 break;             }         }         generic_info=RelinquishVirtualMemory(generic_info);         break;       }     }     pixel_info=RelinquishVirtualMemory(pixel_info);     SetQuantumImageType(image,quantum_type);   next_tiff_frame:     if (quantum_info != (QuantumInfo *) NULL)       quantum_info=DestroyQuantumInfo(quantum_info);     if (tiff_status == -1)       {         status=MagickFalse;         break;       }     if (photometric == PHOTOMETRIC_CIELAB)       DecodeLabImage(image,exception);     if ((photometric == PHOTOMETRIC_LOGL) ||         (photometric == PHOTOMETRIC_MINISBLACK) ||         (photometric == PHOTOMETRIC_MINISWHITE))       {         image->type=GrayscaleType;         if (bits_per_sample == 1)           image->type=BilevelType;       }     /*       Proceed to next image.     */     if (image_info->number_scenes != 0)       if (image->scene >= (image_info->scene+image_info->number_scenes-1))         break;     more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;     if (more_frames != MagickFalse)       {         /*           Allocate next image structure.         */         AcquireNextImage(image_info,image);         if (GetNextImageInList(image) == (Image *) NULL)           {             status=MagickFalse;             break;           }         image=SyncNextImageInList(image);         status=SetImageProgress(image,LoadImagesTag,image->scene-1,           image->scene);         if (status == MagickFalse)           break;       }   } while ((status != MagickFalse) && (more_frames != MagickFalse));   TIFFClose(tiff);   if ((image_info->number_scenes != 0) &&       (image_info->scene >= GetImageListLength(image)))     status=MagickFalse;   if (status == MagickFalse)     return(DestroyImageList(image));   TIFFReadPhotoshopLayers(image_info,image,exception);   return(GetFirstImageInList(image)); }"
"211868_CWE-269.c","CWE-269","struct nft_flow_rule *nft_flow_rule_create(struct net *net, 					   const struct nft_rule *rule) { 	struct nft_offload_ctx *ctx; 	struct nft_flow_rule *flow; 	int num_actions = 0, err; 	struct nft_expr *expr;  	expr = nft_expr_first(rule); 	while (nft_expr_more(rule, expr)) { 		if (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION) 			num_actions++;  		expr = nft_expr_next(expr); 	}  	if (num_actions == 0) 		return ERR_PTR(-EOPNOTSUPP);  	flow = nft_flow_rule_alloc(num_actions); 	if (!flow) 		return ERR_PTR(-ENOMEM);  	expr = nft_expr_first(rule);  	ctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL); 	if (!ctx) { 		err = -ENOMEM; 		goto err_out; 	} 	ctx->net = net; 	ctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;  	while (nft_expr_more(rule, expr)) { 		if (!expr->ops->offload) { 			err = -EOPNOTSUPP; 			goto err_out; 		} 		err = expr->ops->offload(ctx, flow, expr); 		if (err < 0) 			goto err_out;  		expr = nft_expr_next(expr); 	} 	nft_flow_rule_transfer_vlan(ctx, flow);  	flow->proto = ctx->dep.l3num; 	kfree(ctx);  	return flow; err_out: 	kfree(ctx); 	nft_flow_rule_destroy(flow);  	return ERR_PTR(err); }"
"211877_CWE-668.c","CWE-668","addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,            const XML_Char *uri, BINDING **bindingsPtr) {   static const XML_Char xmlNamespace[]       = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,          ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,          ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,          ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,          ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,          ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,          ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,          ASCII_e,      '\0'};   static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;   static const XML_Char xmlnsNamespace[]       = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,          ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,          ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,          ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,          ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\0'};   static const int xmlnsLen       = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;    XML_Bool mustBeXML = XML_FALSE;   XML_Bool isXML = XML_TRUE;   XML_Bool isXMLNS = XML_TRUE;    BINDING *b;   int len;    /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */   if (*uri == XML_T('\0') && prefix->name)     return XML_ERROR_UNDECLARING_PREFIX;    if (prefix->name && prefix->name[0] == XML_T(ASCII_x)       && prefix->name[1] == XML_T(ASCII_m)       && prefix->name[2] == XML_T(ASCII_l)) {     /* Not allowed to bind xmlns */     if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)         && prefix->name[5] == XML_T('\0'))       return XML_ERROR_RESERVED_PREFIX_XMLNS;      if (prefix->name[3] == XML_T('\0'))       mustBeXML = XML_TRUE;   }    for (len = 0; uri[len]; len++) {     if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))       isXML = XML_FALSE;      if (! mustBeXML && isXMLNS         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))       isXMLNS = XML_FALSE;   }   isXML = isXML && len == xmlLen;   isXMLNS = isXMLNS && len == xmlnsLen;    if (mustBeXML != isXML)     return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML                      : XML_ERROR_RESERVED_NAMESPACE_URI;    if (isXMLNS)     return XML_ERROR_RESERVED_NAMESPACE_URI;    if (parser->m_namespaceSeparator)     len++;   if (parser->m_freeBindingList) {     b = parser->m_freeBindingList;     if (len > b->uriAlloc) {       /* Detect and prevent integer overflow */       if (len > INT_MAX - EXPAND_SPARE) {         return XML_ERROR_NO_MEMORY;       }        /* Detect and prevent integer overflow.        * The preprocessor guard addresses the ""always false"" warning        * from -Wtype-limits on platforms where        * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */ #if UINT_MAX >= SIZE_MAX       if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {         return XML_ERROR_NO_MEMORY;       } #endif        XML_Char *temp = (XML_Char *)REALLOC(           parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));       if (temp == NULL)         return XML_ERROR_NO_MEMORY;       b->uri = temp;       b->uriAlloc = len + EXPAND_SPARE;     }     parser->m_freeBindingList = b->nextTagBinding;   } else {     b = (BINDING *)MALLOC(parser, sizeof(BINDING));     if (! b)       return XML_ERROR_NO_MEMORY;      /* Detect and prevent integer overflow */     if (len > INT_MAX - EXPAND_SPARE) {       return XML_ERROR_NO_MEMORY;     }     /* Detect and prevent integer overflow.      * The preprocessor guard addresses the ""always false"" warning      * from -Wtype-limits on platforms where      * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */ #if UINT_MAX >= SIZE_MAX     if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {       return XML_ERROR_NO_MEMORY;     } #endif      b->uri         = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));     if (! b->uri) {       FREE(parser, b);       return XML_ERROR_NO_MEMORY;     }     b->uriAlloc = len + EXPAND_SPARE;   }   b->uriLen = len;   memcpy(b->uri, uri, len * sizeof(XML_Char));   if (parser->m_namespaceSeparator)     b->uri[len - 1] = parser->m_namespaceSeparator;   b->prefix = prefix;   b->attId = attId;   b->prevPrefixBinding = prefix->binding;   /* NULL binding when default namespace undeclared */   if (*uri == XML_T('\0') && prefix == &parser->m_dtd->defaultPrefix)     prefix->binding = NULL;   else     prefix->binding = b;   b->nextTagBinding = *bindingsPtr;   *bindingsPtr = b;   /* if attId == NULL then we are not starting a namespace scope */   if (attId && parser->m_startNamespaceDeclHandler)     parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,                                         prefix->binding ? uri : 0);   return XML_ERROR_NONE; }"
"211915_CWE-125.c","CWE-125","jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr) { 	jp2_box_t *box; 	int found; 	jas_image_t *image; 	jp2_dec_t *dec; 	bool samedtype; 	int dtype; 	unsigned int i; 	jp2_cmap_t *cmapd; 	jp2_pclr_t *pclrd; 	jp2_cdef_t *cdefd; 	unsigned int channo; 	int newcmptno; 	int_fast32_t *lutents; #if 0 	jp2_cdefchan_t *cdefent; 	int cmptno; #endif 	jp2_cmapent_t *cmapent; 	jas_icchdr_t icchdr; 	jas_iccprof_t *iccprof;  	dec = 0; 	box = 0; 	image = 0;  	JAS_DBGLOG(100, (""jp2_decode(%p, \""%s\"")\n"", in, optstr));  	if (!(dec = jp2_dec_create())) { 		goto error; 	}  	/* Get the first box.  This should be a JP box. */ 	if (!(box = jp2_box_get(in))) { 		jas_eprintf(""error: cannot get box\n""); 		goto error; 	} 	if (box->type != JP2_BOX_JP) { 		jas_eprintf(""error: expecting signature box\n""); 		goto error; 	} 	if (box->data.jp.magic != JP2_JP_MAGIC) { 		jas_eprintf(""incorrect magic number\n""); 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Get the second box.  This should be a FTYP box. */ 	if (!(box = jp2_box_get(in))) { 		goto error; 	} 	if (box->type != JP2_BOX_FTYP) { 		jas_eprintf(""expecting file type box\n""); 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Get more boxes... */ 	found = 0; 	while ((box = jp2_box_get(in))) { 		if (jas_getdbglevel() >= 1) { 			jas_eprintf(""got box type %s\n"", box->info->name); 		} 		switch (box->type) { 		case JP2_BOX_JP2C: 			found = 1; 			break; 		case JP2_BOX_IHDR: 			if (!dec->ihdr) { 				dec->ihdr = box; 				box = 0; 			} 			break; 		case JP2_BOX_BPCC: 			if (!dec->bpcc) { 				dec->bpcc = box; 				box = 0; 			} 			break; 		case JP2_BOX_CDEF: 			if (!dec->cdef) { 				dec->cdef = box; 				box = 0; 			} 			break; 		case JP2_BOX_PCLR: 			if (!dec->pclr) { 				dec->pclr = box; 				box = 0; 			} 			break; 		case JP2_BOX_CMAP: 			if (!dec->cmap) { 				dec->cmap = box; 				box = 0; 			} 			break; 		case JP2_BOX_COLR: 			if (!dec->colr) { 				dec->colr = box; 				box = 0; 			} 			break; 		} 		if (box) { 			jp2_box_destroy(box); 			box = 0; 		} 		if (found) { 			break; 		} 	}  	if (!found) { 		jas_eprintf(""error: no code stream found\n""); 		goto error; 	}  	if (!(dec->image = jpc_decode(in, optstr))) { 		jas_eprintf(""error: cannot decode code stream\n""); 		goto error; 	}  	/* An IHDR box must be present. */ 	if (!dec->ihdr) { 		jas_eprintf(""error: missing IHDR box\n""); 		goto error; 	}  	/* Does the number of components indicated in the IHDR box match 	  the value specified in the code stream? */ 	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint, 	  jas_image_numcmpts(dec->image))) { 		jas_eprintf(""warning: number of components mismatch\n""); 	}  	/* At least one component must be present. */ 	if (!jas_image_numcmpts(dec->image)) { 		jas_eprintf(""error: no components\n""); 		goto error; 	}  	/* Determine if all components have the same data type. */ 	samedtype = true; 	dtype = jas_image_cmptdtype(dec->image, 0); 	for (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) { 		if (jas_image_cmptdtype(dec->image, i) != dtype) { 			samedtype = false; 			break; 		} 	}  	/* Is the component data type indicated in the IHDR box consistent 	  with the data in the code stream? */ 	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) || 	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) { 		jas_eprintf(""warning: component data type mismatch\n""); 	}  	/* Is the compression type supported? */ 	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) { 		jas_eprintf(""error: unsupported compression type\n""); 		goto error; 	}  	if (dec->bpcc) { 		/* Is the number of components indicated in the BPCC box 		  consistent with the code stream data? */ 		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts( 		  dec->image))) { 			jas_eprintf(""warning: number of components mismatch\n""); 		} 		/* Is the component data type information indicated in the BPCC 		  box consistent with the code stream data? */ 		if (!samedtype) { 			for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); 			  ++i) { 				if (jas_image_cmptdtype(dec->image, i) != 				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) { 					jas_eprintf(""warning: component data type mismatch\n""); 				} 			} 		} else { 			jas_eprintf(""warning: superfluous BPCC box\n""); 		} 	}  	/* A COLR box must be present. */ 	if (!dec->colr) { 		jas_eprintf(""error: no COLR box\n""); 		goto error; 	}  	switch (dec->colr->data.colr.method) { 	case JP2_COLR_ENUM: 		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr)); 		break; 	case JP2_COLR_ICC: 		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp, 		  dec->colr->data.colr.iccplen); 		if (!iccprof) { 			jas_eprintf(""error: failed to parse ICC profile\n""); 			goto error; 		} 		jas_iccprof_gethdr(iccprof, &icchdr); 		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc); 		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc)); 		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof); 		assert(dec->image->cmprof_); 		jas_iccprof_destroy(iccprof); 		break; 	}  	/* If a CMAP box is present, a PCLR box must also be present. */ 	if (dec->cmap && !dec->pclr) { 		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n""); 		jp2_box_destroy(dec->cmap); 		dec->cmap = 0; 	}  	/* If a CMAP box is not present, a PCLR box must not be present. */ 	if (!dec->cmap && dec->pclr) { 		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n""); 		jp2_box_destroy(dec->pclr); 		dec->pclr = 0; 	}  	/* Determine the number of channels (which is essentially the number 	  of components after any palette mappings have been applied). */ 	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans : 	  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));  	/* Perform a basic sanity check on the CMAP box if present. */ 	if (dec->cmap) { 		for (i = 0; i < dec->numchans; ++i) { 			/* Is the component number reasonable? */ 			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint, 			  jas_image_numcmpts(dec->image))) { 				jas_eprintf(""error: invalid component number in CMAP box\n""); 				goto error; 			} 			/* Is the LUT index reasonable? */ 			if (dec->cmap->data.cmap.ents[i].pcol >= 			  dec->pclr->data.pclr.numchans) { 				jas_eprintf(""error: invalid CMAP LUT index\n""); 				goto error; 			} 		} 	}  	/* Allocate space for the channel-number to component-number LUT. */ 	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans, 	  sizeof(uint_fast16_t)))) { 		jas_eprintf(""error: no memory\n""); 		goto error; 	}  	if (!dec->cmap) { 		for (i = 0; i < dec->numchans; ++i) { 			dec->chantocmptlut[i] = i; 		} 	} else { 		cmapd = &dec->cmap->data.cmap; 		pclrd = &dec->pclr->data.pclr; 		cdefd = &dec->cdef->data.cdef; 		for (channo = 0; channo < cmapd->numchans; ++channo) { 			cmapent = &cmapd->ents[channo]; 			if (cmapent->map == JP2_CMAP_DIRECT) { 				dec->chantocmptlut[channo] = channo; 			} else if (cmapent->map == JP2_CMAP_PALETTE) { 				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t)); 				for (i = 0; i < pclrd->numlutents; ++i) { 					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans]; 				} 				newcmptno = jas_image_numcmpts(dec->image); 				jas_image_depalettize(dec->image, cmapent->cmptno, 				  pclrd->numlutents, lutents, 				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno); 				dec->chantocmptlut[channo] = newcmptno; 				jas_free(lutents); #if 0 				if (dec->cdef) { 					cdefent = jp2_cdef_lookup(cdefd, channo); 					if (!cdefent) { 						abort(); 					} 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc)); 				} else { 				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1)); 				} #endif 			} 		} 	}  	/* Mark all components as being of unknown type. */  	for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) { 		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN); 	}  	/* Determine the type of each component. */ 	if (dec->cdef) { 		for (i = 0; i < dec->numchans; ++i) { 			/* Is the channel number reasonable? */ 			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) { 				jas_eprintf(""error: invalid channel number in CDEF box\n""); 				goto error; 			} 			jas_image_setcmpttype(dec->image, 			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo], 			  jp2_getct(jas_image_clrspc(dec->image), 			  dec->cdef->data.cdef.ents[i].type, 			  dec->cdef->data.cdef.ents[i].assoc)); 		} 	} else { 		for (i = 0; i < dec->numchans; ++i) { 			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i], 			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1)); 		} 	}  	/* Delete any components that are not of interest. */ 	for (i = jas_image_numcmpts(dec->image); i > 0; --i) { 		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) { 			jas_image_delcmpt(dec->image, i - 1); 		} 	}  	/* Ensure that some components survived. */ 	if (!jas_image_numcmpts(dec->image)) { 		jas_eprintf(""error: no components\n""); 		goto error; 	} #if 0 jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image)); #endif  	/* Prevent the image from being destroyed later. */ 	image = dec->image; 	dec->image = 0;  	jp2_dec_destroy(dec);  	return image;  error: 	if (box) { 		jp2_box_destroy(box); 	} 	if (dec) { 		jp2_dec_destroy(dec); 	} 	return 0; }"
"212083_CWE-703.c","CWE-703","static int ismt_access(struct i2c_adapter *adap, u16 addr, 		       unsigned short flags, char read_write, u8 command, 		       int size, union i2c_smbus_data *data) { 	int ret; 	unsigned long time_left; 	dma_addr_t dma_addr = 0; /* address of the data buffer */ 	u8 dma_size = 0; 	enum dma_data_direction dma_direction = 0; 	struct ismt_desc *desc; 	struct ismt_priv *priv = i2c_get_adapdata(adap); 	struct device *dev = &priv->pci_dev->dev; 	u8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);  	desc = &priv->hw[priv->head];  	/* Initialize the DMA buffer */ 	memset(priv->buffer, 0, sizeof(priv->buffer));  	/* Initialize the descriptor */ 	memset(desc, 0, sizeof(struct ismt_desc)); 	desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);  	/* Always clear the log entries */ 	memset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));  	/* Initialize common control bits */ 	if (likely(pci_dev_msi_enabled(priv->pci_dev))) 		desc->control = ISMT_DESC_INT | ISMT_DESC_FAIR; 	else 		desc->control = ISMT_DESC_FAIR;  	if ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK) 	    && (size != I2C_SMBUS_I2C_BLOCK_DATA)) 		desc->control |= ISMT_DESC_PEC;  	switch (size) { 	case I2C_SMBUS_QUICK: 		dev_dbg(dev, ""I2C_SMBUS_QUICK\n""); 		break;  	case I2C_SMBUS_BYTE: 		if (read_write == I2C_SMBUS_WRITE) { 			/* 			 * Send Byte 			 * The command field contains the write data 			 */ 			dev_dbg(dev, ""I2C_SMBUS_BYTE:  WRITE\n""); 			desc->control |= ISMT_DESC_CWRL; 			desc->wr_len_cmd = command; 		} else { 			/* Receive Byte */ 			dev_dbg(dev, ""I2C_SMBUS_BYTE:  READ\n""); 			dma_size = 1; 			dma_direction = DMA_FROM_DEVICE; 			desc->rd_len = 1; 		} 		break;  	case I2C_SMBUS_BYTE_DATA: 		if (read_write == I2C_SMBUS_WRITE) { 			/* 			 * Write Byte 			 * Command plus 1 data byte 			 */ 			dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  WRITE\n""); 			desc->wr_len_cmd = 2; 			dma_size = 2; 			dma_direction = DMA_TO_DEVICE; 			dma_buffer[0] = command; 			dma_buffer[1] = data->byte; 		} else { 			/* Read Byte */ 			dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  READ\n""); 			desc->control |= ISMT_DESC_CWRL; 			desc->wr_len_cmd = command; 			desc->rd_len = 1; 			dma_size = 1; 			dma_direction = DMA_FROM_DEVICE; 		} 		break;  	case I2C_SMBUS_WORD_DATA: 		if (read_write == I2C_SMBUS_WRITE) { 			/* Write Word */ 			dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  WRITE\n""); 			desc->wr_len_cmd = 3; 			dma_size = 3; 			dma_direction = DMA_TO_DEVICE; 			dma_buffer[0] = command; 			dma_buffer[1] = data->word & 0xff; 			dma_buffer[2] = data->word >> 8; 		} else { 			/* Read Word */ 			dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  READ\n""); 			desc->wr_len_cmd = command; 			desc->control |= ISMT_DESC_CWRL; 			desc->rd_len = 2; 			dma_size = 2; 			dma_direction = DMA_FROM_DEVICE; 		} 		break;  	case I2C_SMBUS_PROC_CALL: 		dev_dbg(dev, ""I2C_SMBUS_PROC_CALL\n""); 		desc->wr_len_cmd = 3; 		desc->rd_len = 2; 		dma_size = 3; 		dma_direction = DMA_BIDIRECTIONAL; 		dma_buffer[0] = command; 		dma_buffer[1] = data->word & 0xff; 		dma_buffer[2] = data->word >> 8; 		break;  	case I2C_SMBUS_BLOCK_DATA: 		if (read_write == I2C_SMBUS_WRITE) { 			/* Block Write */ 			dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n""); 			dma_size = data->block[0] + 1; 			dma_direction = DMA_TO_DEVICE; 			desc->wr_len_cmd = dma_size; 			desc->control |= ISMT_DESC_BLK; 			dma_buffer[0] = command; 			memcpy(&dma_buffer[1], &data->block[1], dma_size - 1); 		} else { 			/* Block Read */ 			dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  READ\n""); 			dma_size = I2C_SMBUS_BLOCK_MAX; 			dma_direction = DMA_FROM_DEVICE; 			desc->rd_len = dma_size; 			desc->wr_len_cmd = command; 			desc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL); 		} 		break;  	case I2C_SMBUS_BLOCK_PROC_CALL: 		dev_dbg(dev, ""I2C_SMBUS_BLOCK_PROC_CALL\n""); 		dma_size = I2C_SMBUS_BLOCK_MAX; 		desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1); 		desc->wr_len_cmd = data->block[0] + 1; 		desc->rd_len = dma_size; 		desc->control |= ISMT_DESC_BLK; 		dma_direction = DMA_BIDIRECTIONAL; 		dma_buffer[0] = command; 		memcpy(&dma_buffer[1], &data->block[1], data->block[0]); 		break;  	case I2C_SMBUS_I2C_BLOCK_DATA: 		/* Make sure the length is valid */ 		if (data->block[0] < 1) 			data->block[0] = 1;  		if (data->block[0] > I2C_SMBUS_BLOCK_MAX) 			data->block[0] = I2C_SMBUS_BLOCK_MAX;  		if (read_write == I2C_SMBUS_WRITE) { 			/* i2c Block Write */ 			dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n""); 			dma_size = data->block[0] + 1; 			dma_direction = DMA_TO_DEVICE; 			desc->wr_len_cmd = dma_size; 			desc->control |= ISMT_DESC_I2C; 			dma_buffer[0] = command; 			memcpy(&dma_buffer[1], &data->block[1], dma_size - 1); 		} else { 			/* i2c Block Read */ 			dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n""); 			dma_size = data->block[0]; 			dma_direction = DMA_FROM_DEVICE; 			desc->rd_len = dma_size; 			desc->wr_len_cmd = command; 			desc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL); 			/* 			 * Per the ""Table 15-15. I2C Commands"", 			 * in the External Design Specification (EDS), 			 * (Document Number: 508084, Revision: 2.0), 			 * the _rw bit must be 0 			 */ 			desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0); 		} 		break;  	default: 		dev_err(dev, ""Unsupported transaction %d\n"", 			size); 		return -EOPNOTSUPP; 	}  	/* map the data buffer */ 	if (dma_size != 0) { 		dev_dbg(dev, "" dev=%p\n"", dev); 		dev_dbg(dev, "" data=%p\n"", data); 		dev_dbg(dev, "" dma_buffer=%p\n"", dma_buffer); 		dev_dbg(dev, "" dma_size=%d\n"", dma_size); 		dev_dbg(dev, "" dma_direction=%d\n"", dma_direction);  		dma_addr = dma_map_single(dev, 				      dma_buffer, 				      dma_size, 				      dma_direction);  		if (dma_mapping_error(dev, dma_addr)) { 			dev_err(dev, ""Error in mapping dma buffer %p\n"", 				dma_buffer); 			return -EIO; 		}  		dev_dbg(dev, "" dma_addr = %pad\n"", &dma_addr);  		desc->dptr_low = lower_32_bits(dma_addr); 		desc->dptr_high = upper_32_bits(dma_addr); 	}  	reinit_completion(&priv->cmp);  	/* Add the descriptor */ 	ismt_submit_desc(priv);  	/* Now we wait for interrupt completion, 1s */ 	time_left = wait_for_completion_timeout(&priv->cmp, HZ*1);  	/* unmap the data buffer */ 	if (dma_size != 0) 		dma_unmap_single(dev, dma_addr, dma_size, dma_direction);  	if (unlikely(!time_left)) { 		dev_err(dev, ""completion wait timed out\n""); 		ret = -ETIMEDOUT; 		goto out; 	}  	/* do any post processing of the descriptor here */ 	ret = ismt_process_desc(desc, data, priv, size, read_write);  out: 	/* Update the ring pointer */ 	priv->head++; 	priv->head %= ISMT_DESC_ENTRIES;  	return ret; }"
"212095_CWE-703.c","CWE-703","MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {     const char *label = orth_entry->label;     uint32_t *infl_groups = NULL;     size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);          if (infl_count == 0 || !infl_groups) {         return MOBI_SUCCESS;     }         const char *start_tag = ""<idx:infl>"";     const char *end_tag = ""</idx:infl>"";     const char *iform_tag = ""<idx:iform%s value=\""%s\""/>"";     char name_attr[INDX_INFLBUF_SIZEMAX + 1];     char infl_tag[INDX_INFLBUF_SIZEMAX + 1];     strcpy(outstring, start_tag);     size_t initlen = strlen(start_tag) + strlen(end_tag);     size_t outlen = initlen;     size_t label_length = strlen(label);     if (label_length > INDX_INFLBUF_SIZEMAX) {         debug_print(""Entry label too long (%s)\n"", label);         return MOBI_DATA_CORRUPT;     }     if (infl->cncx_record == NULL) {         debug_print(""%s\n"", ""Missing cncx record"");         return MOBI_DATA_CORRUPT;     }     for (size_t i = 0; i < infl_count; i++) {         size_t offset = infl_groups[i];         if (offset >= infl->entries_count) {             debug_print(""%s\n"", ""Invalid entry offset"");             return MOBI_DATA_CORRUPT;         }         uint32_t *groups;         size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);         uint32_t *parts;         size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);         if (group_cnt != part_cnt) {             return MOBI_DATA_CORRUPT;         }         for (size_t j = 0; j < part_cnt; j++) {             name_attr[0] = '\0';             char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);             if (group_name == NULL) {                 debug_print(""%s\n"", ""Memory allocation failed"");                 return MOBI_MALLOC_FAILED;             }             if (strlen(group_name)) {                 snprintf(name_attr, INDX_INFLBUF_SIZEMAX, "" name=\""%s\"""", group_name);             }             free(group_name);                          unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];             memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);             unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;             memcpy(decoded, label, label_length);             int decoded_length = (int) label_length;             MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);             if (ret != MOBI_SUCCESS) {                 return ret;             }             if (decoded_length == 0) {                 continue;             }             int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);             if (n > INDX_INFLBUF_SIZEMAX) {                 debug_print(""Skipping truncated tag: %s\n"", infl_tag);                 continue;             }             outlen += strlen(infl_tag);             if (outlen > INDX_INFLTAG_SIZEMAX) {                 debug_print(""Inflections text in %s too long (%zu)\n"", label, outlen);                 return MOBI_ERROR;             }             strcat(outstring, infl_tag);         }     }     if (outlen == initlen) {         outstring[0] = '\0';     } else {         strcat(outstring, end_tag);     }     return MOBI_SUCCESS; }"
"212144_CWE-119.c","CWE-119","MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {     MOBI_RET ret;     const size_t offset = mobi_get_kf8offset(m);     if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {         debug_print(""%s"", ""HUFF/CDIC records metadata not found in MOBI header\n"");         return MOBI_DATA_CORRUPT;     }     const size_t huff_rec_index = *m->mh->huff_rec_index + offset;     const size_t huff_rec_count = *m->mh->huff_rec_count;     if (huff_rec_count > HUFF_RECORD_MAXCNT) {         debug_print(""Too many HUFF record (%zu)\n"", huff_rec_count);         return MOBI_DATA_CORRUPT;     }     const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);     if (curr == NULL || huff_rec_count < 2) {         debug_print(""%s"", ""HUFF/CDIC record not found\n"");         return MOBI_DATA_CORRUPT;     }     if (curr->size < HUFF_RECORD_MINSIZE) {         debug_print(""HUFF record too short (%zu b)\n"", curr->size);         return MOBI_DATA_CORRUPT;     }     ret = mobi_parse_huff(huffcdic, curr);     if (ret != MOBI_SUCCESS) {         debug_print(""%s"", ""HUFF parsing failed\n"");         return ret;     }     curr = curr->next;     /* allocate memory for symbols data in each CDIC record */     huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));     if (huffcdic->symbols == NULL) {         debug_print(""%s\n"", ""Memory allocation failed"");         return MOBI_MALLOC_FAILED;     }     /* get following CDIC records */     size_t i = 0;     while (i < huff_rec_count - 1) {         if (curr == NULL) {             debug_print(""%s\n"", ""CDIC record not found"");             return MOBI_DATA_CORRUPT;         }         ret = mobi_parse_cdic(huffcdic, curr, i++);         if (ret != MOBI_SUCCESS) {             debug_print(""%s"", ""CDIC parsing failed\n"");             return ret;         }         curr = curr->next;     }     return MOBI_SUCCESS; }"
"212152_CWE-787.c","CWE-787","disable_priv_mode () {   int e;    if (setuid (current_user.uid) < 0)     {       e = errno;       sys_error (_(""cannot set uid to %d: effective uid %d""), current_user.uid, current_user.euid); #if defined (EXIT_ON_SETUID_FAILURE)       if (e == EAGAIN) 	exit (e); #endif     }   if (setgid (current_user.gid) < 0)     sys_error (_(""cannot set gid to %d: effective gid %d""), current_user.gid, current_user.egid);    current_user.euid = current_user.uid;   current_user.egid = current_user.gid; }"
"212165_CWE-476.c","CWE-476","static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint) { 	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic); 	struct kvm_lapic_irq irq; 	int ret, vector;  	if (sint >= ARRAY_SIZE(synic->sint)) 		return -EINVAL;  	vector = synic_get_sint_vector(synic_read_sint(synic, sint)); 	if (vector < 0) 		return -ENOENT;  	memset(&irq, 0, sizeof(irq)); 	irq.shorthand = APIC_DEST_SELF; 	irq.dest_mode = APIC_DEST_PHYSICAL; 	irq.delivery_mode = APIC_DM_FIXED; 	irq.vector = vector; 	irq.level = 1;  	ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL); 	trace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret); 	return ret; }"
"212339_CWE-119.c","CWE-119","static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream) {     auth_client *auth_user = stream;     size_t bytes = size * nmemb;     client_t *client = auth_user->client;      if (client)     {         auth_t *auth = client->auth;         auth_url *url = auth->state;         if (strncasecmp (ptr, url->auth_header, url->auth_header_len) == 0)             client->authenticated = 1;         if (strncasecmp (ptr, url->timelimit_header, url->timelimit_header_len) == 0)         {             unsigned int limit = 0;             sscanf ((char *)ptr+url->timelimit_header_len, ""%u\r\n"", &limit);             client->con->discon_time = time(NULL) + limit;         }         if (strncasecmp (ptr, ""icecast-auth-message: "", 22) == 0)         {             char *eol;             snprintf (url->errormsg, sizeof (url->errormsg), ""%s"", (char*)ptr+22);             eol = strchr (url->errormsg, '\r');             if (eol == NULL)                 eol = strchr (url->errormsg, '\n');             if (eol)                 *eol = '\0';         }     }      return bytes; }"
"212347_CWE-787.c","CWE-787","append_command(char_u *cmd) {     char_u *s = cmd;     char_u *d;      STRCAT(IObuff, "": "");     d = IObuff + STRLEN(IObuff);     while (*s != NUL && d - IObuff + 5 < IOSIZE)     { 	if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0) 	{ 	    s += enc_utf8 ? 2 : 1; 	    STRCPY(d, ""<a0>""); 	    d += 4; 	} 	else if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE) 	    break; 	else 	    MB_COPY_CHAR(s, d);     }     *d = NUL; }"
"212403_CWE-787.c","CWE-787","find_start_brace(void)	    // XXX {     pos_T	cursor_save;     pos_T	*trypos;     pos_T	*pos;     static pos_T	pos_copy;      cursor_save = curwin->w_cursor;     while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)     { 	pos_copy = *trypos;	// copy pos_T, next findmatch will change it 	trypos = &pos_copy; 	curwin->w_cursor = *trypos; 	pos = NULL; 	// ignore the { if it's in a // or / *  * / comment 	if ((colnr_T)cin_skip2pos(trypos) == trypos->col 		       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX 	    break; 	if (pos != NULL) 	    curwin->w_cursor.lnum = pos->lnum;     }     curwin->w_cursor = cursor_save;     return trypos; }"
"212407_CWE-703.c","CWE-703","http_isfiltered(const struct http *fm, unsigned u, unsigned how) { 	const char *e; 	const struct http_hdrflg *f;  	if (fm->hdf[u] & HDF_FILTER) 		return (1); 	e = strchr(fm->hd[u].b, ':'); 	if (e == NULL) 		return (0); 	f = http_hdr_flags(fm->hd[u].b, e); 	return (f != NULL && f->flag & how); }"
"212414_CWE-416.c","CWE-416","static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n, 			  struct netlink_ext_ack *extack) { 	struct net *net = sock_net(skb->sk); 	struct nlattr *tca[TCA_MAX + 1]; 	char name[IFNAMSIZ]; 	struct tcmsg *t; 	u32 protocol; 	u32 prio; 	bool prio_allocate; 	u32 parent; 	u32 chain_index; 	struct Qdisc *q = NULL; 	struct tcf_chain_info chain_info; 	struct tcf_chain *chain = NULL; 	struct tcf_block *block; 	struct tcf_proto *tp; 	unsigned long cl; 	void *fh; 	int err; 	int tp_created; 	bool rtnl_held = false; 	u32 flags;  	if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) 		return -EPERM;  replay: 	tp_created = 0;  	err = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX, 				     rtm_tca_policy, extack); 	if (err < 0) 		return err;  	t = nlmsg_data(n); 	protocol = TC_H_MIN(t->tcm_info); 	prio = TC_H_MAJ(t->tcm_info); 	prio_allocate = false; 	parent = t->tcm_parent; 	tp = NULL; 	cl = 0; 	block = NULL; 	flags = 0;  	if (prio == 0) { 		/* If no priority is provided by the user, 		 * we allocate one. 		 */ 		if (n->nlmsg_flags & NLM_F_CREATE) { 			prio = TC_H_MAKE(0x80000000U, 0U); 			prio_allocate = true; 		} else { 			NL_SET_ERR_MSG(extack, ""Invalid filter command with priority of zero""); 			return -ENOENT; 		} 	}  	/* Find head of filter chain. */  	err = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack); 	if (err) 		return err;  	if (tcf_proto_check_kind(tca[TCA_KIND], name)) { 		NL_SET_ERR_MSG(extack, ""Specified TC filter name too long""); 		err = -EINVAL; 		goto errout; 	}  	/* Take rtnl mutex if rtnl_held was set to true on previous iteration, 	 * block is shared (no qdisc found), qdisc is not unlocked, classifier 	 * type is not specified, classifier is not unlocked. 	 */ 	if (rtnl_held || 	    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) || 	    !tcf_proto_is_unlocked(name)) { 		rtnl_held = true; 		rtnl_lock(); 	}  	err = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack); 	if (err) 		goto errout;  	block = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index, 				 extack); 	if (IS_ERR(block)) { 		err = PTR_ERR(block); 		goto errout; 	} 	block->classid = parent;  	chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0; 	if (chain_index > TC_ACT_EXT_VAL_MASK) { 		NL_SET_ERR_MSG(extack, ""Specified chain index exceeds upper limit""); 		err = -EINVAL; 		goto errout; 	} 	chain = tcf_chain_get(block, chain_index, true); 	if (!chain) { 		NL_SET_ERR_MSG(extack, ""Cannot create specified filter chain""); 		err = -ENOMEM; 		goto errout; 	}  	mutex_lock(&chain->filter_chain_lock); 	tp = tcf_chain_tp_find(chain, &chain_info, protocol, 			       prio, prio_allocate); 	if (IS_ERR(tp)) { 		NL_SET_ERR_MSG(extack, ""Filter with specified priority/protocol not found""); 		err = PTR_ERR(tp); 		goto errout_locked; 	}  	if (tp == NULL) { 		struct tcf_proto *tp_new = NULL;  		if (chain->flushing) { 			err = -EAGAIN; 			goto errout_locked; 		}  		/* Proto-tcf does not exist, create new one */  		if (tca[TCA_KIND] == NULL || !protocol) { 			NL_SET_ERR_MSG(extack, ""Filter kind and protocol must be specified""); 			err = -EINVAL; 			goto errout_locked; 		}  		if (!(n->nlmsg_flags & NLM_F_CREATE)) { 			NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); 			err = -ENOENT; 			goto errout_locked; 		}  		if (prio_allocate) 			prio = tcf_auto_prio(tcf_chain_tp_prev(chain, 							       &chain_info));  		mutex_unlock(&chain->filter_chain_lock); 		tp_new = tcf_proto_create(name, protocol, prio, chain, 					  rtnl_held, extack); 		if (IS_ERR(tp_new)) { 			err = PTR_ERR(tp_new); 			goto errout_tp; 		}  		tp_created = 1; 		tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio, 						rtnl_held); 		if (IS_ERR(tp)) { 			err = PTR_ERR(tp); 			goto errout_tp; 		} 	} else { 		mutex_unlock(&chain->filter_chain_lock); 	}  	if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) { 		NL_SET_ERR_MSG(extack, ""Specified filter kind does not match existing one""); 		err = -EINVAL; 		goto errout; 	}  	fh = tp->ops->get(tp, t->tcm_handle);  	if (!fh) { 		if (!(n->nlmsg_flags & NLM_F_CREATE)) { 			NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); 			err = -ENOENT; 			goto errout; 		} 	} else if (n->nlmsg_flags & NLM_F_EXCL) { 		tfilter_put(tp, fh); 		NL_SET_ERR_MSG(extack, ""Filter already exists""); 		err = -EEXIST; 		goto errout; 	}  	if (chain->tmplt_ops && chain->tmplt_ops != tp->ops) { 		NL_SET_ERR_MSG(extack, ""Chain template is set to a different filter kind""); 		err = -EINVAL; 		goto errout; 	}  	if (!(n->nlmsg_flags & NLM_F_CREATE)) 		flags |= TCA_ACT_FLAGS_REPLACE; 	if (!rtnl_held) 		flags |= TCA_ACT_FLAGS_NO_RTNL; 	err = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh, 			      flags, extack); 	if (err == 0) { 		tfilter_notify(net, skb, n, tp, block, q, parent, fh, 			       RTM_NEWTFILTER, false, rtnl_held); 		tfilter_put(tp, fh); 		/* q pointer is NULL for shared blocks */ 		if (q) 			q->flags &= ~TCQ_F_CAN_BYPASS; 	}  errout: 	if (err && tp_created) 		tcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL); errout_tp: 	if (chain) { 		if (tp && !IS_ERR(tp)) 			tcf_proto_put(tp, rtnl_held, NULL); 		if (!tp_created) 			tcf_chain_put(chain); 	} 	tcf_block_release(q, block, rtnl_held);  	if (rtnl_held) 		rtnl_unlock();  	if (err == -EAGAIN) { 		/* Take rtnl lock in case EAGAIN is caused by concurrent flush 		 * of target chain. 		 */ 		rtnl_held = true; 		/* Replay the request. */ 		goto replay; 	} 	return err;  errout_locked: 	mutex_unlock(&chain->filter_chain_lock); 	goto errout; }"
"212433_CWE-416.c","CWE-416","do_tag(     char_u	*tag,		// tag (pattern) to jump to     int		type,     int		count,     int		forceit,	// :ta with !     int		verbose)	// print ""tag not found"" message {     taggy_T	*tagstack = curwin->w_tagstack;     int		tagstackidx = curwin->w_tagstackidx;     int		tagstacklen = curwin->w_tagstacklen;     int		cur_match = 0;     int		cur_fnum = curbuf->b_fnum;     int		oldtagstackidx = tagstackidx;     int		prevtagstackidx = tagstackidx;     int		prev_num_matches;     int		new_tag = FALSE;     int		i;     int		ic;     int		no_regexp = FALSE;     int		error_cur_match = 0;     int		save_pos = FALSE;     fmark_T	saved_fmark; #ifdef FEAT_CSCOPE     int		jumped_to_tag = FALSE; #endif     int		new_num_matches;     char_u	**new_matches;     int		use_tagstack;     int		skip_msg = FALSE;     char_u	*buf_ffname = curbuf->b_ffname;	    // name to use for 						    // priority computation     int		use_tfu = 1;     char_u	*tofree = NULL;      // remember the matches for the last used tag     static int		num_matches = 0;     static int		max_num_matches = 0;  // limit used for match search     static char_u	**matches = NULL;     static int		flags;  #ifdef FEAT_EVAL     if (tfu_in_use)     { 	emsg(_(e_cannot_modify_tag_stack_within_tagfunc)); 	return FALSE;     } #endif  #ifdef EXITFREE     if (type == DT_FREE)     { 	// remove the list of matches 	FreeWild(num_matches, matches); # ifdef FEAT_CSCOPE 	cs_free_tags(); # endif 	num_matches = 0; 	return FALSE;     } #endif      if (type == DT_HELP)     { 	type = DT_TAG; 	no_regexp = TRUE; 	use_tfu = 0;     }      prev_num_matches = num_matches;     free_string_option(nofile_fname);     nofile_fname = NULL;      CLEAR_POS(&saved_fmark.mark);	// shutup gcc 4.0     saved_fmark.fnum = 0;      /*      * Don't add a tag to the tagstack if 'tagstack' has been reset.      */     if ((!p_tgst && *tag != NUL))     { 	use_tagstack = FALSE; 	new_tag = TRUE; #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	{ 	    tagstack_clear_entry(&ptag_entry); 	    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL) 		goto end_do_tag; 	} #endif     }     else     { #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	    use_tagstack = FALSE; 	else #endif 	    use_tagstack = TRUE;  	// new pattern, add to the tag stack 	if (*tag != NUL 		&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP #ifdef FEAT_QUICKFIX 		    || type == DT_LTAG #endif #ifdef FEAT_CSCOPE 		    || type == DT_CSCOPE #endif 		    )) 	{ #if defined(FEAT_QUICKFIX) 	    if (g_do_tagpreview != 0) 	    { 		if (ptag_entry.tagname != NULL 			&& STRCMP(ptag_entry.tagname, tag) == 0) 		{ 		    // Jumping to same tag: keep the current match, so that 		    // the CursorHold autocommand example works. 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else 		{ 		    tagstack_clear_entry(&ptag_entry); 		    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL) 			goto end_do_tag; 		} 	    } 	    else #endif 	    { 		/* 		 * If the last used entry is not at the top, delete all tag 		 * stack entries above it. 		 */ 		while (tagstackidx < tagstacklen) 		    tagstack_clear_entry(&tagstack[--tagstacklen]);  		// if the tagstack is full: remove oldest entry 		if (++tagstacklen > TAGSTACKSIZE) 		{ 		    tagstacklen = TAGSTACKSIZE; 		    tagstack_clear_entry(&tagstack[0]); 		    for (i = 1; i < tagstacklen; ++i) 			tagstack[i - 1] = tagstack[i]; 		    --tagstackidx; 		}  		/* 		 * put the tag name in the tag stack 		 */ 		if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL) 		{ 		    curwin->w_tagstacklen = tagstacklen - 1; 		    goto end_do_tag; 		} 		curwin->w_tagstacklen = tagstacklen;  		save_pos = TRUE;	// save the cursor position below 	    }  	    new_tag = TRUE; 	} 	else 	{ 	    if ( #if defined(FEAT_QUICKFIX) 		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL : #endif 		    tagstacklen == 0) 	    { 		// empty stack 		emsg(_(e_tag_stack_empty)); 		goto end_do_tag; 	    }  	    if (type == DT_POP)		// go to older position 	    { #ifdef FEAT_FOLDING 		int	old_KeyTyped = KeyTyped; #endif 		if ((tagstackidx -= count) < 0) 		{ 		    emsg(_(e_at_bottom_of_tag_stack)); 		    if (tagstackidx + count == 0) 		    { 			// We did [num]^T from the bottom of the stack 			tagstackidx = 0; 			goto end_do_tag; 		    } 		    // We weren't at the bottom of the stack, so jump all the 		    // way to the bottom now. 		    tagstackidx = 0; 		} 		else if (tagstackidx >= tagstacklen)    // count == 0? 		{ 		    emsg(_(e_at_top_of_tag_stack)); 		    goto end_do_tag; 		}  		// Make a copy of the fmark, autocommands may invalidate the 		// tagstack before it's used. 		saved_fmark = tagstack[tagstackidx].fmark; 		if (saved_fmark.fnum != curbuf->b_fnum) 		{ 		    /* 		     * Jump to other file. If this fails (e.g. because the 		     * file was changed) keep original position in tag stack. 		     */ 		    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum, 					       GETF_SETMARK, forceit) == FAIL) 		    { 			tagstackidx = oldtagstackidx;  // back to old posn 			goto end_do_tag; 		    } 		    // An BufReadPost autocommand may jump to the '"" mark, but 		    // we don't what that here. 		    curwin->w_cursor.lnum = saved_fmark.mark.lnum; 		} 		else 		{ 		    setpcmark(); 		    curwin->w_cursor.lnum = saved_fmark.mark.lnum; 		} 		curwin->w_cursor.col = saved_fmark.mark.col; 		curwin->w_set_curswant = TRUE; 		check_cursor(); #ifdef FEAT_FOLDING 		if ((fdo_flags & FDO_TAG) && old_KeyTyped) 		    foldOpenCursor(); #endif  		// remove the old list of matches 		FreeWild(num_matches, matches); #ifdef FEAT_CSCOPE 		cs_free_tags(); #endif 		num_matches = 0; 		tag_freematch(); 		goto end_do_tag; 	    }  	    if (type == DT_TAG #if defined(FEAT_QUICKFIX) 		    || type == DT_LTAG #endif 	       ) 	    { #if defined(FEAT_QUICKFIX) 		if (g_do_tagpreview != 0) 		{ 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else #endif 		{ 		    // "":tag"" (no argument): go to newer pattern 		    save_pos = TRUE;	// save the cursor position below 		    if ((tagstackidx += count - 1) >= tagstacklen) 		    { 			/* 			 * Beyond the last one, just give an error message and 			 * go to the last one.  Don't store the cursor 			 * position. 			 */ 			tagstackidx = tagstacklen - 1; 			emsg(_(e_at_top_of_tag_stack)); 			save_pos = FALSE; 		    } 		    else if (tagstackidx < 0)	// must have been count == 0 		    { 			emsg(_(e_at_bottom_of_tag_stack)); 			tagstackidx = 0; 			goto end_do_tag; 		    } 		    cur_match = tagstack[tagstackidx].cur_match; 		    cur_fnum = tagstack[tagstackidx].cur_fnum; 		} 		new_tag = TRUE; 	    } 	    else				// go to other matching tag 	    { 		// Save index for when selection is cancelled. 		prevtagstackidx = tagstackidx;  #if defined(FEAT_QUICKFIX) 		if (g_do_tagpreview != 0) 		{ 		    cur_match = ptag_entry.cur_match; 		    cur_fnum = ptag_entry.cur_fnum; 		} 		else #endif 		{ 		    if (--tagstackidx < 0) 			tagstackidx = 0; 		    cur_match = tagstack[tagstackidx].cur_match; 		    cur_fnum = tagstack[tagstackidx].cur_fnum; 		} 		switch (type) 		{ 		    case DT_FIRST: cur_match = count - 1; break; 		    case DT_SELECT: 		    case DT_JUMP: #ifdef FEAT_CSCOPE 		    case DT_CSCOPE: #endif 		    case DT_LAST:  cur_match = MAXCOL - 1; break; 		    case DT_NEXT:  cur_match += count; break; 		    case DT_PREV:  cur_match -= count; break; 		} 		if (cur_match >= MAXCOL) 		    cur_match = MAXCOL - 1; 		else if (cur_match < 0) 		{ 		    emsg(_(e_cannot_go_before_first_matching_tag)); 		    skip_msg = TRUE; 		    cur_match = 0; 		    cur_fnum = curbuf->b_fnum; 		} 	    } 	}  #if defined(FEAT_QUICKFIX) 	if (g_do_tagpreview != 0) 	{ 	    if (type != DT_SELECT && type != DT_JUMP) 	    { 		ptag_entry.cur_match = cur_match; 		ptag_entry.cur_fnum = cur_fnum; 	    } 	} 	else #endif 	{ 	    /* 	     * For "":tag [arg]"" or "":tselect"" remember position before the jump. 	     */ 	    saved_fmark = tagstack[tagstackidx].fmark; 	    if (save_pos) 	    { 		tagstack[tagstackidx].fmark.mark = curwin->w_cursor; 		tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum; 	    }  	    // Curwin will change in the call to jumpto_tag() if "":stag"" was 	    // used or an autocommand jumps to another window; store value of 	    // tagstackidx now. 	    curwin->w_tagstackidx = tagstackidx; 	    if (type != DT_SELECT && type != DT_JUMP) 	    { 		curwin->w_tagstack[tagstackidx].cur_match = cur_match; 		curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum; 	    } 	}     }      // When not using the current buffer get the name of buffer ""cur_fnum"".     // Makes sure that the tag order doesn't change when using a remembered     // position for ""cur_match"".     if (cur_fnum != curbuf->b_fnum)     { 	buf_T *buf = buflist_findnr(cur_fnum);  	if (buf != NULL) 	    buf_ffname = buf->b_ffname;     }      /*      * Repeat searching for tags, when a file has not been found.      */     for (;;)     { 	int	other_name; 	char_u	*name;  	/* 	 * When desired match not found yet, try to find it (and others). 	 */ 	if (use_tagstack) 	{ 	    // make a copy, the tagstack may change in 'tagfunc' 	    name = vim_strsave(tagstack[tagstackidx].tagname); 	    vim_free(tofree); 	    tofree = name; 	} #if defined(FEAT_QUICKFIX) 	else if (g_do_tagpreview != 0) 	    name = ptag_entry.tagname; #endif 	else 	    name = tag; 	other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0); 	if (new_tag 		|| (cur_match >= num_matches && max_num_matches != MAXCOL) 		|| other_name) 	{ 	    if (other_name) 	    { 		vim_free(tagmatchname); 		tagmatchname = vim_strsave(name); 	    }  	    if (type == DT_SELECT || type == DT_JUMP #if defined(FEAT_QUICKFIX) 		|| type == DT_LTAG #endif 		) 		cur_match = MAXCOL - 1; 	    if (type == DT_TAG) 		max_num_matches = MAXCOL; 	    else 		max_num_matches = cur_match + 1;  	    // when the argument starts with '/', use it as a regexp 	    if (!no_regexp && *name == '/') 	    { 		flags = TAG_REGEXP; 		++name; 	    } 	    else 		flags = TAG_NOIC;  #ifdef FEAT_CSCOPE 	    if (type == DT_CSCOPE) 		flags = TAG_CSCOPE; #endif 	    if (verbose) 		flags |= TAG_VERBOSE;  	    if (!use_tfu) 		flags |= TAG_NO_TAGFUNC;  	    if (find_tags(name, &new_num_matches, &new_matches, flags, 					    max_num_matches, buf_ffname) == OK 		    && new_num_matches < max_num_matches) 		max_num_matches = MAXCOL; // If less than max_num_matches 					  // found: all matches found.  	    // If there already were some matches for the same name, move them 	    // to the start.  Avoids that the order changes when using 	    // "":tnext"" and jumping to another file. 	    if (!new_tag && !other_name) 	    { 		int	    j, k; 		int	    idx = 0; 		tagptrs_T   tagp, tagp2;  		// Find the position of each old match in the new list.  Need 		// to use parse_match() to find the tag line. 		for (j = 0; j < num_matches; ++j) 		{ 		    parse_match(matches[j], &tagp); 		    for (i = idx; i < new_num_matches; ++i) 		    { 			parse_match(new_matches[i], &tagp2); 			if (STRCMP(tagp.tagname, tagp2.tagname) == 0) 			{ 			    char_u *p = new_matches[i]; 			    for (k = i; k > idx; --k) 				new_matches[k] = new_matches[k - 1]; 			    new_matches[idx++] = p; 			    break; 			} 		    } 		} 	    } 	    FreeWild(num_matches, matches); 	    num_matches = new_num_matches; 	    matches = new_matches; 	}  	if (num_matches <= 0) 	{ 	    if (verbose) 		semsg(_(e_tag_not_found_str), name); #if defined(FEAT_QUICKFIX) 	    g_do_tagpreview = 0; #endif 	} 	else 	{ 	    int ask_for_selection = FALSE;  #ifdef FEAT_CSCOPE 	    if (type == DT_CSCOPE && num_matches > 1) 	    { 		cs_print_tags(); 		ask_for_selection = TRUE; 	    } 	    else #endif 	    if (type == DT_TAG && *tag != NUL) 		// If a count is supplied to the "":tag <name>"" command, then 		// jump to count'th matching tag. 		cur_match = count > 0 ? count - 1 : 0; 	    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1)) 	    { 		print_tag_list(new_tag, use_tagstack, num_matches, matches); 		ask_for_selection = TRUE; 	    } #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL) 	    else if (type == DT_LTAG) 	    { 		if (add_llist_tags(tag, num_matches, matches) == FAIL) 		    goto end_do_tag; 		cur_match = 0;		// Jump to the first tag 	    } #endif  	    if (ask_for_selection == TRUE) 	    { 		/* 		 * Ask to select a tag from the list. 		 */ 		i = prompt_for_number(NULL); 		if (i <= 0 || i > num_matches || got_int) 		{ 		    // no valid choice: don't change anything 		    if (use_tagstack) 		    { 			tagstack[tagstackidx].fmark = saved_fmark; 			tagstackidx = prevtagstackidx; 		    } #ifdef FEAT_CSCOPE 		    cs_free_tags(); 		    jumped_to_tag = TRUE; #endif 		    break; 		} 		cur_match = i - 1; 	    }  	    if (cur_match >= num_matches) 	    { 		// Avoid giving this error when a file wasn't found and we're 		// looking for a match in another file, which wasn't found. 		// There will be an emsg(""file doesn't exist"") below then. 		if ((type == DT_NEXT || type == DT_FIRST) 						      && nofile_fname == NULL) 		{ 		    if (num_matches == 1) 			emsg(_(e_there_is_only_one_matching_tag)); 		    else 			emsg(_(e_cannot_go_beyond_last_matching_tag)); 		    skip_msg = TRUE; 		} 		cur_match = num_matches - 1; 	    } 	    if (use_tagstack) 	    { 		tagptrs_T   tagp;  		tagstack[tagstackidx].cur_match = cur_match; 		tagstack[tagstackidx].cur_fnum = cur_fnum;  		// store user-provided data originating from tagfunc 		if (use_tfu && parse_match(matches[cur_match], &tagp) == OK 			&& tagp.user_data) 		{ 		    VIM_CLEAR(tagstack[tagstackidx].user_data); 		    tagstack[tagstackidx].user_data = vim_strnsave( 			  tagp.user_data, tagp.user_data_end - tagp.user_data); 		}  		++tagstackidx; 	    } #if defined(FEAT_QUICKFIX) 	    else if (g_do_tagpreview != 0) 	    { 		ptag_entry.cur_match = cur_match; 		ptag_entry.cur_fnum = cur_fnum; 	    } #endif  	    /* 	     * Only when going to try the next match, report that the previous 	     * file didn't exist.  Otherwise an emsg() is given below. 	     */ 	    if (nofile_fname != NULL && error_cur_match != cur_match) 		smsg(_(""File \""%s\"" does not exist""), nofile_fname);   	    ic = (matches[cur_match][0] & MT_IC_OFF); 	    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP #ifdef FEAT_CSCOPE 		&& type != DT_CSCOPE #endif 		&& (num_matches > 1 || ic) 		&& !skip_msg) 	    { 		// Give an indication of the number of matching tags 		sprintf((char *)IObuff, _(""tag %d of %d%s""), 				cur_match + 1, 				num_matches, 				max_num_matches != MAXCOL ? _("" or more"") : """"); 		if (ic) 		    STRCAT(IObuff, _(""  Using tag with different case!"")); 		if ((num_matches > prev_num_matches || new_tag) 							   && num_matches > 1) 		{ 		    if (ic) 			msg_attr((char *)IObuff, HL_ATTR(HLF_W)); 		    else 			msg((char *)IObuff); 		    msg_scroll = TRUE;	// don't overwrite this message 		} 		else 		    give_warning(IObuff, ic); 		if (ic && !msg_scrolled && msg_silent == 0) 		{ 		    out_flush(); 		    ui_delay(1007L, TRUE); 		} 	    }  #if defined(FEAT_EVAL) 	    // Let the SwapExists event know what tag we are jumping to. 	    vim_snprintf((char *)IObuff, IOSIZE, "":ta %s\r"", name); 	    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1); #endif  	    /* 	     * Jump to the desired match. 	     */ 	    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);  #if defined(FEAT_EVAL) 	    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1); #endif  	    if (i == NOTAGFILE) 	    { 		// File not found: try again with another matching tag 		if ((type == DT_PREV && cur_match > 0) 			|| ((type == DT_TAG || type == DT_NEXT 							  || type == DT_FIRST) 			    && (max_num_matches != MAXCOL 					     || cur_match < num_matches - 1))) 		{ 		    error_cur_match = cur_match; 		    if (use_tagstack) 			--tagstackidx; 		    if (type == DT_PREV) 			--cur_match; 		    else 		    { 			type = DT_NEXT; 			++cur_match; 		    } 		    continue; 		} 		semsg(_(e_file_str_does_not_exist), nofile_fname); 	    } 	    else 	    { 		// We may have jumped to another window, check that 		// tagstackidx is still valid. 		if (use_tagstack && tagstackidx > curwin->w_tagstacklen) 		    tagstackidx = curwin->w_tagstackidx; #ifdef FEAT_CSCOPE 		jumped_to_tag = TRUE; #endif 	    } 	} 	break;     }  end_do_tag:     // Only store the new index when using the tagstack and it's valid.     if (use_tagstack && tagstackidx <= curwin->w_tagstacklen) 	curwin->w_tagstackidx = tagstackidx;     postponed_split = 0;	// don't split next time # ifdef FEAT_QUICKFIX     g_do_tagpreview = 0;	// don't do tag preview next time # endif      vim_free(tofree); #ifdef FEAT_CSCOPE     return jumped_to_tag; #else     return FALSE; #endif }"
"212436_CWE-787.c","CWE-787","static int prealloc_elems_and_freelist(struct bpf_stack_map *smap) { 	u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size; 	int err;  	smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries, 					 smap->map.numa_node); 	if (!smap->elems) 		return -ENOMEM;  	err = pcpu_freelist_init(&smap->freelist); 	if (err) 		goto free_elems;  	pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size, 			       smap->map.max_entries); 	return 0;  free_elems: 	bpf_map_area_free(smap->elems); 	return err; }"
"212688_CWE-327.c","CWE-327","int hci_conn_check_link_mode(struct hci_conn *conn) { 	BT_DBG(""hcon %p"", conn);  	/* In Secure Connections Only mode, it is required that Secure 	 * Connections is used and the link is encrypted with AES-CCM 	 * using a P-256 authenticated combination key. 	 */ 	if (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) { 		if (!hci_conn_sc_enabled(conn) || 		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) || 		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256) 			return 0; 	}  	if (hci_conn_ssp_enabled(conn) && 	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags)) 		return 0;  	return 1; }"
"212810_CWE-190.c","CWE-190","regional_alloc(struct regional *r, size_t size) { 	size_t a = ALIGN_UP(size, ALIGNMENT); 	void *s; 	/* large objects */ 	if(a > REGIONAL_LARGE_OBJECT_SIZE) { 		s = malloc(ALIGNMENT + size); 		if(!s) return NULL; 		r->total_large += ALIGNMENT+size; 		*(char**)s = r->large_list; 		r->large_list = (char*)s; 		return (char*)s+ALIGNMENT; 	} 	/* create a new chunk */ 	if(a > r->available) { 		s = malloc(REGIONAL_CHUNK_SIZE); 		if(!s) return NULL; 		*(char**)s = r->next; 		r->next = (char*)s; 		r->data = (char*)s + ALIGNMENT; 		r->available = REGIONAL_CHUNK_SIZE - ALIGNMENT; 	} 	/* put in this chunk */ 	r->available -= a; 	s = r->data; 	r->data += a; 	return s; }"
"212818_CWE-191.c","CWE-191","static pj_status_t decode_errcode_attr(pj_pool_t *pool,  				       const pj_uint8_t *buf, 				       const pj_stun_msg_hdr *msghdr,  				       void **p_attr) {     pj_stun_errcode_attr *attr;     pj_str_t value;      PJ_UNUSED_ARG(msghdr);      /* Create the attribute */     attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);     GETATTRHDR(buf, &attr->hdr);      attr->err_code = buf[6] * 100 + buf[7];      /* Get pointer to the string in the message */     value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);     value.slen = attr->hdr.length - 4;      /* Copy the string to the attribute */     pj_strdup(pool, &attr->reason, &value);      /* Done */     *p_attr = attr;      return PJ_SUCCESS; }"
"212822_CWE-787.c","CWE-787","pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs) {     uint count = min(max_data,                      pcs->status.write_pos - pcs->status.read_pos);      if (count)         memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);     pcs->status.read_pos += count;     if (pcs->status.read_pos == pcs->status.write_pos) {         gs_free_object(pcs->memory, pcs->status.buffer, ""status buffer"");         pcs->status.write_pos = pcs->status.read_pos = 0;     }     return count; }"
"212829_CWE-476.c","CWE-476"," */ static void php_wddx_pop_element(void *user_data, const XML_Char *name) { 	st_entry 			*ent1, *ent2; 	wddx_stack 			*stack = (wddx_stack *)user_data; 	HashTable 			*target_hash; 	zend_class_entry 	**pce; 	zval				*obj; 	zval				*tmp; 	TSRMLS_FETCH();  /* OBJECTS_FIXME */ 	if (stack->top == 0) { 		return; 	}  	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) || 		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) || 	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) || 		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) || 		!strcmp(name, EL_DATETIME)) { 		wddx_stack_top(stack, (void**)&ent1);  		if (!ent1->data) { 			if (stack->top > 1) { 				stack->top--; 			} else { 				stack->done = 1; 			} 			efree(ent1); 			return; 		}  		if (!strcmp(name, EL_BINARY)) { 			int new_len=0; 			unsigned char *new_str;  			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len); 			STR_FREE(Z_STRVAL_P(ent1->data)); 			Z_STRVAL_P(ent1->data) = new_str; 			Z_STRLEN_P(ent1->data) = new_len; 		}  		/* Call __wakeup() method on the object. */ 		if (Z_TYPE_P(ent1->data) == IS_OBJECT) { 			zval *fname, *retval = NULL;  			MAKE_STD_ZVAL(fname); 			ZVAL_STRING(fname, ""__wakeup"", 1);  			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);  			zval_dtor(fname); 			FREE_ZVAL(fname); 			if (retval) { 				zval_ptr_dtor(&retval); 			} 		}  		if (stack->top > 1) { 			stack->top--; 			wddx_stack_top(stack, (void**)&ent2);  			/* if non-existent field */ 			if (ent2->type == ST_FIELD && ent2->data == NULL) { 				zval_ptr_dtor(&ent1->data); 				efree(ent1); 				return; 			}  			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) { 				target_hash = HASH_OF(ent2->data);  				if (ent1->varname) { 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) && 						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) && 						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) { 						zend_bool incomplete_class = 0;  						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data), 										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) { 							incomplete_class = 1; 							pce = &PHP_IC_ENTRY; 						}  						/* Initialize target object */ 						MAKE_STD_ZVAL(obj); 						object_init_ex(obj, *pce);  						/* Merge current hashtable with object's default properties */ 						zend_hash_merge(Z_OBJPROP_P(obj), 										Z_ARRVAL_P(ent2->data), 										(void (*)(void *)) zval_add_ref, 										(void *) &tmp, sizeof(zval *), 0);  						if (incomplete_class) { 							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); 						}  						/* Clean up old array entry */ 						zval_ptr_dtor(&ent2->data);  						/* Set stack entry to point to the newly created object */ 						ent2->data = obj;  						/* Clean up class name var entry */ 						zval_ptr_dtor(&ent1->data); 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) { 						zend_class_entry *old_scope = EG(scope);  						EG(scope) = Z_OBJCE_P(ent2->data); 						Z_DELREF_P(ent1->data); 						add_property_zval(ent2->data, ent1->varname, ent1->data); 						EG(scope) = old_scope; 					} else { 						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL); 					} 					efree(ent1->varname); 				} else	{ 					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL); 				} 			} 			efree(ent1); 		} else { 			stack->done = 1; 		} 	} else if (!strcmp(name, EL_VAR) && stack->varname) { 		efree(stack->varname); 		stack->varname = NULL; 	} else if (!strcmp(name, EL_FIELD)) { 		st_entry *ent; 		wddx_stack_top(stack, (void **)&ent); 		efree(ent); 		stack->top--; 	}"
"212834_CWE-190.c","CWE-190","processDataRcvd(ptcpsess_t *const __restrict__ pThis, 	char **buff, 	const int buffLen, 	struct syslogTime *stTime, 	const time_t ttGenTime, 	multi_submit_t *pMultiSub, 	unsigned *const __restrict__ pnMsgs) { 	DEFiRet; 	char c = **buff; 	int octatesToCopy, octatesToDiscard;  	if(pThis->inputState == eAtStrtFram) { 		if(pThis->bSuppOctetFram && isdigit((int) c)) { 			pThis->inputState = eInOctetCnt; 			pThis->iOctetsRemain = 0; 			pThis->eFraming = TCP_FRAMING_OCTET_COUNTING; 		} else if(pThis->bSPFramingFix && c == ' ') { 			/* Cisco very occasionally sends a SP after a LF, which 			 * thrashes framing if not taken special care of. Here, 			 * we permit space *in front of the next frame* and 			 * ignore it. 			 */ 			 FINALIZE; 		} else { 			pThis->inputState = eInMsg; 			pThis->eFraming = TCP_FRAMING_OCTET_STUFFING; 		} 	}  	if(pThis->inputState == eInOctetCnt) { 		if(isdigit(c)) { 			pThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0'; 		} else { /* done with the octet count, so this must be the SP terminator */ 			DBGPRINTF(""TCP Message with octet-counter, size %d.\n"", pThis->iOctetsRemain); 			if(c != ' ') { 				errmsg.LogError(0, NO_ERRCODE, ""Framing Error in received TCP message: "" 					    ""delimiter is not SP but has ASCII value %d."", c); 			} 			if(pThis->iOctetsRemain < 1) { 				/* TODO: handle the case where the octet count is 0! */ 				DBGPRINTF(""Framing Error: invalid octet count\n""); 				errmsg.LogError(0, NO_ERRCODE, ""Framing Error in received TCP message: "" 					    ""invalid octet count %d."", pThis->iOctetsRemain); 			} else if(pThis->iOctetsRemain > iMaxLine) { 				/* while we can not do anything against it, we can at least log an indication 				 * that something went wrong) -- rgerhards, 2008-03-14 				 */ 				DBGPRINTF(""truncating message with %d octets - max msg size is %d\n"", 					  pThis->iOctetsRemain, iMaxLine); 				errmsg.LogError(0, NO_ERRCODE, ""received oversize message: size is %d bytes, "" 					        ""max msg size is %d, truncating..."", pThis->iOctetsRemain, iMaxLine); 			} 			pThis->inputState = eInMsg; 		} 	} else { 		assert(pThis->inputState == eInMsg);  		if (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) { 			if(pThis->iMsg >= iMaxLine) { 				/* emergency, we now need to flush, no matter if we are at end of message or not... */ 				int i = 1; 				char currBuffChar; 				while(i < buffLen && ((currBuffChar = (*buff)[i]) != '\n' 					&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER 						|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) { 					i++; 				} 				LogError(0, NO_ERRCODE, ""error: message received is at least %d byte larger than max msg"" 					"" size; message will be split starting at: \""%.*s\""\n"", i, (i < 32) ? i : 32, *buff); 				doSubmitMsg(pThis, stTime, ttGenTime, pMultiSub); 				++(*pnMsgs); 				/* we might think if it is better to ignore the rest of the 				 * message than to treat it as a new one. Maybe this is a good 				 * candidate for a configuration parameter... 				 * rgerhards, 2006-12-04 				 */ 			}  			if ((c == '\n') 				   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER) 					   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim)) 				   ) { /* record delimiter? */ 				doSubmitMsg(pThis, stTime, ttGenTime, pMultiSub); 				++(*pnMsgs); 				pThis->inputState = eAtStrtFram; 			} else { 				/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes! 				 * If we have a message that is larger than the max msg size, we truncate it. This is the best 				 * we can do in light of what the engine supports. -- rgerhards, 2008-03-14 				 */ 				if(pThis->iMsg < iMaxLine) { 					*(pThis->pMsg + pThis->iMsg++) = c; 				} 			} 		} else { 			assert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING); 			octatesToCopy = pThis->iOctetsRemain; 			octatesToDiscard = 0; 			if (buffLen < octatesToCopy) { 				octatesToCopy = buffLen; 			} 			if (octatesToCopy + pThis->iMsg > iMaxLine) { 				octatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg); 				octatesToCopy = iMaxLine - pThis->iMsg; 			}  			memcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy); 			pThis->iMsg += octatesToCopy; 			pThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard); 			*buff += (octatesToCopy + octatesToDiscard - 1); 			if (pThis->iOctetsRemain == 0) { 				/* we have end of frame! */ 				doSubmitMsg(pThis, stTime, ttGenTime, pMultiSub); 				++(*pnMsgs); 				pThis->inputState = eAtStrtFram; 			} 		}  	}  finalize_it: 	RETiRet; }"
"212857_CWE-416.c","CWE-416","qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid) {     linenr_T	lnum;     qfline_T	*qfp;     int		old_KeyTyped = KeyTyped;     list_T	*qftf_list = NULL;     listitem_T	*qftf_li = NULL;      if (old_last == NULL)     { 	if (buf != curbuf) 	{ 	    internal_error(""qf_fill_buffer()""); 	    return; 	}  	// delete all existing lines 	while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0) 	    (void)ml_delete((linenr_T)1);     }      // Check if there is anything to display     if (qfl != NULL)     { 	char_u		dirname[MAXPATHL]; 	int		invalid_val = FALSE; 	int		prev_bufnr = -1;  	*dirname = NUL;  	// Add one line for each error 	if (old_last == NULL) 	{ 	    qfp = qfl->qf_start; 	    lnum = 0; 	} 	else 	{ 	    if (old_last->qf_next != NULL) 		qfp = old_last->qf_next; 	    else 		qfp = old_last; 	    lnum = buf->b_ml.ml_line_count; 	}  	qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1), 							(long)qfl->qf_count); 	if (qftf_list != NULL) 	    qftf_li = qftf_list->lv_first;  	while (lnum < qfl->qf_count) 	{ 	    char_u	*qftf_str = NULL;  	    // Use the text supplied by the user defined function (if any). 	    // If the returned value is not string, then ignore the rest 	    // of the returned values and use the default. 	    if (qftf_li != NULL && !invalid_val) 	    { 		qftf_str = tv_get_string_chk(&qftf_li->li_tv); 		if (qftf_str == NULL) 		    invalid_val = TRUE; 	    }  	    if (qf_buf_add_line(buf, lnum, qfp, dirname, 			prev_bufnr != qfp->qf_fnum, qftf_str) == FAIL) 		break;  	    prev_bufnr = qfp->qf_fnum; 	    ++lnum; 	    qfp = qfp->qf_next; 	    if (qfp == NULL) 		break;  	    if (qftf_li != NULL) 		qftf_li = qftf_li->li_next; 	}  	if (old_last == NULL) 	    // Delete the empty line which is now at the end 	    (void)ml_delete(lnum + 1);     }      // correct cursor position     check_lnums(TRUE);      if (old_last == NULL)     { 	// Set the 'filetype' to ""qf"" each time after filling the buffer. 	// This resembles reading a file into a buffer, it's more logical when 	// using autocommands. 	++curbuf_lock; 	set_option_value_give_err((char_u *)""ft"", 						0L, (char_u *)""qf"", OPT_LOCAL); 	curbuf->b_p_ma = FALSE;  	keep_filetype = TRUE;		// don't detect 'filetype' 	apply_autocmds(EVENT_BUFREADPOST, (char_u *)""quickfix"", NULL, 							       FALSE, curbuf); 	apply_autocmds(EVENT_BUFWINENTER, (char_u *)""quickfix"", NULL, 							       FALSE, curbuf); 	keep_filetype = FALSE; 	--curbuf_lock;  	// make sure it will be redrawn 	redraw_curbuf_later(UPD_NOT_VALID);     }      // Restore KeyTyped, setting 'filetype' may reset it.     KeyTyped = old_KeyTyped; }"
"212871_CWE-787.cpp","CWE-787","std::string controller::bookmark( 		const std::string& url, 		const std::string& title, 		const std::string& description, 		const std::string& feed_title) { 	std::string bookmark_cmd = cfg.get_configvalue(""bookmark-cmd""); 	bool is_interactive = cfg.get_configvalue_as_bool(""bookmark-interactive""); 	if (bookmark_cmd.length() > 0) { 		std::string cmdline = strprintf::fmt(""%s '%s' %s %s %s"", 		                                       bookmark_cmd, 		                                       utils::replace_all(url,""'"", ""%27""), 		                                       quote_empty(stfl::quote(title)), 		                                       quote_empty(stfl::quote(description)), 		                                       quote_empty(stfl::quote(feed_title)));  		LOG(level::DEBUG, ""controller::bookmark: cmd = %s"", cmdline);  		if (is_interactive) { 			v->push_empty_formaction(); 			stfl::reset(); 			utils::run_interactively(cmdline, ""controller::bookmark""); 			v->pop_current_formaction(); 			return """"; 		} else { 			char * my_argv[4]; 			my_argv[0] = const_cast<char *>(""/bin/sh""); 			my_argv[1] = const_cast<char *>(""-c""); 			my_argv[2] = const_cast<char *>(cmdline.c_str()); 			my_argv[3] = nullptr; 			return utils::run_program(my_argv, """"); 		} 	} else { 		return _(""bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.""); 	} }"
"212927_CWE-835.c","CWE-835","static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,                                int size) {     NetClientState *nc = qemu_get_queue(s->nic);      if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {         nc->info->receive(nc, buf, size);     } else {         qemu_send_packet(nc, buf, size);     } }"
"212934_CWE-732.c","CWE-732","static int write_entry(struct mailbox *mailbox,                        unsigned int uid,                        const char *entry,                        const char *userid,                        const struct buf *value,                        int ignorequota,                        int silent,                        const struct annotate_metadata *mdata,                        int maywrite)  {     char key[MAX_MAILBOX_PATH+1];     int keylen, r;     annotate_db_t *d = NULL;     struct buf oldval = BUF_INITIALIZER;     const char *mboxname = mailbox ? mailbox->name : """";     modseq_t modseq = mdata ? mdata->modseq : 0;      r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);     if (r)         return r;      /* must be in a transaction to modify the db */     annotate_begin(d);      keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));      if (mailbox) {         struct annotate_metadata oldmdata;         r = read_old_value(d, key, keylen, &oldval, &oldmdata);         if (r) goto out;          /* if the value is identical, don't touch the mailbox */         if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))             goto out;          if (!ignorequota) {             quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;             qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;             r = mailbox_quota_check(mailbox, qdiffs);             if (r) goto out;         }          if (!maywrite) {             r = IMAP_PERMISSION_DENIED;             if (r) goto out;         }          /* do the annot-changed here before altering the DB */         mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);          /* grab the message annotation modseq, if not overridden */         if (uid && !mdata) {             modseq = mailbox->i.highestmodseq;         }     }      /* zero length annotation is deletion.      * keep tombstones for message annotations */     if (!value->len && !uid) {  #if DEBUG         syslog(LOG_ERR, ""write_entry: deleting key %s from %s"",                 key_as_string(d, key, keylen), d->filename); #endif          do {             r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);         } while (r == CYRUSDB_AGAIN);     }     else {         struct buf data = BUF_INITIALIZER;         unsigned char flags = 0;         if (!value->len || value->s == NULL) {             flags |= ANNOTATE_FLAG_DELETED;         }         else {             // this is only here to allow cleanup of invalid values in the past...             // the calling of this API with a NULL ""userid"" is bogus, because that's             // supposed to be reserved for the make_key of prefixes - but there has             // been API abuse in the past, so some of these are in the wild.  *sigh*.             // Don't allow new ones to be written             if (!userid) goto out;         }         make_entry(&data, value, modseq, flags);  #if DEBUG         syslog(LOG_ERR, ""write_entry: storing key %s (value: %s) to %s (modseq="" MODSEQ_FMT "")"",                 key_as_string(d, key, keylen), value->s, d->filename, modseq); #endif          do {             r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));         } while (r == CYRUSDB_AGAIN);         buf_free(&data);     }      if (!mailbox)         sync_log_annotation("""");  out:     annotate_putdb(&d);     buf_free(&oldval);      return r; }"
"212955_CWE-476.c","CWE-476","static int ax25_release(struct socket *sock) { 	struct sock *sk = sock->sk; 	ax25_cb *ax25; 	ax25_dev *ax25_dev;  	if (sk == NULL) 		return 0;  	sock_hold(sk); 	lock_sock(sk); 	sock_orphan(sk); 	ax25 = sk_to_ax25(sk); 	ax25_dev = ax25->ax25_dev;  	if (sk->sk_type == SOCK_SEQPACKET) { 		switch (ax25->state) { 		case AX25_STATE_0: 			release_sock(sk); 			ax25_disconnect(ax25, 0); 			lock_sock(sk); 			ax25_destroy_socket(ax25); 			break;  		case AX25_STATE_1: 		case AX25_STATE_2: 			ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND); 			release_sock(sk); 			ax25_disconnect(ax25, 0); 			lock_sock(sk); 			if (!sock_flag(ax25->sk, SOCK_DESTROY)) 				ax25_destroy_socket(ax25); 			break;  		case AX25_STATE_3: 		case AX25_STATE_4: 			ax25_clear_queues(ax25); 			ax25->n2count = 0;  			switch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) { 			case AX25_PROTO_STD_SIMPLEX: 			case AX25_PROTO_STD_DUPLEX: 				ax25_send_control(ax25, 						  AX25_DISC, 						  AX25_POLLON, 						  AX25_COMMAND); 				ax25_stop_t2timer(ax25); 				ax25_stop_t3timer(ax25); 				ax25_stop_idletimer(ax25); 				break; #ifdef CONFIG_AX25_DAMA_SLAVE 			case AX25_PROTO_DAMA_SLAVE: 				ax25_stop_t3timer(ax25); 				ax25_stop_idletimer(ax25); 				break; #endif 			} 			ax25_calculate_t1(ax25); 			ax25_start_t1timer(ax25); 			ax25->state = AX25_STATE_2; 			sk->sk_state                = TCP_CLOSE; 			sk->sk_shutdown            |= SEND_SHUTDOWN; 			sk->sk_state_change(sk); 			sock_set_flag(sk, SOCK_DESTROY); 			break;  		default: 			break; 		} 	} else { 		sk->sk_state     = TCP_CLOSE; 		sk->sk_shutdown |= SEND_SHUTDOWN; 		sk->sk_state_change(sk); 		ax25_destroy_socket(ax25); 	} 	if (ax25_dev) { 		dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker); 		ax25_dev_put(ax25_dev); 	}  	sock->sk   = NULL; 	release_sock(sk); 	sock_put(sk);  	return 0; }"
"213037_CWE-125.c","CWE-125","mbfl_filt_conv_big5_wchar(int c, mbfl_convert_filter *filter) { 	int k; 	int c1, w, c2;  	switch (filter->status) { 	case 0: 		if (filter->from->no_encoding == mbfl_no_encoding_cp950) { 			c1 = 0x80; 		} else { 			c1 = 0xa0; 		}  		if (c >= 0 && c <= 0x80) {	/* latin */ 			CK((*filter->output_function)(c, filter->data)); 		} else if (c == 0xff) { 			CK((*filter->output_function)(0xf8f8, filter->data)); 		} else if (c > c1 && c < 0xff) {	/* dbcs lead byte */ 			filter->status = 1; 			filter->cache = c; 		} else { 			w = c & MBFL_WCSGROUP_MASK; 			w |= MBFL_WCSGROUP_THROUGH; 			CK((*filter->output_function)(w, filter->data)); 		} 		break;  	case 1:		/* dbcs second byte */ 		filter->status = 0; 		c1 = filter->cache; 		if ((c > 0x39 && c < 0x7f) | (c > 0xa0 && c < 0xff)) { 			if (c < 0x7f){ 				w = (c1 - 0xa1)*157 + (c - 0x40); 			} else { 				w = (c1 - 0xa1)*157 + (c - 0xa1) + 0x3f; 			} 			if (w >= 0 && w < big5_ucs_table_size) { 				w = big5_ucs_table[w]; 			} else { 				w = 0; 			}  			if (filter->from->no_encoding == mbfl_no_encoding_cp950) { 				/* PUA for CP950 */ 				if (w <= 0 && 					(((c1 >= 0xfa && c1 <= 0xfe) || (c1 >= 0x8e && c1 <= 0xa0) || 					  (c1 >= 0x81 && c1 <= 0x8d) ||(c1 >= 0xc7 && c1 <= 0xc8)) 					 && ((c > 0x39 && c < 0x7f) || (c > 0xa0 && c < 0xff))) || 					((c1 == 0xc6) && (c > 0xa0 && c < 0xff))) { 					c2 = c1 << 8 | c; 					for (k = 0; k < sizeof(cp950_pua_tbl)/(sizeof(unsigned short)*4); k++) { 						if (c2 >= cp950_pua_tbl[k][2] && c2 <= cp950_pua_tbl[k][3]) { 							break; 						} 					}  					if ((cp950_pua_tbl[k][2] & 0xff) == 0x40) { 						w = 157*(c1 - (cp950_pua_tbl[k][2]>>8)) + c - (c >= 0xa1 ? 0x62 : 0x40) 							+ cp950_pua_tbl[k][0]; 					} else { 						w = c2 - cp950_pua_tbl[k][2] + cp950_pua_tbl[k][0]; 					} 				} 			}  			if (w <= 0) { 				w = (c1 << 8) | c; 				w &= MBFL_WCSPLANE_MASK; 				w |= MBFL_WCSPLANE_BIG5; 			} 			CK((*filter->output_function)(w, filter->data)); 		} else if ((c >= 0 && c < 0x21) || c == 0x7f) {		/* CTLs */ 			CK((*filter->output_function)(c, filter->data)); 		} else { 			w = (c1 << 8) | c; 			w &= MBFL_WCSGROUP_MASK; 			w |= MBFL_WCSGROUP_THROUGH; 			CK((*filter->output_function)(w, filter->data)); 		} 		break;  	default: 		filter->status = 0; 		break; 	}  	return c; }"
"213075_CWE-416.c","CWE-416","void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv) { 	struct nci_dev *ndev = priv->ndev;  	if (priv->ndev->nfc_dev->fw_download_in_progress) 		nfcmrvl_fw_dnld_abort(priv);  	nfcmrvl_fw_dnld_deinit(priv);  	if (gpio_is_valid(priv->config.reset_n_io)) 		gpio_free(priv->config.reset_n_io);  	nci_unregister_device(ndev); 	nci_free_device(ndev); 	kfree(priv); }"
"213076_CWE-125.c","CWE-125","static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks) { DEFINE_COMPILER; jump_list *found = NULL; jump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks; sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX; struct sljit_jump *jump = NULL; PCRE2_SPTR ccbegin; int compares, invertcmp, numberofcmps; #if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16) BOOL utf = common->utf; #endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */  #ifdef SUPPORT_UNICODE sljit_u32 unicode_status = 0; int typereg = TMP1; const sljit_u32 *other_cases; sljit_uw typeoffset; #endif /* SUPPORT_UNICODE */  /* Scanning the necessary info. */ cc++; ccbegin = cc; compares = 0;  if (cc[-1] & XCL_MAP)   {   min = 0;   cc += 32 / sizeof(PCRE2_UCHAR);   }  while (*cc != XCL_END)   {   compares++;   if (*cc == XCL_SINGLE)     {     cc ++;     GETCHARINCTEST(c, cc);     if (c > max) max = c;     if (c < min) min = c; #ifdef SUPPORT_UNICODE     unicode_status |= XCLASS_SAVE_CHAR; #endif /* SUPPORT_UNICODE */     }   else if (*cc == XCL_RANGE)     {     cc ++;     GETCHARINCTEST(c, cc);     if (c < min) min = c;     GETCHARINCTEST(c, cc);     if (c > max) max = c; #ifdef SUPPORT_UNICODE     unicode_status |= XCLASS_SAVE_CHAR; #endif /* SUPPORT_UNICODE */     } #ifdef SUPPORT_UNICODE   else     {     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);     cc++;     if (*cc == PT_CLIST)       {       other_cases = PRIV(ucd_caseless_sets) + cc[1];       while (*other_cases != NOTACHAR)         {         if (*other_cases > max) max = *other_cases;         if (*other_cases < min) min = *other_cases;         other_cases++;         }       }     else       {       max = READ_CHAR_MAX;       min = 0;       }      switch(*cc)       {       case PT_ANY:       /* Any either accepts everything or ignored. */       if (cc[-1] == XCL_PROP)         {         compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);         if (list == backtracks)           add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));         return;         }       break;        case PT_LAMP:       case PT_GC:       case PT_PC:       case PT_ALNUM:       unicode_status |= XCLASS_HAS_TYPE;       break;        case PT_SCX:       unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;       if (cc[-1] == XCL_NOTPROP)         {         unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;         break;         }       compares++;       /* Fall through */         case PT_SC:       unicode_status |= XCLASS_HAS_SCRIPT;       break;        case PT_SPACE:       case PT_PXSPACE:       case PT_WORD:       case PT_PXGRAPH:       case PT_PXPRINT:       case PT_PXPUNCT:       unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;       break;        case PT_CLIST:       case PT_UCNC:       unicode_status |= XCLASS_SAVE_CHAR;       break;        case PT_BOOL:       unicode_status |= XCLASS_HAS_BOOL;       break;        case PT_BIDICL:       unicode_status |= XCLASS_HAS_BIDICL;       break;        default:       SLJIT_UNREACHABLE();       break;       }     cc += 2;     } #endif /* SUPPORT_UNICODE */   } SLJIT_ASSERT(compares > 0);  /* We are not necessary in utf mode even in 8 bit mode. */ cc = ccbegin; if ((cc[-1] & XCL_NOT) != 0)   read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR); else   { #ifdef SUPPORT_UNICODE   read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0); #else /* !SUPPORT_UNICODE */   read_char(common, min, max, NULL, 0); #endif /* SUPPORT_UNICODE */   }  if ((cc[-1] & XCL_HASPROP) == 0)   {   if ((cc[-1] & XCL_MAP) != 0)     {     jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);     if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))       {       OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);       OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);       OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);       OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);       OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);       add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));       }      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));     JUMPHERE(jump);      cc += 32 / sizeof(PCRE2_UCHAR);     }   else     {     OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);     add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));     }   } else if ((cc[-1] & XCL_MAP) != 0)   {   OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0); #ifdef SUPPORT_UNICODE   unicode_status |= XCLASS_CHAR_SAVED; #endif /* SUPPORT_UNICODE */   if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))     { #if PCRE2_CODE_UNIT_WIDTH == 8     jump = NULL;     if (common->utf) #endif /* PCRE2_CODE_UNIT_WIDTH == 8 */       jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);     OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);     OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);     add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));  #if PCRE2_CODE_UNIT_WIDTH == 8     if (common->utf) #endif /* PCRE2_CODE_UNIT_WIDTH == 8 */       JUMPHERE(jump);     }    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);   cc += 32 / sizeof(PCRE2_UCHAR);   }  #ifdef SUPPORT_UNICODE if (unicode_status & XCLASS_NEEDS_UCD)   {   if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)     OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);  #if PCRE2_CODE_UNIT_WIDTH == 32   if (!common->utf)     {     jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);     OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);     JUMPHERE(jump);     } #endif /* PCRE2_CODE_UNIT_WIDTH == 32 */    OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));   OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);   OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);   OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));   OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);   OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);   OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);   OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);    ccbegin = cc;    if (unicode_status & XCLASS_HAS_BIDICL)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));     OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_BIDICL)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;           jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);           add_jump(compiler, compares > 0 ? list : backtracks, jump);           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_BOOL)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_BOOL)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;            OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_SCRIPT)     {     OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         switch (*cc)           {           case PT_SCX:           if (cc[-1] == XCL_NOTPROP)             break;           /* Fall through */             case PT_SC:           compares--;           invertcmp = (compares == 0 && list != backtracks);           if (cc[-1] == XCL_NOTPROP)             invertcmp ^= 0x1;            add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));           }         cc += 2;         }       }      cc = ccbegin;     }    if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)     {     OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));     OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);     OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);      if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)       {       if (unicode_status & XCLASS_HAS_TYPE)         {         if (unicode_status & XCLASS_SAVE_CHAR)           {           OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;           }         else           {           OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);           unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;           }         }       OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));       }      while (*cc != XCL_END)       {       if (*cc == XCL_SINGLE)         {         cc ++;         GETCHARINCTEST(c, cc);         }       else if (*cc == XCL_RANGE)         {         cc ++;         GETCHARINCTEST(c, cc);         GETCHARINCTEST(c, cc);         }       else         {         SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);         cc++;         if (*cc == PT_SCX)           {           compares--;           invertcmp = (compares == 0 && list != backtracks);            jump = NULL;           if (cc[-1] == XCL_NOTPROP)             {             jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);             if (invertcmp)               {               add_jump(compiler, backtracks, jump);               jump = NULL;               }             invertcmp ^= 0x1;             }            OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));           add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));            if (jump != NULL)             JUMPHERE(jump);           }         cc += 2;         }       }      if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)       OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);     else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)       OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);     cc = ccbegin;     }    if (unicode_status & XCLASS_SAVE_CHAR)     OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);    if (unicode_status & XCLASS_HAS_TYPE)     {     if (unicode_status & XCLASS_SAVE_CHAR)       typereg = RETURN_ADDR;      OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));     }   } #endif /* SUPPORT_UNICODE */  /* Generating code. */ charoffset = 0; numberofcmps = 0; #ifdef SUPPORT_UNICODE typeoffset = 0; #endif /* SUPPORT_UNICODE */  while (*cc != XCL_END)   {   compares--;   invertcmp = (compares == 0 && list != backtracks);   jump = NULL;    if (*cc == XCL_SINGLE)     {     cc ++;     GETCHARINCTEST(c, cc);      if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))       {       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       numberofcmps++;       }     else if (numberofcmps > 0)       {       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       numberofcmps = 0;       }     else       {       jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       numberofcmps = 0;       }     }   else if (*cc == XCL_RANGE)     {     cc ++;     GETCHARINCTEST(c, cc);     SET_CHAR_OFFSET(c);     GETCHARINCTEST(c, cc);      if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))       {       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       numberofcmps++;       }     else if (numberofcmps > 0)       {       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       numberofcmps = 0;       }     else       {       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));       numberofcmps = 0;       }     } #ifdef SUPPORT_UNICODE   else     {     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);     if (*cc == XCL_NOTPROP)       invertcmp ^= 0x1;     cc++;     switch(*cc)       {       case PT_ANY:       if (!invertcmp)         jump = JUMP(SLJIT_JUMP);       break;        case PT_LAMP:       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_GC:       c = PRIV(ucp_typerange)[(int)cc[1] * 2];       SET_TYPE_OFFSET(c);       jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);       break;        case PT_PC:       jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);       break;        case PT_SC:       case PT_SCX:       case PT_BOOL:       case PT_BIDICL:       compares++;       /* Do nothing. */       break;        case PT_SPACE:       case PT_PXSPACE:       SET_CHAR_OFFSET(9);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        SET_TYPE_OFFSET(ucp_Zl);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_WORD:       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       /* Fall through. */        case PT_ALNUM:       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);       OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       SET_TYPE_OFFSET(ucp_Nd);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_CLIST:       other_cases = PRIV(ucd_caseless_sets) + cc[1];        /* At least three characters are required.          Otherwise this case would be handled by the normal code path. */       SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);       SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);        /* Optimizing character pairs, if their difference is power of 2. */       if (is_powerof2(other_cases[1] ^ other_cases[0]))         {         if (charoffset == 0)           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);         else           {           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);           }         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);         other_cases += 2;         }       else if (is_powerof2(other_cases[2] ^ other_cases[1]))         {         if (charoffset == 0)           OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);         else           {           OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);           OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);           }         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);          OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));         OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);          other_cases += 3;         }       else         {         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));         OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);         }        while (*other_cases != NOTACHAR)         {         OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));         OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);         }       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_UCNC:       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);       OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        SET_CHAR_OFFSET(0xa0);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);       SET_CHAR_OFFSET(0);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        case PT_PXGRAPH:       /* C and Z groups are the farthest two groups. */       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);        jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);        /* In case of ucp_Cf, we overwrite the result. */       SET_CHAR_OFFSET(0x2066);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        JUMPHERE(jump);       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);       break;        case PT_PXPRINT:       /* C and Z groups are the farthest two groups. */       SET_TYPE_OFFSET(ucp_Ll);       OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);        OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);        jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);        /* In case of ucp_Cf, we overwrite the result. */       SET_CHAR_OFFSET(0x2066);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);       OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);        JUMPHERE(jump);       jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);       break;        case PT_PXPUNCT:       SET_TYPE_OFFSET(ucp_Sc);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);       OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);        SET_CHAR_OFFSET(0);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);       OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);        SET_TYPE_OFFSET(ucp_Pc);       OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);       OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);       jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);       break;        default:       SLJIT_UNREACHABLE();       break;       }     cc += 2;     } #endif /* SUPPORT_UNICODE */    if (jump != NULL)     add_jump(compiler, compares > 0 ? list : backtracks, jump);   }  if (found != NULL)   set_jumps(found, LABEL()); }"
"213370_CWE-754.c","CWE-754","g_socket_client_connected_callback (GObject      *source, 				    GAsyncResult *result, 				    gpointer      user_data) {   ConnectionAttempt *attempt = user_data;   GSocketClientAsyncConnectData *data = attempt->data;   GSList *l;   GError *error = NULL;   GProxy *proxy;   const gchar *protocol;    /* data is NULL once the task is completed */   if (data && g_task_return_error_if_cancelled (data->task))     {       g_object_unref (data->task);       connection_attempt_unref (attempt);       return;     }    if (attempt->timeout_source)     {       g_source_destroy (attempt->timeout_source);       g_clear_pointer (&attempt->timeout_source, g_source_unref);     }    if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source), 					   result, &error))     {       if (!g_cancellable_is_cancelled (attempt->cancellable))         {           clarify_connect_error (error, data->connectable, attempt->address);           set_last_error (data, error);         }       else         g_clear_error (&error);        if (data)         {           connection_attempt_remove (attempt);           enumerator_next_async (data);         }       else         connection_attempt_unref (attempt);        return;     }    data->socket = g_steal_pointer (&attempt->socket);   data->connection = g_steal_pointer (&attempt->connection);    for (l = data->connection_attempts; l; l = g_slist_next (l))     {       ConnectionAttempt *attempt_entry = l->data;       g_cancellable_cancel (attempt_entry->cancellable);       attempt_entry->data = NULL;       connection_attempt_unref (attempt_entry);     }   g_slist_free (data->connection_attempts);   data->connection_attempts = NULL;   connection_attempt_unref (attempt);    g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);   g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);    /* wrong, but backward compatible */   g_socket_set_blocking (data->socket, TRUE);    if (!data->proxy_addr)     {       g_socket_client_tls_handshake (data);       return;     }    protocol = g_proxy_address_get_protocol (data->proxy_addr);    /* The connection should not be anything other than TCP,    * but let's put a safety guard in case    */   if (!G_IS_TCP_CONNECTION (data->connection))     {       g_critical (""Trying to proxy over non-TCP connection, this is ""           ""most likely a bug in GLib IO library."");        g_set_error_literal (&data->last_error,           G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,           _(""Proxying over a non-TCP connection is not supported.""));        enumerator_next_async (data);     }   else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))     {       /* Simply complete the connection, we don't want to do TLS handshake        * as the application proxy handling may need proxy handshake first */       g_socket_client_async_connect_complete (data);     }   else if ((proxy = g_proxy_get_default_for_protocol (protocol)))     {       g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);       g_proxy_connect_async (proxy,                              data->connection,                              data->proxy_addr,                              g_task_get_cancellable (data->task),                              g_socket_client_proxy_connect_callback,                              data);       g_object_unref (proxy);     }   else     {       g_clear_error (&data->last_error);        g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,           _(""Proxy protocol %s is not supported.""),           protocol);        enumerator_next_async (data);     } }"
"213482_CWE-252.c","CWE-252","nbd_internal_command_common (struct nbd_handle *h,                              uint16_t flags, uint16_t type,                              uint64_t offset, uint64_t count, int count_err,                              void *data, struct command_cb *cb) {   struct command *cmd;    if (h->disconnect_request) {       set_error (EINVAL, ""cannot request more commands after NBD_CMD_DISC"");       goto err;   }   if (h->in_flight == INT_MAX) {       set_error (ENOMEM, ""too many commands already in flight"");       goto err;   }    if (count_err) {     if ((h->strict & LIBNBD_STRICT_ZERO_SIZE) && count == 0) {       set_error (EINVAL, ""count cannot be 0"");       goto err;     }      if ((h->strict & LIBNBD_STRICT_BOUNDS) &&         (offset > h->exportsize || count > h->exportsize - offset)) {       set_error (count_err, ""request out of bounds"");       goto err;     }      if (h->block_minimum && (h->strict & LIBNBD_STRICT_ALIGN) &&         (offset | count) & (h->block_minimum - 1)) {       set_error (EINVAL, ""request is unaligned"");       goto err;     }   }    switch (type) {     /* Commands which send or receive data are limited to MAX_REQUEST_SIZE. */   case NBD_CMD_READ:   case NBD_CMD_WRITE:     if (count > MAX_REQUEST_SIZE) {       set_error (ERANGE, ""request too large: maximum request size is %d"",                  MAX_REQUEST_SIZE);       goto err;     }     break;      /* Other commands are currently limited by the 32 bit field in the      * command structure on the wire, but in future we hope to support      * 64 bit values here with a change to the NBD protocol which is      * being discussed upstream.      */   default:     if (count > UINT32_MAX) {       set_error (ERANGE, ""request too large: maximum request size is %"" PRIu32,                  UINT32_MAX);       goto err;     }     break;   }    cmd = calloc (1, sizeof *cmd);   if (cmd == NULL) {     set_error (errno, ""calloc"");     goto err;   }   cmd->flags = flags;   cmd->type = type;   cmd->cookie = h->unique++;   cmd->offset = offset;   cmd->count = count;   cmd->data = data;   if (cb)     cmd->cb = *cb;    /* If structured replies were negotiated then we trust the server to    * send back sufficient data to cover the whole buffer.  It's tricky    * to check this, so an easier thing is simply to zero the buffer    * ahead of time which avoids any security problems.  I measured the    * overhead of this and for non-TLS there is no measurable overhead    * in the highly intensive loopback case.  For TLS we get a    * performance gain, go figure.    */   if (h->structured_replies && cmd->data && type == NBD_CMD_READ)     memset (cmd->data, 0, cmd->count);    /* Add the command to the end of the queue. Kick the state machine    * if there is no other command being processed, otherwise, it will    * be handled automatically on a future cycle around to READY.    * Beyond this point, we have to return a cookie to the user, since    * we are queuing the command, even if kicking the state machine    * detects a failure.  Not reporting a state machine failure here is    * okay - any caller of an async command will be calling more API to    * await results, and will eventually learn that the machine has    * moved on to DEAD at that time.    */   h->in_flight++;   if (h->cmds_to_issue != NULL) {     assert (nbd_internal_is_state_processing (get_next_state (h)));     h->cmds_to_issue_tail = h->cmds_to_issue_tail->next = cmd;   }   else {     assert (h->cmds_to_issue_tail == NULL);     h->cmds_to_issue = h->cmds_to_issue_tail = cmd;     if (nbd_internal_is_state_ready (get_next_state (h)) &&         nbd_internal_run (h, cmd_issue) == -1)       debug (h, ""command queued, ignoring state machine failure"");   }    return cmd->cookie;   err:   /* Since we did not queue the command, we must free the callbacks. */   if (cb) {     if (type == NBD_CMD_BLOCK_STATUS)       FREE_CALLBACK (cb->fn.extent);     if (type == NBD_CMD_READ)       FREE_CALLBACK (cb->fn.chunk);     FREE_CALLBACK (cb->completion);   }   return -1; }"
"213513_CWE-369.cpp","CWE-369","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,   double *X,double *Y,double *Z) {   assert(X != (double *) NULL);   assert(Y != (double *) NULL);   assert(Z != (double *) NULL);   if (L > (CIEK*CIEEpsilon))     *Y=(double) pow((L+16.0)/116.0,3.0);   else     *Y=L/CIEK;   *X=((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+     5.0*(*Y))/((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/     3.0)-(-1.0/3.0));   *Z=(*X*(((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-     5.0*(*Y); }"
"213515_CWE-787.c","CWE-787","spell_suggest(int count) {     char_u	*line;     pos_T	prev_cursor = curwin->w_cursor;     char_u	wcopy[MAXWLEN + 2];     char_u	*p;     int		i;     int		c;     suginfo_T	sug;     suggest_T	*stp;     int		mouse_used;     int		need_cap;     int		limit;     int		selected = count;     int		badlen = 0;     int		msg_scroll_save = msg_scroll;     int		wo_spell_save = curwin->w_p_spell;      if (!curwin->w_p_spell)     { 	did_set_spelllang(curwin); 	curwin->w_p_spell = TRUE;     }      if (*curwin->w_s->b_p_spl == NUL)     { 	emsg(_(e_spell_checking_is_not_possible)); 	return;     }      if (VIsual_active)     { 	// Use the Visually selected text as the bad word.  But reject 	// a multi-line selection. 	if (curwin->w_cursor.lnum != VIsual.lnum) 	{ 	    vim_beep(BO_SPELL); 	    return; 	} 	badlen = (int)curwin->w_cursor.col - (int)VIsual.col; 	if (badlen < 0) 	    badlen = -badlen; 	else 	    curwin->w_cursor.col = VIsual.col; 	++badlen; 	end_visual_mode();     }     // Find the start of the badly spelled word.     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0 	    || curwin->w_cursor.col > prev_cursor.col)     { 	// No bad word or it starts after the cursor: use the word under the 	// cursor. 	curwin->w_cursor = prev_cursor; 	line = ml_get_curline(); 	p = line + curwin->w_cursor.col; 	// Backup to before start of word. 	while (p > line && spell_iswordp_nmw(p, curwin)) 	    MB_PTR_BACK(line, p); 	// Forward to start of word. 	while (*p != NUL && !spell_iswordp_nmw(p, curwin)) 	    MB_PTR_ADV(p);  	if (!spell_iswordp_nmw(p, curwin))		// No word found. 	{ 	    beep_flush(); 	    return; 	} 	curwin->w_cursor.col = (colnr_T)(p - line);     }      // Get the word and its length.      // Figure out if the word should be capitalised.     need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);      // Make a copy of current line since autocommands may free the line.     line = vim_strsave(ml_get_curline());     if (line == NULL) 	goto skip;      // Get the list of suggestions.  Limit to 'lines' - 2 or the number in     // 'spellsuggest', whatever is smaller.     if (sps_limit > (int)Rows - 2) 	limit = (int)Rows - 2;     else 	limit = sps_limit;     spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit, 							TRUE, need_cap, TRUE);      if (sug.su_ga.ga_len == 0) 	msg(_(""Sorry, no suggestions""));     else if (count > 0)     { 	if (count > sug.su_ga.ga_len) 	    smsg(_(""Sorry, only %ld suggestions""), (long)sug.su_ga.ga_len);     }     else     { #ifdef FEAT_RIGHTLEFT 	// When 'rightleft' is set the list is drawn right-left. 	cmdmsg_rl = curwin->w_p_rl; 	if (cmdmsg_rl) 	    msg_col = Columns - 1; #endif  	// List the suggestions. 	msg_start(); 	msg_row = Rows - 1;	// for when 'cmdheight' > 1 	lines_left = Rows;	// avoid more prompt 	vim_snprintf((char *)IObuff, IOSIZE, _(""Change \""%.*s\"" to:""), 						sug.su_badlen, sug.su_badptr); #ifdef FEAT_RIGHTLEFT 	if (cmdmsg_rl && STRNCMP(IObuff, ""Change"", 6) == 0) 	{ 	    // And now the rabbit from the high hat: Avoid showing the 	    // untranslated message rightleft. 	    vim_snprintf((char *)IObuff, IOSIZE, "":ot \""%.*s\"" egnahC"", 						sug.su_badlen, sug.su_badptr); 	} #endif 	msg_puts((char *)IObuff); 	msg_clr_eos(); 	msg_putchar('\n');  	msg_scroll = TRUE; 	for (i = 0; i < sug.su_ga.ga_len; ++i) 	{ 	    stp = &SUG(sug.su_ga, i);  	    // The suggested word may replace only part of the bad word, add 	    // the not replaced part. 	    vim_strncpy(wcopy, stp->st_word, MAXWLEN); 	    if (sug.su_badlen > stp->st_orglen) 		vim_strncpy(wcopy + stp->st_wordlen, 					       sug.su_badptr + stp->st_orglen, 					      sug.su_badlen - stp->st_orglen); 	    vim_snprintf((char *)IObuff, IOSIZE, ""%2d"", i + 1); #ifdef FEAT_RIGHTLEFT 	    if (cmdmsg_rl) 		rl_mirror(IObuff); #endif 	    msg_puts((char *)IObuff);  	    vim_snprintf((char *)IObuff, IOSIZE, "" \""%s\"""", wcopy); 	    msg_puts((char *)IObuff);  	    // The word may replace more than ""su_badlen"". 	    if (sug.su_badlen < stp->st_orglen) 	    { 		vim_snprintf((char *)IObuff, IOSIZE, _("" < \""%.*s\""""), 					       stp->st_orglen, sug.su_badptr); 		msg_puts((char *)IObuff); 	    }  	    if (p_verbose > 0) 	    { 		// Add the score. 		if (sps_flags & (SPS_DOUBLE | SPS_BEST)) 		    vim_snprintf((char *)IObuff, IOSIZE, "" (%s%d - %d)"", 			stp->st_salscore ? ""s "" : """", 			stp->st_score, stp->st_altscore); 		else 		    vim_snprintf((char *)IObuff, IOSIZE, "" (%d)"", 			    stp->st_score); #ifdef FEAT_RIGHTLEFT 		if (cmdmsg_rl) 		    // Mirror the numbers, but keep the leading space. 		    rl_mirror(IObuff + 1); #endif 		msg_advance(30); 		msg_puts((char *)IObuff); 	    } 	    msg_putchar('\n'); 	}  #ifdef FEAT_RIGHTLEFT 	cmdmsg_rl = FALSE; 	msg_col = 0; #endif 	// Ask for choice. 	selected = prompt_for_number(&mouse_used); 	if (mouse_used) 	    selected -= lines_left; 	lines_left = Rows;		// avoid more prompt 	// don't delay for 'smd' in normal_cmd() 	msg_scroll = msg_scroll_save;     }      if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)     { 	// Save the from and to text for :spellrepall. 	VIM_CLEAR(repl_from); 	VIM_CLEAR(repl_to);  	stp = &SUG(sug.su_ga, selected - 1); 	if (sug.su_badlen > stp->st_orglen) 	{ 	    // Replacing less than ""su_badlen"", append the remainder to 	    // repl_to. 	    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen); 	    vim_snprintf((char *)IObuff, IOSIZE, ""%s%.*s"", stp->st_word, 		    sug.su_badlen - stp->st_orglen, 					      sug.su_badptr + stp->st_orglen); 	    repl_to = vim_strsave(IObuff); 	} 	else 	{ 	    // Replacing su_badlen or more, use the whole word. 	    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen); 	    repl_to = vim_strsave(stp->st_word); 	}  	// Replace the word. 	p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1); 	if (p != NULL) 	{ 	    c = (int)(sug.su_badptr - line); 	    mch_memmove(p, line, c); 	    STRCPY(p + c, stp->st_word); 	    STRCAT(p, sug.su_badptr + stp->st_orglen);  	    // For redo we use a change-word command. 	    ResetRedobuff(); 	    AppendToRedobuff((char_u *)""ciw""); 	    AppendToRedobuffLit(p + c, 			    stp->st_wordlen + sug.su_badlen - stp->st_orglen); 	    AppendCharToRedobuff(ESC);  	    // ""p"" may be freed here 	    ml_replace(curwin->w_cursor.lnum, p, FALSE); 	    curwin->w_cursor.col = c;  	    changed_bytes(curwin->w_cursor.lnum, c); 	}     }     else 	curwin->w_cursor = prev_cursor;      spell_find_cleanup(&sug); skip:     vim_free(line);     curwin->w_p_spell = wo_spell_save; }"
"213528_CWE-416.c","CWE-416","int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param) { 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc); 	struct cgroup_subsys *ss; 	struct fs_parse_result result; 	int opt, i;  	opt = fs_parse(fc, cgroup1_fs_parameters, param, &result); 	if (opt == -ENOPARAM) { 		if (strcmp(param->key, ""source"") == 0) { 			if (fc->source) 				return invalf(fc, ""Multiple sources not supported""); 			fc->source = param->string; 			param->string = NULL; 			return 0; 		} 		for_each_subsys(ss, i) { 			if (strcmp(param->key, ss->legacy_name)) 				continue; 			if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i)) 				return invalfc(fc, ""Disabled controller '%s'"", 					       param->key); 			ctx->subsys_mask |= (1 << i); 			return 0; 		} 		return invalfc(fc, ""Unknown subsys name '%s'"", param->key); 	} 	if (opt < 0) 		return opt;  	switch (opt) { 	case Opt_none: 		/* Explicitly have no subsystems */ 		ctx->none = true; 		break; 	case Opt_all: 		ctx->all_ss = true; 		break; 	case Opt_noprefix: 		ctx->flags |= CGRP_ROOT_NOPREFIX; 		break; 	case Opt_clone_children: 		ctx->cpuset_clone_children = true; 		break; 	case Opt_cpuset_v2_mode: 		ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE; 		break; 	case Opt_xattr: 		ctx->flags |= CGRP_ROOT_XATTR; 		break; 	case Opt_release_agent: 		/* Specifying two release agents is forbidden */ 		if (ctx->release_agent) 			return invalfc(fc, ""release_agent respecified""); 		ctx->release_agent = param->string; 		param->string = NULL; 		break; 	case Opt_name: 		/* blocked by boot param? */ 		if (cgroup_no_v1_named) 			return -ENOENT; 		/* Can't specify an empty name */ 		if (!param->size) 			return invalfc(fc, ""Empty name""); 		if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1) 			return invalfc(fc, ""Name too long""); 		/* Must match [\w.-]+ */ 		for (i = 0; i < param->size; i++) { 			char c = param->string[i]; 			if (isalnum(c)) 				continue; 			if ((c == '.') || (c == '-') || (c == '_')) 				continue; 			return invalfc(fc, ""Invalid name""); 		} 		/* Specifying two names is forbidden */ 		if (ctx->name) 			return invalfc(fc, ""name respecified""); 		ctx->name = param->string; 		param->string = NULL; 		break; 	} 	return 0; }"
"213589_CWE-119.c","CWE-119","process_button(struct parsed_tag *tag) {     Str tmp = NULL;     char *p, *q, *r, *qq = """";     int qlen, v;      if (cur_form_id < 0) {        char *s = ""<form_int method=internal action=none>"";        tmp = process_form(parse_tag(&s, TRUE));     }     if (tmp == NULL)        tmp = Strnew();      p = ""submit"";     parsedtag_get_value(tag, ATTR_TYPE, &p);     q = NULL;     parsedtag_get_value(tag, ATTR_VALUE, &q);     r = """";     parsedtag_get_value(tag, ATTR_NAME, &r);      v = formtype(p);     if (v == FORM_UNKNOWN)        return NULL;      if (!q) {        switch (v) {        case FORM_INPUT_SUBMIT:        case FORM_INPUT_BUTTON:            q = ""SUBMIT"";            break;        case FORM_INPUT_RESET:            q = ""RESET"";            break;        }     }     if (q) {        qq = html_quote(q);        qlen = strlen(q);     }      /*    Strcat_charp(tmp, ""<pre_int>""); */     Strcat(tmp, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" ""                        ""name=\""%s\"" value=\""%s\"">"",                        cur_hseq++, cur_form_id, html_quote(p),                        html_quote(r), qq));     return tmp; }"
"213998_CWE-119.c","CWE-119","FindEmptyObjectSlot( 		    TPMI_DH_OBJECT  *handle         // OUT: (optional) 		    ) {     UINT32               i;     OBJECT              *object;     for(i = 0; i < MAX_LOADED_OBJECTS; i++) 	{ 	    object = &s_objects[i]; 	    if(object->attributes.occupied == CLEAR) 		{ 		    if(handle) 			*handle = i + TRANSIENT_FIRST; 		    // Initialize the object attributes 		    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES)); 		    return object; 		} 	}     return NULL; }"
"214003_CWE-787.c","CWE-787","HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh) {     rfbRREHeader hdr;     int i;     CARDBPP pix;     uint8_t *ptr;     int x, y, w, h;      if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader)) 	return FALSE;      hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);      if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix))) 	return FALSE;      client->GotFillRect(client, rx, ry, rw, rh, pix);      if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8)))) 	return FALSE;      ptr = (uint8_t *)client->buffer;      for (i = 0; i < hdr.nSubrects; i++) { 	pix = *(CARDBPP *)ptr; 	ptr += BPP/8; 	x = *ptr++; 	y = *ptr++; 	w = *ptr++; 	h = *ptr++;  	client->GotFillRect(client, rx+x, ry+y, w, h, pix);     }      return TRUE; }"
"214124_CWE-125.c","CWE-125","lzw_result lzw_decode(struct lzw_ctx *ctx, 		const uint8_t ** const stack_pos_out) { 	lzw_result res; 	uint32_t code_new; 	uint32_t code_out; 	uint8_t last_value; 	uint8_t *stack_pos = ctx->stack_base; 	uint32_t clear_code = ctx->clear_code; 	uint32_t current_entry = ctx->current_entry; 	struct lzw_dictionary_entry * const table = ctx->table;  	/* Get a new code from the input */ 	res = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new); 	if (res != LZW_OK) { 		return res; 	}  	/* Handle the new code */ 	if (code_new == clear_code) { 		/* Got Clear code */ 		return lzw__clear_codes(ctx, stack_pos_out);  	} else if (code_new == ctx->eoi_code) { 		/* Got End of Information code */ 		return LZW_EOI_CODE;  	} else if (code_new > current_entry) { 		/* Code is invalid */ 		return LZW_BAD_CODE;  	} else if (code_new < current_entry) { 		/* Code is in table */ 		code_out = code_new; 		last_value = table[code_new].first_value; 	} else { 		/* Code not in table */ 		*stack_pos++ = ctx->previous_code_first; 		code_out = ctx->previous_code; 		last_value = ctx->previous_code_first; 	}  	/* Add to the dictionary, only if there's space */ 	if (current_entry < (1 << LZW_CODE_MAX)) { 		struct lzw_dictionary_entry *entry = table + current_entry; 		entry->last_value     = last_value; 		entry->first_value    = ctx->previous_code_first; 		entry->previous_entry = ctx->previous_code; 		ctx->current_entry++; 	}  	/* Ensure code size is increased, if needed. */ 	if (current_entry == ctx->current_code_size_max) { 		if (ctx->current_code_size < LZW_CODE_MAX) { 			ctx->current_code_size++; 			ctx->current_code_size_max = 					(1 << ctx->current_code_size) - 1; 		} 	}  	/* Store details of this code as ""previous code"" to the context. */ 	ctx->previous_code_first = table[code_new].first_value; 	ctx->previous_code = code_new;  	/* Put rest of data for this code on output stack. 	 * Note, in the case of ""code not in table"", the last entry of the 	 * current code has already been placed on the stack above. */ 	while (code_out > clear_code) { 		struct lzw_dictionary_entry *entry = table + code_out; 		*stack_pos++ = entry->last_value; 		code_out = entry->previous_entry; 	} 	*stack_pos++ = table[code_out].last_value;  	*stack_pos_out = stack_pos; 	return LZW_OK; }"
"214160_CWE-476.c","CWE-476","composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl) { 	struct usb_composite_dev	*cdev = get_gadget_data(gadget); 	struct usb_request		*req = cdev->req; 	int				value = -EOPNOTSUPP; 	int				status = 0; 	u16				w_index = le16_to_cpu(ctrl->wIndex); 	u8				intf = w_index & 0xFF; 	u16				w_value = le16_to_cpu(ctrl->wValue); 	u16				w_length = le16_to_cpu(ctrl->wLength); 	struct usb_function		*f = NULL; 	u8				endp;  	if (w_length > USB_COMP_EP0_BUFSIZ) { 		if (ctrl->bRequestType & USB_DIR_IN) { 			/* Cast away the const, we are going to overwrite on purpose. */ 			__le16 *temp = (__le16 *)&ctrl->wLength;  			*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ); 			w_length = USB_COMP_EP0_BUFSIZ; 		} else { 			goto done; 		} 	}  	/* partial re-init of the response message; the function or the 	 * gadget might need to intercept e.g. a control-OUT completion 	 * when we delegate to it. 	 */ 	req->zero = 0; 	req->context = cdev; 	req->complete = composite_setup_complete; 	req->length = 0; 	gadget->ep0->driver_data = cdev;  	/* 	 * Don't let non-standard requests match any of the cases below 	 * by accident. 	 */ 	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD) 		goto unknown;  	switch (ctrl->bRequest) {  	/* we handle all standard USB descriptors */ 	case USB_REQ_GET_DESCRIPTOR: 		if (ctrl->bRequestType != USB_DIR_IN) 			goto unknown; 		switch (w_value >> 8) {  		case USB_DT_DEVICE: 			cdev->desc.bNumConfigurations = 				count_configs(cdev, USB_DT_DEVICE); 			cdev->desc.bMaxPacketSize0 = 				cdev->gadget->ep0->maxpacket; 			if (gadget_is_superspeed(gadget)) { 				if (gadget->speed >= USB_SPEED_SUPER) { 					cdev->desc.bcdUSB = cpu_to_le16(0x0320); 					cdev->desc.bMaxPacketSize0 = 9; 				} else { 					cdev->desc.bcdUSB = cpu_to_le16(0x0210); 				} 			} else { 				if (gadget->lpm_capable) 					cdev->desc.bcdUSB = cpu_to_le16(0x0201); 				else 					cdev->desc.bcdUSB = cpu_to_le16(0x0200); 			}  			value = min(w_length, (u16) sizeof cdev->desc); 			memcpy(req->buf, &cdev->desc, value); 			break; 		case USB_DT_DEVICE_QUALIFIER: 			if (!gadget_is_dualspeed(gadget) || 			    gadget->speed >= USB_SPEED_SUPER) 				break; 			device_qual(cdev); 			value = min_t(int, w_length, 				sizeof(struct usb_qualifier_descriptor)); 			break; 		case USB_DT_OTHER_SPEED_CONFIG: 			if (!gadget_is_dualspeed(gadget) || 			    gadget->speed >= USB_SPEED_SUPER) 				break; 			fallthrough; 		case USB_DT_CONFIG: 			value = config_desc(cdev, w_value); 			if (value >= 0) 				value = min(w_length, (u16) value); 			break; 		case USB_DT_STRING: 			value = get_string(cdev, req->buf, 					w_index, w_value & 0xff); 			if (value >= 0) 				value = min(w_length, (u16) value); 			break; 		case USB_DT_BOS: 			if (gadget_is_superspeed(gadget) || 			    gadget->lpm_capable) { 				value = bos_desc(cdev); 				value = min(w_length, (u16) value); 			} 			break; 		case USB_DT_OTG: 			if (gadget_is_otg(gadget)) { 				struct usb_configuration *config; 				int otg_desc_len = 0;  				if (cdev->config) 					config = cdev->config; 				else 					config = list_first_entry( 							&cdev->configs, 						struct usb_configuration, list); 				if (!config) 					goto done;  				if (gadget->otg_caps && 					(gadget->otg_caps->otg_rev >= 0x0200)) 					otg_desc_len += sizeof( 						struct usb_otg20_descriptor); 				else 					otg_desc_len += sizeof( 						struct usb_otg_descriptor);  				value = min_t(int, w_length, otg_desc_len); 				memcpy(req->buf, config->descriptors[0], value); 			} 			break; 		} 		break;  	/* any number of configs can work */ 	case USB_REQ_SET_CONFIGURATION: 		if (ctrl->bRequestType != 0) 			goto unknown; 		if (gadget_is_otg(gadget)) { 			if (gadget->a_hnp_support) 				DBG(cdev, ""HNP available\n""); 			else if (gadget->a_alt_hnp_support) 				DBG(cdev, ""HNP on another port\n""); 			else 				VDBG(cdev, ""HNP inactive\n""); 		} 		spin_lock(&cdev->lock); 		value = set_config(cdev, ctrl, w_value); 		spin_unlock(&cdev->lock); 		break; 	case USB_REQ_GET_CONFIGURATION: 		if (ctrl->bRequestType != USB_DIR_IN) 			goto unknown; 		if (cdev->config) 			*(u8 *)req->buf = cdev->config->bConfigurationValue; 		else 			*(u8 *)req->buf = 0; 		value = min(w_length, (u16) 1); 		break;  	/* function drivers must handle get/set altsetting */ 	case USB_REQ_SET_INTERFACE: 		if (ctrl->bRequestType != USB_RECIP_INTERFACE) 			goto unknown; 		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES) 			break; 		f = cdev->config->interface[intf]; 		if (!f) 			break;  		/* 		 * If there's no get_alt() method, we know only altsetting zero 		 * works. There is no need to check if set_alt() is not NULL 		 * as we check this in usb_add_function(). 		 */ 		if (w_value && !f->get_alt) 			break;  		spin_lock(&cdev->lock); 		value = f->set_alt(f, w_index, w_value); 		if (value == USB_GADGET_DELAYED_STATUS) { 			DBG(cdev, 			 ""%s: interface %d (%s) requested delayed status\n"", 					__func__, intf, f->name); 			cdev->delayed_status++; 			DBG(cdev, ""delayed_status count %d\n"", 					cdev->delayed_status); 		} 		spin_unlock(&cdev->lock); 		break; 	case USB_REQ_GET_INTERFACE: 		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE)) 			goto unknown; 		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES) 			break; 		f = cdev->config->interface[intf]; 		if (!f) 			break; 		/* lots of interfaces only need altsetting zero... */ 		value = f->get_alt ? f->get_alt(f, w_index) : 0; 		if (value < 0) 			break; 		*((u8 *)req->buf) = value; 		value = min(w_length, (u16) 1); 		break; 	case USB_REQ_GET_STATUS: 		if (gadget_is_otg(gadget) && gadget->hnp_polling_support && 						(w_index == OTG_STS_SELECTOR)) { 			if (ctrl->bRequestType != (USB_DIR_IN | 							USB_RECIP_DEVICE)) 				goto unknown; 			*((u8 *)req->buf) = gadget->host_request_flag; 			value = 1; 			break; 		}  		/* 		 * USB 3.0 additions: 		 * Function driver should handle get_status request. If such cb 		 * wasn't supplied we respond with default value = 0 		 * Note: function driver should supply such cb only for the 		 * first interface of the function 		 */ 		if (!gadget_is_superspeed(gadget)) 			goto unknown; 		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE)) 			goto unknown; 		value = 2;	/* This is the length of the get_status reply */ 		put_unaligned_le16(0, req->buf); 		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES) 			break; 		f = cdev->config->interface[intf]; 		if (!f) 			break; 		status = f->get_status ? f->get_status(f) : 0; 		if (status < 0) 			break; 		put_unaligned_le16(status & 0x0000ffff, req->buf); 		break; 	/* 	 * Function drivers should handle SetFeature/ClearFeature 	 * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied 	 * only for the first interface of the function 	 */ 	case USB_REQ_CLEAR_FEATURE: 	case USB_REQ_SET_FEATURE: 		if (!gadget_is_superspeed(gadget)) 			goto unknown; 		if (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE)) 			goto unknown; 		switch (w_value) { 		case USB_INTRF_FUNC_SUSPEND: 			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES) 				break; 			f = cdev->config->interface[intf]; 			if (!f) 				break; 			value = 0; 			if (f->func_suspend) 				value = f->func_suspend(f, w_index >> 8); 			if (value < 0) { 				ERROR(cdev, 				      ""func_suspend() returned error %d\n"", 				      value); 				value = 0; 			} 			break; 		} 		break; 	default: unknown: 		/* 		 * OS descriptors handling 		 */ 		if (cdev->use_os_string && cdev->os_desc_config && 		    (ctrl->bRequestType & USB_TYPE_VENDOR) && 		    ctrl->bRequest == cdev->b_vendor_code) { 			struct usb_configuration	*os_desc_cfg; 			u8				*buf; 			int				interface; 			int				count = 0;  			req = cdev->os_desc_req; 			req->context = cdev; 			req->complete = composite_setup_complete; 			buf = req->buf; 			os_desc_cfg = cdev->os_desc_config; 			w_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ); 			memset(buf, 0, w_length); 			buf[5] = 0x01; 			switch (ctrl->bRequestType & USB_RECIP_MASK) { 			case USB_RECIP_DEVICE: 				if (w_index != 0x4 || (w_value >> 8)) 					break; 				buf[6] = w_index; 				/* Number of ext compat interfaces */ 				count = count_ext_compat(os_desc_cfg); 				buf[8] = count; 				count *= 24; /* 24 B/ext compat desc */ 				count += 16; /* header */ 				put_unaligned_le32(count, buf); 				value = w_length; 				if (w_length > 0x10) { 					value = fill_ext_compat(os_desc_cfg, buf); 					value = min_t(u16, w_length, value); 				} 				break; 			case USB_RECIP_INTERFACE: 				if (w_index != 0x5 || (w_value >> 8)) 					break; 				interface = w_value & 0xFF; 				buf[6] = w_index; 				count = count_ext_prop(os_desc_cfg, 					interface); 				put_unaligned_le16(count, buf + 8); 				count = len_ext_prop(os_desc_cfg, 					interface); 				put_unaligned_le32(count, buf); 				value = w_length; 				if (w_length > 0x0A) { 					value = fill_ext_prop(os_desc_cfg, 							      interface, buf); 					if (value >= 0) 						value = min_t(u16, w_length, value); 				} 				break; 			}  			goto check_value; 		}  		VDBG(cdev, 			""non-core control req%02x.%02x v%04x i%04x l%d\n"", 			ctrl->bRequestType, ctrl->bRequest, 			w_value, w_index, w_length);  		/* functions always handle their interfaces and endpoints... 		 * punt other recipients (other, WUSB, ...) to the current 		 * configuration code. 		 */ 		if (cdev->config) { 			list_for_each_entry(f, &cdev->config->functions, list) 				if (f->req_match && 				    f->req_match(f, ctrl, false)) 					goto try_fun_setup; 		} else { 			struct usb_configuration *c; 			list_for_each_entry(c, &cdev->configs, list) 				list_for_each_entry(f, &c->functions, list) 					if (f->req_match && 					    f->req_match(f, ctrl, true)) 						goto try_fun_setup; 		} 		f = NULL;  		switch (ctrl->bRequestType & USB_RECIP_MASK) { 		case USB_RECIP_INTERFACE: 			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES) 				break; 			f = cdev->config->interface[intf]; 			break;  		case USB_RECIP_ENDPOINT: 			if (!cdev->config) 				break; 			endp = ((w_index & 0x80) >> 3) | (w_index & 0x0f); 			list_for_each_entry(f, &cdev->config->functions, list) { 				if (test_bit(endp, f->endpoints)) 					break; 			} 			if (&f->list == &cdev->config->functions) 				f = NULL; 			break; 		} try_fun_setup: 		if (f && f->setup) 			value = f->setup(f, ctrl); 		else { 			struct usb_configuration	*c;  			c = cdev->config; 			if (!c) 				goto done;  			/* try current config's setup */ 			if (c->setup) { 				value = c->setup(c, ctrl); 				goto done; 			}  			/* try the only function in the current config */ 			if (!list_is_singular(&c->functions)) 				goto done; 			f = list_first_entry(&c->functions, struct usb_function, 					     list); 			if (f->setup) 				value = f->setup(f, ctrl); 		}  		goto done; 	}  check_value: 	/* respond with data transfer before status phase? */ 	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) { 		req->length = value; 		req->context = cdev; 		req->zero = value < w_length; 		value = composite_ep0_queue(cdev, req, GFP_ATOMIC); 		if (value < 0) { 			DBG(cdev, ""ep_queue --> %d\n"", value); 			req->status = 0; 			composite_setup_complete(gadget->ep0, req); 		} 	} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) { 		WARN(cdev, 			""%s: Delayed status not supported for w_length != 0"", 			__func__); 	}  done: 	/* device either stalls (value < 0) or reports success */ 	return value; }"
"214272_CWE-787.c","CWE-787","find_next_quote(     char_u	*line,     int		col,     int		quotechar,     char_u	*escape)	// escape characters, can be NULL {     int		c;      for (;;)     { 	c = line[col]; 	if (c == NUL) 	    return -1; 	else if (escape != NULL && vim_strchr(escape, c)) 	    ++col; 	else if (c == quotechar) 	    break; 	if (has_mbyte) 	    col += (*mb_ptr2len)(line + col); 	else 	    ++col;     }     return col; }"
"214276_CWE-20.c","CWE-20","static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr) { 	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx; 	struct tipc_aead_key *skey = NULL; 	u16 key_gen = msg_key_gen(hdr); 	u16 size = msg_data_sz(hdr); 	u8 *data = msg_data(hdr);  	spin_lock(&rx->lock); 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) { 		pr_err(""%s: key existed <%p>, gen %d vs %d\n"", rx->name, 		       rx->skey, key_gen, rx->key_gen); 		goto exit; 	}  	/* Allocate memory for the key */ 	skey = kmalloc(size, GFP_ATOMIC); 	if (unlikely(!skey)) { 		pr_err(""%s: unable to allocate memory for skey\n"", rx->name); 		goto exit; 	}  	/* Copy key from msg data */ 	skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME))); 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME); 	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32), 	       skey->keylen);  	/* Sanity check */ 	if (unlikely(size != tipc_aead_key_size(skey))) { 		kfree(skey); 		skey = NULL; 		goto exit; 	}  	rx->key_gen = key_gen; 	rx->skey_mode = msg_key_mode(hdr); 	rx->skey = skey; 	rx->nokey = 0; 	mb(); /* for nokey flag */  exit: 	spin_unlock(&rx->lock);  	/* Schedule the key attaching on this crypto */ 	if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0))) 		return true;  	return false; }"
"214282_CWE-787.cpp","CWE-787","R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { 	RBinJavaClassesAttribute *icattr; 	RBinJavaAttrInfo *attr = NULL; 	RBinJavaCPTypeObj *obj; 	ut32 i = 0; 	ut64 offset = 0, curpos; 	attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); 	offset += 6; 	if (attr == NULL) { 		// TODO eprintf 		return attr; 	} 	attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR; 	attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset); 	offset += 2; 	attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free); 	for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) { 		curpos = buf_offset + offset; 		if (offset + 8 > sz) { 			eprintf (""Invalid amount of inner classes\n""); 			break; 		} 		icattr = R_NEW0 (RBinJavaClassesAttribute); 		if (!icattr) { 			break; 		} 		icattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		icattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		icattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		icattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset); 		offset += 2; 		icattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags); 		icattr->file_offset = curpos; 		icattr->size = 8;  		obj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx); 		if (obj == NULL) { 			eprintf (""BINCPLIS IS HULL %d\n"", icattr->inner_name_idx); 		} 		icattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj); 		if (!icattr->name) { 			obj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx); 			if (!obj) { 				eprintf (""BINCPLIST IS NULL %d\n"", icattr->inner_class_info_idx); 			} 			icattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj); 			if (!icattr->name) { 				icattr->name = r_str_dup (NULL, ""NULL""); 				eprintf (""r_bin_java_inner_classes_attr: Unable to find the name for %d index.\n"", icattr->inner_name_idx); 				free (icattr); 				break; 			} 		}  		IFDBG eprintf(""r_bin_java_inner_classes_attr: Inner class name %d is %s.\n"", icattr->inner_name_idx, icattr->name); 		r_list_append (attr->info.inner_classes_attr.classes, (void *) icattr); 	} 	attr->size = offset; 	// IFDBG r_bin_java_print_inner_classes_attr_summary(attr); 	return attr; }"
"214335_CWE-79.cc","CWE-79","int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs, 					      off_t bl_len) {   const char *content_type = NULL;   string content_type_str;   map<string, string> response_attrs;   map<string, string>::iterator riter;   bufferlist metadata_bl;    string expires = get_s3_expiration_header(s, lastmod);    if (sent_header)     goto send_data;    if (custom_http_ret) {     set_req_state_err(s, 0);     dump_errno(s, custom_http_ret);   } else {     set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT                   : op_ret);     dump_errno(s);   }    if (op_ret)     goto done;    if (range_str)     dump_range(s, start, end, s->obj_size);    if (s->system_request &&       s->info.args.exists(RGW_SYS_PARAM_PREFIX ""prepend-metadata"")) {      dump_header(s, ""Rgwx-Object-Size"", (long long)total_len);      if (rgwx_stat) {       /*        * in this case, we're not returning the object's content, only the prepended        * extra metadata        */       total_len = 0;     }      /* JSON encode object metadata */     JSONFormatter jf;     jf.open_object_section(""obj_metadata"");     encode_json(""attrs"", attrs, &jf);     utime_t ut(lastmod);     encode_json(""mtime"", ut, &jf);     jf.close_section();     stringstream ss;     jf.flush(ss);     metadata_bl.append(ss.str());     dump_header(s, ""Rgwx-Embedded-Metadata-Len"", metadata_bl.length());     total_len += metadata_bl.length();   }    if (s->system_request && !real_clock::is_zero(lastmod)) {     /* we end up dumping mtime in two different methods, a bit redundant */     dump_epoch_header(s, ""Rgwx-Mtime"", lastmod);     uint64_t pg_ver = 0;     int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);     if (r < 0) {       ldpp_dout(this, 0) << ""ERROR: failed to decode pg ver attr, ignoring"" << dendl;     }     dump_header(s, ""Rgwx-Obj-PG-Ver"", pg_ver);      uint32_t source_zone_short_id = 0;     r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);     if (r < 0) {       ldpp_dout(this, 0) << ""ERROR: failed to decode pg ver attr, ignoring"" << dendl;     }     if (source_zone_short_id != 0) {       dump_header(s, ""Rgwx-Source-Zone-Short-Id"", source_zone_short_id);     }   }    for (auto &it : crypt_http_responses)     dump_header(s, it.first, it.second);    dump_content_length(s, total_len);   dump_last_modified(s, lastmod);   dump_header_if_nonempty(s, ""x-amz-version-id"", version_id);   dump_header_if_nonempty(s, ""x-amz-expiration"", expires);    if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {     dump_header(s, ""x-rgw-object-type"", ""Appendable"");     dump_header(s, ""x-rgw-next-append-position"", s->obj_size);   } else {     dump_header(s, ""x-rgw-object-type"", ""Normal"");   }    if (! op_ret) {     if (! lo_etag.empty()) {       /* Handle etag of Swift API's large objects (DLO/SLO). It's entirerly        * legit to perform GET on them through S3 API. In such situation,        * a client should receive the composited content with corresponding        * etag value. */       dump_etag(s, lo_etag);     } else {       auto iter = attrs.find(RGW_ATTR_ETAG);       if (iter != attrs.end()) {         dump_etag(s, iter->second.to_str());       }     }      for (struct response_attr_param *p = resp_attr_params; p->param; p++) {       bool exists;       string val = s->info.args.get(p->param, &exists);       if (exists) { 	/* reject unauthenticated response header manipulation, see 	 * https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html */ 	if (s->auth.identity->is_anonymous()) { 	  return -ERR_INVALID_REQUEST; 	} 	if (strcmp(p->param, ""response-content-type"") != 0) { 	  response_attrs[p->http_attr] = val; 	} else { 	  content_type_str = val; 	  content_type = content_type_str.c_str(); 	}       }     }      for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {       const char *name = iter->first.c_str();       map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);       if (aiter != rgw_to_http_attrs.end()) {         if (response_attrs.count(aiter->second) == 0) {           /* Was not already overridden by a response param. */            size_t len = iter->second.length();           string s(iter->second.c_str(), len);           while (len && !s[len - 1]) {             --len;             s.resize(len);           }           response_attrs[aiter->second] = s;         }       } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {         /* Special handling for content_type. */         if (!content_type) {           content_type_str = rgw_bl_str(iter->second);           content_type = content_type_str.c_str();         }       } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {         // this attr has an extra length prefix from encode() in prior versions         dump_header(s, ""X-Object-Meta-Static-Large-Object"", ""True"");       } else if (strncmp(name, RGW_ATTR_META_PREFIX, 			 sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {         /* User custom metadata. */         name += sizeof(RGW_ATTR_PREFIX) - 1;         dump_header(s, name, iter->second);       } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {         RGWObjTags obj_tags;         try{           auto it = iter->second.cbegin();           obj_tags.decode(it);         } catch (buffer::error &err) {           ldpp_dout(this,0) << ""Error caught buffer::error couldn't decode TagSet "" << dendl;         }         dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());       } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){         RGWObjectRetention retention;         try {           decode(retention, iter->second);           dump_header(s, ""x-amz-object-lock-mode"", retention.get_mode());           dump_time_header(s, ""x-amz-object-lock-retain-until-date"", retention.get_retain_until_date());         } catch (buffer::error& err) {           ldpp_dout(this, 0) << ""ERROR: failed to decode RGWObjectRetention"" << dendl;         }       } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {         RGWObjectLegalHold legal_hold;         try {           decode(legal_hold, iter->second);           dump_header(s, ""x-amz-object-lock-legal-hold"",legal_hold.get_status());         } catch (buffer::error& err) {           ldpp_dout(this, 0) << ""ERROR: failed to decode RGWObjectLegalHold"" << dendl;         }       }     }   }  done:   for (riter = response_attrs.begin(); riter != response_attrs.end();        ++riter) {     dump_header(s, riter->first, riter->second);   }    if (op_ret == -ERR_NOT_MODIFIED) {       end_header(s, this);   } else {       if (!content_type)           content_type = ""binary/octet-stream"";        end_header(s, this, content_type);   }    if (metadata_bl.length()) {     dump_body(s, metadata_bl);   }   sent_header = true;  send_data:   if (get_data && !op_ret) {     int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);     if (r < 0)       return r;   }    return 0; }"
"214336_CWE-362.c","CWE-362","static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs) { 	struct pfkey_sock *pfk = pfkey_sk(sk); 	struct sk_buff *supp_skb;  	if (hdr->sadb_msg_satype > SADB_SATYPE_MAX) 		return -EINVAL;  	if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) { 		if (pfk->registered&(1<<hdr->sadb_msg_satype)) 			return -EEXIST; 		pfk->registered |= (1<<hdr->sadb_msg_satype); 	}  	xfrm_probe_algs();  	supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO); 	if (!supp_skb) { 		if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) 			pfk->registered &= ~(1<<hdr->sadb_msg_satype);  		return -ENOBUFS; 	}  	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, 			sock_net(sk)); 	return 0; }"
"214339_CWE-787.c","CWE-787","int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu) { 	struct rtas_token_definition *d; 	struct rtas_args args; 	rtas_arg_t *orig_rets; 	gpa_t args_phys; 	int rc;  	/* 	 * r4 contains the guest physical address of the RTAS args 	 * Mask off the top 4 bits since this is a guest real address 	 */ 	args_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;  	vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu); 	rc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args)); 	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx); 	if (rc) 		goto fail;  	/* 	 * args->rets is a pointer into args->args. Now that we've 	 * copied args we need to fix it up to point into our copy, 	 * not the guest args. We also need to save the original 	 * value so we can restore it on the way out. 	 */ 	orig_rets = args.rets; 	args.rets = &args.args[be32_to_cpu(args.nargs)];  	mutex_lock(&vcpu->kvm->arch.rtas_token_lock);  	rc = -ENOENT; 	list_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) { 		if (d->token == be32_to_cpu(args.token)) { 			d->handler->handler(vcpu, &args); 			rc = 0; 			break; 		} 	}  	mutex_unlock(&vcpu->kvm->arch.rtas_token_lock);  	if (rc == 0) { 		args.rets = orig_rets; 		rc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args)); 		if (rc) 			goto fail; 	}  	return rc;  fail: 	/* 	 * We only get here if the guest has called RTAS with a bogus 	 * args pointer. That means we can't get to the args, and so we 	 * can't fail the RTAS call. So fail right out to userspace, 	 * which should kill the guest. 	 */ 	return rc; }"
"214358_CWE-20.c","CWE-20","int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {   unsigned int frame_start, frame_end, window_posn, match_offset, range;   unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;   int i, j, selector, extra, sym, match_length, ret;   unsigned short H, L, C, symf;    register unsigned int bit_buffer;   register unsigned char bits_left;   unsigned char bits_needed, bit_run;    /* easy answers */   if (!qtm || (out_bytes < 0)) return CL_ENULLARG;   if (qtm->error) return qtm->error;    /* flush out any stored-up bytes before we begin */   i = qtm->o_end - qtm->o_ptr;   if ((off_t) i > out_bytes) i = (int) out_bytes;   if (i) {     if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {       return qtm->error = ret;     }     qtm->o_ptr  += i;     out_bytes   -= i;   }   if (out_bytes == 0) return CL_SUCCESS;    /* restore local state */   QTM_RESTORE_BITS;   window = qtm->window;   window_posn = qtm->window_posn;   frame_start = qtm->frame_start;   H = qtm->H;   L = qtm->L;   C = qtm->C;    /* while we do not have enough decoded bytes in reserve: */   while ((qtm->o_end - qtm->o_ptr) < out_bytes) {      /* read header if necessary. Initialises H, L and C */     if (!qtm->header_read) {       H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);       qtm->header_read = 1;     }      /* decode more, at most up to to frame boundary */     frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));     if ((frame_start + QTM_FRAME_SIZE) < frame_end) {       frame_end = frame_start + QTM_FRAME_SIZE;     }      while (window_posn < frame_end) {       QTM_GET_SYMBOL(qtm->model7, selector);       if (selector < 4) { 	struct qtm_model *mdl = (selector == 0) ? &qtm->model0 : 	                        ((selector == 1) ? &qtm->model1 : 				((selector == 2) ? &qtm->model2 :                                                    &qtm->model3)); 	QTM_GET_SYMBOL((*mdl), sym); 	window[window_posn++] = sym;       }       else { 	switch (selector) { 	case 4: /* selector 4 = fixed length match (3 bytes) */ 	  QTM_GET_SYMBOL(qtm->model4, sym); 	  QTM_READ_BITS(extra, qtm->extra_bits[sym]); 	  match_offset = qtm->position_base[sym] + extra + 1; 	  match_length = 3; 	  break;  	case 5: /* selector 5 = fixed length match (4 bytes) */ 	  QTM_GET_SYMBOL(qtm->model5, sym); 	  QTM_READ_BITS(extra, qtm->extra_bits[sym]); 	  match_offset = qtm->position_base[sym] + extra + 1; 	  match_length = 4; 	  break;  	case 6: /* selector 6 = variable length match */ 	  QTM_GET_SYMBOL(qtm->model6len, sym); 	  QTM_READ_BITS(extra, qtm->length_extra[sym]); 	  match_length = qtm->length_base[sym] + extra + 5;  	  QTM_GET_SYMBOL(qtm->model6, sym); 	  QTM_READ_BITS(extra, qtm->extra_bits[sym]); 	  match_offset = qtm->position_base[sym] + extra + 1; 	  break;  	default: 	  /* should be impossible, model7 can only return 0-6 */ 	  return qtm->error = CL_EFORMAT; 	}  	rundest = &window[window_posn]; 	i = match_length; 	/* does match offset wrap the window? */ 	if (match_offset > window_posn) { 	  /* j = length from match offset to end of window */ 	  j = match_offset - window_posn; 	  if (j > (int) qtm->window_size) { 	    cli_dbgmsg(""qtm_decompress: match offset beyond window boundaries\n""); 	    return qtm->error = CL_EFORMAT; 	  } 	  runsrc = &window[qtm->window_size - j]; 	  if (j < i) { 	    /* if match goes over the window edge, do two copy runs */ 	    i -= j; while (j-- > 0) *rundest++ = *runsrc++; 	    runsrc = window; 	  } 	  while (i-- > 0) *rundest++ = *runsrc++; 	} 	else { 	  runsrc = rundest - match_offset; 	  if(i > (int) (qtm->window_size - window_posn)) 	    i = qtm->window_size - window_posn; 	  while (i-- > 0) *rundest++ = *runsrc++; 	} 	window_posn += match_length;       }     } /* while (window_posn < frame_end) */      qtm->o_end = &window[window_posn];      /* another frame completed? */     if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {       if ((window_posn - frame_start) != QTM_FRAME_SIZE) { 	cli_dbgmsg(""qtm_decompress: overshot frame alignment\n""); 	return qtm->error = CL_EFORMAT;       }        /* re-align input */       if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);       do { QTM_READ_BITS(i, 8); } while (i != 0xFF);       qtm->header_read = 0;        /* window wrap? */       if (window_posn == qtm->window_size) { 	/* flush all currently stored data */ 	i = (qtm->o_end - qtm->o_ptr); 	if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) { 	  return qtm->error = ret; 	} 	out_bytes -= i; 	qtm->o_ptr = &window[0]; 	qtm->o_end = &window[0]; 	window_posn = 0;       }        frame_start = window_posn;     }    } /* while (more bytes needed) */    if (out_bytes) {     i = (int) out_bytes;     if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {       return qtm->error = ret;     }     qtm->o_ptr += i;   }    /* store local state */   QTM_STORE_BITS;   qtm->window_posn = window_posn;   qtm->frame_start = frame_start;   qtm->H = H;   qtm->L = L;   qtm->C = C;    return CL_SUCCESS; }"
"214364_CWE-119.c","CWE-119","void simplestring_addn(simplestring* target, const char* source, int add_len) {    if(target && source) {       if(!target->str) {          simplestring_init_str(target);       }       if(target->len + add_len + 1 > target->size) {          /* newsize is current length + new length */          int newsize = target->len + add_len + 1;          int incr = target->size * 2;           /* align to SIMPLESTRING_INCR increments */          newsize = newsize - (newsize % incr) + incr;          target->str = (char*)realloc(target->str, newsize);           target->size = target->str ? newsize : 0;       }        if(target->str) {          if(add_len) {             memcpy(target->str + target->len, source, add_len);          }          target->len += add_len;          target->str[target->len] = 0; /* null terminate */       }    } }"
"214909_CWE-401.c","CWE-401","static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size) { 	struct mlx5_fpga_device *fdev = conn->fdev; 	struct mlx5_core_dev *mdev = fdev->mdev; 	u32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0}; 	u32 out[MLX5_ST_SZ_DW(create_cq_out)]; 	struct mlx5_wq_param wqp; 	struct mlx5_cqe64 *cqe; 	int inlen, err, eqn; 	unsigned int irqn; 	void *cqc, *in; 	__be64 *pas; 	u32 i;  	cq_size = roundup_pow_of_two(cq_size); 	MLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));  	wqp.buf_numa_node = mdev->priv.numa_node; 	wqp.db_numa_node  = mdev->priv.numa_node;  	err = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq, 			       &conn->cq.wq_ctrl); 	if (err) 		return err;  	for (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) { 		cqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i); 		cqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK; 	}  	inlen = MLX5_ST_SZ_BYTES(create_cq_in) + 		sizeof(u64) * conn->cq.wq_ctrl.buf.npages; 	in = kvzalloc(inlen, GFP_KERNEL); 	if (!in) { 		err = -ENOMEM; 		goto err_cqwq; 	}  	err = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn); 	if (err) 		goto err_cqwq;  	cqc = MLX5_ADDR_OF(create_cq_in, in, cq_context); 	MLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size)); 	MLX5_SET(cqc, cqc, c_eqn, eqn); 	MLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index); 	MLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift - 			   MLX5_ADAPTER_PAGE_SHIFT); 	MLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);  	pas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas); 	mlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);  	err = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out)); 	kvfree(in);  	if (err) 		goto err_cqwq;  	conn->cq.mcq.cqe_sz     = 64; 	conn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db; 	conn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1; 	*conn->cq.mcq.set_ci_db = 0; 	*conn->cq.mcq.arm_db    = 0; 	conn->cq.mcq.vector     = 0; 	conn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete; 	conn->cq.mcq.event      = mlx5_fpga_conn_cq_event; 	conn->cq.mcq.irqn       = irqn; 	conn->cq.mcq.uar        = fdev->conn_res.uar; 	tasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet, 		     (unsigned long)conn);  	mlx5_fpga_dbg(fdev, ""Created CQ #0x%x\n"", conn->cq.mcq.cqn);  	goto out;  err_cqwq: 	mlx5_wq_destroy(&conn->cq.wq_ctrl); out: 	return err; }"
"214948_CWE-476.c","CWE-476","static int qh_help(int sd, char *buf, unsigned int len) { 	struct query_handler *qh = NULL;  	if (!*buf || !strcmp(buf, ""help"")) { 		nsock_printf_nul(sd, 			""  help <name>   show help for handler <name>\n"" 			""  help list     list registered handlers\n""); 		return 0; 	}  	if (!strcmp(buf, ""list"")) {  		for (qh = qhandlers; qh != NULL; qh = qh->next_qh) { 			nsock_printf(sd, ""%-10s %s\n"", qh->name, qh->description ? qh->description : ""(No description available)""); 		}  		nsock_printf(sd, ""%c"", 0); 		return 0; 	}  	qh = qh_find_handler(buf); 	if (qh == NULL) {  		nsock_printf_nul(sd, ""No handler named '%s' is registered\n"", buf);  	} else if (qh->handler(sd, ""help"", 4) > 200) {  		nsock_printf_nul(sd, ""The handler %s doesn't have any help yet."", buf); 	}  	return 0; }"
"214997_CWE-787.c","CWE-787","compileRule(FileInfo *file, TranslationTableHeader **table, 		DisplayTableHeader **displayTable, const MacroList **inScopeMacros) { 	CharsString token; 	TranslationTableOpcode opcode; 	CharsString ruleChars; 	CharsString ruleDots; 	CharsString cells; 	CharsString scratchPad; 	CharsString emphClass; 	TranslationTableCharacterAttributes after = 0; 	TranslationTableCharacterAttributes before = 0; 	int noback, nofor, nocross; 	noback = nofor = nocross = 0; doOpcode: 	if (!getToken(file, &token, NULL)) return 1;				  /* blank line */ 	if (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */ 	if (file->lineNumber == 1 && 			(eqasc2uni((unsigned char *)""ISO"", token.chars, 3) || 					eqasc2uni((unsigned char *)""UTF-8"", token.chars, 5))) { 		if (table) 			compileHyphenation(file, &token, table); 		else 			/* ignore the whole file */ 			while (_lou_getALine(file)) 				; 		return 1; 	} 	opcode = getOpcode(file, &token); 	switch (opcode) { 	case CTO_Macro: { 		const Macro *macro; #ifdef ENABLE_MACROS 		if (!inScopeMacros) { 			compileError(file, ""Defining macros only allowed in table files.""); 			return 0; 		} 		if (compileMacro(file, &macro)) { 			*inScopeMacros = cons_macro(macro, *inScopeMacros); 			return 1; 		} 		return 0; #else 		compileError(file, ""Macro feature is disabled.""); 		return 0; #endif 	} 	case CTO_IncludeFile: { 		CharsString includedFile; 		if (!getToken(file, &token, ""include file name"")) return 0; 		if (!parseChars(file, &includedFile, &token)) return 0; 		return includeFile(file, &includedFile, table, displayTable); 	} 	case CTO_NoBack: 		if (nofor) { 			compileError(file, ""%s already specified."", _lou_findOpcodeName(CTO_NoFor)); 			return 0; 		} 		noback = 1; 		goto doOpcode; 	case CTO_NoFor: 		if (noback) { 			compileError(file, ""%s already specified."", _lou_findOpcodeName(CTO_NoBack)); 			return 0; 		} 		nofor = 1; 		goto doOpcode; 	case CTO_Space: 		return compileCharDef( 				file, opcode, CTC_Space, noback, nofor, table, displayTable); 	case CTO_Digit: 		return compileCharDef( 				file, opcode, CTC_Digit, noback, nofor, table, displayTable); 	case CTO_LitDigit: 		return compileCharDef( 				file, opcode, CTC_LitDigit, noback, nofor, table, displayTable); 	case CTO_Punctuation: 		return compileCharDef( 				file, opcode, CTC_Punctuation, noback, nofor, table, displayTable); 	case CTO_Math: 		return compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable); 	case CTO_Sign: 		return compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable); 	case CTO_Letter: 		return compileCharDef( 				file, opcode, CTC_Letter, noback, nofor, table, displayTable); 	case CTO_UpperCase: 		return compileCharDef( 				file, opcode, CTC_UpperCase, noback, nofor, table, displayTable); 	case CTO_LowerCase: 		return compileCharDef( 				file, opcode, CTC_LowerCase, noback, nofor, table, displayTable); 	case CTO_Grouping: 		return compileGrouping(file, noback, nofor, table, displayTable); 	case CTO_Display: 		if (!displayTable) return 1;  // ignore 		if (!getRuleCharsText(file, &ruleChars)) return 0; 		if (!getRuleDotsPattern(file, &ruleDots)) return 0; 		if (ruleChars.length != 1 || ruleDots.length != 1) { 			compileError(file, ""Exactly one character and one cell are required.""); 			return 0; 		} 		return putCharDotsMapping( 				file, ruleChars.chars[0], ruleDots.chars[0], displayTable); 	case CTO_UpLow: 	case CTO_None: { 		// check if token is a macro name 		if (inScopeMacros) { 			const MacroList *macros = *inScopeMacros; 			while (macros) { 				const Macro *m = macros->head; 				if (token.length == strlen(m->name) && 						eqasc2uni((unsigned char *)m->name, token.chars, token.length)) { 					if (!inScopeMacros) { 						compileError(file, ""Calling macros only allowed in table files.""); 						return 0; 					} 					FileInfo tmpFile; 					memset(&tmpFile, 0, sizeof(tmpFile)); 					tmpFile.fileName = file->fileName; 					tmpFile.sourceFile = file->sourceFile; 					tmpFile.lineNumber = file->lineNumber; 					tmpFile.encoding = noEncoding; 					tmpFile.status = 0; 					tmpFile.linepos = 0; 					tmpFile.linelen = 0; 					int argument_count = 0; 					CharsString *arguments = 							malloc(m->argument_count * sizeof(CharsString)); 					while (argument_count < m->argument_count) { 						if (getToken(file, &token, ""macro argument"")) 							arguments[argument_count++] = token; 						else 							break; 					} 					if (argument_count < m->argument_count) { 						compileError(file, ""Expected %d arguments"", m->argument_count); 						return 0; 					} 					int i = 0; 					int subst = 0; 					int next = subst < m->substitution_count ? m->substitutions[2 * subst] 															 : m->definition_length; 					for (;;) { 						while (i < next) { 							widechar c = m->definition[i++]; 							if (c == '\n') { 								if (!compileRule(&tmpFile, table, displayTable, 											inScopeMacros)) { 									_lou_logMessage(LOU_LOG_ERROR, 											""result of macro expansion was: %s"", 											_lou_showString( 													tmpFile.line, tmpFile.linelen, 0)); 									return 0; 								} 								tmpFile.linepos = 0; 								tmpFile.linelen = 0; 							} else if (tmpFile.linelen >= MAXSTRING) { 								compileError(file, 										""Line exceeds %d characters (post macro "" 										""expansion)"", 										MAXSTRING); 								return 0; 							} else 								tmpFile.line[tmpFile.linelen++] = c; 						} 						if (subst < m->substitution_count) { 							CharsString arg = 									arguments[m->substitutions[2 * subst + 1] - 1]; 							for (int j = 0; j < arg.length; j++) 								tmpFile.line[tmpFile.linelen++] = arg.chars[j]; 							subst++; 							next = subst < m->substitution_count 									? m->substitutions[2 * subst] 									: m->definition_length; 						} else { 							if (!compileRule( 										&tmpFile, table, displayTable, inScopeMacros)) { 								_lou_logMessage(LOU_LOG_ERROR, 										""result of macro expansion was: %s"", 										_lou_showString( 												tmpFile.line, tmpFile.linelen, 0)); 								return 0; 							} 							break; 						} 					} 					return 1; 				} 				macros = macros->tail; 			} 		} 		if (opcode == CTO_UpLow) { 			compileError(file, ""The uplow opcode is deprecated.""); 			return 0; 		} 		compileError(file, ""opcode %s not defined."", 				_lou_showString(token.chars, token.length, 0)); 		return 0; 	}  	/* now only opcodes follow that don't modify the display table */ 	default: 		if (!table) return 1; 		switch (opcode) { 		case CTO_Locale: 			compileWarning(file, 					""The locale opcode is not implemented. Use the locale meta data "" 					""instead.""); 			return 1; 		case CTO_Undefined: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->undefined; 			if (!compileBrailleIndicator(file, ""undefined character opcode"", 						CTO_Undefined, &ruleOffset, noback, nofor, table)) 				return 0; 			(*table)->undefined = ruleOffset; 			return 1; 		} 		case CTO_Match: { 			int ok = 0; 			widechar *patterns = NULL; 			TranslationTableRule *rule; 			TranslationTableOffset ruleOffset; 			CharsString ptn_before, ptn_after; 			TranslationTableOffset patternsOffset; 			int len, mrk; 			size_t patternsByteSize = sizeof(*patterns) * 27720; 			patterns = (widechar *)malloc(patternsByteSize); 			if (!patterns) _lou_outOfMemory(); 			memset(patterns, 0xffff, patternsByteSize); 			noback = 1; 			getCharacters(file, &ptn_before); 			getRuleCharsText(file, &ruleChars); 			getCharacters(file, &ptn_after); 			getRuleDotsPattern(file, &ruleDots); 			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset, 						&rule, noback, nofor, table)) 				goto CTO_Match_cleanup; 			if (ptn_before.chars[0] == '-' && ptn_before.length == 1) 				len = _lou_pattern_compile( 						&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file); 			else 				len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length, 						&patterns[1], 13841, *table, file); 			if (!len) goto CTO_Match_cleanup; 			mrk = patterns[0] = len + 1; 			_lou_pattern_reverse(&patterns[1]); 			if (ptn_after.chars[0] == '-' && ptn_after.length == 1) 				len = _lou_pattern_compile( 						&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file); 			else 				len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length, 						&patterns[mrk], 13841, *table, file); 			if (!len) goto CTO_Match_cleanup; 			len += mrk; 			if (!allocateSpaceInTranslationTable( 						file, &patternsOffset, len * sizeof(widechar), table)) 				goto CTO_Match_cleanup; 			// allocateSpaceInTranslationTable may have moved table, so make sure rule is 			// still valid 			rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset]; 			memcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar)); 			rule->patterns = patternsOffset; 			ok = 1; 		CTO_Match_cleanup: 			free(patterns); 			return ok; 		}  		case CTO_BackMatch: { 			int ok = 0; 			widechar *patterns = NULL; 			TranslationTableRule *rule; 			TranslationTableOffset ruleOffset; 			CharsString ptn_before, ptn_after; 			TranslationTableOffset patternOffset; 			int len, mrk; 			size_t patternsByteSize = sizeof(*patterns) * 27720; 			patterns = (widechar *)malloc(patternsByteSize); 			if (!patterns) _lou_outOfMemory(); 			memset(patterns, 0xffff, patternsByteSize); 			nofor = 1; 			getCharacters(file, &ptn_before); 			getRuleCharsText(file, &ruleChars); 			getCharacters(file, &ptn_after); 			getRuleDotsPattern(file, &ruleDots); 			if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule, 						noback, nofor, table)) 				goto CTO_BackMatch_cleanup; 			if (ptn_before.chars[0] == '-' && ptn_before.length == 1) 				len = _lou_pattern_compile( 						&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file); 			else 				len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length, 						&patterns[1], 13841, *table, file); 			if (!len) goto CTO_BackMatch_cleanup; 			mrk = patterns[0] = len + 1; 			_lou_pattern_reverse(&patterns[1]); 			if (ptn_after.chars[0] == '-' && ptn_after.length == 1) 				len = _lou_pattern_compile( 						&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file); 			else 				len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length, 						&patterns[mrk], 13841, *table, file); 			if (!len) goto CTO_BackMatch_cleanup; 			len += mrk; 			if (!allocateSpaceInTranslationTable( 						file, &patternOffset, len * sizeof(widechar), table)) 				goto CTO_BackMatch_cleanup; 			// allocateSpaceInTranslationTable may have moved table, so make sure rule is 			// still valid 			rule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset]; 			memcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar)); 			rule->patterns = patternOffset; 			ok = 1; 		CTO_BackMatch_cleanup: 			free(patterns); 			return ok; 		}  		case CTO_CapsLetter: 		case CTO_BegCapsWord: 		case CTO_EndCapsWord: 		case CTO_BegCaps: 		case CTO_EndCaps: 		case CTO_BegCapsPhrase: 		case CTO_EndCapsPhrase: 		case CTO_LenCapsPhrase: 		/* these 8 general purpose opcodes are compiled further down to more specific 		 * internal opcodes: 		 * - modeletter 		 * - begmodeword 		 * - endmodeword 		 * - begmode 		 * - endmode 		 * - begmodephrase 		 * - endmodephrase 		 * - lenmodephrase 		 */ 		case CTO_ModeLetter: 		case CTO_BegModeWord: 		case CTO_EndModeWord: 		case CTO_BegMode: 		case CTO_EndMode: 		case CTO_BegModePhrase: 		case CTO_EndModePhrase: 		case CTO_LenModePhrase: { 			TranslationTableCharacterAttributes mode; 			int i; 			switch (opcode) { 			case CTO_CapsLetter: 			case CTO_BegCapsWord: 			case CTO_EndCapsWord: 			case CTO_BegCaps: 			case CTO_EndCaps: 			case CTO_BegCapsPhrase: 			case CTO_EndCapsPhrase: 			case CTO_LenCapsPhrase: 				mode = CTC_UpperCase; 				i = 0; 				opcode += (CTO_ModeLetter - CTO_CapsLetter); 				break; 			default: 				if (!getToken(file, &token, ""attribute name"")) return 0; 				if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) { 					return 0; 				} 				const CharacterClass *characterClass = findCharacterClass(&token, *table); 				if (!characterClass) { 					characterClass = 							addCharacterClass(file, token.chars, token.length, *table, 1); 					if (!characterClass) return 0; 				} 				mode = characterClass->attribute; 				if (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space && 						mode <= CTC_LitDigit) { 					compileError(file, 							""mode must be \""uppercase\"", \""digit\"", or a custom "" 							""attribute name.""); 					return 0; 				} 				/* check if this mode is already defined and if the number of modes does 				 * not exceed the maximal number */ 				if (mode == CTC_UpperCase) 					i = 0; 				else { 					for (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) { 						if ((*table)->modes[i].mode == mode) { 							break; 						} 					} 					if (i == MAX_MODES) { 						compileError(file, ""Max number of modes (%i) reached"", MAX_MODES); 						return 0; 					} 				} 			} 			if (!(*table)->modes[i].value) 				(*table)->modes[i] = (EmphasisClass){ plain_text, mode, 					0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i }; 			switch (opcode) { 			case CTO_BegModePhrase: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset]; 				if (!compileBrailleIndicator(file, ""first word capital sign"", 							CTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor, 							table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset; 				return 1; 			} 			case CTO_EndModePhrase: { 				TranslationTableOffset ruleOffset; 				switch (compileBeforeAfter(file)) { 				case 1:	 // before 					if ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) { 						compileError( 								file, ""Capital sign after last word already defined.""); 						return 0; 					} 					// not passing pointer because compileBrailleIndicator may reallocate 					// table 					ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i] 													[endPhraseBeforeOffset]; 					if (!compileBrailleIndicator(file, ""capital sign before last word"", 								CTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset, 								noback, nofor, table)) 						return 0; 					(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] = 							ruleOffset; 					return 1; 				case 2:	 // after 					if ((*table)->emphRules[MAX_EMPH_CLASSES + i] 										   [endPhraseBeforeOffset]) { 						compileError( 								file, ""Capital sign before last word already defined.""); 						return 0; 					} 					// not passing pointer because compileBrailleIndicator may reallocate 					// table 					ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i] 													[endPhraseAfterOffset]; 					if (!compileBrailleIndicator(file, ""capital sign after last word"", 								CTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback, 								nofor, table)) 						return 0; 					(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] = 							ruleOffset; 					return 1; 				default:  // error 					compileError(file, ""Invalid lastword indicator location.""); 					return 0; 				} 				return 0; 			} 			case CTO_BegMode: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset]; 				if (!compileBrailleIndicator(file, ""first letter capital sign"", 							CTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset; 				return 1; 			} 			case CTO_EndMode: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset]; 				if (!compileBrailleIndicator(file, ""last letter capital sign"", 							CTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset; 				return 1; 			} 			case CTO_ModeLetter: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset]; 				if (!compileBrailleIndicator(file, ""single letter capital sign"", 							CTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor, 							table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset; 				return 1; 			} 			case CTO_BegModeWord: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset]; 				if (!compileBrailleIndicator(file, ""capital word"", 							CTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor, 							table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset; 				return 1; 			} 			case CTO_EndModeWord: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset]; 				if (!compileBrailleIndicator(file, ""capital word stop"", 							CTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor, 							table)) 					return 0; 				(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset; 				return 1; 			} 			case CTO_LenModePhrase: 				return (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] = 							   compileNumber(file); 			default: 				break; 			} 			break; 		}  		/* these 8 general purpose emphasis opcodes are compiled further down to more 		 * specific internal opcodes: 		 * - emphletter 		 * - begemphword 		 * - endemphword 		 * - begemph 		 * - endemph 		 * - begemphphrase 		 * - endemphphrase 		 * - lenemphphrase 		 */ 		case CTO_EmphClass: 			if (!getToken(file, &emphClass, ""emphasis class"")) { 				compileError(file, ""emphclass must be followed by a valid class name.""); 				return 0; 			} 			int k, i; 			char *s = malloc(sizeof(char) * (emphClass.length + 1)); 			for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k]; 			s[k++] = '\0'; 			for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++) 				if (strcmp(s, (*table)->emphClassNames[i]) == 0) { 					_lou_logMessage(LOU_LOG_WARN, ""Duplicate emphasis class: %s"", s); 					warningCount++; 					free(s); 					return 1; 				} 			if (i == MAX_EMPH_CLASSES) { 				_lou_logMessage(LOU_LOG_ERROR, 						""Max number of emphasis classes (%i) reached"", MAX_EMPH_CLASSES); 				errorCount++; 				free(s); 				return 0; 			} 			switch (i) { 			/* For backwards compatibility (i.e. because programs will assume 			 * the first 3 typeform bits are `italic', `underline' and `bold') 			 * we require that the first 3 emphclass definitions are (in that 			 * order): 			 * 			 *   emphclass italic 			 *   emphclass underline 			 *   emphclass bold 			 * 			 * While it would be possible to use the emphclass opcode only for 			 * defining _additional_ classes (not allowing for them to be called 			 * italic, underline or bold), thereby reducing the amount of 			 * boilerplate, we deliberately choose not to do that in order to 			 * not give italic, underline and bold any special status. The 			 * hope is that eventually all programs will use liblouis for 			 * emphasis the recommended way (i.e. by looking up the supported 			 * typeforms in the documentation or API) so that we can drop this 			 * restriction. 			 */ 			case 0: 				if (strcmp(s, ""italic"") != 0) { 					_lou_logMessage(LOU_LOG_ERROR, 							""First emphasis class must be \""italic\"" but got "" 							""%s"", 							s); 					errorCount++; 					free(s); 					return 0; 				} 				break; 			case 1: 				if (strcmp(s, ""underline"") != 0) { 					_lou_logMessage(LOU_LOG_ERROR, 							""Second emphasis class must be \""underline\"" but "" 							""got "" 							""%s"", 							s); 					errorCount++; 					free(s); 					return 0; 				} 				break; 			case 2: 				if (strcmp(s, ""bold"") != 0) { 					_lou_logMessage(LOU_LOG_ERROR, 							""Third emphasis class must be \""bold\"" but got "" 							""%s"", 							s); 					errorCount++; 					free(s); 					return 0; 				} 				break; 			} 			(*table)->emphClassNames[i] = s; 			(*table)->emphClasses[i] = (EmphasisClass){ emph_1 						<< i, /* relies on the order of typeforms emph_1..emph_10 */ 				0, 0x1 << i, i }; 			return 1; 		case CTO_EmphLetter: 		case CTO_BegEmphWord: 		case CTO_EndEmphWord: 		case CTO_BegEmph: 		case CTO_EndEmph: 		case CTO_BegEmphPhrase: 		case CTO_EndEmphPhrase: 		case CTO_LenEmphPhrase: 		case CTO_EmphModeChars: 		case CTO_NoEmphChars: { 			if (!getToken(file, &token, ""emphasis class"")) return 0; 			if (!parseChars(file, &emphClass, &token)) return 0; 			char *s = malloc(sizeof(char) * (emphClass.length + 1)); 			int k, i; 			for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k]; 			s[k++] = '\0'; 			for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++) 				if (strcmp(s, (*table)->emphClassNames[i]) == 0) break; 			if (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) { 				_lou_logMessage(LOU_LOG_ERROR, ""Emphasis class %s not declared"", s); 				errorCount++; 				free(s); 				return 0; 			} 			int ok = 0; 			switch (opcode) { 			case CTO_EmphLetter: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset]; 				if (!compileBrailleIndicator(file, ""single letter"", 							CTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][letterOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_BegEmphWord: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset]; 				if (!compileBrailleIndicator(file, ""word"", 							CTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][begWordOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_EndEmphWord: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset]; 				if (!compileBrailleIndicator(file, ""word stop"", 							CTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][endWordOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_BegEmph: { 				/* fail if both begemph and any of begemphphrase or begemphword are 				 * defined */ 				if ((*table)->emphRules[i][begWordOffset] || 						(*table)->emphRules[i][begPhraseOffset]) { 					compileError(file, 							""Cannot define emphasis for both no context and word or "" 							""phrase context, i.e. cannot have both begemph and "" 							""begemphword or begemphphrase.""); 					break; 				} 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset]; 				if (!compileBrailleIndicator(file, ""first letter"", 							CTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][begOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_EndEmph: { 				if ((*table)->emphRules[i][endWordOffset] || 						(*table)->emphRules[i][endPhraseBeforeOffset] || 						(*table)->emphRules[i][endPhraseAfterOffset]) { 					compileError(file, 							""Cannot define emphasis for both no context and word or "" 							""phrase context, i.e. cannot have both endemph and "" 							""endemphword or endemphphrase.""); 					break; 				} 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset]; 				if (!compileBrailleIndicator(file, ""last letter"", 							CTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][endOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_BegEmphPhrase: { 				// not passing pointer because compileBrailleIndicator may reallocate 				// table 				TranslationTableOffset ruleOffset = 						(*table)->emphRules[i][begPhraseOffset]; 				if (!compileBrailleIndicator(file, ""first word"", 							CTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset, 							noback, nofor, table)) 					break; 				(*table)->emphRules[i][begPhraseOffset] = ruleOffset; 				ok = 1; 				break; 			} 			case CTO_EndEmphPhrase: 				switch (compileBeforeAfter(file)) { 				case 1: {  // before 					if ((*table)->emphRules[i][endPhraseAfterOffset]) { 						compileError(file, ""last word after already defined.""); 						break; 					} 					// not passing pointer because compileBrailleIndicator may reallocate 					// table 					TranslationTableOffset ruleOffset = 							(*table)->emphRules[i][endPhraseBeforeOffset]; 					if (!compileBrailleIndicator(file, ""last word before"", 								CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i), 								&ruleOffset, noback, nofor, table)) 						break; 					(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset; 					ok = 1; 					break; 				} 				case 2: {  // after 					if ((*table)->emphRules[i][endPhraseBeforeOffset]) { 						compileError(file, ""last word before already defined.""); 						break; 					} 					// not passing pointer because compileBrailleIndicator may reallocate 					// table 					TranslationTableOffset ruleOffset = 							(*table)->emphRules[i][endPhraseAfterOffset]; 					if (!compileBrailleIndicator(file, ""last word after"", 								CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i), 								&ruleOffset, noback, nofor, table)) 						break; 					(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset; 					ok = 1; 					break; 				} 				default:  // error 					compileError(file, ""Invalid lastword indicator location.""); 					break; 				} 				break; 			case CTO_LenEmphPhrase: 				if (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file))) 					ok = 1; 				break; 			case CTO_EmphModeChars: { 				if (!getRuleCharsText(file, &ruleChars)) break; 				widechar *emphmodechars = (*table)->emphModeChars[i]; 				int len; 				for (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++) 					; 				if (len + ruleChars.length > EMPHMODECHARSSIZE) { 					compileError(file, ""More than %d characters"", EMPHMODECHARSSIZE); 					break; 				} 				ok = 1; 				for (int k = 0; k < ruleChars.length; k++) { 					if (!getChar(ruleChars.chars[k], *table, NULL)) { 						compileError(file, ""Emphasis mode character undefined""); 						ok = 0; 						break; 					} 					emphmodechars[len++] = ruleChars.chars[k]; 				} 				break; 			} 			case CTO_NoEmphChars: { 				if (!getRuleCharsText(file, &ruleChars)) break; 				widechar *noemphchars = (*table)->noEmphChars[i]; 				int len; 				for (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++) 					; 				if (len + ruleChars.length > NOEMPHCHARSSIZE) { 					compileError(file, ""More than %d characters"", NOEMPHCHARSSIZE); 					break; 				} 				ok = 1; 				for (int k = 0; k < ruleChars.length; k++) { 					if (!getChar(ruleChars.chars[k], *table, NULL)) { 						compileError(file, ""Character undefined""); 						ok = 0; 						break; 					} 					noemphchars[len++] = ruleChars.chars[k]; 				} 				break; 			} 			default: 				break; 			} 			free(s); 			return ok; 		} 		case CTO_LetterSign: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->letterSign; 			if (!compileBrailleIndicator(file, ""letter sign"", CTO_LetterRule, &ruleOffset, 						noback, nofor, table)) 				return 0; 			(*table)->letterSign = ruleOffset; 			return 1; 		} 		case CTO_NoLetsignBefore: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) { 				compileError(file, ""More than %d characters"", LETSIGNBEFORESIZE); 				return 0; 			} 			for (int k = 0; k < ruleChars.length; k++) 				(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] = 						ruleChars.chars[k]; 			return 1; 		case CTO_NoLetsign: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) { 				compileError(file, ""More than %d characters"", LETSIGNSIZE); 				return 0; 			} 			for (int k = 0; k < ruleChars.length; k++) 				(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k]; 			return 1; 		case CTO_NoLetsignAfter: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) { 				compileError(file, ""More than %d characters"", LETSIGNAFTERSIZE); 				return 0; 			} 			for (int k = 0; k < ruleChars.length; k++) 				(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] = 						ruleChars.chars[k]; 			return 1; 		case CTO_NumberSign: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->numberSign; 			if (!compileBrailleIndicator(file, ""number sign"", CTO_NumberRule, &ruleOffset, 						noback, nofor, table)) 				return 0; 			(*table)->numberSign = ruleOffset; 			return 1; 		}  		case CTO_NumericModeChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Numeric mode character undefined: %s"", 							_lou_showString(&ruleChars.chars[k], 1, 0)); 					return 0; 				} 				c->attributes |= CTC_NumericMode; 				(*table)->usesNumericMode = 1; 			} 			return 1;  		case CTO_MidEndNumericModeChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Midendnumeric mode character undefined""); 					return 0; 				} 				c->attributes |= CTC_MidEndNumericMode; 				(*table)->usesNumericMode = 1; 			} 			return 1;  		case CTO_NumericNoContractChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Numeric no contraction character undefined""); 					return 0; 				} 				c->attributes |= CTC_NumericNoContract; 				(*table)->usesNumericMode = 1; 			} 			return 1;  		case CTO_NoContractSign: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->noContractSign; 			if (!compileBrailleIndicator(file, ""no contractions sign"", CTO_NoContractRule, 						&ruleOffset, noback, nofor, table)) 				return 0; 			(*table)->noContractSign = ruleOffset; 			return 1; 		} 		case CTO_SeqDelimiter: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Sequence delimiter character undefined""); 					return 0; 				} 				c->attributes |= CTC_SeqDelimiter; 				(*table)->usesSequences = 1; 			} 			return 1;  		case CTO_SeqBeforeChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Sequence before character undefined""); 					return 0; 				} 				c->attributes |= CTC_SeqBefore; 			} 			return 1;  		case CTO_SeqAfterChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Sequence after character undefined""); 					return 0; 				} 				c->attributes |= CTC_SeqAfter; 			} 			return 1;  		case CTO_SeqAfterPattern: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) { 				compileError(file, ""More than %d characters"", SEQPATTERNSIZE); 				return 0; 			} 			for (int k = 0; k < ruleChars.length; k++) 				(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k]; 			(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0; 			return 1;  		case CTO_SeqAfterExpression: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for ((*table)->seqAfterExpressionLength = 0; 					(*table)->seqAfterExpressionLength < ruleChars.length; 					(*table)->seqAfterExpressionLength++) 				(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 						ruleChars.chars[(*table)->seqAfterExpressionLength]; 			(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0; 			return 1;  		case CTO_CapsModeChars: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!c) { 					compileError(file, ""Capital mode character undefined""); 					return 0; 				} 				c->attributes |= CTC_CapsMode; 				(*table)->hasCapsModeChars = 1; 			} 			return 1;  		case CTO_BegComp: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->begComp; 			if (!compileBrailleIndicator(file, ""begin computer braille"", CTO_BegCompRule, 						&ruleOffset, noback, nofor, table)) 				return 0; 			(*table)->begComp = ruleOffset; 			return 1; 		} 		case CTO_EndComp: { 			// not passing pointer because compileBrailleIndicator may reallocate table 			TranslationTableOffset ruleOffset = (*table)->endComp; 			if (!compileBrailleIndicator(file, ""end computer braslle"", CTO_EndCompRule, 						&ruleOffset, noback, nofor, table)) 				return 0; 			(*table)->endComp = ruleOffset; 			return 1; 		} 		case CTO_NoCross: 			if (nocross) { 				compileError( 						file, ""%s already specified."", _lou_findOpcodeName(CTO_NoCross)); 				return 0; 			} 			nocross = 1; 			goto doOpcode; 		case CTO_Syllable: 			(*table)->syllables = 1; 		case CTO_Always: 		case CTO_LargeSign: 		case CTO_WholeWord: 		case CTO_PartWord: 		case CTO_JoinNum: 		case CTO_JoinableWord: 		case CTO_LowWord: 		case CTO_SuffixableWord: 		case CTO_PrefixableWord: 		case CTO_BegWord: 		case CTO_BegMidWord: 		case CTO_MidWord: 		case CTO_MidEndWord: 		case CTO_EndWord: 		case CTO_PrePunc: 		case CTO_PostPunc: 		case CTO_BegNum: 		case CTO_MidNum: 		case CTO_EndNum: 		case CTO_Repeated: 		case CTO_RepWord: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (!getRuleDotsPattern(file, &ruleDots)) return 0; 			if (ruleDots.length == 0) 				// check that all characters in a rule with `=` as second operand are 				// defined (or based on another character) 				for (int k = 0; k < ruleChars.length; k++) { 					TranslationTableCharacter *c = 							getChar(ruleChars.chars[k], *table, NULL); 					if (!(c && (c->definitionRule || c->basechar))) { 						compileError(file, ""Character %s is not defined"", 								_lou_showString(&ruleChars.chars[k], 1, 0)); 						return 0; 					} 				} 			TranslationTableRule *r; 			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r, 						noback, nofor, table)) 				return 0; 			if (nocross) r->nocross = 1; 			return 1; 			// if (opcode == CTO_MidNum) 			// { 			//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]); 			//   if(c) 			//     c->attributes |= CTC_NumericMode; 			// } 		case CTO_RepEndWord: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			CharsString dots; 			if (!getToken(file, &dots, ""dots,dots operand"")) return 0; 			int len = dots.length; 			for (int k = 0; k < len - 1; k++) { 				if (dots.chars[k] == ',') { 					dots.length = k; 					if (!parseDots(file, &ruleDots, &dots)) return 0; 					ruleDots.chars[ruleDots.length++] = ','; 					k++; 					if (k == len - 1 && dots.chars[k] == '=') { 						// check that all characters are defined (or based on another 						// character) 						for (int l = 0; l < ruleChars.length; l++) { 							TranslationTableCharacter *c = 									getChar(ruleChars.chars[l], *table, NULL); 							if (!(c && (c->definitionRule || c->basechar))) { 								compileError(file, ""Character %s is not defined"", 										_lou_showString(&ruleChars.chars[l], 1, 0)); 								return 0; 							} 						} 					} else { 						CharsString x, y; 						x.length = 0; 						while (k < len) x.chars[x.length++] = dots.chars[k++]; 						if (parseDots(file, &y, &x)) 							for (int l = 0; l < y.length; l++) 								ruleDots.chars[ruleDots.length++] = y.chars[l]; 					} 					return addRule(file, opcode, &ruleChars, &ruleDots, after, before, 							NULL, NULL, noback, nofor, table); 				} 			} 			return 0; 		case CTO_CompDots: 		case CTO_Comp6: { 			TranslationTableOffset ruleOffset; 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (ruleChars.length != 1) { 				compileError(file, ""first operand must be 1 character""); 				return 0; 			} 			if (nofor || noback) { 				compileWarning(file, ""nofor and noback not allowed on comp6 rules""); 			} 			if (!getRuleDotsPattern(file, &ruleDots)) return 0; 			if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset, 						NULL, noback, nofor, table)) 				return 0; 			return 1; 		} 		case CTO_ExactDots: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (ruleChars.chars[0] != '@') { 				compileError(file, ""The operand must begin with an at sign (@)""); 				return 0; 			} 			for (int k = 1; k < ruleChars.length; k++) 				scratchPad.chars[k - 1] = ruleChars.chars[k]; 			scratchPad.length = ruleChars.length - 1; 			if (!parseDots(file, &ruleDots, &scratchPad)) return 0; 			return addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL, 					noback, nofor, table); 		case CTO_CapsNoCont: { 			TranslationTableOffset ruleOffset; 			ruleChars.length = 1; 			ruleChars.chars[0] = 'a'; 			if (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before, 						&ruleOffset, NULL, noback, nofor, table)) 				return 0; 			(*table)->capsNoCont = ruleOffset; 			return 1; 		} 		case CTO_Replace: 			if (getRuleCharsText(file, &ruleChars)) { 				if (atEndOfLine(file)) 					ruleDots.length = ruleDots.chars[0] = 0; 				else { 					getRuleDotsText(file, &ruleDots); 					if (ruleDots.chars[0] == '#') 						ruleDots.length = ruleDots.chars[0] = 0; 					else if (ruleDots.chars[0] == '\\' && ruleDots.chars[1] == '#') 						memmove(&ruleDots.chars[0], &ruleDots.chars[1], 								ruleDots.length-- * CHARSIZE); 				} 			} 			for (int k = 0; k < ruleChars.length; k++) 				putChar(file, ruleChars.chars[k], table, NULL); 			for (int k = 0; k < ruleDots.length; k++) 				putChar(file, ruleDots.chars[k], table, NULL); 			return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL, 					noback, nofor, table); 		case CTO_Correct: 			(*table)->corrections = 1; 			goto doPass; 		case CTO_Pass2: 			if ((*table)->numPasses < 2) (*table)->numPasses = 2; 			goto doPass; 		case CTO_Pass3: 			if ((*table)->numPasses < 3) (*table)->numPasses = 3; 			goto doPass; 		case CTO_Pass4: 			if ((*table)->numPasses < 4) (*table)->numPasses = 4; 		doPass: 		case CTO_Context: 			if (!(nofor || noback)) { 				compileError(file, ""%s or %s must be specified."", 						_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack)); 				return 0; 			} 			return compilePassOpcode(file, opcode, noback, nofor, table); 		case CTO_Contraction: 		case CTO_NoCont: 		case CTO_CompBrl: 		case CTO_Literal: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			// check that all characters in a compbrl, contraction, 			// nocont or literal rule are defined (or based on another 			// character) 			for (int k = 0; k < ruleChars.length; k++) { 				TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL); 				if (!(c && (c->definitionRule || c->basechar))) { 					compileError(file, ""Character %s is not defined"", 							_lou_showString(&ruleChars.chars[k], 1, 0)); 					return 0; 				} 			} 			return addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL, 					noback, nofor, table); 		case CTO_MultInd: { 			ruleChars.length = 0; 			if (!getToken(file, &token, ""multiple braille indicators"") || 					!parseDots(file, &cells, &token)) 				return 0; 			while (getToken(file, &token, ""multind opcodes"")) { 				opcode = getOpcode(file, &token); 				if (opcode == CTO_None) { 					compileError(file, ""opcode %s not defined."", 							_lou_showString(token.chars, token.length, 0)); 					return 0; 				} 				if (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) { 					compileError(file, ""Not a braille indicator opcode.""); 					return 0; 				} 				ruleChars.chars[ruleChars.length++] = (widechar)opcode; 				if (atEndOfLine(file)) break; 			} 			return addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL, 					NULL, noback, nofor, table); 		}  		case CTO_Class: 			compileWarning(file, ""class is deprecated, use attribute instead""); 		case CTO_Attribute: { 			if (nofor || noback) { 				compileWarning( 						file, ""nofor and noback not allowed before class/attribute""); 			} 			if ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) || 					(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) { 				compileError(file, 						""attribute and class rules must not be both present in a table""); 				return 0; 			} 			if (opcode == CTO_Class) 				(*table)->usesAttributeOrClass = 2; 			else 				(*table)->usesAttributeOrClass = 1; 			if (!getToken(file, &token, ""attribute name"")) { 				compileError(file, ""Expected %s"", ""attribute name""); 				return 0; 			} 			if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) { 				return 0; 			}  			TranslationTableCharacterAttributes attribute = 0; 			{ 				int attrNumber = -1; 				switch (token.chars[0]) { 				case '0': 				case '1': 				case '2': 				case '3': 				case '4': 				case '5': 				case '6': 				case '7': 				case '8': 				case '9': 					attrNumber = token.chars[0] - '0'; 					break; 				} 				if (attrNumber >= 0) { 					if (opcode == CTO_Class) { 						compileError(file, 								""Invalid class name: may not contain digits, use "" 								""attribute instead of class""); 						return 0; 					} 					if (token.length > 1 || attrNumber > 7) { 						compileError(file, 								""Invalid attribute name: must be a digit between 0 and 7 "" 								""or a word containing only letters""); 						return 0; 					} 					if (!(*table)->numberedAttributes[attrNumber]) 						// attribute not used before yet: assign it a value 						(*table)->numberedAttributes[attrNumber] = 								getNextNumberedAttribute(*table); 					attribute = (*table)->numberedAttributes[attrNumber]; 				} else { 					const CharacterClass *namedAttr = findCharacterClass(&token, *table); 					if (!namedAttr) { 						// no class with that name: create one 						namedAttr = addCharacterClass( 								file, &token.chars[0], token.length, *table, 1); 						if (!namedAttr) return 0; 					} 					// there is a class with that name or a new class was successfully 					// created 					attribute = namedAttr->attribute; 					if (attribute == CTC_UpperCase || attribute == CTC_LowerCase) 						attribute |= CTC_Letter; 				} 			} 			CharsString characters; 			if (!getCharacters(file, &characters)) return 0; 			for (int i = 0; i < characters.length; i++) { 				// get the character from the table, or if it is not defined yet, 				// define it 				TranslationTableCharacter *character = 						putChar(file, characters.chars[i], table, NULL); 				// set the attribute 				character->attributes |= attribute; 				// also set the attribute on the associated dots (if any) 				if (character->basechar) 					character = (TranslationTableCharacter *)&(*table) 										->ruleArea[character->basechar]; 				if (character->definitionRule) { 					TranslationTableRule *defRule = 							(TranslationTableRule *)&(*table) 									->ruleArea[character->definitionRule]; 					if (defRule->dotslen == 1) { 						TranslationTableCharacter *dots = 								getDots(defRule->charsdots[defRule->charslen], *table); 						if (dots) dots->attributes |= attribute; 					} 				} 			} 			return 1; 		}  			{ 				TranslationTableCharacterAttributes *attributes; 				const CharacterClass *class; 			case CTO_After: 				attributes = &after; 				goto doBeforeAfter; 			case CTO_Before: 				attributes = &before; 			doBeforeAfter: 				if (!(*table)->characterClasses) { 					if (!allocateCharacterClasses(*table)) return 0; 				} 				if (!getToken(file, &token, ""attribute name"")) return 0; 				if (!(class = findCharacterClass(&token, *table))) { 					compileError(file, ""attribute not defined""); 					return 0; 				} 				*attributes |= class->attribute; 				goto doOpcode; 			} 		case CTO_Base: 			if (nofor || noback) { 				compileWarning(file, ""nofor and noback not allowed before base""); 			} 			if (!getToken(file, &token, ""attribute name"")) { 				compileError( 						file, ""base opcode must be followed by a valid attribute name.""); 				return 0; 			} 			if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) { 				return 0; 			} 			const CharacterClass *mode = findCharacterClass(&token, *table); 			if (!mode) { 				mode = addCharacterClass(file, token.chars, token.length, *table, 1); 				if (!mode) return 0; 			} 			if (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) && 					mode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) { 				compileError(file, 						""base opcode must be followed by \""uppercase\"", \""digit\"", or a "" 						""custom attribute name.""); 				return 0; 			} 			if (!getRuleCharsText(file, &token)) return 0; 			if (token.length != 1) { 				compileError(file, 						""Exactly one character followed by one base character is "" 						""required.""); 				return 0; 			} 			TranslationTableOffset characterOffset; 			TranslationTableCharacter *character = 					putChar(file, token.chars[0], table, &characterOffset); 			if (!getRuleCharsText(file, &token)) return 0; 			if (token.length != 1) { 				compileError(file, ""Exactly one base character is required.""); 				return 0; 			} 			if (character->definitionRule) { 				TranslationTableRule *prevRule = 						(TranslationTableRule *)&(*table) 								->ruleArea[character->definitionRule]; 				_lou_logMessage(LOU_LOG_DEBUG, 						""%s:%d: Character already defined (%s). The base rule will take "" 						""precedence."", 						file->fileName, file->lineNumber, 						printSource(file, prevRule->sourceFile, prevRule->sourceLine)); 				character->definitionRule = 0; 			} 			TranslationTableOffset basechar; 			putChar(file, token.chars[0], table, &basechar); 			// putChar may have moved table, so make sure character is still valid 			character = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset]; 			if (character->basechar) { 				if (character->basechar == basechar && 						character->mode == mode->attribute) { 					_lou_logMessage(LOU_LOG_DEBUG, ""%s:%d: Duplicate base rule."", 							file->fileName, file->lineNumber); 				} else { 					_lou_logMessage(LOU_LOG_DEBUG, 							""%s:%d: A different base rule already exists for this "" 							""character (%s). The new rule will take precedence."", 							file->fileName, file->lineNumber, 							printSource( 									file, character->sourceFile, character->sourceLine)); 				} 			} 			character->basechar = basechar; 			character->mode = mode->attribute; 			character->sourceFile = file->sourceFile; 			character->sourceLine = file->lineNumber; 			/* some other processing is done at the end of the compilation, in 			 * finalizeTable() */ 			return 1; 		case CTO_EmpMatchBefore: 			before |= CTC_EmpMatch; 			goto doOpcode; 		case CTO_EmpMatchAfter: 			after |= CTC_EmpMatch; 			goto doOpcode;  		case CTO_SwapCc: 		case CTO_SwapCd: 		case CTO_SwapDd: 			return compileSwap(file, opcode, noback, nofor, table); 		case CTO_Hyphen: 		case CTO_DecPoint: 			//	case CTO_Apostrophe: 			//	case CTO_Initial: 			if (!getRuleCharsText(file, &ruleChars)) return 0; 			if (!getRuleDotsPattern(file, &ruleDots)) return 0; 			if (ruleChars.length != 1 || ruleDots.length < 1) { 				compileError(file, 						""One Unicode character and at least one cell are "" 						""required.""); 				return 0; 			} 			return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL, 					noback, nofor, table); 			// if (opcode == CTO_DecPoint) 			// { 			//   TranslationTableCharacter *c = 			//   getChar(ruleChars.chars[0]); 			//   if(c) 			//     c->attributes |= CTC_NumericMode; 			// } 		default: 			compileError(file, ""unimplemented opcode.""); 			return 0; 		} 	} 	return 0; }"
"215038_CWE-125.c","CWE-125","gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf) {   GstCaps *caps;   guint avail;   GstFlowReturn res = GST_FLOW_OK;    GstFlxDec *flxdec;   FlxHeader *flxh;    g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);   flxdec = (GstFlxDec *) parent;   g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);    gst_adapter_push (flxdec->adapter, buf);   avail = gst_adapter_available (flxdec->adapter);    if (flxdec->state == GST_FLXDEC_READ_HEADER) {     if (avail >= FlxHeaderSize) {       const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);       GstCaps *templ;        memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);       FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));       gst_adapter_unmap (flxdec->adapter);       gst_adapter_flush (flxdec->adapter, FlxHeaderSize);        flxh = &flxdec->hdr;        /* check header */       if (flxh->type != FLX_MAGICHDR_FLI &&           flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)         goto wrong_type;        GST_LOG (""size      :  %d"", flxh->size);       GST_LOG (""frames    :  %d"", flxh->frames);       GST_LOG (""width     :  %d"", flxh->width);       GST_LOG (""height    :  %d"", flxh->height);       GST_LOG (""depth     :  %d"", flxh->depth);       GST_LOG (""speed     :  %d"", flxh->speed);        flxdec->next_time = 0;        if (flxh->type == FLX_MAGICHDR_FLI) {         flxdec->frame_time = JIFFIE * flxh->speed;       } else if (flxh->speed == 0) {         flxdec->frame_time = GST_SECOND / 70;       } else {         flxdec->frame_time = flxh->speed * GST_MSECOND;       }        flxdec->duration = flxh->frames * flxdec->frame_time;       GST_LOG (""duration   :  %"" GST_TIME_FORMAT,           GST_TIME_ARGS (flxdec->duration));        templ = gst_pad_get_pad_template_caps (flxdec->srcpad);       caps = gst_caps_copy (templ);       gst_caps_unref (templ);       gst_caps_set_simple (caps,           ""width"", G_TYPE_INT, flxh->width,           ""height"", G_TYPE_INT, flxh->height,           ""framerate"", GST_TYPE_FRACTION, (gint) GST_MSECOND,           (gint) flxdec->frame_time / 1000, NULL);        gst_pad_set_caps (flxdec->srcpad, caps);       gst_caps_unref (caps);        if (flxh->depth <= 8)         flxdec->converter =             flx_colorspace_converter_new (flxh->width, flxh->height);        if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {         GST_LOG (""(FLC) aspect_dx :  %d"", flxh->aspect_dx);         GST_LOG (""(FLC) aspect_dy :  %d"", flxh->aspect_dy);         GST_LOG (""(FLC) oframe1   :  0x%08x"", flxh->oframe1);         GST_LOG (""(FLC) oframe2   :  0x%08x"", flxh->oframe2);       }        flxdec->size = ((guint) flxh->width * (guint) flxh->height);        /* create delta and output frame */       flxdec->frame_data = g_malloc (flxdec->size);       flxdec->delta_data = g_malloc (flxdec->size);        flxdec->state = GST_FLXDEC_PLAYING;     }   } else if (flxdec->state == GST_FLXDEC_PLAYING) {     GstBuffer *out;      /* while we have enough data in the adapter */     while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {       FlxFrameChunk flxfh;       guchar *chunk;       const guint8 *data;       GstMapInfo map;        chunk = NULL;       data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);       memcpy (&flxfh, data, FlxFrameChunkSize);       FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);       gst_adapter_unmap (flxdec->adapter);        switch (flxfh.id) {         case FLX_FRAME_TYPE:           /* check if we have the complete frame */           if (avail < flxfh.size)             goto need_more_data;            /* flush header */           gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);            chunk = gst_adapter_take (flxdec->adapter,               flxfh.size - FlxFrameChunkSize);           FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);           if (((FlxFrameType *) chunk)->chunks == 0)             break;            /* create 32 bits output frame */ //          res = gst_pad_alloc_buffer_and_set_caps (flxdec->srcpad, //              GST_BUFFER_OFFSET_NONE, //              flxdec->size * 4, GST_PAD_CAPS (flxdec->srcpad), &out); //          if (res != GST_FLOW_OK) //            break;            out = gst_buffer_new_and_alloc (flxdec->size * 4);            /* decode chunks */           if (!flx_decode_chunks (flxdec,                   ((FlxFrameType *) chunk)->chunks,                   chunk + FlxFrameTypeSize, flxdec->frame_data)) {             GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,                 (""%s"", ""Could not decode chunk""), NULL);             return GST_FLOW_ERROR;           }            /* save copy of the current frame for possible delta. */           memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);            gst_buffer_map (out, &map, GST_MAP_WRITE);           /* convert current frame. */           flx_colorspace_convert (flxdec->converter, flxdec->frame_data,               map.data);           gst_buffer_unmap (out, &map);            GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;           flxdec->next_time += flxdec->frame_time;            res = gst_pad_push (flxdec->srcpad, out);           break;         default:           /* check if we have the complete frame */           if (avail < flxfh.size)             goto need_more_data;            gst_adapter_flush (flxdec->adapter, flxfh.size);           break;       }        g_free (chunk);        avail = gst_adapter_available (flxdec->adapter);     }   } need_more_data:   return res;    /* ERRORS */ wrong_type:   {     GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),         (""not a flx file (type %x)"", flxh->type));     gst_object_unref (flxdec);     return GST_FLOW_ERROR;   } }"
"215073_CWE-269.c","CWE-269","static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of, 					  char *buf, size_t nbytes, loff_t off) { 	struct cgroup *cgrp;  	BUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);  	cgrp = cgroup_kn_lock_live(of->kn, false); 	if (!cgrp) 		return -ENODEV; 	spin_lock(&release_agent_path_lock); 	strlcpy(cgrp->root->release_agent_path, strstrip(buf), 		sizeof(cgrp->root->release_agent_path)); 	spin_unlock(&release_agent_path_lock); 	cgroup_kn_unlock(of->kn); 	return nbytes; }"
"215103_CWE-617.cpp","CWE-617","createRandomCursorExecutor(const CollectionPtr& coll,                            const boost::intrusive_ptr<ExpressionContext>& expCtx,                            long long sampleSize,                            long long numRecords,                            boost::optional<BucketUnpacker> bucketUnpacker) {     OperationContext* opCtx = expCtx->opCtx;      // Verify that we are already under a collection lock. We avoid taking locks ourselves in this     // function because double-locking forces any PlanExecutor we create to adopt a NO_YIELD policy.     invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));      static const double kMaxSampleRatioForRandCursor = 0.05;     if (!expCtx->ns.isTimeseriesBucketsCollection()) {         if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {             return std::pair{nullptr, false};         }     } else {         // Suppose that a time-series bucket collection is observed to contain 200 buckets, and the         // 'gTimeseriesBucketMaxCount' parameter is set to 1000. If all buckets are full, then the         // maximum possible measurment count would be 200 * 1000 = 200,000. While the         // 'SampleFromTimeseriesBucket' plan is more efficient when the sample size is small         // relative to the total number of measurements in the time-series collection, for larger         // sample sizes the top-k sort based sample is faster. Experiments have approximated that         // the tipping point is roughly when the requested sample size is greater than 1% of the         // maximum possible number of measurements in the collection (i.e. numBuckets *         // maxMeasurementsPerBucket).         static const double kCoefficient = 0.01;         if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {             return std::pair{nullptr, false};         }     }      // Attempt to get a random cursor from the RecordStore.     auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);     if (!rsRandCursor) {         // The storage engine has no random cursor support.         return std::pair{nullptr, false};     }      // Build a MultiIteratorStage and pass it the random-sampling RecordCursor.     auto ws = std::make_unique<WorkingSet>();     std::unique_ptr<PlanStage> root =         std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);     static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));      // If the incoming operation is sharded, use the CSS to infer the filtering metadata for the     // collection, otherwise treat it as unsharded     auto collectionFilter =         CollectionShardingState::get(opCtx, coll->ns())             ->getOwnershipFilter(                 opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);      TrialStage* trialStage = nullptr;      // Because 'numRecords' includes orphan documents, our initial decision to optimize the $sample     // cursor may have been mistaken. For sharded collections, build a TRIAL plan that will switch     // to a collection scan if the ratio of orphaned to owned documents encountered over the first     // 100 works() is such that we would have chosen not to optimize.     static const size_t kMaxPresampleSize = 100;     if (collectionFilter.isSharded() && !expCtx->ns.isTimeseriesBucketsCollection()) {         // The ratio of owned to orphaned documents must be at least equal to the ratio between the         // requested sampleSize and the maximum permitted sampleSize for the original constraints to         // be satisfied. For instance, if there are 200 documents and the sampleSize is 5, then at         // least (5 / (200*0.05)) = (5/10) = 50% of those documents must be owned. If less than 5%         // of the documents in the collection are owned, we default to the backup plan.         const auto minAdvancedToWorkRatio = std::max(             sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);         // The trial plan is SHARDING_FILTER-MULTI_ITERATOR.         auto randomCursorPlan = std::make_unique<ShardFilterStage>(             expCtx.get(), collectionFilter, ws.get(), std::move(root));         // The backup plan is SHARDING_FILTER-COLLSCAN.         std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);         collScanPlan = std::make_unique<ShardFilterStage>(             expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));         // Place a TRIAL stage at the root of the plan tree, and pass it the trial and backup plans.         root = std::make_unique<TrialStage>(expCtx.get(),                                             ws.get(),                                             std::move(randomCursorPlan),                                             std::move(collScanPlan),                                             kMaxPresampleSize,                                             minAdvancedToWorkRatio);         trialStage = static_cast<TrialStage*>(root.get());     } else if (expCtx->ns.isTimeseriesBucketsCollection()) {         // Use a 'TrialStage' to run a trial between 'SampleFromTimeseriesBucket' and         // 'UnpackTimeseriesBucket' with $sample left in the pipeline in-place. If the buckets are         // not sufficiently full, or the 'SampleFromTimeseriesBucket' plan draws too many         // duplicates, then we will fall back to the 'TrialStage' backup plan. This backup plan uses         // the top-k sort sampling approach.         //         // Suppose the 'gTimeseriesBucketMaxCount' is 1000, but each bucket only contains 500         // documents on average. The observed trial advanced/work ratio approximates the average         // bucket fullness, noted here as ""abf"". In this example, abf = 500 / 1000 = 0.5.         // Experiments have shown that the optimized 'SampleFromTimeseriesBucket' algorithm performs         // better than backup plan when         //         //     sampleSize < 0.02 * abf * numRecords * gTimeseriesBucketMaxCount         //         //  This inequality can be rewritten as         //         //     abf > sampleSize / (0.02 * numRecords * gTimeseriesBucketMaxCount)         //         // Therefore, if the advanced/work ratio exceeds this threshold, we will use the         // 'SampleFromTimeseriesBucket' plan. Note that as the sample size requested by the user         // becomes larger with respect to the number of buckets, we require a higher advanced/work         // ratio in order to justify using 'SampleFromTimeseriesBucket'.         //         // Additionally, we require the 'TrialStage' to approximate the abf as at least 0.25. When         // buckets are mostly empty, the 'SampleFromTimeseriesBucket' will be inefficient due to a         // lot of sampling ""misses"".         static const auto kCoefficient = 0.02;         static const auto kMinBucketFullness = 0.25;         const auto minAdvancedToWorkRatio = std::max(             std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),             kMinBucketFullness);          auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(             expCtx.get(),             ws.get(),             std::move(root),             *bucketUnpacker,             // By using a quantity slightly higher than 'kMaxPresampleSize', we ensure that the             // 'SampleFromTimeseriesBucket' stage won't fail due to too many consecutive sampling             // attempts during the 'TrialStage's trial period.             kMaxPresampleSize + 5,             sampleSize,             gTimeseriesBucketMaxCount);          std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(             expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);          auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(             expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);          root = std::make_unique<TrialStage>(expCtx.get(),                                             ws.get(),                                             std::move(arhashPlan),                                             std::move(topkSortPlan),                                             kMaxPresampleSize,                                             minAdvancedToWorkRatio);         trialStage = static_cast<TrialStage*>(root.get());     }      auto execStatus = plan_executor_factory::make(expCtx,                                                   std::move(ws),                                                   std::move(root),                                                   &coll,                                                   opCtx->inMultiDocumentTransaction()                                                       ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY                                                       : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,                                                   QueryPlannerParams::RETURN_OWNED_DATA);     if (!execStatus.isOK()) {         return execStatus.getStatus();     }      // For sharded collections, the root of the plan tree is a TrialStage that may have chosen     // either a random-sampling cursor trial plan or a COLLSCAN backup plan. We can only optimize     // the $sample aggregation stage if the trial plan was chosen.     return std::pair{std::move(execStatus.getValue()),                      !trialStage || !trialStage->pickedBackupPlan()}; }"
"215122_CWE-787.c","CWE-787","getvcol(     win_T	*wp,     pos_T	*pos,     colnr_T	*start,     colnr_T	*cursor,     colnr_T	*end) {     colnr_T	vcol;     char_u	*ptr;		// points to current char     char_u	*posptr;	// points to char at pos->col     char_u	*line;		// start of the line     int		incr;     int		head; #ifdef FEAT_VARTABS     int		*vts = wp->w_buffer->b_p_vts_array; #endif     int		ts = wp->w_buffer->b_p_ts;     int		c;      vcol = 0;     line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);     if (pos->col == MAXCOL) 	posptr = NULL;  // continue until the NUL     else     { 	// Special check for an empty line, which can happen on exit, when 	// ml_get_buf() always returns an empty string. 	if (*ptr == NUL) 	    pos->col = 0; 	posptr = ptr + pos->col; 	if (has_mbyte) 	    // always start on the first byte 	    posptr -= (*mb_head_off)(line, posptr);     }      /*      * This function is used very often, do some speed optimizations.      * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set      * use a simple loop.      * Also use this when 'list' is set but tabs take their normal size.      */     if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL) #ifdef FEAT_LINEBREAK 	    && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri #endif        )     { 	for (;;) 	{ 	    head = 0; 	    c = *ptr; 	    // make sure we don't go past the end of the line 	    if (c == NUL) 	    { 		incr = 1;	// NUL at end of line only takes one column 		break; 	    } 	    // A tab gets expanded, depending on the current column 	    if (c == TAB) #ifdef FEAT_VARTABS 		incr = tabstop_padding(vcol, ts, vts); #else 		incr = ts - (vcol % ts); #endif 	    else 	    { 		if (has_mbyte) 		{ 		    // For utf-8, if the byte is >= 0x80, need to look at 		    // further bytes to find the cell width. 		    if (enc_utf8 && c >= 0x80) 			incr = utf_ptr2cells(ptr); 		    else 			incr = g_chartab[c] & CT_CELL_MASK;  		    // If a double-cell char doesn't fit at the end of a line 		    // it wraps to the next line, it's like this char is three 		    // cells wide. 		    if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1 			    && in_win_border(wp, vcol)) 		    { 			++incr; 			head = 1; 		    } 		} 		else 		    incr = g_chartab[c] & CT_CELL_MASK; 	    }  	    if (posptr != NULL && ptr >= posptr) // character at pos->col 		break;  	    vcol += incr; 	    MB_PTR_ADV(ptr); 	}     }     else     { 	for (;;) 	{ 	    // A tab gets expanded, depending on the current column 	    head = 0; 	    incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head); 	    // make sure we don't go past the end of the line 	    if (*ptr == NUL) 	    { 		incr = 1;	// NUL at end of line only takes one column 		break; 	    }  	    if (posptr != NULL && ptr >= posptr) // character at pos->col 		break;  	    vcol += incr; 	    MB_PTR_ADV(ptr); 	}     }     if (start != NULL) 	*start = vcol + head;     if (end != NULL) 	*end = vcol + incr - 1;     if (cursor != NULL)     { 	if (*ptr == TAB 		&& (State & NORMAL) 		&& !wp->w_p_list 		&& !virtual_active() 		&& !(VIsual_active 				&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual))) 		) 	    *cursor = vcol + incr - 1;	    // cursor at end 	else 	    *cursor = vcol + head;	    // cursor at start     } }"
"215142_CWE-703.c","CWE-703","setup_secureChannel(void) {     TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);     UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);     UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);      testingConnection = createDummyConnection(65535, &sentData);     UA_Connection_attachSecureChannel(&testingConnection, &testChannel);     testChannel.connection = &testingConnection;      testChannel.state = UA_SECURECHANNELSTATE_OPEN; }"
"215162_CWE-787.cpp","CWE-787","diff_mark_adjust_tp(     tabpage_T	*tp,     int		idx,     linenr_T	line1,     linenr_T	line2,     long	amount,     long	amount_after) {     diff_T	*dp;     diff_T	*dprev;     diff_T	*dnext;     int		i;     int		inserted, deleted;     int		n, off;     linenr_T	last;     linenr_T	lnum_deleted = line1;	// lnum of remaining deletion     int		check_unchanged;      if (diff_internal())     { 	// Will update diffs before redrawing.  Set _invalid to update the 	// diffs themselves, set _update to also update folds properly just 	// before redrawing. 	// Do update marks here, it is needed for :%diffput. 	tp->tp_diff_invalid = TRUE; 	tp->tp_diff_update = TRUE;     }      if (line2 == MAXLNUM)     { 	// mark_adjust(99, MAXLNUM, 9, 0): insert lines 	inserted = amount; 	deleted = 0;     }     else if (amount_after > 0)     { 	// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines 	inserted = amount_after; 	deleted = 0;     }     else     { 	// mark_adjust(98, 99, MAXLNUM, -2): delete lines 	inserted = 0; 	deleted = -amount_after;     }      dprev = NULL;     dp = tp->tp_first_diff;     for (;;)     { 	// If the change is after the previous diff block and before the next 	// diff block, thus not touching an existing change, create a new diff 	// block.  Don't do this when ex_diffgetput() is busy. 	if ((dp == NULL || dp->df_lnum[idx] - 1 > line2 		    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1)) 		&& (dprev == NULL 		    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1) 		&& !diff_busy) 	{ 	    dnext = diff_alloc_new(tp, dprev, dp); 	    if (dnext == NULL) 		return;  	    dnext->df_lnum[idx] = line1; 	    dnext->df_count[idx] = inserted; 	    for (i = 0; i < DB_COUNT; ++i) 		if (tp->tp_diffbuf[i] != NULL && i != idx) 		{ 		    if (dprev == NULL) 			dnext->df_lnum[i] = line1; 		    else 			dnext->df_lnum[i] = line1 			    + (dprev->df_lnum[i] + dprev->df_count[i]) 			    - (dprev->df_lnum[idx] + dprev->df_count[idx]); 		    dnext->df_count[i] = deleted; 		} 	}  	// if at end of the list, quit 	if (dp == NULL) 	    break;  	/* 	 * Check for these situations: 	 *	  1  2	3 	 *	  1  2	3 	 * line1     2	3  4  5 	 *	     2	3  4  5 	 *	     2	3  4  5 	 * line2     2	3  4  5 	 *		3     5  6 	 *		3     5  6 	 */ 	// compute last line of this change 	last = dp->df_lnum[idx] + dp->df_count[idx] - 1;  	// 1. change completely above line1: nothing to do 	if (last >= line1 - 1) 	{ 	    // 6. change below line2: only adjust for amount_after; also when 	    // ""deleted"" became zero when deleted all lines between two diffs 	    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2) 	    { 		if (amount_after == 0) 		    break;	// nothing left to change 		dp->df_lnum[idx] += amount_after; 	    } 	    else 	    { 		check_unchanged = FALSE;  		// 2. 3. 4. 5.: inserted/deleted lines touching this diff. 		if (deleted > 0) 		{ 		    if (dp->df_lnum[idx] >= line1) 		    { 			off = dp->df_lnum[idx] - lnum_deleted; 			if (last <= line2) 			{ 			    // 4. delete all lines of diff 			    if (dp->df_next != NULL 				    && dp->df_next->df_lnum[idx] - 1 <= line2) 			    { 				// delete continues in next diff, only do 				// lines until that one 				n = dp->df_next->df_lnum[idx] - lnum_deleted; 				deleted -= n; 				n -= dp->df_count[idx]; 				lnum_deleted = dp->df_next->df_lnum[idx]; 			    } 			    else 				n = deleted - dp->df_count[idx]; 			    dp->df_count[idx] = 0; 			} 			else 			{ 			    // 5. delete lines at or just before top of diff 			    n = off; 			    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1; 			    check_unchanged = TRUE; 			} 			dp->df_lnum[idx] = line1; 		    } 		    else 		    { 			off = 0; 			if (last < line2) 			{ 			    // 2. delete at end of diff 			    dp->df_count[idx] -= last - lnum_deleted + 1; 			    if (dp->df_next != NULL 				    && dp->df_next->df_lnum[idx] - 1 <= line2) 			    { 				// delete continues in next diff, only do 				// lines until that one 				n = dp->df_next->df_lnum[idx] - 1 - last; 				deleted -= dp->df_next->df_lnum[idx] 							       - lnum_deleted; 				lnum_deleted = dp->df_next->df_lnum[idx]; 			    } 			    else 				n = line2 - last; 			    check_unchanged = TRUE; 			} 			else 			{ 			    // 3. delete lines inside the diff 			    n = 0; 			    dp->df_count[idx] -= deleted; 			} 		    }  		    for (i = 0; i < DB_COUNT; ++i) 			if (tp->tp_diffbuf[i] != NULL && i != idx) 			{ 			    dp->df_lnum[i] -= off; 			    dp->df_count[i] += n; 			} 		} 		else 		{ 		    if (dp->df_lnum[idx] <= line1) 		    { 			// inserted lines somewhere in this diff 			dp->df_count[idx] += inserted; 			check_unchanged = TRUE; 		    } 		    else 			// inserted lines somewhere above this diff 			dp->df_lnum[idx] += inserted; 		}  		if (check_unchanged) 		    // Check if inserted lines are equal, may reduce the 		    // size of the diff.  TODO: also check for equal lines 		    // in the middle and perhaps split the block. 		    diff_check_unchanged(tp, dp); 	    } 	}  	// check if this block touches the previous one, may merge them. 	if (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx] 							  == dp->df_lnum[idx]) 	{ 	    for (i = 0; i < DB_COUNT; ++i) 		if (tp->tp_diffbuf[i] != NULL) 		    dprev->df_count[i] += dp->df_count[i]; 	    dprev->df_next = dp->df_next; 	    vim_free(dp); 	    dp = dprev->df_next; 	} 	else 	{ 	    // Advance to next entry. 	    dprev = dp; 	    dp = dp->df_next; 	}     }      dprev = NULL;     dp = tp->tp_first_diff;     while (dp != NULL)     { 	// All counts are zero, remove this entry. 	for (i = 0; i < DB_COUNT; ++i) 	    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0) 		break; 	if (i == DB_COUNT) 	{ 	    dnext = dp->df_next; 	    vim_free(dp); 	    dp = dnext; 	    if (dprev == NULL) 		tp->tp_first_diff = dnext; 	    else 		dprev->df_next = dnext; 	} 	else 	{ 	    // Advance to next entry. 	    dprev = dp; 	    dp = dp->df_next; 	}      }      if (tp == curtab)     { 	// Don't redraw right away, this updates the diffs, which can be slow. 	need_diff_redraw = TRUE;  	// Need to recompute the scroll binding, may remove or add filler 	// lines (e.g., when adding lines above w_topline). But it's slow when 	// making many changes, postpone until redrawing. 	diff_need_scrollbind = TRUE;     } }"
"215188_CWE-787.c","CWE-787","void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {     size_t aoffset = (size_t) abs(offset);     unsigned char *source = buf->data + buf->offset;     if (offset >= 0) {         if (buf->offset + aoffset + len > buf->maxlen) {             debug_print(""%s"", ""End of buffer\n"");             buf->error = MOBI_BUFFER_END;             return;         }         source += aoffset;     } else {         if (buf->offset < aoffset) {             debug_print(""%s"", ""End of buffer\n"");             buf->error = MOBI_BUFFER_END;             return;         }         source -= aoffset;     }     memmove(buf->data + buf->offset, source, len);     buf->offset += len; }"
"215216_CWE-770.c","CWE-770","__zzip_fetch_disk_trailer(int fd, zzip_off_t filesize,                           struct _disk_trailer *_zzip_restrict trailer,                           zzip_plugin_io_t io) { #ifdef DEBUG #define return(val) { e=val; HINT2(""%s"", zzip_strerror(e)); goto cleanup; } #else #define return(val) { e=val; goto cleanup; } #endif     register int e;  #ifndef _LOWSTK     auto char buffer[2 * ZZIP_BUFSIZ];     char *buf = buffer; #else     char *buf = malloc(2 * ZZIP_BUFSIZ); #endif     zzip_off_t offset = 0;     zzip_ssize_t maplen = 0;    /* mmap(),read(),getpagesize() use size_t !! */     char *fd_map = 0;      if (! trailer)         { return(EINVAL); }      if (filesize < __sizeof(struct zzip_disk_trailer))           { return(ZZIP_DIR_TOO_SHORT); }      if (! buf)         { return(ZZIP_OUTOFMEM); }      offset = filesize;          /* a.k.a. old offset */     while (1)                   /* outer loop */     {         register unsigned char *mapped;          if (offset <= 0)             { return(ZZIP_DIR_EDH_MISSING); }          /* trailer cannot be farther away than 64K from fileend */         if (filesize - offset > 64 * 1024)             { return(ZZIP_DIR_EDH_MISSING); }          /* the new offset shall overlap with the area after the old offset! */         if (USE_MMAP && io->fd.sys)         {             zzip_off_t mapoff = offset;             {                 zzip_ssize_t pagesize = _zzip_getpagesize(io->fd.sys);                 if (pagesize < ZZIP_BUFSIZ)                     goto non_mmap;      /* an error? */                 if (mapoff == filesize && filesize > pagesize)                     mapoff -= pagesize;                 if (mapoff < pagesize)                 {                     maplen = (zzip_ssize_t) mapoff + pagesize;                     mapoff = 0;                 } else                 {                     mapoff -= pagesize;                     maplen = 2 * pagesize;                     if ((zzip_ssize_t) mapoff & (pagesize - 1))                     {           /*only 1. run */                         pagesize -= (zzip_ssize_t) mapoff & (pagesize - 1);                         mapoff += pagesize;                         maplen -= pagesize;                     }                 }                 if (mapoff + maplen > filesize)                     maplen = filesize - mapoff;             }              fd_map = _zzip_mmap(io->fd.sys, fd, mapoff, (zzip_size_t) maplen);             if (fd_map == MAP_FAILED)                 goto non_mmap;             mapped = (unsigned char *) fd_map;             offset = mapoff;    /* success */             HINT3(""mapped *%p len=%li"", fd_map, (long) maplen);         } else         {           non_mmap:             fd_map = 0;         /* have no mmap */             {                 zzip_off_t pagesize = ZZIP_BUFSIZ;                 if (offset == filesize && filesize > pagesize)                     offset -= pagesize;                 if (offset < pagesize)                 {                     maplen = (zzip_ssize_t) offset + pagesize;                     offset = 0;                 } else                 {                     offset -= pagesize;                     maplen = 2 * pagesize;                     if ((zzip_ssize_t) offset & (pagesize - 1))                     {           /*on 1st run */                         pagesize -= (zzip_ssize_t) offset & (pagesize - 1);                         offset += pagesize;                         maplen -= pagesize;                     }                 }                 if (offset + maplen > filesize)                     maplen = filesize - offset;             }              if (io->fd.seeks(fd, offset, SEEK_SET) < 0)                 { return(ZZIP_DIR_SEEK); }             if (io->fd.read(fd, buf, (zzip_size_t) maplen) < maplen)                 { return(ZZIP_DIR_READ); }             mapped = (unsigned char *) buf;     /* success */             HINT5(""offs=$%lx len=%li filesize=%li pagesize=%i"",                   (long) offset, (long) maplen, (long) filesize, ZZIP_BUFSIZ);         }          {                       /* now, check for the trailer-magic, hopefully near the end of file */             register unsigned char *end = mapped + maplen;             register unsigned char *tail;             for (tail = end - 1; (tail >= mapped); tail--)             {                 if ((*tail == 'P') &&   /* quick pre-check for trailer magic */                     end - tail >= __sizeof(struct zzip_disk_trailer) - 2 &&                     zzip_disk_trailer_check_magic(tail))                 { #                  ifndef ZZIP_DISK64_TRAILER                     /* if the file-comment is not present, it happens                        that the z_comment field often isn't either */                     if (end - tail >= __sizeof(*trailer))                     {                         memcpy(trailer, tail, sizeof(*trailer));                     } else                     {                         memcpy(trailer, tail, sizeof(*trailer) - 2);                         trailer->z_comment[0] = 0;                         trailer->z_comment[1] = 0;                     } #                  else                     struct zzip_disk_trailer *orig =                         (struct zzip_disk_trailer *) tail;                     trailer->zz_tail = tail;                     trailer->zz_entries = zzip_disk_trailer_localentries(orig);                     trailer->zz_finalentries =                         zzip_disk_trailer_finalentries(orig);                     trailer->zz_rootseek = zzip_disk_trailer_rootseek(orig);                     trailer->zz_rootsize = zzip_disk_trailer_rootsize(orig); #                  endif                      __fixup_rootseek(offset + tail - mapped, trailer);                     { return(0); }                 } else if ((*tail == 'P') &&                            end - tail >=                            __sizeof(struct zzip_disk64_trailer) - 2                            && zzip_disk64_trailer_check_magic(tail))                 { #                  ifndef ZZIP_DISK64_TRAILER                     return (ZZIP_DIR_LARGEFILE); #                  else                     struct zzip_disk64_trailer *orig =                         (struct zzip_disk64_trailer *) tail;                     trailer->zz_tail = tail;                     trailer->zz_entries =                         zzip_disk64_trailer_localentries(orig);                     trailer->zz_finalentries =                         zzip_disk64_trailer_finalentries(orig);                     trailer->zz_rootseek = zzip_disk64_trailer_rootseek(orig);                     trailer->zz_rootsize = zzip_disk64_trailer_rootsize(orig);                     { return(0); } #                  endif                 }             }         }          if (USE_MMAP && fd_map)         {             HINT3(""unmap *%p len=%li"", fd_map, (long) maplen);             _zzip_munmap(io->fd.sys, fd_map, (zzip_size_t) maplen);             fd_map = 0;         }     }                           /*outer loop */    cleanup:     if (USE_MMAP && fd_map)     {         HINT3(""unmap *%p len=%li"", fd_map, (long) maplen);         _zzip_munmap(io->fd.sys, fd_map, (zzip_size_t) maplen);     } #   ifdef _LOWSTK     free(buf); #   endif #   undef return     return e; }"
"215262_CWE-835.c","CWE-835","static void gem_transmit(CadenceGEMState *s) {     uint32_t desc[DESC_MAX_NUM_WORDS];     hwaddr packet_desc_addr;     uint8_t     *p;     unsigned    total_bytes;     int q = 0;      /* Do nothing if transmit is not enabled. */     if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {         return;     }      DB_PRINT(""\n"");      /* The packet we will hand off to QEMU.      * Packets scattered across multiple descriptors are gathered to this      * one contiguous buffer first.      */     p = s->tx_packet;     total_bytes = 0;      for (q = s->num_priority_queues - 1; q >= 0; q--) {         /* read current descriptor */         packet_desc_addr = gem_get_tx_desc_addr(s, q);          DB_PRINT(""read descriptor 0x%"" HWADDR_PRIx ""\n"", packet_desc_addr);         address_space_read(&s->dma_as, packet_desc_addr,                            MEMTXATTRS_UNSPECIFIED, desc,                            sizeof(uint32_t) * gem_get_desc_len(s, false));         /* Handle all descriptors owned by hardware */         while (tx_desc_get_used(desc) == 0) {              /* Do nothing if transmit is not enabled. */             if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {                 return;             }             print_gem_tx_desc(desc, q);              /* The real hardware would eat this (and possibly crash).              * For QEMU let's lend a helping hand.              */             if ((tx_desc_get_buffer(s, desc) == 0) ||                 (tx_desc_get_length(desc) == 0)) {                 DB_PRINT(""Invalid TX descriptor @ 0x%"" HWADDR_PRIx ""\n"",                          packet_desc_addr);                 break;             }              if (tx_desc_get_length(desc) > gem_get_max_buf_len(s, true) -                                                (p - s->tx_packet)) {                 qemu_log_mask(LOG_GUEST_ERROR, ""TX descriptor @ 0x%"" \                          HWADDR_PRIx "" too large: size 0x%x space 0x%zx\n"",                          packet_desc_addr, tx_desc_get_length(desc),                          gem_get_max_buf_len(s, true) - (p - s->tx_packet));                 gem_set_isr(s, q, GEM_INT_AMBA_ERR);                 break;             }              /* Gather this fragment of the packet from ""dma memory"" to our              * contig buffer.              */             address_space_read(&s->dma_as, tx_desc_get_buffer(s, desc),                                MEMTXATTRS_UNSPECIFIED,                                p, tx_desc_get_length(desc));             p += tx_desc_get_length(desc);             total_bytes += tx_desc_get_length(desc);              /* Last descriptor for this packet; hand the whole thing off */             if (tx_desc_get_last(desc)) {                 uint32_t desc_first[DESC_MAX_NUM_WORDS];                 hwaddr desc_addr = gem_get_tx_desc_addr(s, q);                  /* Modify the 1st descriptor of this packet to be owned by                  * the processor.                  */                 address_space_read(&s->dma_as, desc_addr,                                    MEMTXATTRS_UNSPECIFIED, desc_first,                                    sizeof(desc_first));                 tx_desc_set_used(desc_first);                 address_space_write(&s->dma_as, desc_addr,                                     MEMTXATTRS_UNSPECIFIED, desc_first,                                     sizeof(desc_first));                 /* Advance the hardware current descriptor past this packet */                 if (tx_desc_get_wrap(desc)) {                     s->tx_desc_addr[q] = gem_get_tx_queue_base_addr(s, q);                 } else {                     s->tx_desc_addr[q] = packet_desc_addr +                                          4 * gem_get_desc_len(s, false);                 }                 DB_PRINT(""TX descriptor next: 0x%08x\n"", s->tx_desc_addr[q]);                  s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;                 gem_set_isr(s, q, GEM_INT_TXCMPL);                  /* Handle interrupt consequences */                 gem_update_int_status(s);                  /* Is checksum offload enabled? */                 if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {                     net_checksum_calculate(s->tx_packet, total_bytes, CSUM_ALL);                 }                  /* Update MAC statistics */                 gem_transmit_updatestats(s, s->tx_packet, total_bytes);                  /* Send the packet somewhere */                 if (s->phy_loop || (s->regs[GEM_NWCTRL] &                                     GEM_NWCTRL_LOCALLOOP)) {                     gem_receive(qemu_get_queue(s->nic), s->tx_packet,                                 total_bytes);                 } else {                     qemu_send_packet(qemu_get_queue(s->nic), s->tx_packet,                                      total_bytes);                 }                  /* Prepare for next packet */                 p = s->tx_packet;                 total_bytes = 0;             }              /* read next descriptor */             if (tx_desc_get_wrap(desc)) {                  if (s->regs[GEM_DMACFG] & GEM_DMACFG_ADDR_64B) {                     packet_desc_addr = s->regs[GEM_TBQPH];                     packet_desc_addr <<= 32;                 } else {                     packet_desc_addr = 0;                 }                 packet_desc_addr |= gem_get_tx_queue_base_addr(s, q);             } else {                 packet_desc_addr += 4 * gem_get_desc_len(s, false);             }             DB_PRINT(""read descriptor 0x%"" HWADDR_PRIx ""\n"", packet_desc_addr);             address_space_read(&s->dma_as, packet_desc_addr,                                MEMTXATTRS_UNSPECIFIED, desc,                                sizeof(uint32_t) * gem_get_desc_len(s, false));         }          if (tx_desc_get_used(desc)) {             s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;             /* IRQ TXUSED is defined only for queue 0 */             if (q == 0) {                 gem_set_isr(s, 0, GEM_INT_TXUSED);             }             gem_update_int_status(s);         }     } }"
"215264_CWE-120.c","CWE-120","STATIC SSize_t S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,                         SSize_t *minlenp, SSize_t *deltap, 			regnode *last, 			scan_data_t *data, 			I32 stopparen,                         U32 recursed_depth, 			regnode_ssc *and_withp, 			U32 flags, U32 depth) 			/* scanp: Start here (read-write). */ 			/* deltap: Write maxlen-minlen here. */ 			/* last: Stop before this one. */ 			/* data: string data about the pattern */ 			/* stopparen: treat close N as END */ 			/* recursed: which subroutines have we recursed into */ 			/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */ {     dVAR;     /* There must be at least this number of characters to match */     SSize_t min = 0;     I32 pars = 0, code;     regnode *scan = *scanp, *next;     SSize_t delta = 0;     int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);     int is_inf_internal = 0;		/* The studied chunk is infinite */     I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;     scan_data_t data_fake;     SV *re_trie_maxbuff = NULL;     regnode *first_non_open = scan;     SSize_t stopmin = SSize_t_MAX;     scan_frame *frame = NULL;     GET_RE_DEBUG_FLAGS_DECL;      PERL_ARGS_ASSERT_STUDY_CHUNK;     RExC_study_started= 1;      Zero(&data_fake, 1, scan_data_t);      if ( depth == 0 ) {         while (first_non_open && OP(first_non_open) == OPEN)             first_non_open=regnext(first_non_open);     }     fake_study_recurse:     DEBUG_r(         RExC_study_chunk_recursed_count++;     );     DEBUG_OPTIMISE_MORE_r(     {         Perl_re_indentf( aTHX_  ""study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p"",             depth, (long)stopparen,             (unsigned long)RExC_study_chunk_recursed_count,             (unsigned long)depth, (unsigned long)recursed_depth,             scan,             last);         if (recursed_depth) {             U32 i;             U32 j;             for ( j = 0 ; j < recursed_depth ; j++ ) {                 for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {                     if (                         PAREN_TEST(RExC_study_chunk_recursed +                                    ( j * RExC_study_chunk_recursed_bytes), i )                         && (                             !j ||                             !PAREN_TEST(RExC_study_chunk_recursed +                                    (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)                         )                     ) {                         Perl_re_printf( aTHX_ "" %d"",(int)i);                         break;                     }                 }                 if ( j + 1 < recursed_depth ) {                     Perl_re_printf( aTHX_  "","");                 }             }         }         Perl_re_printf( aTHX_ ""\n"");     }     );     while ( scan && OP(scan) != END && scan < last ){         UV min_subtract = 0;    /* How mmany chars to subtract from the minimum                                    node length to get a real minimum (because                                    the folded version may be shorter) */ 	bool unfolded_multi_char = FALSE; 	/* Peephole optimizer: */         DEBUG_STUDYDATA(""Peep"", data, depth, is_inf);         DEBUG_PEEP(""Peep"", scan, depth, flags);           /* The reason we do this here is that we need to deal with things like          * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT          * parsing code, as each (?:..) is handled by a different invocation of          * reg() -- Yves          */         JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);          /* Follow the next-chain of the current node and optimize            away all the NOTHINGs from it.          */         rck_elide_nothing(scan);  	/* The principal pseudo-switch.  Cannot be a switch, since we 	   look into several different things.  */         if ( OP(scan) == DEFINEP ) {             SSize_t minlen = 0;             SSize_t deltanext = 0;             SSize_t fake_last_close = 0;             I32 f = SCF_IN_DEFINE;              StructCopy(&zero_scan_data, &data_fake, scan_data_t);             scan = regnext(scan);             assert( OP(scan) == IFTHEN );             DEBUG_PEEP(""expect IFTHEN"", scan, depth, flags);              data_fake.last_closep= &fake_last_close;             minlen = *minlenp;             next = regnext(scan);             scan = NEXTOPER(NEXTOPER(scan));             DEBUG_PEEP(""scan"", scan, depth, flags);             DEBUG_PEEP(""next"", next, depth, flags);              /* we suppose the run is continuous, last=next...              * NOTE we dont use the return here! */             /* DEFINEP study_chunk() recursion */             (void)study_chunk(pRExC_state, &scan, &minlen,                               &deltanext, next, &data_fake, stopparen,                               recursed_depth, NULL, f, depth+1);              scan = next;         } else         if (             OP(scan) == BRANCH  ||             OP(scan) == BRANCHJ ||             OP(scan) == IFTHEN         ) { 	    next = regnext(scan); 	    code = OP(scan);              /* The op(next)==code check below is to see if we              * have ""BRANCH-BRANCH"", ""BRANCHJ-BRANCHJ"", ""IFTHEN-IFTHEN""              * IFTHEN is special as it might not appear in pairs.              * Not sure whether BRANCH-BRANCHJ is possible, regardless              * we dont handle it cleanly. */ 	    if (OP(next) == code || code == IFTHEN) {                 /* NOTE - There is similar code to this block below for                  * handling TRIE nodes on a re-study.  If you change stuff here                  * check there too. */ 		SSize_t max1 = 0, min1 = SSize_t_MAX, num = 0; 		regnode_ssc accum; 		regnode * const startbranch=scan;                  if (flags & SCF_DO_SUBSTR) {                     /* Cannot merge strings after this. */                     scan_commit(pRExC_state, data, minlenp, is_inf);                 }                  if (flags & SCF_DO_STCLASS) 		    ssc_init_zero(pRExC_state, &accum);  		while (OP(scan) == code) { 		    SSize_t deltanext, minnext, fake; 		    I32 f = 0; 		    regnode_ssc this_class;                      DEBUG_PEEP(""Branch"", scan, depth, flags);  		    num++;                     StructCopy(&zero_scan_data, &data_fake, scan_data_t); 		    if (data) { 			data_fake.whilem_c = data->whilem_c; 			data_fake.last_closep = data->last_closep; 		    } 		    else 			data_fake.last_closep = &fake;  		    data_fake.pos_delta = delta; 		    next = regnext(scan);                      scan = NEXTOPER(scan); /* everything */                     if (code != BRANCH)    /* everything but BRANCH */ 			scan = NEXTOPER(scan);  		    if (flags & SCF_DO_STCLASS) { 			ssc_init(pRExC_state, &this_class); 			data_fake.start_class = &this_class; 			f = SCF_DO_STCLASS_AND; 		    } 		    if (flags & SCF_WHILEM_VISITED_POS) 			f |= SCF_WHILEM_VISITED_POS;  		    /* we suppose the run is continuous, last=next...*/                     /* recurse study_chunk() for each BRANCH in an alternation */ 		    minnext = study_chunk(pRExC_state, &scan, minlenp,                                       &deltanext, next, &data_fake, stopparen,                                       recursed_depth, NULL, f, depth+1);  		    if (min1 > minnext) 			min1 = minnext; 		    if (deltanext == SSize_t_MAX) { 			is_inf = is_inf_internal = 1; 			max1 = SSize_t_MAX; 		    } else if (max1 < minnext + deltanext) 			max1 = minnext + deltanext; 		    scan = next; 		    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR)) 			pars++; 	            if (data_fake.flags & SCF_SEEN_ACCEPT) { 	                if ( stopmin > minnext) 	                    stopmin = min + min1; 	                flags &= ~SCF_DO_SUBSTR; 	                if (data) 	                    data->flags |= SCF_SEEN_ACCEPT; 	            } 		    if (data) { 			if (data_fake.flags & SF_HAS_EVAL) 			    data->flags |= SF_HAS_EVAL; 			data->whilem_c = data_fake.whilem_c; 		    } 		    if (flags & SCF_DO_STCLASS) 			ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class); 		} 		if (code == IFTHEN && num < 2) /* Empty ELSE branch */ 		    min1 = 0; 		if (flags & SCF_DO_SUBSTR) { 		    data->pos_min += min1; 		    if (data->pos_delta >= SSize_t_MAX - (max1 - min1)) 		        data->pos_delta = SSize_t_MAX; 		    else 		        data->pos_delta += max1 - min1; 		    if (max1 != min1 || is_inf) 			data->cur_is_floating = 1; 		} 		min += min1; 		if (delta == SSize_t_MAX 		 || SSize_t_MAX - delta - (max1 - min1) < 0) 		    delta = SSize_t_MAX; 		else 		    delta += max1 - min1; 		if (flags & SCF_DO_STCLASS_OR) { 		    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum); 		    if (min1) { 			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp); 			flags &= ~SCF_DO_STCLASS; 		    } 		} 		else if (flags & SCF_DO_STCLASS_AND) { 		    if (min1) { 			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum); 			flags &= ~SCF_DO_STCLASS; 		    } 		    else { 			/* Switch to OR mode: cache the old value of 			 * data->start_class */ 			INIT_AND_WITHP; 			StructCopy(data->start_class, and_withp, regnode_ssc); 			flags &= ~SCF_DO_STCLASS_AND; 			StructCopy(&accum, data->start_class, regnode_ssc); 			flags |= SCF_DO_STCLASS_OR; 		    } 		}                  if (PERL_ENABLE_TRIE_OPTIMISATION &&                         OP( startbranch ) == BRANCH )                 { 		/* demq.                     Assuming this was/is a branch we are dealing with: 'scan'                    now points at the item that follows the branch sequence,                    whatever it is. We now start at the beginning of the                    sequence and look for subsequences of  		   BRANCH->EXACT=>x1 		   BRANCH->EXACT=>x2 		   tail                     which would be constructed from a pattern like                    /A|LIST|OF|WORDS/  		   If we can find such a subsequence we need to turn the first 		   element into a trie and then add the subsequent branch exact 		   strings to the trie.  		   We have two cases                       1. patterns where the whole set of branches can be                         converted.  		     2. patterns where only a subset can be converted.  		   In case 1 we can replace the whole set with a single regop 		   for the trie. In case 2 we need to keep the start and end 		   branches so  		     'BRANCH EXACT; BRANCH EXACT; BRANCH X' 		     becomes BRANCH TRIE; BRANCH X;  		  There is an additional case, that being where there is a 		  common prefix, which gets split out into an EXACT like node 		  preceding the TRIE node.  		  If x(1..n)==tail then we can do a simple trie, if not we make 		  a ""jump"" trie, such that when we match the appropriate word 		  we ""jump"" to the appropriate tail node. Essentially we turn 		  a nested if into a case structure of sorts.  		*/  		    int made=0; 		    if (!re_trie_maxbuff) { 			re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1); 			if (!SvIOK(re_trie_maxbuff)) 			    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT); 		    }                     if ( SvIV(re_trie_maxbuff)>=0  ) {                         regnode *cur;                         regnode *first = (regnode *)NULL;                         regnode *last = (regnode *)NULL;                         regnode *tail = scan;                         U8 trietype = 0;                         U32 count=0;                          /* var tail is used because there may be a TAIL                            regop in the way. Ie, the exacts will point to the                            thing following the TAIL, but the last branch will                            point at the TAIL. So we advance tail. If we                            have nested (?:) we may have to move through several                            tails.                          */                          while ( OP( tail ) == TAIL ) {                             /* this is the TAIL generated by (?:) */                             tail = regnext( tail );                         }                           DEBUG_TRIE_COMPILE_r({                             regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);                             Perl_re_indentf( aTHX_  ""%s %"" UVuf "":%s\n"",                               depth+1,                               ""Looking for TRIE'able sequences. Tail node is "",                               (UV) REGNODE_OFFSET(tail),                               SvPV_nolen_const( RExC_mysv )                             );                         });                          /*                              Step through the branches                                 cur represents each branch,                                 noper is the first thing to be matched as part                                       of that branch                                 noper_next is the regnext() of that node.                              We normally handle a case like this                             /FOO[xyz]|BAR[pqr]/ via a ""jump trie"" but we also                             support building with NOJUMPTRIE, which restricts                             the trie logic to structures like /FOO|BAR/.                              If noper is a trieable nodetype then the branch is                             a possible optimization target. If we are building                             under NOJUMPTRIE then we require that noper_next is                             the same as scan (our current position in the regex                             program).                              Once we have two or more consecutive such branches                             we can create a trie of the EXACT's contents and                             stitch it in place into the program.                              If the sequence represents all of the branches in                             the alternation we replace the entire thing with a                             single TRIE node.                              Otherwise when it is a subsequence we need to                             stitch it in place and replace only the relevant                             branches. This means the first branch has to remain                             as it is used by the alternation logic, and its                             next pointer, and needs to be repointed at the item                             on the branch chain following the last branch we                             have optimized away.                              This could be either a BRANCH, in which case the                             subsequence is internal, or it could be the item                             following the branch sequence in which case the                             subsequence is at the end (which does not                             necessarily mean the first node is the start of the                             alternation).                              TRIE_TYPE(X) is a define which maps the optype to a                             trietype.                                  optype          |  trietype                                 ----------------+-----------                                 NOTHING         | NOTHING                                 EXACT           | EXACT                                 EXACT_ONLY8     | EXACT                                 EXACTFU         | EXACTFU                                 EXACTFU_ONLY8   | EXACTFU                                 EXACTFUP        | EXACTFU                                 EXACTFAA        | EXACTFAA                                 EXACTL          | EXACTL                                 EXACTFLU8       | EXACTFLU8                           */ #define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \                        ? NOTHING                                            \                        : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \                          ? EXACT                                            \                          : (     EXACTFU == (X)                             \                               || EXACTFU_ONLY8 == (X)                       \                               || EXACTFUP == (X) )                          \                            ? EXACTFU                                        \                            : ( EXACTFAA == (X) )                            \                              ? EXACTFAA                                     \                              : ( EXACTL == (X) )                            \                                ? EXACTL                                     \                                : ( EXACTFLU8 == (X) )                       \                                  ? EXACTFLU8                                \                                  : 0 )                          /* dont use tail as the end marker for this traverse */                         for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {                             regnode * const noper = NEXTOPER( cur );                             U8 noper_type = OP( noper );                             U8 noper_trietype = TRIE_TYPE( noper_type ); #if defined(DEBUGGING) || defined(NOJUMPTRIE)                             regnode * const noper_next = regnext( noper );                             U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;                             U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0; #endif                              DEBUG_TRIE_COMPILE_r({                                 regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);                                 Perl_re_indentf( aTHX_  ""- %d:%s (%d)"",                                    depth+1,                                    REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );                                  regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);                                 Perl_re_printf( aTHX_  "" -> %d:%s"",                                     REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));                                  if ( noper_next ) {                                   regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);                                   Perl_re_printf( aTHX_ ""\t=> %d:%s\t"",                                     REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));                                 }                                 Perl_re_printf( aTHX_  ""(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\n"",                                    REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur), 				   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype] 				);                             });                              /* Is noper a trieable nodetype that can be merged                              * with the current trie (if there is one)? */                             if ( noper_trietype                                   &&                                   (                                         ( noper_trietype == NOTHING )                                         || ( trietype == NOTHING )                                         || ( trietype == noper_trietype )                                   ) #ifdef NOJUMPTRIE                                   && noper_next >= tail #endif                                   && count < U16_MAX)                             {                                 /* Handle mergable triable node Either we are                                  * the first node in a new trieable sequence,                                  * in which case we do some bookkeeping,                                  * otherwise we update the end pointer. */                                 if ( !first ) {                                     first = cur; 				    if ( noper_trietype == NOTHING ) { #if !defined(DEBUGGING) && !defined(NOJUMPTRIE) 					regnode * const noper_next = regnext( noper );                                         U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0; 					U8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0; #endif                                          if ( noper_next_trietype ) { 					    trietype = noper_next_trietype;                                         } else if (noper_next_type)  {                                             /* a NOTHING regop is 1 regop wide.                                              * We need at least two for a trie                                              * so we can't merge this in */                                             first = NULL;                                         }                                     } else {                                         trietype = noper_trietype;                                     }                                 } else {                                     if ( trietype == NOTHING )                                         trietype = noper_trietype;                                     last = cur;                                 } 				if (first) 				    count++;                             } /* end handle mergable triable node */                             else {                                 /* handle unmergable node -                                  * noper may either be a triable node which can                                  * not be tried together with the current trie,                                  * or a non triable node */                                 if ( last ) {                                     /* If last is set and trietype is not                                      * NOTHING then we have found at least two                                      * triable branch sequences in a row of a                                      * similar trietype so we can turn them                                      * into a trie. If/when we allow NOTHING to                                      * start a trie sequence this condition                                      * will be required, and it isn't expensive                                      * so we leave it in for now. */                                     if ( trietype && trietype != NOTHING )                                         make_trie( pRExC_state,                                                 startbranch, first, cur, tail,                                                 count, trietype, depth+1 );                                     last = NULL; /* note: we clear/update                                                     first, trietype etc below,                                                     so we dont do it here */                                 }                                 if ( noper_trietype #ifdef NOJUMPTRIE                                      && noper_next >= tail #endif                                 ){                                     /* noper is triable, so we can start a new                                      * trie sequence */                                     count = 1;                                     first = cur;                                     trietype = noper_trietype;                                 } else if (first) {                                     /* if we already saw a first but the                                      * current node is not triable then we have                                      * to reset the first information. */                                     count = 0;                                     first = NULL;                                     trietype = 0;                                 }                             } /* end handle unmergable node */                         } /* loop over branches */                         DEBUG_TRIE_COMPILE_r({                             regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);                             Perl_re_indentf( aTHX_  ""- %s (%d) <SCAN FINISHED> "",                               depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));                             Perl_re_printf( aTHX_  ""(First==%d, Last==%d, Cur==%d, tt==%s)\n"",                                REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),                                PL_reg_name[trietype]                             );                          });                         if ( last && trietype ) {                             if ( trietype != NOTHING ) {                                 /* the last branch of the sequence was part of                                  * a trie, so we have to construct it here                                  * outside of the loop */                                 made= make_trie( pRExC_state, startbranch,                                                  first, scan, tail, count,                                                  trietype, depth+1 ); #ifdef TRIE_STUDY_OPT                                 if ( ((made == MADE_EXACT_TRIE &&                                      startbranch == first)                                      || ( first_non_open == first )) &&                                      depth==0 ) {                                     flags |= SCF_TRIE_RESTUDY;                                     if ( startbranch == first                                          && scan >= tail )                                     {                                         RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;                                     }                                 } #endif                             } else {                                 /* at this point we know whatever we have is a                                  * NOTHING sequence/branch AND if 'startbranch'                                  * is 'first' then we can turn the whole thing                                  * into a NOTHING                                  */                                 if ( startbranch == first ) {                                     regnode *opt;                                     /* the entire thing is a NOTHING sequence,                                      * something like this: (?:|) So we can                                      * turn it into a plain NOTHING op. */                                     DEBUG_TRIE_COMPILE_r({                                         regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);                                         Perl_re_indentf( aTHX_  ""- %s (%d) <NOTHING BRANCH SEQUENCE>\n"",                                           depth+1,                                           SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));                                      });                                     OP(startbranch)= NOTHING;                                     NEXT_OFF(startbranch)= tail - startbranch;                                     for ( opt= startbranch + 1; opt < tail ; opt++ )                                         OP(opt)= OPTIMIZED;                                 }                             }                         } /* end if ( last) */                     } /* TRIE_MAXBUF is non zero */                  } /* do trie */  	    } 	    else if ( code == BRANCHJ ) {  /* single branch is optimized. */ 		scan = NEXTOPER(NEXTOPER(scan)); 	    } else			/* single branch is optimized. */ 		scan = NEXTOPER(scan); 	    continue;         } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {             I32 paren = 0;             regnode *start = NULL;             regnode *end = NULL;             U32 my_recursed_depth= recursed_depth;              if (OP(scan) != SUSPEND) { /* GOSUB */                 /* Do setup, note this code has side effects beyond                  * the rest of this block. Specifically setting                  * RExC_recurse[] must happen at least once during                  * study_chunk(). */                 paren = ARG(scan);                 RExC_recurse[ARG2L(scan)] = scan;                 start = REGNODE_p(RExC_open_parens[paren]);                 end   = REGNODE_p(RExC_close_parens[paren]);                  /* NOTE we MUST always execute the above code, even                  * if we do nothing with a GOSUB */                 if (                     ( flags & SCF_IN_DEFINE )                     ||                     (                         (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))                         &&                         ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )                     )                 ) {                     /* no need to do anything here if we are in a define. */                     /* or we are after some kind of infinite construct                      * so we can skip recursing into this item.                      * Since it is infinite we will not change the maxlen                      * or delta, and if we miss something that might raise                      * the minlen it will merely pessimise a little.                      *                      * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/                      * might result in a minlen of 1 and not of 4,                      * but this doesn't make us mismatch, just try a bit                      * harder than we should.                      * */                     scan= regnext(scan);                     continue;                 }                  if (                     !recursed_depth                     ||                     !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)                 ) {                     /* it is quite possible that there are more efficient ways                      * to do this. We maintain a bitmap per level of recursion                      * of which patterns we have entered so we can detect if a                      * pattern creates a possible infinite loop. When we                      * recurse down a level we copy the previous levels bitmap                      * down. When we are at recursion level 0 we zero the top                      * level bitmap. It would be nice to implement a different                      * more efficient way of doing this. In particular the top                      * level bitmap may be unnecessary.                      */                     if (!recursed_depth) {                         Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);                     } else {                         Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),                              RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),                              RExC_study_chunk_recursed_bytes, U8);                     }                     /* we havent recursed into this paren yet, so recurse into it */                     DEBUG_STUDYDATA(""gosub-set"", data, depth, is_inf);                     PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);                     my_recursed_depth= recursed_depth + 1;                 } else {                     DEBUG_STUDYDATA(""gosub-inf"", data, depth, is_inf);                     /* some form of infinite recursion, assume infinite length                      * */                     if (flags & SCF_DO_SUBSTR) {                         scan_commit(pRExC_state, data, minlenp, is_inf);                         data->cur_is_floating = 1;                     }                     is_inf = is_inf_internal = 1;                     if (flags & SCF_DO_STCLASS_OR) /* Allow everything */                         ssc_anything(data->start_class);                     flags &= ~SCF_DO_STCLASS;                      start= NULL; /* reset start so we dont recurse later on. */ 	        }             } else { 	        paren = stopparen;                 start = scan + 2; 	        end = regnext(scan); 	    }             if (start) {                 scan_frame *newframe;                 assert(end);                 if (!RExC_frame_last) {                     Newxz(newframe, 1, scan_frame);                     SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);                     RExC_frame_head= newframe;                     RExC_frame_count++;                 } else if (!RExC_frame_last->next_frame) {                     Newxz(newframe, 1, scan_frame);                     RExC_frame_last->next_frame= newframe;                     newframe->prev_frame= RExC_frame_last;                     RExC_frame_count++;                 } else {                     newframe= RExC_frame_last->next_frame;                 }                 RExC_frame_last= newframe;                  newframe->next_regnode = regnext(scan);                 newframe->last_regnode = last;                 newframe->stopparen = stopparen;                 newframe->prev_recursed_depth = recursed_depth;                 newframe->this_prev_frame= frame;                  DEBUG_STUDYDATA(""frame-new"", data, depth, is_inf);                 DEBUG_PEEP(""fnew"", scan, depth, flags);  	        frame = newframe; 	        scan =  start; 	        stopparen = paren; 	        last = end;                 depth = depth + 1;                 recursed_depth= my_recursed_depth;  	        continue; 	    } 	} 	else if (   OP(scan) == EXACT                  || OP(scan) == EXACT_ONLY8                  || OP(scan) == EXACTL)         { 	    SSize_t l = STR_LEN(scan); 	    UV uc;             assert(l); 	    if (UTF) { 		const U8 * const s = (U8*)STRING(scan); 		uc = utf8_to_uvchr_buf(s, s + l, NULL); 		l = utf8_length(s, s + l); 	    } else { 		uc = *((U8*)STRING(scan)); 	    } 	    min += l; 	    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */ 		/* The code below prefers earlier match for fixed 		   offset, later match for variable offset.  */ 		if (data->last_end == -1) { /* Update the start info. */ 		    data->last_start_min = data->pos_min;  		    data->last_start_max = is_inf  			? SSize_t_MAX : data->pos_min + data->pos_delta; 		} 		sv_catpvn(data->last_found, STRING(scan), STR_LEN(scan)); 		if (UTF) 		    SvUTF8_on(data->last_found); 		{ 		    SV * const sv = data->last_found; 		    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? 			mg_find(sv, PERL_MAGIC_utf8) : NULL; 		    if (mg && mg->mg_len >= 0) 			mg->mg_len += utf8_length((U8*)STRING(scan),                                               (U8*)STRING(scan)+STR_LEN(scan)); 		} 		data->last_end = data->pos_min + l; 		data->pos_min += l; /* As in the first entry. */ 		data->flags &= ~SF_BEFORE_EOL; 	    }              /* ANDing the code point leaves at most it, and not in locale, and              * can't match null string */ 	    if (flags & SCF_DO_STCLASS_AND) {                 ssc_cp_and(data->start_class, uc);                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;                 ssc_clear_locale(data->start_class); 	    } 	    else if (flags & SCF_DO_STCLASS_OR) {                 ssc_add_cp(data->start_class, uc); 		ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);                  /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING; 	    } 	    flags &= ~SCF_DO_STCLASS; 	}         else if (PL_regkind[OP(scan)] == EXACT) {             /* But OP != EXACT!, so is EXACTFish */ 	    SSize_t l = STR_LEN(scan);             const U8 * s = (U8*)STRING(scan);  	    /* Search for fixed substrings supports EXACT only. */ 	    if (flags & SCF_DO_SUBSTR) { 		assert(data);                 scan_commit(pRExC_state, data, minlenp, is_inf); 	    } 	    if (UTF) { 		l = utf8_length(s, s + l); 	    } 	    if (unfolded_multi_char) {                 RExC_seen |= REG_UNFOLDED_MULTI_SEEN; 	    } 	    min += l - min_subtract;             assert (min >= 0);             delta += min_subtract; 	    if (flags & SCF_DO_SUBSTR) { 		data->pos_min += l - min_subtract; 		if (data->pos_min < 0) {                     data->pos_min = 0;                 }                 data->pos_delta += min_subtract; 		if (min_subtract) { 		    data->cur_is_floating = 1; /* float */ 		} 	    }              if (flags & SCF_DO_STCLASS) {                 SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);                  assert(EXACTF_invlist);                 if (flags & SCF_DO_STCLASS_AND) {                     if (OP(scan) != EXACTFL)                         ssc_clear_locale(data->start_class);                     ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;                     ANYOF_POSIXL_ZERO(data->start_class);                     ssc_intersection(data->start_class, EXACTF_invlist, FALSE);                 }                 else {  /* SCF_DO_STCLASS_OR */                     ssc_union(data->start_class, EXACTF_invlist, FALSE);                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);                      /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */                     ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;                 }                 flags &= ~SCF_DO_STCLASS;                 SvREFCNT_dec(EXACTF_invlist);             } 	} 	else if (REGNODE_VARIES(OP(scan))) { 	    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0; 	    I32 fl = 0, f = flags; 	    regnode * const oscan = scan; 	    regnode_ssc this_class; 	    regnode_ssc *oclass = NULL; 	    I32 next_is_eval = 0;  	    switch (PL_regkind[OP(scan)]) { 	    case WHILEM:		/* End of (?:...)* . */ 		scan = NEXTOPER(scan); 		goto finish; 	    case PLUS: 		if (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) { 		    next = NEXTOPER(scan); 		    if (   OP(next) == EXACT                         || OP(next) == EXACT_ONLY8                         || OP(next) == EXACTL                         || (flags & SCF_DO_STCLASS))                     { 			mincount = 1; 			maxcount = REG_INFTY; 			next = regnext(scan); 			scan = NEXTOPER(scan); 			goto do_curly; 		    } 		} 		if (flags & SCF_DO_SUBSTR) 		    data->pos_min++; 		min++; 		/* FALLTHROUGH */ 	    case STAR:                 next = NEXTOPER(scan);                  /* This temporary node can now be turned into EXACTFU, and                  * must, as regexec.c doesn't handle it */                 if (OP(next) == EXACTFU_S_EDGE) {                     OP(next) = EXACTFU;                 }                  if (     STR_LEN(next) == 1                     &&   isALPHA_A(* STRING(next))                     && (         OP(next) == EXACTFAA                         || (     OP(next) == EXACTFU                             && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next)))))                 {                     /* These differ in just one bit */                     U8 mask = ~ ('A' ^ 'a');                      assert(isALPHA_A(* STRING(next)));                      /* Then replace it by an ANYOFM node, with                     * the mask set to the complement of the                     * bit that differs between upper and lower                     * case, and the lowest code point of the                     * pair (which the '&' forces) */                     OP(next) = ANYOFM;                     ARG_SET(next, *STRING(next) & mask);                     FLAGS(next) = mask;                 }  		if (flags & SCF_DO_STCLASS) { 		    mincount = 0; 		    maxcount = REG_INFTY; 		    next = regnext(scan); 		    scan = NEXTOPER(scan); 		    goto do_curly; 		} 		if (flags & SCF_DO_SUBSTR) {                     scan_commit(pRExC_state, data, minlenp, is_inf);                     /* Cannot extend fixed substrings */ 		    data->cur_is_floating = 1; /* float */ 		}                 is_inf = is_inf_internal = 1;                 scan = regnext(scan); 		goto optimize_curly_tail; 	    case CURLY: 	        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM) 	            && (scan->flags == stopparen)) 		{ 		    mincount = 1; 		    maxcount = 1; 		} else { 		    mincount = ARG1(scan); 		    maxcount = ARG2(scan); 		} 		next = regnext(scan); 		if (OP(scan) == CURLYX) { 		    I32 lp = (data ? *(data->last_closep) : 0); 		    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX); 		} 		scan = NEXTOPER(scan) + EXTRA_STEP_2ARGS; 		next_is_eval = (OP(scan) == EVAL); 	      do_curly: 		if (flags & SCF_DO_SUBSTR) {                     if (mincount == 0)                         scan_commit(pRExC_state, data, minlenp, is_inf);                     /* Cannot extend fixed substrings */ 		    pos_before = data->pos_min; 		} 		if (data) { 		    fl = data->flags; 		    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL); 		    if (is_inf) 			data->flags |= SF_IS_INF; 		} 		if (flags & SCF_DO_STCLASS) { 		    ssc_init(pRExC_state, &this_class); 		    oclass = data->start_class; 		    data->start_class = &this_class; 		    f |= SCF_DO_STCLASS_AND; 		    f &= ~SCF_DO_STCLASS_OR; 		} 	        /* Exclude from super-linear cache processing any {n,m} 		   regops for which the combination of input pos and regex 		   pos is not enough information to determine if a match 		   will be possible.  		   For example, in the regex /foo(bar\s*){4,8}baz/ with the 		   regex pos at the \s*, the prospects for a match depend not 		   only on the input position but also on how many (bar\s*) 		   repeats into the {4,8} we are. */                if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY)) 		    f &= ~SCF_WHILEM_VISITED_POS;  		/* This will finish on WHILEM, setting scan, or on NULL: */                 /* recurse study_chunk() on loop bodies */ 		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,                                   last, data, stopparen, recursed_depth, NULL,                                   (mincount == 0                                    ? (f & ~SCF_DO_SUBSTR)                                    : f)                                   ,depth+1);  		if (flags & SCF_DO_STCLASS) 		    data->start_class = oclass; 		if (mincount == 0 || minnext == 0) { 		    if (flags & SCF_DO_STCLASS_OR) { 			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class); 		    } 		    else if (flags & SCF_DO_STCLASS_AND) { 			/* Switch to OR mode: cache the old value of 			 * data->start_class */ 			INIT_AND_WITHP; 			StructCopy(data->start_class, and_withp, regnode_ssc); 			flags &= ~SCF_DO_STCLASS_AND; 			StructCopy(&this_class, data->start_class, regnode_ssc); 			flags |= SCF_DO_STCLASS_OR;                         ANYOF_FLAGS(data->start_class)                                                 |= SSC_MATCHES_EMPTY_STRING; 		    } 		} else {		/* Non-zero len */ 		    if (flags & SCF_DO_STCLASS_OR) { 			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class); 			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp); 		    } 		    else if (flags & SCF_DO_STCLASS_AND) 			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class); 		    flags &= ~SCF_DO_STCLASS; 		} 		if (!scan) 		/* It was not CURLYX, but CURLY. */ 		    scan = next; 		if (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR) 		    /* ? quantifier ok, except for (?{ ... }) */ 		    && (next_is_eval || !(mincount == 0 && maxcount == 1)) 		    && (minnext == 0) && (deltanext == 0) 		    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))                     && maxcount <= REG_INFTY/3) /* Complement check for big                                                    count */ 		{ 		    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),                         Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),                             ""Quantifier unexpected on zero-length expression ""                             ""in regex m/%"" UTF8f ""/"", 			     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp, 				  RExC_precomp)));                 }                  if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )                     || min >= SSize_t_MAX - minnext * mincount )                 {                     FAIL(""Regexp out of space"");                 }  		min += minnext * mincount; 		is_inf_internal |= deltanext == SSize_t_MAX                          || (maxcount == REG_INFTY && minnext + deltanext > 0); 		is_inf |= is_inf_internal;                 if (is_inf) { 		    delta = SSize_t_MAX;                 } else { 		    delta += (minnext + deltanext) * maxcount                              - minnext * mincount;                 } 		/* Try powerful optimization CURLYX => CURLYN. */ 		if (  OP(oscan) == CURLYX && data 		      && data->flags & SF_IN_PAR 		      && !(data->flags & SF_HAS_EVAL) 		      && !deltanext && minnext == 1 ) { 		    /* Try to optimize to CURLYN.  */ 		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; 		    regnode * const nxt1 = nxt; #ifdef DEBUGGING 		    regnode *nxt2; #endif  		    /* Skip open. */ 		    nxt = regnext(nxt); 		    if (!REGNODE_SIMPLE(OP(nxt)) 			&& !(PL_regkind[OP(nxt)] == EXACT 			     && STR_LEN(nxt) == 1)) 			goto nogo; #ifdef DEBUGGING 		    nxt2 = nxt; #endif 		    nxt = regnext(nxt); 		    if (OP(nxt) != CLOSE) 			goto nogo; 		    if (RExC_open_parens) {                          /*open->CURLYM*/                         RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);                          /*close->while*/                         RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2; 		    } 		    /* Now we know that nxt2 is the only contents: */ 		    oscan->flags = (U8)ARG(nxt); 		    OP(oscan) = CURLYN; 		    OP(nxt1) = NOTHING;	/* was OPEN. */  #ifdef DEBUGGING 		    OP(nxt1 + 1) = OPTIMIZED; /* was count. */ 		    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */ 		    NEXT_OFF(nxt2) = 0;	/* just for consistency with CURLY. */ 		    OP(nxt) = OPTIMIZED;	/* was CLOSE. */ 		    OP(nxt + 1) = OPTIMIZED; /* was count. */ 		    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */ #endif 		} 	      nogo:  		/* Try optimization CURLYX => CURLYM. */ 		if (  OP(oscan) == CURLYX && data 		      && !(data->flags & SF_HAS_PAR) 		      && !(data->flags & SF_HAS_EVAL) 		      && !deltanext	/* atom is fixed width */ 		      && minnext != 0	/* CURLYM can't handle zero width */                           /* Nor characters whose fold at run-time may be                           * multi-character */                       && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN) 		) { 		    /* XXXX How to optimize if data == 0? */ 		    /* Optimize to a simpler form.  */ 		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */ 		    regnode *nxt2;  		    OP(oscan) = CURLYM; 		    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/ 			    && (OP(nxt2) != WHILEM)) 			nxt = nxt2; 		    OP(nxt2)  = SUCCEED; /* Whas WHILEM */ 		    /* Need to optimize away parenths. */ 		    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) { 			/* Set the parenth number.  */ 			regnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/  			oscan->flags = (U8)ARG(nxt); 			if (RExC_open_parens) {                              /*open->CURLYM*/                             RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);                              /*close->NOTHING*/                             RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)                                                          + 1; 			} 			OP(nxt1) = OPTIMIZED;	/* was OPEN. */ 			OP(nxt) = OPTIMIZED;	/* was CLOSE. */  #ifdef DEBUGGING 			OP(nxt1 + 1) = OPTIMIZED; /* was count. */ 			OP(nxt + 1) = OPTIMIZED; /* was count. */ 			NEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */ 			NEXT_OFF(nxt + 1) = 0; /* just for consistency. */ #endif #if 0 			while ( nxt1 && (OP(nxt1) != WHILEM)) { 			    regnode *nnxt = regnext(nxt1); 			    if (nnxt == nxt) { 				if (reg_off_by_arg[OP(nxt1)]) 				    ARG_SET(nxt1, nxt2 - nxt1); 				else if (nxt2 - nxt1 < U16_MAX) 				    NEXT_OFF(nxt1) = nxt2 - nxt1; 				else 				    OP(nxt) = NOTHING;	/* Cannot beautify */ 			    } 			    nxt1 = nnxt; 			} #endif 			/* Optimize again: */                         /* recurse study_chunk() on optimised CURLYX => CURLYM */ 			study_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,                                     NULL, stopparen, recursed_depth, NULL, 0,                                     depth+1); 		    } 		    else 			oscan->flags = 0; 		} 		else if ((OP(oscan) == CURLYX) 			 && (flags & SCF_WHILEM_VISITED_POS) 			 /* See the comment on a similar expression above. 			    However, this time it's not a subexpression 			    we care about, but the expression itself. */ 			 && (maxcount == REG_INFTY) 			 && data) { 		    /* This stays as CURLYX, we can put the count/of pair. */ 		    /* Find WHILEM (as in regexec.c) */ 		    regnode *nxt = oscan + NEXT_OFF(oscan);  		    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */ 			nxt += ARG(nxt);                     nxt = PREVOPER(nxt);                     if (nxt->flags & 0xf) {                         /* we've already set whilem count on this node */                     } else if (++data->whilem_c < 16) {                         assert(data->whilem_c <= RExC_whilem_seen);                         nxt->flags = (U8)(data->whilem_c                             | (RExC_whilem_seen << 4)); /* On WHILEM */                     } 		} 		if (data && fl & (SF_HAS_PAR|SF_IN_PAR)) 		    pars++; 		if (flags & SCF_DO_SUBSTR) { 		    SV *last_str = NULL;                     STRLEN last_chrs = 0; 		    int counted = mincount != 0;                      if (data->last_end > 0 && mincount != 0) { /* Ends with a                                                                   string. */ 			SSize_t b = pos_before >= data->last_start_min 			    ? pos_before : data->last_start_min; 			STRLEN l; 			const char * const s = SvPV_const(data->last_found, l); 			SSize_t old = b - data->last_start_min;                         assert(old >= 0);  			if (UTF) 			    old = utf8_hop_forward((U8*)s, old,                                                (U8 *) SvEND(data->last_found))                                 - (U8*)s; 			l -= old; 			/* Get the added string: */ 			last_str = newSVpvn_utf8(s  + old, l, UTF);                         last_chrs = UTF ? utf8_length((U8*)(s + old),                                             (U8*)(s + old + l)) : l; 			if (deltanext == 0 && pos_before == b) { 			    /* What was added is a constant string */ 			    if (mincount > 1) {  				SvGROW(last_str, (mincount * l) + 1); 				repeatcpy(SvPVX(last_str) + l, 					  SvPVX_const(last_str), l,                                           mincount - 1); 				SvCUR_set(last_str, SvCUR(last_str) * mincount); 				/* Add additional parts. */ 				SvCUR_set(data->last_found, 					  SvCUR(data->last_found) - l); 				sv_catsv(data->last_found, last_str); 				{ 				    SV * sv = data->last_found; 				    MAGIC *mg = 					SvUTF8(sv) && SvMAGICAL(sv) ? 					mg_find(sv, PERL_MAGIC_utf8) : NULL; 				    if (mg && mg->mg_len >= 0) 					mg->mg_len += last_chrs * (mincount-1); 				}                                 last_chrs *= mincount; 				data->last_end += l * (mincount - 1); 			    } 			} else { 			    /* start offset must point into the last copy */ 			    data->last_start_min += minnext * (mincount - 1); 			    data->last_start_max =                               is_inf                                ? SSize_t_MAX 			       : data->last_start_max +                                  (maxcount - 1) * (minnext + data->pos_delta); 			} 		    } 		    /* It is counted once already... */ 		    data->pos_min += minnext * (mincount - counted); #if 0 Perl_re_printf( aTHX_  ""counted=%"" UVuf "" deltanext=%"" UVuf                               "" SSize_t_MAX=%"" UVuf "" minnext=%"" UVuf                               "" maxcount=%"" UVuf "" mincount=%"" UVuf ""\n"",     (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,     (UV)mincount); if (deltanext != SSize_t_MAX) Perl_re_printf( aTHX_  ""LHS=%"" UVuf "" RHS=%"" UVuf ""\n"",     (UV)(-counted * deltanext + (minnext + deltanext) * maxcount           - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta)); #endif 		    if (deltanext == SSize_t_MAX                         || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta) 		        data->pos_delta = SSize_t_MAX; 		    else 		        data->pos_delta += - counted * deltanext + 			(minnext + deltanext) * maxcount - minnext * mincount; 		    if (mincount != maxcount) { 			 /* Cannot extend fixed substrings found inside 			    the group.  */                         scan_commit(pRExC_state, data, minlenp, is_inf); 			if (mincount && last_str) { 			    SV * const sv = data->last_found; 			    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? 				mg_find(sv, PERL_MAGIC_utf8) : NULL;  			    if (mg) 				mg->mg_len = -1; 			    sv_setsv(sv, last_str); 			    data->last_end = data->pos_min; 			    data->last_start_min = data->pos_min - last_chrs; 			    data->last_start_max = is_inf 				? SSize_t_MAX 				: data->pos_min + data->pos_delta - last_chrs; 			} 			data->cur_is_floating = 1; /* float */ 		    } 		    SvREFCNT_dec(last_str); 		} 		if (data && (fl & SF_HAS_EVAL)) 		    data->flags |= SF_HAS_EVAL; 	      optimize_curly_tail: 		rck_elide_nothing(oscan); 		continue;  	    default: #ifdef DEBUGGING                 Perl_croak(aTHX_ ""panic: unexpected varying REx opcode %d"",                                                                     OP(scan)); #endif             case REF:             case CLUMP: 		if (flags & SCF_DO_SUBSTR) {                     /* Cannot expect anything... */                     scan_commit(pRExC_state, data, minlenp, is_inf); 		    data->cur_is_floating = 1; /* float */ 		} 		is_inf = is_inf_internal = 1; 		if (flags & SCF_DO_STCLASS_OR) {                     if (OP(scan) == CLUMP) {                         /* Actually is any start char, but very few code points                          * aren't start characters */                         ssc_match_all_cp(data->start_class);                     }                     else {                         ssc_anything(data->start_class);                     }                 } 		flags &= ~SCF_DO_STCLASS; 		break; 	    } 	} 	else if (OP(scan) == LNBREAK) { 	    if (flags & SCF_DO_STCLASS) {     	        if (flags & SCF_DO_STCLASS_AND) {                     ssc_intersection(data->start_class,                                     PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);                     ssc_clear_locale(data->start_class);                     ANYOF_FLAGS(data->start_class)                                                 &= ~SSC_MATCHES_EMPTY_STRING;                 }                 else if (flags & SCF_DO_STCLASS_OR) {                     ssc_union(data->start_class,                               PL_XPosix_ptrs[_CC_VERTSPACE],                               FALSE); 		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);                      /* See commit msg for                      * 749e076fceedeb708a624933726e7989f2302f6a */                     ANYOF_FLAGS(data->start_class)                                                 &= ~SSC_MATCHES_EMPTY_STRING;                 } 		flags &= ~SCF_DO_STCLASS;             } 	    min++;             if (delta != SSize_t_MAX)                 delta++;    /* Because of the 2 char string cr-lf */             if (flags & SCF_DO_SUBSTR) {                 /* Cannot expect anything... */                 scan_commit(pRExC_state, data, minlenp, is_inf);     	        data->pos_min += 1;                 if (data->pos_delta != SSize_t_MAX) {                     data->pos_delta += 1;                 } 		data->cur_is_floating = 1; /* float */     	    } 	} 	else if (REGNODE_SIMPLE(OP(scan))) {  	    if (flags & SCF_DO_SUBSTR) {                 scan_commit(pRExC_state, data, minlenp, is_inf); 		data->pos_min++; 	    } 	    min++; 	    if (flags & SCF_DO_STCLASS) {                 bool invert = 0;                 SV* my_invlist = NULL;                 U8 namedclass;                  /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */                 ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;  		/* Some of the logic below assumes that switching 		   locale on will only add false positives. */ 		switch (OP(scan)) {  		default: #ifdef DEBUGGING                    Perl_croak(aTHX_ ""panic: unexpected simple REx opcode %d"",                                                                      OP(scan)); #endif 		case SANY: 		    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */ 			ssc_match_all_cp(data->start_class); 		    break;  		case REG_ANY:                     {                         SV* REG_ANY_invlist = _new_invlist(2);                         REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,                                                             '\n');                         if (flags & SCF_DO_STCLASS_OR) {                             ssc_union(data->start_class,                                       REG_ANY_invlist,                                       TRUE /* TRUE => invert, hence all but \n                                             */                                       );                         }                         else if (flags & SCF_DO_STCLASS_AND) {                             ssc_intersection(data->start_class,                                              REG_ANY_invlist,                                              TRUE  /* TRUE => invert */                                              );                             ssc_clear_locale(data->start_class);                         }                         SvREFCNT_dec_NN(REG_ANY_invlist); 		    } 		    break;                  case ANYOFD:                 case ANYOFL:                 case ANYOFPOSIXL:                 case ANYOFH:                 case ANYOF: 		    if (flags & SCF_DO_STCLASS_AND) 			ssc_and(pRExC_state, data->start_class,                                 (regnode_charclass *) scan); 		    else 			ssc_or(pRExC_state, data->start_class,                                                           (regnode_charclass *) scan); 		    break;                  case NANYOFM:                 case ANYOFM:                   {                     SV* cp_list = get_ANYOFM_contents(scan);                      if (flags & SCF_DO_STCLASS_OR) {                         ssc_union(data->start_class, cp_list, invert);                     }                     else if (flags & SCF_DO_STCLASS_AND) {                         ssc_intersection(data->start_class, cp_list, invert);                     }                      SvREFCNT_dec_NN(cp_list);                     break;                   }  		case NPOSIXL:                     invert = 1;                     /* FALLTHROUGH */  		case POSIXL:                     namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;                     if (flags & SCF_DO_STCLASS_AND) {                         bool was_there = cBOOL(                                           ANYOF_POSIXL_TEST(data->start_class,                                                                  namedclass));                         ANYOF_POSIXL_ZERO(data->start_class);                         if (was_there) {    /* Do an AND */                             ANYOF_POSIXL_SET(data->start_class, namedclass);                         }                         /* No individual code points can now match */                         data->start_class->invlist                                                 = sv_2mortal(_new_invlist(0));                     }                     else {                         int complement = namedclass + ((invert) ? -1 : 1);                          assert(flags & SCF_DO_STCLASS_OR);                          /* If the complement of this class was already there,                          * the result is that they match all code points,                          * (\d + \D == everything).  Remove the classes from                          * future consideration.  Locale is not relevant in                          * this case */                         if (ANYOF_POSIXL_TEST(data->start_class, complement)) {                             ssc_match_all_cp(data->start_class);                             ANYOF_POSIXL_CLEAR(data->start_class, namedclass);                             ANYOF_POSIXL_CLEAR(data->start_class, complement);                         }                         else {  /* The usual case; just add this class to the                                    existing set */                             ANYOF_POSIXL_SET(data->start_class, namedclass);                         }                     }                     break;                  case NPOSIXA:   /* For these, we always know the exact set of                                    what's matched */                     invert = 1;                     /* FALLTHROUGH */ 		case POSIXA:                     my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);                     goto join_posix_and_ascii;  		case NPOSIXD: 		case NPOSIXU:                     invert = 1;                     /* FALLTHROUGH */ 		case POSIXD: 		case POSIXU:                     my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);                      /* NPOSIXD matches all upper Latin1 code points unless the                      * target string being matched is UTF-8, which is                      * unknowable until match time.  Since we are going to                      * invert, we want to get rid of all of them so that the                      * inversion will match all */                     if (OP(scan) == NPOSIXD) {                         _invlist_subtract(my_invlist, PL_UpperLatin1,                                           &my_invlist);                     }                    join_posix_and_ascii:                      if (flags & SCF_DO_STCLASS_AND) {                         ssc_intersection(data->start_class, my_invlist, invert);                         ssc_clear_locale(data->start_class);                     }                     else {                         assert(flags & SCF_DO_STCLASS_OR);                         ssc_union(data->start_class, my_invlist, invert);                     }                     SvREFCNT_dec(my_invlist); 		} 		if (flags & SCF_DO_STCLASS_OR) 		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp); 		flags &= ~SCF_DO_STCLASS; 	    } 	} 	else if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) { 	    data->flags |= (OP(scan) == MEOL 			    ? SF_BEFORE_MEOL 			    : SF_BEFORE_SEOL);             scan_commit(pRExC_state, data, minlenp, is_inf);  	} 	else if (  PL_regkind[OP(scan)] == BRANCHJ 		 /* Lookbehind, or need to calculate parens/evals/stclass: */ 		   && (scan->flags || data || (flags & SCF_DO_STCLASS)) 		   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))         {             if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY                 || OP(scan) == UNLESSM )             {                 /* Negative Lookahead/lookbehind                    In this case we can't do fixed string optimisation.                 */                  SSize_t deltanext, minnext, fake = 0;                 regnode *nscan;                 regnode_ssc intrnl;                 int f = 0;                  StructCopy(&zero_scan_data, &data_fake, scan_data_t);                 if (data) {                     data_fake.whilem_c = data->whilem_c;                     data_fake.last_closep = data->last_closep; 		}                 else                     data_fake.last_closep = &fake; 		data_fake.pos_delta = delta;                 if ( flags & SCF_DO_STCLASS && !scan->flags                      && OP(scan) == IFMATCH ) { /* Lookahead */                     ssc_init(pRExC_state, &intrnl);                     data_fake.start_class = &intrnl;                     f |= SCF_DO_STCLASS_AND; 		}                 if (flags & SCF_WHILEM_VISITED_POS)                     f |= SCF_WHILEM_VISITED_POS;                 next = regnext(scan);                 nscan = NEXTOPER(NEXTOPER(scan));                  /* recurse study_chunk() for lookahead body */                 minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,                                       last, &data_fake, stopparen,                                       recursed_depth, NULL, f, depth+1);                 if (scan->flags) {                     if (   deltanext < 0                         || deltanext > (I32) U8_MAX                         || minnext > (I32)U8_MAX                         || minnext + deltanext > (I32)U8_MAX)                     { 			FAIL2(""Lookbehind longer than %"" UVuf "" not implemented"",                               (UV)U8_MAX);                     }                      /* The 'next_off' field has been repurposed to count the                      * additional starting positions to try beyond the initial                      * one.  (This leaves it at 0 for non-variable length                      * matches to avoid breakage for those not using this                      * extension) */                     if (deltanext) {                         scan->next_off = deltanext;                         ckWARNexperimental(RExC_parse,                             WARN_EXPERIMENTAL__VLB,                             ""Variable length lookbehind is experimental"");                     }                     scan->flags = (U8)minnext + deltanext;                 }                 if (data) {                     if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))                         pars++;                     if (data_fake.flags & SF_HAS_EVAL)                         data->flags |= SF_HAS_EVAL;                     data->whilem_c = data_fake.whilem_c;                 }                 if (f & SCF_DO_STCLASS_AND) { 		    if (flags & SCF_DO_STCLASS_OR) { 			/* OR before, AND after: ideally we would recurse with 			 * data_fake to get the AND applied by study of the 			 * remainder of the pattern, and then derecurse; 			 * *** HACK *** for now just treat as ""no information"". 			 * See [perl #56690]. 			 */ 			ssc_init(pRExC_state, data->start_class); 		    }  else {                         /* AND before and after: combine and continue.  These                          * assertions are zero-length, so can match an EMPTY                          * string */ 			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);                         ANYOF_FLAGS(data->start_class)                                                    |= SSC_MATCHES_EMPTY_STRING; 		    }                 } 	    } #if PERL_ENABLE_POSITIVE_ASSERTION_STUDY             else {                 /* Positive Lookahead/lookbehind                    In this case we can do fixed string optimisation,                    but we must be careful about it. Note in the case of                    lookbehind the positions will be offset by the minimum                    length of the pattern, something we won't know about                    until after the recurse.                 */                 SSize_t deltanext, fake = 0;                 regnode *nscan;                 regnode_ssc intrnl;                 int f = 0;                 /* We use SAVEFREEPV so that when the full compile                     is finished perl will clean up the allocated                     minlens when it's all done. This way we don't                     have to worry about freeing them when we know                     they wont be used, which would be a pain.                  */                 SSize_t *minnextp;                 Newx( minnextp, 1, SSize_t );                 SAVEFREEPV(minnextp);                  if (data) {                     StructCopy(data, &data_fake, scan_data_t);                     if ((flags & SCF_DO_SUBSTR) && data->last_found) {                         f |= SCF_DO_SUBSTR;                         if (scan->flags)                             scan_commit(pRExC_state, &data_fake, minlenp, is_inf);                         data_fake.last_found=newSVsv(data->last_found);                     }                 }                 else                     data_fake.last_closep = &fake;                 data_fake.flags = 0;                 data_fake.substrs[0].flags = 0;                 data_fake.substrs[1].flags = 0; 		data_fake.pos_delta = delta;                 if (is_inf) 	            data_fake.flags |= SF_IS_INF;                 if ( flags & SCF_DO_STCLASS && !scan->flags                      && OP(scan) == IFMATCH ) { /* Lookahead */                     ssc_init(pRExC_state, &intrnl);                     data_fake.start_class = &intrnl;                     f |= SCF_DO_STCLASS_AND;                 }                 if (flags & SCF_WHILEM_VISITED_POS)                     f |= SCF_WHILEM_VISITED_POS;                 next = regnext(scan);                 nscan = NEXTOPER(NEXTOPER(scan));                  /* positive lookahead study_chunk() recursion */                 *minnextp = study_chunk(pRExC_state, &nscan, minnextp,                                         &deltanext, last, &data_fake,                                         stopparen, recursed_depth, NULL,                                         f, depth+1);                 if (scan->flags) {                     assert(0);  /* This code has never been tested since this                                    is normally not compiled */                     if (   deltanext < 0                         || deltanext > (I32) U8_MAX                         || *minnextp > (I32)U8_MAX                         || *minnextp + deltanext > (I32)U8_MAX)                     { 			FAIL2(""Lookbehind longer than %"" UVuf "" not implemented"",                               (UV)U8_MAX);                     }                      if (deltanext) {                         scan->next_off = deltanext;                     }                     scan->flags = (U8)*minnextp + deltanext;                 }                  *minnextp += min;                  if (f & SCF_DO_STCLASS_AND) {                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);                     ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;                 }                 if (data) {                     if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))                         pars++;                     if (data_fake.flags & SF_HAS_EVAL)                         data->flags |= SF_HAS_EVAL;                     data->whilem_c = data_fake.whilem_c;                     if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {                         int i;                         if (RExC_rx->minlen<*minnextp)                             RExC_rx->minlen=*minnextp;                         scan_commit(pRExC_state, &data_fake, minnextp, is_inf);                         SvREFCNT_dec_NN(data_fake.last_found);                          for (i = 0; i < 2; i++) {                             if (data_fake.substrs[i].minlenp != minlenp) {                                 data->substrs[i].min_offset =                                             data_fake.substrs[i].min_offset;                                 data->substrs[i].max_offset =                                             data_fake.substrs[i].max_offset;                                 data->substrs[i].minlenp =                                             data_fake.substrs[i].minlenp;                                 data->substrs[i].lookbehind += scan->flags;                             }                         }                     }                 } 	    } #endif 	}  	else if (OP(scan) == OPEN) { 	    if (stopparen != (I32)ARG(scan)) 	        pars++; 	} 	else if (OP(scan) == CLOSE) { 	    if (stopparen == (I32)ARG(scan)) { 	        break; 	    } 	    if ((I32)ARG(scan) == is_par) { 		next = regnext(scan);  		if ( next && (OP(next) != WHILEM) && next < last) 		    is_par = 0;		/* Disable optimization */ 	    } 	    if (data) 		*(data->last_closep) = ARG(scan); 	} 	else if (OP(scan) == EVAL) { 		if (data) 		    data->flags |= SF_HAS_EVAL; 	} 	else if ( PL_regkind[OP(scan)] == ENDLIKE ) { 	    if (flags & SCF_DO_SUBSTR) {                 scan_commit(pRExC_state, data, minlenp, is_inf); 		flags &= ~SCF_DO_SUBSTR; 	    } 	    if (data && OP(scan)==ACCEPT) { 	        data->flags |= SCF_SEEN_ACCEPT; 	        if (stopmin > min) 	            stopmin = min; 	    } 	} 	else if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */ 	{ 		if (flags & SCF_DO_SUBSTR) {                     scan_commit(pRExC_state, data, minlenp, is_inf); 		    data->cur_is_floating = 1; /* float */ 		} 		is_inf = is_inf_internal = 1; 		if (flags & SCF_DO_STCLASS_OR) /* Allow everything */ 		    ssc_anything(data->start_class); 		flags &= ~SCF_DO_STCLASS; 	} 	else if (OP(scan) == GPOS) {             if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) && 	        !(delta || is_inf || (data && data->pos_delta))) 	    {                 if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))                     RExC_rx->intflags |= PREGf_ANCH_GPOS; 	        if (RExC_rx->gofs < (STRLEN)min) 		    RExC_rx->gofs = min;             } else {                 RExC_rx->intflags |= PREGf_GPOS_FLOAT;                 RExC_rx->gofs = 0;             } 	} #ifdef TRIE_STUDY_OPT #ifdef FULL_TRIE_STUDY         else if (PL_regkind[OP(scan)] == TRIE) {             /* NOTE - There is similar code to this block above for handling                BRANCH nodes on the initial study.  If you change stuff here                check there too. */             regnode *trie_node= scan;             regnode *tail= regnext(scan);             reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];             SSize_t max1 = 0, min1 = SSize_t_MAX;             regnode_ssc accum;              if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */                 /* Cannot merge strings after this. */                 scan_commit(pRExC_state, data, minlenp, is_inf);             }             if (flags & SCF_DO_STCLASS)                 ssc_init_zero(pRExC_state, &accum);              if (!trie->jump) {                 min1= trie->minlen;                 max1= trie->maxlen;             } else {                 const regnode *nextbranch= NULL;                 U32 word;                  for ( word=1 ; word <= trie->wordcount ; word++)                 {                     SSize_t deltanext=0, minnext=0, f = 0, fake;                     regnode_ssc this_class;                      StructCopy(&zero_scan_data, &data_fake, scan_data_t);                     if (data) {                         data_fake.whilem_c = data->whilem_c;                         data_fake.last_closep = data->last_closep;                     }                     else                         data_fake.last_closep = &fake; 		    data_fake.pos_delta = delta;                     if (flags & SCF_DO_STCLASS) {                         ssc_init(pRExC_state, &this_class);                         data_fake.start_class = &this_class;                         f = SCF_DO_STCLASS_AND;                     }                     if (flags & SCF_WHILEM_VISITED_POS)                         f |= SCF_WHILEM_VISITED_POS;                      if (trie->jump[word]) {                         if (!nextbranch)                             nextbranch = trie_node + trie->jump[0];                         scan= trie_node + trie->jump[word];                         /* We go from the jump point to the branch that follows                            it. Note this means we need the vestigal unused                            branches even though they arent otherwise used. */                         /* optimise study_chunk() for TRIE */                         minnext = study_chunk(pRExC_state, &scan, minlenp,                             &deltanext, (regnode *)nextbranch, &data_fake,                             stopparen, recursed_depth, NULL, f, depth+1);                     }                     if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)                         nextbranch= regnext((regnode*)nextbranch);                      if (min1 > (SSize_t)(minnext + trie->minlen))                         min1 = minnext + trie->minlen;                     if (deltanext == SSize_t_MAX) {                         is_inf = is_inf_internal = 1;                         max1 = SSize_t_MAX;                     } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))                         max1 = minnext + deltanext + trie->maxlen;                      if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))                         pars++;                     if (data_fake.flags & SCF_SEEN_ACCEPT) {                         if ( stopmin > min + min1) 	                    stopmin = min + min1; 	                flags &= ~SCF_DO_SUBSTR; 	                if (data) 	                    data->flags |= SCF_SEEN_ACCEPT; 	            }                     if (data) {                         if (data_fake.flags & SF_HAS_EVAL)                             data->flags |= SF_HAS_EVAL;                         data->whilem_c = data_fake.whilem_c;                     }                     if (flags & SCF_DO_STCLASS)                         ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);                 }             }             if (flags & SCF_DO_SUBSTR) {                 data->pos_min += min1;                 data->pos_delta += max1 - min1;                 if (max1 != min1 || is_inf)                     data->cur_is_floating = 1; /* float */             }             min += min1;             if (delta != SSize_t_MAX) {                 if (SSize_t_MAX - (max1 - min1) >= delta)                     delta += max1 - min1;                 else                     delta = SSize_t_MAX;             }             if (flags & SCF_DO_STCLASS_OR) {                 ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);                 if (min1) {                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);                     flags &= ~SCF_DO_STCLASS;                 }             }             else if (flags & SCF_DO_STCLASS_AND) {                 if (min1) {                     ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);                     flags &= ~SCF_DO_STCLASS;                 }                 else {                     /* Switch to OR mode: cache the old value of                      * data->start_class */ 		    INIT_AND_WITHP;                     StructCopy(data->start_class, and_withp, regnode_ssc);                     flags &= ~SCF_DO_STCLASS_AND;                     StructCopy(&accum, data->start_class, regnode_ssc);                     flags |= SCF_DO_STCLASS_OR;                 }             }             scan= tail;             continue;         } #else 	else if (PL_regkind[OP(scan)] == TRIE) { 	    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ]; 	    U8*bang=NULL;  	    min += trie->minlen; 	    delta += (trie->maxlen - trie->minlen); 	    flags &= ~SCF_DO_STCLASS; /* xxx */             if (flags & SCF_DO_SUBSTR) {                 /* Cannot expect anything... */                 scan_commit(pRExC_state, data, minlenp, is_inf);     	        data->pos_min += trie->minlen;     	        data->pos_delta += (trie->maxlen - trie->minlen); 		if (trie->maxlen != trie->minlen) 		    data->cur_is_floating = 1; /* float */     	    }     	    if (trie->jump) /* no more substrings -- for now /grr*/                flags &= ~SCF_DO_SUBSTR; 	} #endif /* old or new */ #endif /* TRIE_STUDY_OPT */  	/* Else: zero-length, ignore. */ 	scan = regnext(scan);     }    finish:     if (frame) {         /* we need to unwind recursion. */         depth = depth - 1;          DEBUG_STUDYDATA(""frame-end"", data, depth, is_inf);         DEBUG_PEEP(""fend"", scan, depth, flags);          /* restore previous context */         last = frame->last_regnode;         scan = frame->next_regnode;         stopparen = frame->stopparen;         recursed_depth = frame->prev_recursed_depth;          RExC_frame_last = frame->prev_frame;         frame = frame->this_prev_frame;         goto fake_study_recurse;     }      assert(!frame);     DEBUG_STUDYDATA(""pre-fin"", data, depth, is_inf);      *scanp = scan;     *deltap = is_inf_internal ? SSize_t_MAX : delta;      if (flags & SCF_DO_SUBSTR && is_inf) 	data->pos_delta = SSize_t_MAX - data->pos_min;     if (is_par > (I32)U8_MAX) 	is_par = 0;     if (is_par && pars==1 && data) { 	data->flags |= SF_IN_PAR; 	data->flags &= ~SF_HAS_PAR;     }     else if (pars && data) { 	data->flags |= SF_HAS_PAR; 	data->flags &= ~SF_IN_PAR;     }     if (flags & SCF_DO_STCLASS_OR) 	ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);     if (flags & SCF_TRIE_RESTUDY)         data->flags |= 	SCF_TRIE_RESTUDY;      DEBUG_STUDYDATA(""post-fin"", data, depth, is_inf);      {         SSize_t final_minlen= min < stopmin ? min : stopmin;          if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {             if (final_minlen > SSize_t_MAX - delta)                 RExC_maxlen = SSize_t_MAX;             else if (RExC_maxlen < final_minlen + delta)                 RExC_maxlen = final_minlen + delta;         }         return final_minlen;     }     NOT_REACHED; /* NOTREACHED */"
"215312_CWE-20.c","CWE-20","asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim) { 	struct rlimit new_rlim, *old_rlim; 	unsigned long it_prof_secs; 	int retval;  	if (resource >= RLIM_NLIMITS) 		return -EINVAL; 	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim))) 		return -EFAULT; 	if (new_rlim.rlim_cur > new_rlim.rlim_max) 		return -EINVAL; 	old_rlim = current->signal->rlim + resource; 	if ((new_rlim.rlim_max > old_rlim->rlim_max) && 	    !capable(CAP_SYS_RESOURCE)) 		return -EPERM; 	if (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN) 		return -EPERM;  	retval = security_task_setrlimit(resource, &new_rlim); 	if (retval) 		return retval;  	task_lock(current->group_leader); 	*old_rlim = new_rlim; 	task_unlock(current->group_leader);  	if (resource != RLIMIT_CPU) 		goto out;  	/* 	 * RLIMIT_CPU handling.   Note that the kernel fails to return an error 	 * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a 	 * very long-standing error, and fixing it now risks breakage of 	 * applications, so we live with it 	 */ 	if (new_rlim.rlim_cur == RLIM_INFINITY) 		goto out;  	it_prof_secs = cputime_to_secs(current->signal->it_prof_expires); 	if (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) { 		unsigned long rlim_cur = new_rlim.rlim_cur; 		cputime_t cputime;  		if (rlim_cur == 0) { 			/* 			 * The caller is asking for an immediate RLIMIT_CPU 			 * expiry.  But we use the zero value to mean ""it was 			 * never set"".  So let's cheat and make it one second 			 * instead 			 */ 			rlim_cur = 1; 		} 		cputime = secs_to_cputime(rlim_cur); 		read_lock(&tasklist_lock); 		spin_lock_irq(&current->sighand->siglock); 		set_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL); 		spin_unlock_irq(&current->sighand->siglock); 		read_unlock(&tasklist_lock); 	} out: 	return 0; }"
"215342_CWE-20.c","CWE-20","int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, 		unsigned long start, int len, int write, int force, 		struct page **pages, struct vm_area_struct **vmas) { 	int i; 	unsigned int vm_flags;  	if (len <= 0) 		return 0; 	/*  	 * Require read or write permissions. 	 * If 'force' is set, we only require the ""MAY"" flags. 	 */ 	vm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD); 	vm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE); 	i = 0;  	do { 		struct vm_area_struct *vma; 		unsigned int foll_flags;  		vma = find_extend_vma(mm, start); 		if (!vma && in_gate_area(tsk, start)) { 			unsigned long pg = start & PAGE_MASK; 			struct vm_area_struct *gate_vma = get_gate_vma(tsk); 			pgd_t *pgd; 			pud_t *pud; 			pmd_t *pmd; 			pte_t *pte; 			if (write) /* user gate pages are read-only */ 				return i ? : -EFAULT; 			if (pg > TASK_SIZE) 				pgd = pgd_offset_k(pg); 			else 				pgd = pgd_offset_gate(mm, pg); 			BUG_ON(pgd_none(*pgd)); 			pud = pud_offset(pgd, pg); 			BUG_ON(pud_none(*pud)); 			pmd = pmd_offset(pud, pg); 			if (pmd_none(*pmd)) 				return i ? : -EFAULT; 			pte = pte_offset_map(pmd, pg); 			if (pte_none(*pte)) { 				pte_unmap(pte); 				return i ? : -EFAULT; 			} 			if (pages) { 				struct page *page = vm_normal_page(gate_vma, start, *pte); 				pages[i] = page; 				if (page) 					get_page(page); 			} 			pte_unmap(pte); 			if (vmas) 				vmas[i] = gate_vma; 			i++; 			start += PAGE_SIZE; 			len--; 			continue; 		}  		if (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP)) 				|| !(vm_flags & vma->vm_flags)) 			return i ? : -EFAULT;  		if (is_vm_hugetlb_page(vma)) { 			i = follow_hugetlb_page(mm, vma, pages, vmas, 						&start, &len, i, write); 			continue; 		}  		foll_flags = FOLL_TOUCH; 		if (pages) 			foll_flags |= FOLL_GET; 		if (!write && !(vma->vm_flags & VM_LOCKED) && 		    (!vma->vm_ops || !vma->vm_ops->fault)) 			foll_flags |= FOLL_ANON;  		do { 			struct page *page;  			/* 			 * If tsk is ooming, cut off its access to large memory 			 * allocations. It has a pending SIGKILL, but it can't 			 * be processed until returning to user space. 			 */ 			if (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE))) 				return -ENOMEM;  			if (write) 				foll_flags |= FOLL_WRITE;  			cond_resched(); 			while (!(page = follow_page(vma, start, foll_flags))) { 				int ret; 				ret = handle_mm_fault(mm, vma, start, 						foll_flags & FOLL_WRITE); 				if (ret & VM_FAULT_ERROR) { 					if (ret & VM_FAULT_OOM) 						return i ? i : -ENOMEM; 					else if (ret & VM_FAULT_SIGBUS) 						return i ? i : -EFAULT; 					BUG(); 				} 				if (ret & VM_FAULT_MAJOR) 					tsk->maj_flt++; 				else 					tsk->min_flt++;  				/* 				 * The VM_FAULT_WRITE bit tells us that 				 * do_wp_page has broken COW when necessary, 				 * even if maybe_mkwrite decided not to set 				 * pte_write. We can thus safely do subsequent 				 * page lookups as if they were reads. 				 */ 				if (ret & VM_FAULT_WRITE) 					foll_flags &= ~FOLL_WRITE;  				cond_resched(); 			} 			if (pages) { 				pages[i] = page;  				flush_anon_page(vma, page, start); 				flush_dcache_page(page); 			} 			if (vmas) 				vmas[i] = vma; 			i++; 			start += PAGE_SIZE; 			len--; 		} while (len && start < vma->vm_end); 	} while (len); 	return i; }"
"215374_CWE-189.c","CWE-189","static int sctp_setsockopt_auth_key(struct sock *sk, 				    char __user *optval, 				    int optlen) { 	struct sctp_authkey *authkey; 	struct sctp_association *asoc; 	int ret;  	if (!sctp_auth_enable) 		return -EACCES;  	if (optlen <= sizeof(struct sctp_authkey)) 		return -EINVAL;  	authkey = kmalloc(optlen, GFP_KERNEL); 	if (!authkey) 		return -ENOMEM;  	if (copy_from_user(authkey, optval, optlen)) { 		ret = -EFAULT; 		goto out; 	}  	if (authkey->sca_keylength > optlen) { 		ret = -EINVAL; 		goto out; 	}  	asoc = sctp_id2assoc(sk, authkey->sca_assoc_id); 	if (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) { 		ret = -EINVAL; 		goto out; 	}  	ret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey); out: 	kfree(authkey); 	return ret; }"
"215391_CWE-20.c","CWE-20","static sctp_disposition_t sctp_sf_violation_paramlen( 				     const struct sctp_endpoint *ep, 				     const struct sctp_association *asoc, 				     const sctp_subtype_t type, 				     void *arg, 				     sctp_cmd_seq_t *commands) { 	static const char err_str[] = ""The following parameter had invalid length:"";  	return sctp_sf_abort_violation(ep, asoc, arg, commands, err_str, 					sizeof(err_str)); }"
"215399_CWE-119.cpp","CWE-119","int hfsplus_find_cat(struct super_block *sb, u32 cnid, 		     struct hfs_find_data *fd) { 	hfsplus_cat_entry tmp; 	int err; 	u16 type;  	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL); 	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry)); 	if (err) 		return err;  	type = be16_to_cpu(tmp.type); 	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) { 		printk(KERN_ERR ""hfs: found bad thread record in catalog\n""); 		return -EIO; 	}  	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID), 				 &tmp.thread.nodeName); 	return hfs_brec_find(fd); }"
"215400_CWE-20.c","CWE-20","int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max) { 	struct page *page; 	struct address_space *mapping; 	__be32 *pptr, *curr, *end; 	u32 mask, start, len, n; 	__be32 val; 	int i;  	len = *max; 	if (!len) 		return size;  	dprint(DBG_BITMAP, ""block_allocate: %u,%u,%u\n"", size, offset, len); 	mutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex); 	mapping = HFSPLUS_SB(sb).alloc_file->i_mapping; 	page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL); 	pptr = kmap(page); 	curr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32; 	i = offset % 32; 	offset &= ~(PAGE_CACHE_BITS - 1); 	if ((size ^ offset) / PAGE_CACHE_BITS) 		end = pptr + PAGE_CACHE_BITS / 32; 	else 		end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;  	/* scan the first partial u32 for zero bits */ 	val = *curr; 	if (~val) { 		n = be32_to_cpu(val); 		mask = (1U << 31) >> i; 		for (; i < 32; mask >>= 1, i++) { 			if (!(n & mask)) 				goto found; 		} 	} 	curr++;  	/* scan complete u32s for the first zero bit */ 	while (1) { 		while (curr < end) { 			val = *curr; 			if (~val) { 				n = be32_to_cpu(val); 				mask = 1 << 31; 				for (i = 0; i < 32; mask >>= 1, i++) { 					if (!(n & mask)) 						goto found; 				} 			} 			curr++; 		} 		kunmap(page); 		offset += PAGE_CACHE_BITS; 		if (offset >= size) 			break; 		page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, 					 NULL); 		curr = pptr = kmap(page); 		if ((size ^ offset) / PAGE_CACHE_BITS) 			end = pptr + PAGE_CACHE_BITS / 32; 		else 			end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32; 	} 	dprint(DBG_BITMAP, ""bitmap full\n""); 	start = size; 	goto out;  found: 	start = offset + (curr - pptr) * 32 + i; 	if (start >= size) { 		dprint(DBG_BITMAP, ""bitmap full\n""); 		goto out; 	} 	/* do any partial u32 at the start */ 	len = min(size - start, len); 	while (1) { 		n |= mask; 		if (++i >= 32) 			break; 		mask >>= 1; 		if (!--len || n & mask) 			goto done; 	} 	if (!--len) 		goto done; 	*curr++ = cpu_to_be32(n); 	/* do full u32s */ 	while (1) { 		while (curr < end) { 			n = be32_to_cpu(*curr); 			if (len < 32) 				goto last; 			if (n) { 				len = 32; 				goto last; 			} 			*curr++ = cpu_to_be32(0xffffffff); 			len -= 32; 		} 		set_page_dirty(page); 		kunmap(page); 		offset += PAGE_CACHE_BITS; 		page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, 					 NULL); 		pptr = kmap(page); 		curr = pptr; 		end = pptr + PAGE_CACHE_BITS / 32; 	} last: 	/* do any partial u32 at end */ 	mask = 1U << 31; 	for (i = 0; i < len; i++) { 		if (n & mask) 			break; 		n |= mask; 		mask >>= 1; 	} done: 	*curr = cpu_to_be32(n); 	set_page_dirty(page); 	kunmap(page); 	*max = offset + (curr - pptr) * 32 + i - start; 	HFSPLUS_SB(sb).free_blocks -= *max; 	sb->s_dirt = 1; 	dprint(DBG_BITMAP, ""-> %u,%u\n"", start, *max); out: 	mutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex); 	return start; }"
"215549_CWE-189.cpp","CWE-189","int unlzw(in, out)     int in, out;    /* input and output file descriptors */ {     REG2   char_type  *stackp;     REG3   code_int   code;     REG4   int        finchar;     REG5   code_int   oldcode;     REG6   code_int   incode;     REG7   long       inbits;     REG8   long       posbits;     REG9   int        outpos; /*  REG10  int        insize; (global) */     REG11  unsigned   bitmask;     REG12  code_int   free_ent;     REG13  code_int   maxcode;     REG14  code_int   maxmaxcode;     REG15  int        n_bits;     REG16  int        rsize;  #ifdef MAXSEG_64K     tab_prefix[0] = tab_prefix0;     tab_prefix[1] = tab_prefix1; #endif     maxbits = get_byte();     block_mode = maxbits & BLOCK_MODE;     if ((maxbits & LZW_RESERVED) != 0) { 	WARN((stderr, ""\n%s: %s: warning, unknown flags 0x%x\n"", 	      program_name, ifname, maxbits & LZW_RESERVED));     }     maxbits &= BIT_MASK;     maxmaxcode = MAXCODE(maxbits);      if (maxbits > BITS) { 	fprintf(stderr, 		""\n%s: %s: compressed with %d bits, can only handle %d bits\n"", 		program_name, ifname, maxbits, BITS); 	exit_code = ERROR; 	return ERROR;     }     rsize = insize;     maxcode = MAXCODE(n_bits = INIT_BITS)-1;     bitmask = (1<<n_bits)-1;     oldcode = -1;     finchar = 0;     outpos = 0;     posbits = inptr<<3;      free_ent = ((block_mode) ? FIRST : 256);      clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */      for (code = 255 ; code >= 0 ; --code) { 	tab_suffixof(code) = (char_type)code;     }     do { 	REG1 int i; 	int  e; 	int  o;      resetbuf: 	e = insize-(o = (posbits>>3));  	for (i = 0 ; i < e ; ++i) { 	    inbuf[i] = inbuf[i+o]; 	} 	insize = e; 	posbits = 0;  	if (insize < INBUF_EXTRA) { 	    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ); 	    if (rsize == -1) { 		read_error(); 	    } 	    insize += rsize; 	    bytes_in += (off_t)rsize; 	} 	inbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 : 		  ((long)insize<<3)-(n_bits-1));  	while (inbits > posbits) { 	    if (free_ent > maxcode) { 		posbits = ((posbits-1) + 			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3))); 		++n_bits; 		if (n_bits == maxbits) { 		    maxcode = maxmaxcode; 		} else { 		    maxcode = MAXCODE(n_bits)-1; 		} 		bitmask = (1<<n_bits)-1; 		goto resetbuf; 	    } 	    input(inbuf,posbits,code,n_bits,bitmask); 	    Tracev((stderr, ""%d "", code));  	    if (oldcode == -1) { 		if (256 <= code) 		  gzip_error (""corrupt input.""); 		outbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code)); 		continue; 	    } 	    if (code == CLEAR && block_mode) { 		clear_tab_prefixof(); 		free_ent = FIRST - 1; 		posbits = ((posbits-1) + 			   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3))); 		maxcode = MAXCODE(n_bits = INIT_BITS)-1; 		bitmask = (1<<n_bits)-1; 		goto resetbuf; 	    } 	    incode = code; 	    stackp = de_stack;  	    if (code >= free_ent) { /* Special case for KwKwK string. */ 		if (code > free_ent) { #ifdef DEBUG 		    char_type *p;  		    posbits -= n_bits; 		    p = &inbuf[posbits>>3]; 		    fprintf(stderr, 			    ""code:%ld free_ent:%ld n_bits:%d insize:%u\n"", 			    code, free_ent, n_bits, insize); 		    fprintf(stderr, 			    ""posbits:%ld inbuf:%02X %02X %02X %02X %02X\n"", 			    posbits, p[-1],p[0],p[1],p[2],p[3]); #endif 		    if (!test && outpos > 0) { 			write_buf(out, (char*)outbuf, outpos); 			bytes_out += (off_t)outpos; 		    } 		    gzip_error (to_stdout 				? ""corrupt input."" 				: ""corrupt input. Use zcat to recover some data.""); 		} 		*--stackp = (char_type)finchar; 		code = oldcode; 	    }  	    while ((cmp_code_int)code >= (cmp_code_int)256) { 		/* Generate output characters in reverse order */ 		*--stackp = tab_suffixof(code); 		code = tab_prefixof(code); 	    } 	    *--stackp =	(char_type)(finchar = tab_suffixof(code));  	    /* And put them out in forward order */ 	    { 		REG1 int	i;  		if (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) { 		    do { 			if (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;  			if (i > 0) { 			    memcpy(outbuf+outpos, stackp, i); 			    outpos += i; 			} 			if (outpos >= OUTBUFSIZ) { 			    if (!test) { 				write_buf(out, (char*)outbuf, outpos); 				bytes_out += (off_t)outpos; 			    } 			    outpos = 0; 			} 			stackp+= i; 		    } while ((i = (de_stack-stackp)) > 0); 		} else { 		    memcpy(outbuf+outpos, stackp, i); 		    outpos += i; 		} 	    }  	    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */  		tab_prefixof(code) = (unsigned short)oldcode; 		tab_suffixof(code) = (char_type)finchar; 		free_ent = code+1; 	    } 	    oldcode = incode;	/* Remember previous code.	*/ 	}     } while (rsize != 0);      if (!test && outpos > 0) { 	write_buf(out, (char*)outbuf, outpos); 	bytes_out += (off_t)outpos;     }     return OK; }"
"215921_CWE-119.c","CWE-119","bmexec_trans (kwset_t kwset, char const *text, size_t size) {   unsigned char const *d1;   char const *ep, *sp, *tp;   int d;   int len = kwset->mind;   char const *trans = kwset->trans;    if (len == 0)     return 0;   if (len > size)     return -1;   if (len == 1)     {       tp = memchr_kwset (text, size, kwset);       return tp ? tp - text : -1;     }    d1 = kwset->delta;   sp = kwset->target + len;   tp = text + len;   char gc1 = kwset->gc1;   char gc2 = kwset->gc2;    /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */   if (size > 12 * len)     /* 11 is not a bug, the initial offset happens only once. */     for (ep = text + size - 11 * len; tp <= ep; )       {         char const *tp0 = tp;         d = d1[U(tp[-1])], tp += d;         d = d1[U(tp[-1])], tp += d;         if (d != 0)           {             d = d1[U(tp[-1])], tp += d;             d = d1[U(tp[-1])], tp += d;             d = d1[U(tp[-1])], tp += d;             if (d != 0)               {                 d = d1[U(tp[-1])], tp += d;                 d = d1[U(tp[-1])], tp += d;                 d = d1[U(tp[-1])], tp += d;                 if (d != 0)                   {                     d = d1[U(tp[-1])], tp += d;                     d = d1[U(tp[-1])], tp += d;                      /* As a heuristic, prefer memchr to seeking by                        delta1 when the latter doesn't advance much.  */                     int advance_heuristic = 16 * sizeof (long);                     if (advance_heuristic <= tp - tp0)                       goto big_advance;                     tp--;                     tp = memchr_kwset (tp, text + size - tp, kwset);                     if (! tp)                       return -1;                     tp++;                   }               }           }         if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))           return tp - text;       big_advance:;       }    /* Now we have only a few characters left to search.  We      carefully avoid ever producing an out-of-bounds pointer. */   ep = text + size;   d = d1[U(tp[-1])];   while (d <= ep - tp)     {       d = d1[U((tp += d)[-1])];       if (d != 0)         continue;       if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))         return tp - text;     }    return -1; }"
"215948_CWE-310.c","CWE-310","ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp) {   mp_limb_t u1, u0;   mp_size_t n;    n = 2*p->size;   u1 = rp[--n];   u0 = rp[n-1];    /* This is not particularly fast, but should work well with assembly implementation. */   for (; n >= p->size; n--)     {       mp_limb_t q2, q1, q0, t, cy;        /* <q2, q1, q0> = v * u1 + <u1,u0>, with v = 2^32 - 1:  	   +---+---+ 	   | u1| u0| 	   +---+---+ 	       |-u1| 	     +-+-+-+ 	     | u1|        +---+-+-+-+-+        | q2| q1| q0|        +---+---+---+       */       q1 = u1 - (u1 > u0);       q0 = u0 - u1;       t = u1 << 32;       q0 += t;       t = (u1 >> 32) + (q0 < t) + 1;       q1 += t;       q2 = q1 < t;        /* Compute candidate remainder */       u1 = u0 + (q1 << 32) - q1;       t = -(mp_limb_t) (u1 > q0);       u1 -= t & 0xffffffff;       q1 += t;       q2 += t + (q1 < t);        assert (q2 < 2);        /* We multiply by two low limbs of p, 2^96 - 1, so we could use 	 shifts rather than mul. */       t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);       t += cnd_sub_n (q2, rp + n - 3, p->m, 1);       t += (-q2) & 0xffffffff;        u0 = rp[n-2];       cy = (u0 < t);       u0 -= t;       t = (u1 < cy);       u1 -= cy;       u1 += cnd_add_n (t, rp + n - 4, p->m, 3);       u1 -= (-t) & 0xffffffff;     }   rp[2] = u0;   rp[3] = u1; }"
"215976_CWE-119.cpp","CWE-119","extract_group_icon_cursor_resource(WinLibrary *fi, WinResource *wr, char *lang,                                    int *ressize, bool is_icon) { 	Win32CursorIconDir *icondir; 	Win32CursorIconFileDir *fileicondir; 	char *memory; 	int c, size, offset, skipped;  	/* get resource data and size */ 	icondir = (Win32CursorIconDir *) get_resource_entry(fi, wr, &size); 	if (icondir == NULL) { 		/* get_resource_entry will print error */ 		return NULL; 	}  	/* calculate total size of output file */ 	RETURN_IF_BAD_POINTER(NULL, icondir->count); 	skipped = 0; 	for (c = 0 ; c < icondir->count ; c++) { 		int level; 	    	int iconsize; 		char name[14]; 		WinResource *fwr;  		RETURN_IF_BAD_POINTER(NULL, icondir->entries[c]); 		/*printf(""%d. bytes_in_res=%d width=%d height=%d planes=%d bit_count=%d\n"", c, 			icondir->entries[c].bytes_in_res, 			(is_icon ? icondir->entries[c].res_info.icon.width : icondir->entries[c].res_info.cursor.width), 			(is_icon ? icondir->entries[c].res_info.icon.height : icondir->entries[c].res_info.cursor.height), 			icondir->entries[c].plane_count, 			icondir->entries[c].bit_count);*/  		/* find the corresponding icon resource */ 		snprintf(name, sizeof(name)/sizeof(char), ""-%d"", icondir->entries[c].res_id); 		fwr = find_resource(fi, (is_icon ? ""-3"" : ""-1""), name, lang, &level); 		if (fwr == NULL) { 			warn(_(""%s: could not find `%s' in `%s' resource.""), 			 	fi->name, &name[1], (is_icon ? ""group_icon"" : ""group_cursor"")); 			return NULL; 		}  		if (get_resource_entry(fi, fwr, &iconsize) != NULL) { 		    if (iconsize == 0) { 			warn(_(""%s: icon resource `%s' is empty, skipping""), fi->name, name); 			skipped++; 			continue; 		    } 		    if (iconsize != icondir->entries[c].bytes_in_res) { 			warn(_(""%s: mismatch of size in icon resource `%s' and group (%d vs %d)""), fi->name, name, iconsize, icondir->entries[c].bytes_in_res); 		    } 		    size += iconsize < icondir->entries[c].bytes_in_res ? icondir->entries[c].bytes_in_res : iconsize;  		    /* cursor resources have two additional WORDs that contain 		     * hotspot info */ 		    if (!is_icon) 			size -= sizeof(uint16_t)*2; 		} 	} 	offset = sizeof(Win32CursorIconFileDir) + (icondir->count-skipped) * sizeof(Win32CursorIconFileDirEntry); 	size += offset; 	*ressize = size;  	/* allocate that much memory */ 	memory = xmalloc(size); 	fileicondir = (Win32CursorIconFileDir *) memory;  	/* transfer Win32CursorIconDir structure members */ 	fileicondir->reserved = icondir->reserved; 	fileicondir->type = icondir->type; 	fileicondir->count = icondir->count - skipped;  	/* transfer each cursor/icon: Win32CursorIconDirEntry and data */ 	skipped = 0; 	for (c = 0 ; c < icondir->count ; c++) { 		int level; 		char name[14]; 		WinResource *fwr; 		char *data; 	 		/* find the corresponding icon resource */ 		snprintf(name, sizeof(name)/sizeof(char), ""-%d"", icondir->entries[c].res_id); 		fwr = find_resource(fi, (is_icon ? ""-3"" : ""-1""), name, lang, &level); 		if (fwr == NULL) { 			warn(_(""%s: could not find `%s' in `%s' resource.""), 			 	fi->name, &name[1], (is_icon ? ""group_icon"" : ""group_cursor"")); 			return NULL; 		}  		/* get data and size of that resource */ 		data = get_resource_entry(fi, fwr, &size); 		if (data == NULL) { 			/* get_resource_entry has printed error */ 			return NULL; 		}     	    	if (size == 0) { 		    skipped++; 		    continue; 		}  		/* copy ICONDIRENTRY (not including last dwImageOffset) */ 		memcpy(&fileicondir->entries[c-skipped], &icondir->entries[c], 			sizeof(Win32CursorIconFileDirEntry)-sizeof(uint32_t));  		/* special treatment for cursors */ 		if (!is_icon) { 			fileicondir->entries[c-skipped].width = icondir->entries[c].res_info.cursor.width; 			fileicondir->entries[c-skipped].height = icondir->entries[c].res_info.cursor.height / 2; 			fileicondir->entries[c-skipped].color_count = 0; 			fileicondir->entries[c-skipped].reserved = 0; 		}  		/* set image offset and increase it */ 		fileicondir->entries[c-skipped].dib_offset = offset;  		/* transfer resource into file memory */ 		if (is_icon) { 			memcpy(&memory[offset], data, icondir->entries[c].bytes_in_res); 		} else { 			fileicondir->entries[c-skipped].hotspot_x = ((uint16_t *) data)[0]; 			fileicondir->entries[c-skipped].hotspot_y = ((uint16_t *) data)[1]; 			memcpy(&memory[offset], data+sizeof(uint16_t)*2, 				   icondir->entries[c].bytes_in_res-sizeof(uint16_t)*2); 			offset -= sizeof(uint16_t)*2; 		}  		/* increase the offset pointer */ 		offset += icondir->entries[c].bytes_in_res; 	}  	return (void *) memory; }"
"215992_CWE-125.c","CWE-125","load_image (const gchar  *filename,             GError      **error) {   FILE     *fp;   tga_info  info;   guchar    header[18];   guchar    footer[26];   guchar    extension[495];   long      offset;   gint32    image_ID = -1;    gimp_progress_init_printf (_(""Opening '%s'""),                              gimp_filename_to_utf8 (filename));    fp = g_fopen (filename, ""rb"");    if (! fp)     {       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),                    _(""Could not open '%s' for reading: %s""),                    gimp_filename_to_utf8 (filename), g_strerror (errno));       return -1;     }    /* Is file big enough for a footer? */   if (!fseek (fp, -26L, SEEK_END))     {       if (fread (footer, sizeof (footer), 1, fp) != 1)         {           g_message (_(""Cannot read footer from '%s'""),                      gimp_filename_to_utf8 (filename));           return -1;         }       else if (memcmp (footer + 8, magic, sizeof (magic)) == 0)         {           /* Check the signature. */            offset = (footer[0]          +                     footer[1] * 256L   +                     footer[2] * 65536L +                     footer[3] * 16777216L);            if (offset != 0)             {               if (fseek (fp, offset, SEEK_SET) ||                   fread (extension, sizeof (extension), 1, fp) != 1)                 {                   g_message (_(""Cannot read extension from '%s'""),                              gimp_filename_to_utf8 (filename));                   return -1;                 }               /* Eventually actually handle version 2 TGA here */             }         }     }    if (fseek (fp, 0, SEEK_SET) ||       fread (header, sizeof (header), 1, fp) != 1)     {       g_message (_(""Cannot read header from '%s'""),                  gimp_filename_to_utf8 (filename));       return -1;     }    switch (header[2])     {     case 1:       info.imageType        = TGA_TYPE_MAPPED;       info.imageCompression = TGA_COMP_NONE;       break;     case 2:       info.imageType        = TGA_TYPE_COLOR;       info.imageCompression = TGA_COMP_NONE;       break;     case 3:       info.imageType        = TGA_TYPE_GRAY;       info.imageCompression = TGA_COMP_NONE;       break;      case 9:       info.imageType        = TGA_TYPE_MAPPED;       info.imageCompression = TGA_COMP_RLE;       break;     case 10:       info.imageType        = TGA_TYPE_COLOR;       info.imageCompression = TGA_COMP_RLE;       break;     case 11:       info.imageType        = TGA_TYPE_GRAY;       info.imageCompression = TGA_COMP_RLE;       break;      default:       info.imageType = 0;     }    info.idLength     = header[0];   info.colorMapType = header[1];    info.colorMapIndex  = header[3] + header[4] * 256;   info.colorMapLength = header[5] + header[6] * 256;   info.colorMapSize   = header[7];    info.xOrigin = header[8]  + header[9] * 256;   info.yOrigin = header[10] + header[11] * 256;   info.width   = header[12] + header[13] * 256;   info.height  = header[14] + header[15] * 256;    info.bpp       = header[16];   info.bytes     = (info.bpp + 7) / 8;   info.alphaBits = header[17] & 0x0f; /* Just the low 4 bits */   info.flipHoriz = (header[17] & 0x10) ? 1 : 0;   info.flipVert  = (header[17] & 0x20) ? 0 : 1;    /* hack to handle some existing files with incorrect headers, see bug #306675 */   if (info.alphaBits == info.bpp)     info.alphaBits = 0;    /* hack to handle yet another flavor of incorrect headers, see bug #540969 */   if (info.alphaBits == 0)     {       if (info.imageType == TGA_TYPE_COLOR && info.bpp == 32)         info.alphaBits = 8;        if (info.imageType == TGA_TYPE_GRAY && info.bpp == 16)         info.alphaBits = 8;     }    switch (info.imageType)     {       case TGA_TYPE_MAPPED:         if (info.bpp != 8)           {             g_message (""Unhandled sub-format in '%s' (type = %u, bpp = %u)"",                        gimp_filename_to_utf8 (filename),                        info.imageType, info.bpp);             return -1;           }         break;       case TGA_TYPE_COLOR:         if (info.bpp != 15 && info.bpp != 16 &&             info.bpp != 24 && info.bpp != 32)           {             g_message (""Unhandled sub-format in '%s' (type = %u, bpp = %u)"",                        gimp_filename_to_utf8 (filename),                        info.imageType, info.bpp);             return -1;           }         break;       case TGA_TYPE_GRAY:         if (info.bpp != 8 &&             (info.alphaBits != 8 || (info.bpp != 16 && info.bpp != 15)))           {             g_message (""Unhandled sub-format in '%s' (type = %u, bpp = %u)"",                        gimp_filename_to_utf8 (filename),                        info.imageType, info.bpp);             return -1;           }         break;        default:         g_message (""Unknown image type %u for '%s'"",                    info.imageType, gimp_filename_to_utf8 (filename));         return -1;     }    /* Plausible but unhandled formats */   if (info.bytes * 8 != info.bpp && info.bpp != 15)     {       g_message (""Unhandled sub-format in '%s' (type = %u, bpp = %u)"",                  gimp_filename_to_utf8 (filename),                  info.imageType, info.bpp);       return -1;     }    /* Check that we have a color map only when we need it. */   if (info.imageType == TGA_TYPE_MAPPED && info.colorMapType != 1)     {       g_message (""Indexed image has invalid color map type %u"",                  info.colorMapType);       return -1;     }   else if (info.imageType != TGA_TYPE_MAPPED && info.colorMapType != 0)     {       g_message (""Non-indexed image has invalid color map type %u"",                  info.colorMapType);       return -1;     }    /* Skip the image ID field. */   if (info.idLength && fseek (fp, info.idLength, SEEK_CUR))     {       g_message (""File '%s' is truncated or corrupted"",                  gimp_filename_to_utf8 (filename));       return -1;     }    image_ID = ReadImage (fp, &info, filename);    fclose (fp);    return image_ID; }"
"216027_CWE-476.c","CWE-476","pax_decode_header (struct tar_sparse_file *file) {   if (file->stat_info->sparse_major > 0)     {       uintmax_t u;       char nbuf[UINTMAX_STRSIZE_BOUND];       union block *blk;       char *p;       size_t i;       off_t start;        #define COPY_BUF(b,buf,src) do                                     \  {                                                                 \    char *endp = b->buffer + BLOCKSIZE;                             \    char *dst = buf;                                                \    do                                                              \      {                                                             \        if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \          {                                                         \            ERROR ((0, 0, _(""%s: numeric overflow in sparse archive member""), \ 	          file->stat_info->orig_file_name));               \            return false;                                           \          }                                                         \        if (src == endp)                                            \ 	 {                                                         \ 	   set_next_block_after (b);                               \            b = find_next_block ();                                 \            src = b->buffer;                                        \ 	   endp = b->buffer + BLOCKSIZE;                           \ 	 }                                                         \        *dst = *src++;                                              \      }                                                             \    while (*dst++ != '\n');                                         \    dst[-1] = 0;                                                    \  } while (0)        start = current_block_ordinal ();       set_next_block_after (current_header);       blk = find_next_block ();       p = blk->buffer;       COPY_BUF (blk,nbuf,p);       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t))) 	{ 	  ERROR ((0, 0, _(""%s: malformed sparse archive member""), 		  file->stat_info->orig_file_name)); 	  return false; 	}       file->stat_info->sparse_map_size = u;       file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size, 					     sizeof (*file->stat_info->sparse_map));       file->stat_info->sparse_map_avail = 0;       for (i = 0; i < file->stat_info->sparse_map_size; i++) 	{ 	  struct sp_array sp;  	  COPY_BUF (blk,nbuf,p); 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t))) 	    { 	      ERROR ((0, 0, _(""%s: malformed sparse archive member""), 		      file->stat_info->orig_file_name)); 	      return false; 	    } 	  sp.offset = u; 	  COPY_BUF (blk,nbuf,p); 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t))) 	    { 	      ERROR ((0, 0, _(""%s: malformed sparse archive member""), 		      file->stat_info->orig_file_name)); 	      return false; 	    } 	  sp.numbytes = u; 	  sparse_add_map (file->stat_info, &sp); 	}       set_next_block_after (blk);        file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);     }    return true; }"
"216126_CWE-20.cpp","CWE-20","    kssl_keytab_is_available(KSSL_CTX *kssl_ctx) {     krb5_context		krb5context = NULL;     krb5_keytab 		krb5keytab = NULL;     krb5_keytab_entry           entry;     krb5_principal              princ = NULL;     krb5_error_code  		krb5rc = KRB5KRB_ERR_GENERIC;     int rc = 0;      if ((krb5rc = krb5_init_context(&krb5context)))         return(0);      /*	kssl_ctx->keytab_file == NULL ==> use Kerberos default     */     if (kssl_ctx->keytab_file)     {         krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,                                   &krb5keytab);         if (krb5rc)             goto exit;     }     else     {         krb5rc = krb5_kt_default(krb5context,&krb5keytab);         if (krb5rc)             goto exit;     }      /* the host key we are looking for */     krb5rc = krb5_sname_to_principal(krb5context, NULL,                                       kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,                                      KRB5_NT_SRV_HST, &princ);      krb5rc = krb5_kt_get_entry(krb5context, krb5keytab,                                  princ,                                 0 /* IGNORE_VNO */,                                 0 /* IGNORE_ENCTYPE */,                                 &entry);     if ( krb5rc == KRB5_KT_NOTFOUND ) {         rc = 1;         goto exit;     } else if ( krb5rc )         goto exit;          krb5_kt_free_entry(krb5context, &entry);     rc = 1;    exit:     if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);     if (princ)          krb5_free_principal(krb5context, princ);     if (krb5context)	krb5_free_context(krb5context);     return(rc); }"
"216202_CWE-399.c","CWE-399","int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {   sftp_status_message status = NULL;   sftp_message msg = NULL;   sftp_attributes errno_attr = NULL;   struct sftp_attributes_struct attr;   ssh_buffer buffer;   ssh_string path;   uint32_t id;    buffer = ssh_buffer_new();   if (buffer == NULL) {     ssh_set_error_oom(sftp->session);     return -1;   }    path = ssh_string_from_char(directory);   if (path == NULL) {     ssh_set_error_oom(sftp->session);     ssh_buffer_free(buffer);     return -1;   }    ZERO_STRUCT(attr);   attr.permissions = mode;   attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;    id = sftp_get_new_id(sftp);   if (buffer_add_u32(buffer, id) < 0 ||       buffer_add_ssh_string(buffer, path) < 0 ||       buffer_add_attributes(buffer, &attr) < 0 ||       sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {     ssh_buffer_free(buffer);     ssh_string_free(path);   }   ssh_buffer_free(buffer);   ssh_string_free(path);    while (msg == NULL) {     if (sftp_read_and_dispatch(sftp) < 0) {       return -1;     }     msg = sftp_dequeue(sftp, id);   }    /* By specification, this command only returns SSH_FXP_STATUS */   if (msg->packet_type == SSH_FXP_STATUS) {     status = parse_status_msg(msg);     sftp_message_free(msg);     if (status == NULL) {       return -1;     }     sftp_set_error(sftp, status->status);     switch (status->status) {       case SSH_FX_FAILURE:         /*          * mkdir always returns a failure, even if the path already exists.          * To be POSIX conform and to be able to map it to EEXIST a stat          * call is needed here.          */         errno_attr = sftp_lstat(sftp, directory);         if (errno_attr != NULL) {           SAFE_FREE(errno_attr);           sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);         }         break;       case SSH_FX_OK:         status_msg_free(status);         return 0;         break;       default:         break;     }     /*      * The status should be SSH_FX_OK if the command was successful, if it      * didn't, then there was an error      */     ssh_set_error(sftp->session, SSH_REQUEST_DENIED,         ""SFTP server: %s"", status->errormsg);     status_msg_free(status);     return -1;   } else {     ssh_set_error(sftp->session, SSH_FATAL,         ""Received message %d when attempting to make directory"",         msg->packet_type);     sftp_message_free(msg);   }    return -1; }"
"216515_CWE-362.c","CWE-362","int ssl3_get_new_session_ticket(SSL *s) {     int ok, al, ret = 0, ticklen;     long n;     const unsigned char *p;     unsigned char *d;      n = s->method->ssl_get_message(s,                                    SSL3_ST_CR_SESSION_TICKET_A,                                    SSL3_ST_CR_SESSION_TICKET_B,                                    SSL3_MT_NEWSESSION_TICKET, 16384, &ok);      if (!ok)         return ((int)n);      if (n < 6) {         /* need at least ticket_lifetime_hint + ticket length */         al = SSL_AD_DECODE_ERROR;         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);         goto f_err;     }      p = d = (unsigned char *)s->init_msg;     n2l(p, s->session->tlsext_tick_lifetime_hint);     n2s(p, ticklen);     /* ticket_lifetime_hint + ticket_length + ticket */     if (ticklen + 6 != n) {         al = SSL_AD_DECODE_ERROR;         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);         goto f_err;     }     if (s->session->tlsext_tick) {         OPENSSL_free(s->session->tlsext_tick);         s->session->tlsext_ticklen = 0;     }     s->session->tlsext_tick = OPENSSL_malloc(ticklen);     if (!s->session->tlsext_tick) {         SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);         goto err;     }     memcpy(s->session->tlsext_tick, p, ticklen);     s->session->tlsext_ticklen = ticklen;     /*      * There are two ways to detect a resumed ticket session. One is to set      * an appropriate session ID and then the server must return a match in      * ServerHello. This allows the normal client session ID matching to work      * and we know much earlier that the ticket has been accepted. The      * other way is to set zero length session ID when the ticket is      * presented and rely on the handshake to determine session resumption.      * We choose the former approach because this fits in with assumptions      * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is      * SHA256 is disabled) hash of the ticket.      */     EVP_Digest(p, ticklen,                s->session->session_id, &s->session->session_id_length, # ifndef OPENSSL_NO_SHA256                EVP_sha256(), NULL); # else                EVP_sha1(), NULL); # endif     ret = 1;     return (ret);  f_err:     ssl3_send_alert(s, SSL3_AL_FATAL, al);  err:     s->state = SSL_ST_ERR;     return (-1); }"
"216637_CWE-275.cpp","CWE-275","SCM_DEFINE (scm_mkdir, ""mkdir"", 1, 1, 0,             (SCM path, SCM mode), 	    ""Create a new directory named by @var{path}.  If @var{mode} is omitted\n"" 	    ""then the permissions of the directory file are set using the current\n"" 	    ""umask.  Otherwise they are set to the decimal value specified with\n"" 	    ""@var{mode}.  The return value is unspecified."") #define FUNC_NAME s_scm_mkdir {   int rv;   mode_t mask;    if (SCM_UNBNDP (mode))     {       mask = umask (0);       umask (mask);       STRING_SYSCALL (path, c_path, rv = mkdir (c_path, 0777 ^ mask));     }   else     {       STRING_SYSCALL (path, c_path, rv = mkdir (c_path, scm_to_uint (mode)));     }   if (rv != 0)     SCM_SYSERROR;   return SCM_UNSPECIFIED; }"
"216654_CWE-20.c","CWE-20","auth_request_get_var_expand_table_full(const struct auth_request *auth_request, 				       auth_request_escape_func_t *escape_func, 				       unsigned int *count) { 	const unsigned int auth_count = 		N_ELEMENTS(auth_request_var_expand_static_tab); 	struct var_expand_table *tab, *ret_tab; 	const char *orig_user, *auth_user;  	if (escape_func == NULL) 		escape_func = escape_none;  	/* keep the extra fields at the beginning. the last static_tab field 	   contains the ending NULL-fields. */ 	tab = ret_tab = t_malloc((*count + auth_count) * sizeof(*tab)); 	memset(tab, 0, *count * sizeof(*tab)); 	tab += *count; 	*count += auth_count;  	memcpy(tab, auth_request_var_expand_static_tab, 	       auth_count * sizeof(*tab));  	tab[0].value = escape_func(auth_request->user, auth_request); 	tab[1].value = escape_func(t_strcut(auth_request->user, '@'), 				   auth_request); 	tab[2].value = strchr(auth_request->user, '@'); 	if (tab[2].value != NULL) 		tab[2].value = escape_func(tab[2].value+1, auth_request); 	tab[3].value = escape_func(auth_request->service, auth_request); 	/* tab[4] = we have no home dir */ 	if (auth_request->local_ip.family != 0) 		tab[5].value = net_ip2addr(&auth_request->local_ip); 	if (auth_request->remote_ip.family != 0) 		tab[6].value = net_ip2addr(&auth_request->remote_ip); 	tab[7].value = dec2str(auth_request->client_pid); 	if (auth_request->mech_password != NULL) { 		tab[8].value = escape_func(auth_request->mech_password, 					   auth_request); 	} 	if (auth_request->userdb_lookup) { 		tab[9].value = auth_request->userdb == NULL ? """" : 			dec2str(auth_request->userdb->userdb->id); 	} else { 		tab[9].value = auth_request->passdb == NULL ? """" : 			dec2str(auth_request->passdb->passdb->id); 	} 	tab[10].value = auth_request->mech_name == NULL ? """" : 		escape_func(auth_request->mech_name, auth_request); 	tab[11].value = auth_request->secured ? ""secured"" : """"; 	tab[12].value = dec2str(auth_request->local_port); 	tab[13].value = dec2str(auth_request->remote_port); 	tab[14].value = auth_request->valid_client_cert ? ""valid"" : """";  	if (auth_request->requested_login_user != NULL) { 		const char *login_user = auth_request->requested_login_user;  		tab[15].value = escape_func(login_user, auth_request); 		tab[16].value = escape_func(t_strcut(login_user, '@'), 					    auth_request); 		tab[17].value = strchr(login_user, '@'); 		if (tab[17].value != NULL) { 			tab[17].value = escape_func(tab[17].value+1, 						    auth_request); 		} 	} 	tab[18].value = auth_request->session_id == NULL ? NULL : 		escape_func(auth_request->session_id, auth_request); 	if (auth_request->real_local_ip.family != 0) 		tab[19].value = net_ip2addr(&auth_request->real_local_ip); 	if (auth_request->real_remote_ip.family != 0) 		tab[20].value = net_ip2addr(&auth_request->real_remote_ip); 	tab[21].value = dec2str(auth_request->real_local_port); 	tab[22].value = dec2str(auth_request->real_remote_port); 	tab[23].value = strchr(auth_request->user, '@'); 	if (tab[23].value != NULL) { 		tab[23].value = escape_func(t_strcut(tab[23].value+1, '@'), 					    auth_request); 	} 	tab[24].value = strrchr(auth_request->user, '@'); 	if (tab[24].value != NULL) 		tab[24].value = escape_func(tab[24].value+1, auth_request); 	tab[25].value = auth_request->master_user == NULL ? NULL : 		escape_func(auth_request->master_user, auth_request); 	tab[26].value = auth_request->session_pid == (pid_t)-1 ? NULL : 		dec2str(auth_request->session_pid);  	orig_user = auth_request->original_username != NULL ? 		auth_request->original_username : auth_request->user; 	tab[27].value = escape_func(orig_user, auth_request); 	tab[28].value = escape_func(t_strcut(orig_user, '@'), auth_request); 	tab[29].value = strchr(orig_user, '@'); 	if (tab[29].value != NULL) 		tab[29].value = escape_func(tab[29].value+1, auth_request);  	if (auth_request->master_user != NULL) 		auth_user = auth_request->master_user; 	else 		auth_user = orig_user; 	tab[30].value = escape_func(auth_user, auth_request); 	tab[31].value = escape_func(t_strcut(auth_user, '@'), auth_request); 	tab[32].value = strchr(auth_user, '@'); 	if (tab[32].value != NULL) 		tab[32].value = escape_func(tab[32].value+1, auth_request); 	if (auth_request->local_name != NULL) 		tab[33].value = escape_func(auth_request->local_name, auth_request); 	else 		tab[33].value = """"; 	return ret_tab; }"
"216701_CWE-770.c","CWE-770","static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(     TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,     void** value, uint64 maxcount) { 	int typesize; 	uint32 datasize; 	void* data;         uint64 target_count64; 	typesize=TIFFDataWidth(direntry->tdir_type);          target_count64 = (direntry->tdir_count > maxcount) ?                 maxcount : direntry->tdir_count;  	if ((target_count64==0)||(typesize==0)) 	{ 		*value=0; 		return(TIFFReadDirEntryErrOk); 	}         (void) desttypesize;          /*           * As a sanity check, make sure we have no more than a 2GB tag array           * in either the current data type or the dest data type.  This also          * avoids problems with overflow of tmsize_t on 32bit systems.          */ 	if ((uint64)(2147483647/typesize)<target_count64) 		return(TIFFReadDirEntryErrSizesan); 	if ((uint64)(2147483647/desttypesize)<target_count64) 		return(TIFFReadDirEntryErrSizesan);  	*count=(uint32)target_count64; 	datasize=(*count)*typesize; 	assert((tmsize_t)datasize>0); 	data=_TIFFCheckMalloc(tif, *count, typesize, ""ReadDirEntryArray""); 	if (data==0) 		return(TIFFReadDirEntryErrAlloc); 	if (!(tif->tif_flags&TIFF_BIGTIFF)) 	{ 		if (datasize<=4) 			_TIFFmemcpy(data,&direntry->tdir_offset,datasize); 		else 		{ 			enum TIFFReadDirEntryErr err; 			uint32 offset = direntry->tdir_offset.toff_long; 			if (tif->tif_flags&TIFF_SWAB) 				TIFFSwabLong(&offset); 			err=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data); 			if (err!=TIFFReadDirEntryErrOk) 			{ 				_TIFFfree(data); 				return(err); 			} 		} 	} 	else 	{ 		if (datasize<=8) 			_TIFFmemcpy(data,&direntry->tdir_offset,datasize); 		else 		{ 			enum TIFFReadDirEntryErr err; 			uint64 offset = direntry->tdir_offset.toff_long8; 			if (tif->tif_flags&TIFF_SWAB) 				TIFFSwabLong8(&offset); 			err=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data); 			if (err!=TIFFReadDirEntryErrOk) 			{ 				_TIFFfree(data); 				return(err); 			} 		} 	} 	*value=data; 	return(TIFFReadDirEntryErrOk); }"
"216726_CWE-327.c","CWE-327","static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,                                   void *ptr) {     EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);      switch(type) {     case EVP_CTRL_INIT:         if (actx == NULL)             actx = ctx->cipher_data                  = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());         if (actx == NULL) {             EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);             return 0;         }         actx->len.aad = 0;         actx->len.text = 0;         actx->aad = 0;         actx->mac_inited = 0;         actx->tag_len = 0;         actx->nonce_len = 12;         actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;         memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);         return 1;      case EVP_CTRL_COPY:         if (actx) {             EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;              dst->cipher_data =                    OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());             if (dst->cipher_data == NULL) {                 EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);                 return 0;             }         }         return 1;      case EVP_CTRL_AEAD_SET_IVLEN:         if (arg <= 0 || arg > CHACHA_CTR_SIZE)             return 0;         actx->nonce_len = arg;         return 1;      case EVP_CTRL_AEAD_SET_IV_FIXED:         if (arg != 12)             return 0;         actx->nonce[0] = actx->key.counter[1]                        = CHACHA_U8TOU32((unsigned char *)ptr);         actx->nonce[1] = actx->key.counter[2]                        = CHACHA_U8TOU32((unsigned char *)ptr+4);         actx->nonce[2] = actx->key.counter[3]                        = CHACHA_U8TOU32((unsigned char *)ptr+8);         return 1;      case EVP_CTRL_AEAD_SET_TAG:         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)             return 0;         if (ptr != NULL) {             memcpy(actx->tag, ptr, arg);             actx->tag_len = arg;         }         return 1;      case EVP_CTRL_AEAD_GET_TAG:         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)             return 0;         memcpy(ptr, actx->tag, arg);         return 1;      case EVP_CTRL_AEAD_TLS1_AAD:         if (arg != EVP_AEAD_TLS1_AAD_LEN)             return 0;         {             unsigned int len;             unsigned char *aad = ptr;              memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];             aad = actx->tls_aad;             if (!ctx->encrypt) {                 if (len < POLY1305_BLOCK_SIZE)                     return 0;                 len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */                 aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);                 aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;             }             actx->tls_payload_length = len;              /*              * merge record sequence number as per RFC7905              */             actx->key.counter[1] = actx->nonce[0];             actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);             actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);             actx->mac_inited = 0;              return POLY1305_BLOCK_SIZE;         /* tag length */         }      case EVP_CTRL_AEAD_SET_MAC_KEY:         /* no-op */         return 1;      default:         return -1;     } }"
"216767_CWE-835.c","CWE-835","static int smtp_command_parse_parameters(struct smtp_command_parser *parser) { 	const unsigned char *p, *mp; 	uoff_t max_size = (parser->auth_response ? 		parser->limits.max_auth_size : 		parser->limits.max_parameters_size);  	/* We assume parameters to match textstr (HT, SP, Printable US-ASCII). 	   For command parameters, we also accept valid UTF-8 characters. 	 */ 	p = parser->cur + parser->state.poff; 	while (p < parser->end) { 		unichar_t ch; 		int nch = 1;  		if (parser->auth_response) 			ch = *p; 		else { 			nch = uni_utf8_get_char_n(p, (size_t)(p - parser->end), 						  &ch); 		} 		if (nch < 0) { 			smtp_command_parser_error(parser, 				SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND, 				""Invalid UTF-8 character in command parameters""); 			return -1; 		} 		if ((parser->auth_response || (ch & 0x80) == 0x00) && 		    !smtp_char_is_textstr((unsigned char)ch)) 			break; 		p += nch; 	} 	if (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) { 		smtp_command_parser_error(parser, 			SMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG, 			""%s line is too long"", 			(parser->auth_response ? 				""AUTH response"" : ""Command"")); 		return -1; 	} 	parser->state.poff = p - parser->cur; 	if (p == parser->end) 		return 0;  	/* In the interest of improved interoperability, SMTP receivers SHOULD 	   tolerate trailing white space before the terminating <CRLF>.  	   WSP =  SP / HTAB ; white space  	   --> Trim the end of the buffer 	 */ 	mp = p; 	if (mp > parser->cur) { 		while (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\t')) 			mp--; 	}  	if (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') { 		smtp_command_parser_error(parser, 			SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND, 			""Duplicate space after command name""); 		return -1; 	}  	parser->state.cmd_params = i_strdup_until(parser->cur, mp); 	parser->cur = p; 	parser->state.poff = 0; 	return 1; }"
"216800_CWE-125.c","CWE-125","rpa_read_buffer(pool_t pool, const unsigned char **data, 		const unsigned char *end, unsigned char **buffer) { 	const unsigned char *p = *data; 	unsigned int len;  	if (p > end) 		return 0;  	len = *p++; 	if (p + len > end) 		return 0;  	*buffer = p_malloc(pool, len); 	memcpy(*buffer, p, len);  	*data += 1 + len;  	return len; }"
"216812_CWE-476.c","CWE-476","int setup_tests(void) {     ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));     return 1; }"
"216861_CWE-125.cpp","CWE-125","EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params) {     int ok = 0, tmp;     EC_GROUP *ret = NULL, *dup = NULL;     BIGNUM *p = NULL, *a = NULL, *b = NULL;     EC_POINT *point = NULL;     long field_bits;     int curve_name = NID_undef;     BN_CTX *ctx = NULL;      if (!params->fieldID || !params->fieldID->fieldType ||         !params->fieldID->p.ptr) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);         goto err;     }      /*      * Now extract the curve parameters a and b. Note that, although SEC 1      * specifies the length of their encodings, historical versions of OpenSSL      * encoded them incorrectly, so we must accept any length for backwards      * compatibility.      */     if (!params->curve || !params->curve->a ||         !params->curve->a->data || !params->curve->b ||         !params->curve->b->data) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);         goto err;     }     a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);     if (a == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);         goto err;     }     b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);     if (b == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);         goto err;     }      /* get the field parameters */     tmp = OBJ_obj2nid(params->fieldID->fieldType);     if (tmp == NID_X9_62_characteristic_two_field) #ifdef OPENSSL_NO_EC2M     {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);         goto err;     } #else     {         X9_62_CHARACTERISTIC_TWO *char_two;          char_two = params->fieldID->p.char_two;          field_bits = char_two->m;         if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);             goto err;         }          if ((p = BN_new()) == NULL) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);             goto err;         }          /* get the base type */         tmp = OBJ_obj2nid(char_two->type);          if (tmp == NID_X9_62_tpBasis) {             long tmp_long;              if (!char_two->p.tpBasis) {                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);                 goto err;             }              tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);              if (!(char_two->m > tmp_long && tmp_long > 0)) {                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,                       EC_R_INVALID_TRINOMIAL_BASIS);                 goto err;             }              /* create the polynomial */             if (!BN_set_bit(p, (int)char_two->m))                 goto err;             if (!BN_set_bit(p, (int)tmp_long))                 goto err;             if (!BN_set_bit(p, 0))                 goto err;         } else if (tmp == NID_X9_62_ppBasis) {             X9_62_PENTANOMIAL *penta;              penta = char_two->p.ppBasis;             if (!penta) {                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);                 goto err;             }              if (!                 (char_two->m > penta->k3 && penta->k3 > penta->k2                  && penta->k2 > penta->k1 && penta->k1 > 0)) {                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,                       EC_R_INVALID_PENTANOMIAL_BASIS);                 goto err;             }              /* create the polynomial */             if (!BN_set_bit(p, (int)char_two->m))                 goto err;             if (!BN_set_bit(p, (int)penta->k1))                 goto err;             if (!BN_set_bit(p, (int)penta->k2))                 goto err;             if (!BN_set_bit(p, (int)penta->k3))                 goto err;             if (!BN_set_bit(p, 0))                 goto err;         } else if (tmp == NID_X9_62_onBasis) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);             goto err;         } else {                /* error */              ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);             goto err;         }          /* create the EC_GROUP structure */         ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);     } #endif     else if (tmp == NID_X9_62_prime_field) {         /* we have a curve over a prime field */         /* extract the prime number */         if (!params->fieldID->p.prime) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);             goto err;         }         p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);         if (p == NULL) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);             goto err;         }          if (BN_is_negative(p) || BN_is_zero(p)) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);             goto err;         }          field_bits = BN_num_bits(p);         if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);             goto err;         }          /* create the EC_GROUP structure */         ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);     } else {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);         goto err;     }      if (ret == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);         goto err;     }      /* extract seed (optional) */     if (params->curve->seed != NULL) {         OPENSSL_free(ret->seed);         if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);             goto err;         }         memcpy(ret->seed, params->curve->seed->data,                params->curve->seed->length);         ret->seed_len = params->curve->seed->length;     }      if (!params->order || !params->base || !params->base->data) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);         goto err;     }      if ((point = EC_POINT_new(ret)) == NULL)         goto err;      /* set the point conversion form */     EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)                                        (params->base->data[0] & ~0x01));      /* extract the ec point */     if (!EC_POINT_oct2point(ret, point, params->base->data,                             params->base->length, NULL)) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);         goto err;     }      /* extract the order */     if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);         goto err;     }     if (BN_is_negative(a) || BN_is_zero(a)) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);         goto err;     }     if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);         goto err;     }      /* extract the cofactor (optional) */     if (params->cofactor == NULL) {         BN_free(b);         b = NULL;     } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);         goto err;     }     /* set the generator, order and cofactor (if present) */     if (!EC_GROUP_set_generator(ret, point, a, b)) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);         goto err;     }      /*      * Check if the explicit parameters group just created matches one of the      * built-in curves.      *      * We create a copy of the group just built, so that we can remove optional      * fields for the lookup: we do this to avoid the possibility that one of      * the optional parameters is used to force the library into using a less      * performant and less secure EC_METHOD instead of the specialized one.      * In any case, `seed` is not really used in any computation, while a      * cofactor different from the one in the built-in table is just      * mathematically wrong anyway and should not be used.      */     if ((ctx = BN_CTX_new()) == NULL) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);         goto err;     }     if ((dup = EC_GROUP_dup(ret)) == NULL             || EC_GROUP_set_seed(dup, NULL, 0) != 1             || !EC_GROUP_set_generator(dup, point, a, NULL)) {         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);         goto err;     }     if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {         /*          * The input explicit parameters successfully matched one of the          * built-in curves: often for built-in curves we have specialized          * methods with better performance and hardening.          *          * In this case we replace the `EC_GROUP` created through explicit          * parameters with one created from a named group.          */         EC_GROUP *named_group = NULL;  #ifndef OPENSSL_NO_EC_NISTP_64_GCC_128         /*          * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for          * the same curve, we prefer the SECP nid when matching explicit          * parameters as that is associated with a specialized EC_METHOD.          */         if (curve_name == NID_wap_wsg_idm_ecid_wtls12)             curve_name = NID_secp224r1; #endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */          if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);             goto err;         }         EC_GROUP_free(ret);         ret = named_group;          /*          * Set the flag so that EC_GROUPs created from explicit parameters are          * serialized using explicit parameters by default.          */         EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);          /*          * If the input params do not contain the optional seed field we make          * sure it is not added to the returned group.          *          * The seed field is not really used inside libcrypto anyway, and          * adding it to parsed explicit parameter keys would alter their DER          * encoding output (because of the extra field) which could impact          * applications fingerprinting keys by their DER encoding.          */         if (params->curve->seed == NULL) {             if (EC_GROUP_set_seed(ret, NULL, 0) != 1)                 goto err;         }     }      ok = 1;   err:     if (!ok) {         EC_GROUP_free(ret);         ret = NULL;     }     EC_GROUP_free(dup);      BN_free(p);     BN_free(a);     BN_free(b);     EC_POINT_free(point);      BN_CTX_free(ctx);      return ret; }"
"216903_CWE-476.cpp","CWE-476","bool st_select_lex::optimize_unflattened_subqueries(bool const_only) {   SELECT_LEX_UNIT *next_unit= NULL;   for (SELECT_LEX_UNIT *un= first_inner_unit();        un;        un= next_unit ? next_unit : un->next_unit())   {     Item_subselect *subquery_predicate= un->item;     next_unit= NULL;      if (subquery_predicate)     {       if (!subquery_predicate->fixed)       { 	/* 	 This subquery was excluded as part of some expression so it is 	 invisible from all prepared expression.        */ 	next_unit= un->next_unit(); 	un->exclude_level(); 	if (next_unit) 	  continue; 	break;       }       if (subquery_predicate->substype() == Item_subselect::IN_SUBS)       {         Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;         if (in_subs->is_jtbm_merged)           continue;       }        if (const_only && !subquery_predicate->const_item())       {         /* Skip non-constant subqueries if the caller asked so. */         continue;       }        bool empty_union_result= true;       bool is_correlated_unit= false;       bool first= true;       bool union_plan_saved= false;       /*         If the subquery is a UNION, optimize all the subqueries in the UNION. If         there is no UNION, then the loop will execute once for the subquery.       */       for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())       {         JOIN *inner_join= sl->join;         if (first)           first= false;         else         {           if (!union_plan_saved)           {             union_plan_saved= true;             if (un->save_union_explain(un->thd->lex->explain))               return true; /* Failure */           }         }         if (!inner_join)           continue;         SELECT_LEX *save_select= un->thd->lex->current_select;         ulonglong save_options;         int res;         /* We need only 1 row to determine existence */         un->set_limit(un->global_parameters());         un->thd->lex->current_select= sl;         save_options= inner_join->select_options;         if (options & SELECT_DESCRIBE)         {           /* Optimize the subquery in the context of EXPLAIN. */           sl->set_explain_type(FALSE);           sl->options|= SELECT_DESCRIBE;           inner_join->select_options|= SELECT_DESCRIBE;         }         if ((res= inner_join->optimize()))           return TRUE;         if (!inner_join->cleaned)           sl->update_used_tables();         sl->update_correlated_cache();         is_correlated_unit|= sl->is_correlated;         inner_join->select_options= save_options;         un->thd->lex->current_select= save_select;          Explain_query *eq;         if ((eq= inner_join->thd->lex->explain))         {           Explain_select *expl_sel;           if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))           {             sl->set_explain_type(TRUE);             expl_sel->select_type= sl->type;           }         }          if (empty_union_result)         {           /*             If at least one subquery in a union is non-empty, the UNION result             is non-empty. If there is no UNION, the only subquery is non-empy.           */           empty_union_result= inner_join->empty_result();         }         if (res)           return TRUE;       }       if (empty_union_result)         subquery_predicate->no_rows_in_result();       if (!is_correlated_unit)         un->uncacheable&= ~UNCACHEABLE_DEPENDENT;       subquery_predicate->is_correlated= is_correlated_unit;     }   }   return FALSE; }"
"216905_CWE-190.cpp","CWE-190","bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num) {    if (!((options & SELECT_DISTINCT) && !group_list.elements))     hidden_bit_fields= 0;    // find_order_in_list() may need some extra space, so multiply by two.   order_group_num*= 2;    /*     We have to create array in prepared statement memory if it is a     prepared statement   */   Query_arena *arena= thd->stmt_arena;   const uint n_elems= (n_sum_items +                        n_child_sum_items +                        item_list.elements +                        select_n_reserved +                        select_n_having_items +                        select_n_where_fields +                        order_group_num +                        hidden_bit_fields +                        fields_in_window_functions) * 5;   if (!ref_pointer_array.is_null())   {     /*       We need to take 'n_sum_items' into account when allocating the array,       and this may actually increase during the optimization phase due to       MIN/MAX rewrite in Item_in_subselect::single_value_transformer.       In the usual case we can reuse the array from the prepare phase.       If we need a bigger array, we must allocate a new one.      */     if (ref_pointer_array.size() >= n_elems)       return false;    }   Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));   if (array != NULL)     ref_pointer_array= Ref_ptr_array(array, n_elems);    return array == NULL; }"
"216906_CWE-400.cpp","CWE-400","void ha_maria::drop_table(const char *name) {   DBUG_ASSERT(file->s->temporary);   (void) ha_close();   (void) maria_delete_table_files(name, 1, MY_WME); }"
"216938_CWE-416.cpp","CWE-416","bool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx) {   TABLE *table;   const char *key;   uint	key_length;   const char *alias= table_list->alias.str;   uint flags= ot_ctx->get_flags();   MDL_ticket *mdl_ticket;   TABLE_SHARE *share;   uint gts_flags;   bool from_share= false; #ifdef WITH_PARTITION_STORAGE_ENGINE   int part_names_error=0; #endif   DBUG_ENTER(""open_table"");    /*     The table must not be opened already. The table can be pre-opened for     some statements if it is a temporary table.      open_temporary_table() must be used to open temporary tables.   */   DBUG_ASSERT(!table_list->table);    /* an open table operation needs a lot of the stack space */   if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))     DBUG_RETURN(TRUE);    if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed)   {     thd->send_kill_message();     DBUG_RETURN(TRUE);   }    /*     Check if we're trying to take a write lock in a read only transaction.      Note that we allow write locks on log tables as otherwise logging     to general/slow log would be disabled in read only transactions.   */   if (table_list->mdl_request.is_write_lock_request() &&       thd->tx_read_only &&       !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))   {     my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));     DBUG_RETURN(true);   }    if (!table_list->db.str)   {     my_error(ER_NO_DB_ERROR, MYF(0));     DBUG_RETURN(true);   }    key_length= get_table_def_key(table_list, &key);    /*     If we're in pre-locked or LOCK TABLES mode, let's try to find the     requested table in the list of pre-opened and locked tables. If the     table is not there, return an error - we can't open not pre-opened     tables in pre-locked/LOCK TABLES mode.     TODO: move this block into a separate function.   */   if (thd->locked_tables_mode &&       ! (flags & MYSQL_OPEN_GET_NEW_TABLE))   {						// Using table locks     TABLE *best_table= 0;     int best_distance= INT_MIN;     for (table=thd->open_tables; table ; table=table->next)     {       if (table->s->table_cache_key.length == key_length && 	  !memcmp(table->s->table_cache_key.str, key, key_length))       {         if (!my_strcasecmp(system_charset_info, table->alias.c_ptr(), alias) &&             table->query_id != thd->query_id && /* skip tables already used */             (thd->locked_tables_mode == LTM_LOCK_TABLES ||              table->query_id == 0))         {           int distance= ((int) table->reginfo.lock_type -                          (int) table_list->lock_type);            /*             Find a table that either has the exact lock type requested,             or has the best suitable lock. In case there is no locked             table that has an equal or higher lock than requested,             we us the closest matching lock to be able to produce an error             message about wrong lock mode on the table. The best_table             is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.              distance <  0 - No suitable lock found             distance >  0 - we have lock mode higher then we require             distance == 0 - we have lock mode exactly which we need           */           if ((best_distance < 0 && distance > best_distance) ||               (distance >= 0 && distance < best_distance))           {             best_distance= distance;             best_table= table;             if (best_distance == 0)             {               /*                 We have found a perfect match and can finish iterating                 through open tables list. Check for table use conflict                 between calling statement and SP/trigger is done in                 lock_tables().               */               break;             }           }         }       }     }     if (best_table)     {       table= best_table;       table->query_id= thd->query_id;       table->init(thd, table_list);       DBUG_PRINT(""info"",(""Using locked table"")); #ifdef WITH_PARTITION_STORAGE_ENGINE       part_names_error= set_partitions_as_used(table_list, table); #endif       goto reset;     }      if (is_locked_view(thd, table_list))     {       if (table_list->sequence)       {         my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);         DBUG_RETURN(true);       }       DBUG_RETURN(FALSE); // VIEW     }      /*       No table in the locked tables list. In case of explicit LOCK TABLES       this can happen if a user did not include the table into the list.       In case of pre-locked mode locked tables list is generated automatically,       so we may only end up here if the table did not exist when       locked tables list was created.     */     if (thd->locked_tables_mode == LTM_PRELOCKED)       my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db.str, table_list->alias.str);     else       my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);     DBUG_RETURN(TRUE);   }    /*     Non pre-locked/LOCK TABLES mode, and the table is not temporary.     This is the normal use case.   */    if (! (flags & MYSQL_OPEN_HAS_MDL_LOCK))   {     /*       We are not under LOCK TABLES and going to acquire write-lock/       modify the base table. We need to acquire protection against       global read lock until end of this statement in order to have       this statement blocked by active FLUSH TABLES WITH READ LOCK.        We don't need to acquire this protection under LOCK TABLES as       such protection already acquired at LOCK TABLES time and       not released until UNLOCK TABLES.        We don't block statements which modify only temporary tables       as these tables are not preserved by any form of       backup which uses FLUSH TABLES WITH READ LOCK.        TODO: The fact that we sometimes acquire protection against             GRL only when we encounter table to be write-locked             slightly increases probability of deadlock.             This problem will be solved once Alik pushes his             temporary table refactoring patch and we can start             pre-acquiring metadata locks at the beggining of             open_tables() call.     */     if (table_list->mdl_request.is_write_lock_request() &&         ! (flags & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |                     MYSQL_OPEN_FORCE_SHARED_MDL |                     MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |                     MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&         ! ot_ctx->has_protection_against_grl())     {       MDL_request protection_request;       MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);        if (thd->global_read_lock.can_acquire_protection())         DBUG_RETURN(TRUE);        protection_request.init(MDL_key::GLOBAL, """", """", MDL_INTENTION_EXCLUSIVE,                               MDL_STATEMENT);        /*         Install error handler which if possible will convert deadlock error         into request to back-off and restart process of opening tables.       */       thd->push_internal_handler(&mdl_deadlock_handler);       bool result= thd->mdl_context.acquire_lock(&protection_request,                                                  ot_ctx->get_timeout());       thd->pop_internal_handler();        if (result)         DBUG_RETURN(TRUE);        ot_ctx->set_has_protection_against_grl();     }      if (open_table_get_mdl_lock(thd, ot_ctx, &table_list->mdl_request,                                 flags, &mdl_ticket) ||         mdl_ticket == NULL)     {       DEBUG_SYNC(thd, ""before_open_table_wait_refresh"");       DBUG_RETURN(TRUE);     }     DEBUG_SYNC(thd, ""after_open_table_mdl_shared"");   }   else   {     /*       Grab reference to the MDL lock ticket that was acquired       by the caller.     */     mdl_ticket= table_list->mdl_request.ticket;   }    if (table_list->open_strategy == TABLE_LIST::OPEN_IF_EXISTS)   {     if (!ha_table_exists(thd, &table_list->db, &table_list->table_name))       DBUG_RETURN(FALSE);   }   else if (table_list->open_strategy == TABLE_LIST::OPEN_STUB)     DBUG_RETURN(FALSE);    /* Table exists. Let us try to open it. */    if (table_list->i_s_requested_object & OPEN_TABLE_ONLY)     gts_flags= GTS_TABLE;   else if (table_list->i_s_requested_object &  OPEN_VIEW_ONLY)     gts_flags= GTS_VIEW;   else     gts_flags= GTS_TABLE | GTS_VIEW;  retry_share:    share= tdc_acquire_share(thd, table_list, gts_flags, &table);    if (unlikely(!share))   {     /*       Hide ""Table doesn't exist"" errors if the table belongs to a view.       The check for thd->is_error() is necessary to not push an       unwanted error in case the error was already silenced.       @todo Rework the alternative ways to deal with ER_NO_SUCH TABLE.     */     if (thd->is_error())     {       if (table_list->parent_l)       {         thd->clear_error();         my_error(ER_WRONG_MRG_TABLE, MYF(0));       }       else if (table_list->belong_to_view)       {         TABLE_LIST *view= table_list->belong_to_view;         thd->clear_error();         my_error(ER_VIEW_INVALID, MYF(0),                  view->view_db.str, view->view_name.str);       }     }     DBUG_RETURN(TRUE);   }    /*     Check if this TABLE_SHARE-object corresponds to a view. Note, that there is     no need to check TABLE_SHARE::tdc.flushed as we do for regular tables,     because view shares are always up to date.   */   if (share->is_view)   {     /*       If parent_l of the table_list is non null then a merge table       has this view as child table, which is not supported.     */     if (table_list->parent_l)     {       my_error(ER_WRONG_MRG_TABLE, MYF(0));       goto err_lock;     }     if (table_list->sequence)     {       my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str,                table_list->alias.str);       goto err_lock;     }     /*       This table is a view. Validate its metadata version: in particular,       that it was a view when the statement was prepared.     */     if (check_and_update_table_version(thd, table_list, share))       goto err_lock;      /* Open view */     if (mysql_make_view(thd, share, table_list, false))       goto err_lock;       /* TODO: Don't free this */     tdc_release_share(share);      DBUG_ASSERT(table_list->view);      DBUG_RETURN(FALSE);   }  #ifdef WITH_WSREP   if (!((flags & MYSQL_OPEN_IGNORE_FLUSH) ||         (thd->wsrep_applier))) #else   if (!(flags & MYSQL_OPEN_IGNORE_FLUSH)) #endif   {     if (share->tdc->flushed)     {       DBUG_PRINT(""info"", (""Found old share version: %lld  current: %lld"",                           share->tdc->version, tdc_refresh_version()));       /*         We already have an MDL lock. But we have encountered an old         version of table in the table definition cache which is possible         when someone changes the table version directly in the cache         without acquiring a metadata lock (e.g. this can happen during         ""rolling"" FLUSH TABLE(S)).         Release our reference to share, wait until old version of         share goes away and then try to get new version of table share.       */       if (table)         tc_release_table(table);       else         tdc_release_share(share);        MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);       bool wait_result;        thd->push_internal_handler(&mdl_deadlock_handler);       wait_result= tdc_wait_for_old_version(thd, table_list->db.str,                                             table_list->table_name.str,                                             ot_ctx->get_timeout(),                                             mdl_ticket->get_deadlock_weight());       thd->pop_internal_handler();        if (wait_result)         DBUG_RETURN(TRUE);        goto retry_share;     }      if (thd->open_tables && thd->open_tables->s->tdc->flushed)     {       /*         If the version changes while we're opening the tables,         we have to back off, close all the tables opened-so-far,         and try to reopen them. Note: refresh_version is currently         changed only during FLUSH TABLES.       */       if (table)         tc_release_table(table);       else         tdc_release_share(share);       (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,                                            NULL);       DBUG_RETURN(TRUE);     }   }    if (table)   {     DBUG_ASSERT(table->file != NULL);     MYSQL_REBIND_TABLE(table->file); #ifdef WITH_PARTITION_STORAGE_ENGINE     part_names_error= set_partitions_as_used(table_list, table); #endif   }   else   {     enum open_frm_error error;      /* make a new table */     if (!(table=(TABLE*) my_malloc(sizeof(*table),MYF(MY_WME))))       goto err_lock;      error= open_table_from_share(thd, share, &table_list->alias,                                  HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,                                  EXTRA_RECORD,                                  thd->open_options, table, FALSE,                                  IF_PARTITIONING(table_list->partition_names,0));      if (unlikely(error))     {       my_free(table);        if (error == OPEN_FRM_DISCOVER)         (void) ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,                                               table_list);       else if (share->crashed)       {         if (!(flags & MYSQL_OPEN_IGNORE_REPAIR))           (void) ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,                                                 table_list);         else           table_list->crashed= 1;  /* Mark that table was crashed */       }       goto err_lock;     }     if (open_table_entry_fini(thd, share, table))     {       closefrm(table);       my_free(table);       goto err_lock;     }      /* Add table to the share's used tables list. */     tc_add_table(thd, table);     from_share= true;   }    table->mdl_ticket= mdl_ticket;   table->reginfo.lock_type=TL_READ;		/* Assume read */    table->init(thd, table_list);    table->next= thd->open_tables;		/* Link into simple list */   thd->set_open_tables(table);   reset:   /*     Check that there is no reference to a condition from an earlier query     (cf. Bug#58553).    */   DBUG_ASSERT(table->file->pushed_cond == NULL);   table_list->updatable= 1; // It is not derived table nor non-updatable VIEW   table_list->table= table;    if (!from_share && table->vcol_fix_expr(thd))     goto err_lock;  #ifdef WITH_PARTITION_STORAGE_ENGINE   if (unlikely(table->part_info))   {     /* Partitions specified were incorrect.*/     if (part_names_error)     {       table->file->print_error(part_names_error, MYF(0));       DBUG_RETURN(true);     }   }   else if (table_list->partition_names)   {     /* Don't allow PARTITION () clause on a nonpartitioned table */     my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));     DBUG_RETURN(true);   } #endif   if (table_list->sequence && table->s->table_type != TABLE_TYPE_SEQUENCE)   {     my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);     DBUG_RETURN(true);   }    DBUG_RETURN(FALSE);  err_lock:   tdc_release_share(share);    DBUG_PRINT(""exit"", (""failed""));   DBUG_RETURN(TRUE); }"
"216945_CWE-617.cpp","CWE-617","bool Item_equal::create_pushable_equalities(THD *thd,                                             List<Item> *equalities,                                             Pushdown_checker checker,                                             uchar *arg,                                             bool clone_const) {   Item *item;   Item *left_item= NULL;   Item *right_item = get_const();   Item_equal_fields_iterator it(*this);    while ((item=it++))   {     left_item= item;     if (checker && !((item->*checker) (arg)))       continue;     break;   }    if (!left_item)     return false;    if (right_item)   {     Item_func_eq *eq= 0;     Item *left_item_clone= left_item->build_clone(thd);     Item *right_item_clone= !clone_const ?                             right_item : right_item->build_clone(thd);     if (!left_item_clone || !right_item_clone)       return true;     eq= new (thd->mem_root) Item_func_eq(thd,                                          left_item_clone,                                          right_item_clone);     if (!eq ||  equalities->push_back(eq, thd->mem_root))       return true;     if (!clone_const)       right_item->set_extraction_flag(IMMUTABLE_FL);   }    while ((item=it++))   {     if (checker && !((item->*checker) (arg)))       continue;     Item_func_eq *eq= 0;     Item *left_item_clone= left_item->build_clone(thd);     Item *right_item_clone= item->build_clone(thd);     if (!(left_item_clone && right_item_clone))       return true;     left_item_clone->set_item_equal(NULL);     right_item_clone->set_item_equal(NULL);     eq= new (thd->mem_root) Item_func_eq(thd,                                          right_item_clone,                                          left_item_clone);     if (!eq || equalities->push_back(eq, thd->mem_root))       return true;   }   return false; }"
"216946_CWE-416.c","CWE-416","static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl) {   const size_t so_ext_len= sizeof(SO_EXT) - 1;   if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,                     SO_EXT))   {     char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);     memcpy(s, dl->str, dl->length);     strcpy(s + dl->length, SO_EXT);     dl->str= s;     dl->length+= so_ext_len;   } }"
"216949_CWE-89.c","CWE-89","Field *create_tmp_field_from_field(THD *thd, Field *org_field,                                    const char *name, TABLE *table,                                    Item_field *item) {   Field *new_field;    new_field= org_field->make_new_field(thd->mem_root, table,                                        table == org_field->table);   if (new_field)   {     new_field->init(table);     new_field->orig_table= org_field->orig_table;     if (item)       item->result_field= new_field;     else       new_field->field_name= name;     new_field->flags|= (org_field->flags & NO_DEFAULT_VALUE_FLAG);     if (org_field->maybe_null() || (item && item->maybe_null))       new_field->flags&= ~NOT_NULL_FLAG;	// Because of outer join     if (org_field->type() == MYSQL_TYPE_VAR_STRING ||         org_field->type() == MYSQL_TYPE_VARCHAR)       table->s->db_create_options|= HA_OPTION_PACK_RECORD;     else if (org_field->type() == FIELD_TYPE_DOUBLE)       ((Field_double *) new_field)->not_fixed= TRUE;     new_field->vcol_info= 0;     new_field->cond_selectivity= 1.0;     new_field->next_equal_field= NULL;     new_field->option_list= NULL;     new_field->option_struct= NULL;   }   return new_field; }"
"216965_CWE-617.cpp","CWE-617","multi_update::initialize_tables(JOIN *join) {   TABLE_LIST *table_ref;   DBUG_ENTER(""initialize_tables"");    if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&                error_if_full_join(join)))     DBUG_RETURN(1);   main_table=join->join_tab->table;   table_to_update= 0;    /* Any update has at least one pair (field, value) */   DBUG_ASSERT(fields->elements);   /*    Only one table may be modified by UPDATE of an updatable view.    For an updatable view first_table_for_update indicates this    table.    For a regular multi-update it refers to some updated table.   */    TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;    /* Create a temporary table for keys to all tables, except main table */   for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)   {     TABLE *table=table_ref->table;     uint cnt= table_ref->shared;     List<Item> temp_fields;     ORDER     group;     TMP_TABLE_PARAM *tmp_param;      if (ignore)       table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);     if (table == main_table)			// First table in join     {       if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))       { 	table_to_update= table;			// Update table on the fly         has_vers_fields= table->vers_check_update(*fields); 	continue;       }     }     table->prepare_for_position();     join->map2table[table->tablenr]->keep_current_rowid= true;      /*       enable uncacheable flag if we update a view with check option       and check option has a subselect, otherwise, the check option       can be evaluated after the subselect was freed as independent       (See full_local in JOIN::join_free()).     */     if (table_ref->check_option && !join->select_lex->uncacheable)     {       SELECT_LEX_UNIT *tmp_unit;       SELECT_LEX *sl;       for (tmp_unit= join->select_lex->first_inner_unit();            tmp_unit;            tmp_unit= tmp_unit->next_unit())       {         for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())         {           if (sl->master_unit()->item)           {             join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;             goto loop_end;           }         }       }     } loop_end:      if (table == first_table_for_update && table_ref->check_option)     {       table_map unupdated_tables= table_ref->check_option->used_tables() &                                   ~first_table_for_update->map;       List_iterator<TABLE_LIST> ti(*leaves);       TABLE_LIST *tbl_ref;       while ((tbl_ref= ti++) && unupdated_tables)       {         if (unupdated_tables & tbl_ref->table->map)           unupdated_tables&= ~tbl_ref->table->map;         else           continue;         if (unupdated_check_opt_tables.push_back(tbl_ref->table))           DBUG_RETURN(1);       }     }      tmp_param= tmp_table_param+cnt;      /*       Create a temporary table to store all fields that are changed for this       table. The first field in the temporary table is a pointer to the       original row so that we can find and update it. For the updatable       VIEW a few following fields are rowids of tables used in the CHECK       OPTION condition.     */      List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);     TABLE *tbl= table;     do     {       LEX_CSTRING field_name;       field_name.str= tbl->alias.c_ptr();       field_name.length= strlen(field_name.str);       /*         Signal each table (including tables referenced by WITH CHECK OPTION         clause) for which we will store row position in the temporary table         that we need a position to be read first.       */       tbl->prepare_for_position();       join->map2table[tbl->tablenr]->keep_current_rowid= true;        Item_temptable_rowid *item=         new (thd->mem_root) Item_temptable_rowid(tbl);       if (!item)          DBUG_RETURN(1);       item->fix_fields(thd, 0);       if (temp_fields.push_back(item, thd->mem_root))         DBUG_RETURN(1);     } while ((tbl= tbl_it++));      temp_fields.append(fields_for_table[cnt]);      /* Make an unique key over the first field to avoid duplicated updates */     bzero((char*) &group, sizeof(group));     group.direction= ORDER::ORDER_ASC;     group.item= (Item**) temp_fields.head_ref();      tmp_param->quick_group= 1;     tmp_param->field_count= temp_fields.elements;     tmp_param->func_count=  temp_fields.elements - 1;     calc_group_buffer(tmp_param, &group);     /* small table, ignore SQL_BIG_TABLES */     my_bool save_big_tables= thd->variables.big_tables;      thd->variables.big_tables= FALSE;     tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,                                      (ORDER*) &group, 0, 0,                                      TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);     thd->variables.big_tables= save_big_tables;     if (!tmp_tables[cnt])       DBUG_RETURN(1);     tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);   }   join->tmp_table_keep_current_rowid= TRUE;   DBUG_RETURN(0); }"
"216973_CWE-703.c","CWE-703","create_worker_threads(uint n) { 	comp_thread_ctxt_t	*threads; 	uint 			i;  	threads = (comp_thread_ctxt_t *) 		my_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));  	for (i = 0; i < n; i++) { 		comp_thread_ctxt_t *thd = threads + i;  		thd->num = i + 1; 		thd->started = FALSE; 		thd->cancelled = FALSE; 		thd->data_avail = FALSE;  		thd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE + 						   MY_QLZ_COMPRESS_OVERHEAD, 						   MYF(MY_FAE));  		/* Initialize the control mutex and condition var */ 		if (pthread_mutex_init(&thd->ctrl_mutex, NULL) || 		    pthread_cond_init(&thd->ctrl_cond, NULL)) { 			goto err; 		}  		/* Initialize and data mutex and condition var */ 		if (pthread_mutex_init(&thd->data_mutex, NULL) || 		    pthread_cond_init(&thd->data_cond, NULL)) { 			goto err; 		}  		pthread_mutex_lock(&thd->ctrl_mutex);  		if (pthread_create(&thd->id, NULL, compress_worker_thread_func, 				   thd)) { 			msg(""compress: pthread_create() failed: "" 			    ""errno = %d"", errno); 			goto err; 		} 	}  	/* Wait for the threads to start */ 	for (i = 0; i < n; i++) { 		comp_thread_ctxt_t *thd = threads + i;  		while (thd->started == FALSE) 			pthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex); 		pthread_mutex_unlock(&thd->ctrl_mutex); 	}  	return threads;  err: 	my_free(threads); 	return NULL; }"
"217176_CWE-79.c","CWE-79","static void do_viewlog(HttpRequest req, HttpResponse res) {         if (is_readonly(req)) {                 send_error(req, res, SC_FORBIDDEN, ""You do not have sufficient privileges to access this page"");                 return;         }         do_head(res, ""_viewlog"", ""View log"", 100);         if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {                 FILE *f = fopen(Run.files.log, ""r"");                 if (f) {                         size_t n;                         char buf[512];                         StringBuffer_append(res->outputbuffer, ""<br><p><form><textarea cols=120 rows=30 readonly>"");                         while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {                                 buf[n] = 0;                                 StringBuffer_append(res->outputbuffer, ""%s"", buf);                         }                         fclose(f);                         StringBuffer_append(res->outputbuffer, ""</textarea></form>"");                 } else {                         StringBuffer_append(res->outputbuffer, ""Error opening logfile: %s"", STRERROR);                 }         } else {                 StringBuffer_append(res->outputbuffer,                                     ""<b>Cannot view logfile:</b><br>"");                 if (! (Run.flags & Run_Log))                         StringBuffer_append(res->outputbuffer, ""Monit was started without logging"");                 else                         StringBuffer_append(res->outputbuffer, ""Monit uses syslog"");         }         do_foot(res); }"
"217459_CWE-59.cpp","CWE-59","Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)  {      auto* zei = entries.getUnchecked (index);       #if JUCE_WINDOWS      auto entryPath = zei->entry.filename;     #else      auto entryPath = zei->entry.filename.replaceCharacter ('\\', '/');     #endif        if (entryPath.isEmpty())          return Result::ok();        auto targetFile = targetDirectory.getChildFile (entryPath);        if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\'))          return targetFile.createDirectory(); // (entry is a directory, not a file)        std::unique_ptr<InputStream> in (createStreamForEntry (index));        if (in == nullptr)          return Result::fail (""Failed to open the zip file for reading"");        if (targetFile.exists())      {          if (! shouldOverwriteFiles)              return Result::ok();            if (! targetFile.deleteFile())              return Result::fail (""Failed to write to target file: "" + targetFile.getFullPathName());      }        if (! targetFile.getParentDirectory().createDirectory())          return Result::fail (""Failed to create target folder: "" + targetFile.getParentDirectory().getFullPathName());        if (zei->entry.isSymbolicLink)      {          String originalFilePath (in->readEntireStreamAsString()                                      .replaceCharacter (L'/', File::getSeparatorChar()));            if (! File::createSymbolicLink (targetFile, originalFilePath, true))              return Result::fail (""Failed to create symbolic link: "" + originalFilePath);      }      else      {          FileOutputStream out (targetFile);            if (out.failedToOpen())              return Result::fail (""Failed to write to target file: "" + targetFile.getFullPathName());            out << *in;      }        targetFile.setCreationTime (zei->entry.fileTime);      targetFile.setLastModificationTime (zei->entry.fileTime);      targetFile.setLastAccessTime (zei->entry.fileTime);        return Result::ok();  } "
"217547_CWE-120.c","CWE-120","int64_t GmfOpenMesh(const char *FilNam, int mod, ...) {    int      KwdCod, res, *PtrVer, *PtrDim, err;    int64_t  MshIdx;    char     str[ GmfStrSiz ];    va_list  VarArg;    GmfMshSct *msh;     /*---------------------*/    /* MESH STRUCTURE INIT */    /*---------------------*/     if(!(msh = calloc(1, sizeof(GmfMshSct))))       return(0);     MshIdx = (int64_t)msh;     // Save the current stack environment for longjmp    if( (err = setjmp(msh->err)) != 0)    { #ifdef GMFDEBUG       printf(""libMeshb : mesh %p : error %d\n"", msh, err); #endif       if(msh->hdl != NULL)          fclose(msh->hdl);        if(msh->FilDes != 0) #ifdef GMF_WINDOWS          _close(msh->FilDes); #else          close(msh->FilDes); #endif        free(msh);       return(0);    }     // Copy the FilNam into the structure    if(strlen(FilNam) + 7 >= GmfStrSiz)       longjmp(msh->err, -4);     strcpy(msh->FilNam, FilNam);     // Store the opening mod (read or write) and guess    // the filetype (binary or ascii) depending on the extension    msh->mod = mod;    msh->buf = (void *)msh->DblBuf;    msh->FltBuf = (void *)msh->DblBuf;    msh->IntBuf = (void *)msh->DblBuf;     if(strstr(msh->FilNam, "".meshb""))       msh->typ |= (Bin | MshFil);    else if(strstr(msh->FilNam, "".mesh""))       msh->typ |= (Asc | MshFil);    else if(strstr(msh->FilNam, "".solb""))       msh->typ |= (Bin | SolFil);    else if(strstr(msh->FilNam, "".sol""))       msh->typ |= (Asc | SolFil);    else       longjmp(msh->err, -5);     // Open the file in the required mod and initialize the mesh structure    if(msh->mod == GmfRead)    {        /*-----------------------*/       /* OPEN FILE FOR READING */       /*-----------------------*/        va_start(VarArg, mod);       PtrVer = va_arg(VarArg, int *);       PtrDim = va_arg(VarArg, int *);       va_end(VarArg);        // Read the endian coding tag, the mesh version       // and the mesh dimension (mandatory kwd)       if(msh->typ & Bin)       {          // Create the name string and open the file #ifdef WITH_GMF_AIO          // [Bruno] added binary flag (necessary under Windows)          msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);           if(msh->FilDes <= 0)             longjmp(msh->err, -6);           // Read the endian coding tag          if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)             longjmp(msh->err, -7); #else          // [Bruno] added binary flag (necessary under Windows)          if(!(msh->hdl = fopen(msh->FilNam, ""rb"")))             longjmp(msh->err, -8);           // Read the endian coding tag          safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err); #endif           // Read the mesh version and the mesh dimension (mandatory kwd)          if( (msh->cod != 1) && (msh->cod != 16777216) )             longjmp(msh->err, -9);           ScaWrd(msh, (unsigned char *)&msh->ver);           if( (msh->ver < 1) || (msh->ver > 4) )             longjmp(msh->err, -10);           if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )             longjmp(msh->err, -11);           ScaWrd(msh, (unsigned char *)&KwdCod);           if(KwdCod != GmfDimension)             longjmp(msh->err, -12);           GetPos(msh);          ScaWrd(msh, (unsigned char *)&msh->dim);       }       else       {          // Create the name string and open the file          if(!(msh->hdl = fopen(msh->FilNam, ""rb"")))             longjmp(msh->err, -13);           do          {             res = fscanf(msh->hdl, ""%s"", str);          }while( (res != EOF) && strcmp(str, ""MeshVersionFormatted"") );           if(res == EOF)             longjmp(msh->err, -14);           safe_fscanf(msh->hdl, ""%d"", &msh->ver, msh->err);           if( (msh->ver < 1) || (msh->ver > 4) )             longjmp(msh->err, -15);           do          {             res = fscanf(msh->hdl, ""%s"", str);          }while( (res != EOF) && strcmp(str, ""Dimension"") );           if(res == EOF)             longjmp(msh->err, -16);           safe_fscanf(msh->hdl, ""%d"", &msh->dim, msh->err);       }        if( (msh->dim != 2) && (msh->dim != 3) )          longjmp(msh->err, -17);        (*PtrVer) = msh->ver;       (*PtrDim) = msh->dim;        // Set default real numbers size       if(msh->ver == 1)          msh->FltSiz = 32;       else          msh->FltSiz = 64;        /*------------*/       /* KW READING */       /*------------*/        // Read the list of kw present in the file       if(!ScaKwdTab(msh))          return(0);        return(MshIdx);    }    else if(msh->mod == GmfWrite)    {        /*-----------------------*/       /* OPEN FILE FOR WRITING */       /*-----------------------*/        msh->cod = 1;        // Check if the user provided a valid version number and dimension       va_start(VarArg, mod);       msh->ver = va_arg(VarArg, int);       msh->dim = va_arg(VarArg, int);       va_end(VarArg);        if( (msh->ver < 1) || (msh->ver > 4) )          longjmp(msh->err, -18);        if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )          longjmp(msh->err, -19);        if( (msh->dim != 2) && (msh->dim != 3) )          longjmp(msh->err, -20);        // Set default real numbers size       if(msh->ver == 1)          msh->FltSiz = 32;       else          msh->FltSiz = 64;        // Create the mesh file       if(msh->typ & Bin)        {          /*            * [Bruno] replaced previous call to creat():           * with a call to open(), because Windows needs the           * binary flag to be specified.           */ #ifdef WITH_GMF_AIO          msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);           if(msh->FilDes <= 0)             longjmp(msh->err, -21); #else          if(!(msh->hdl = fopen(msh->FilNam, ""wb"")))             longjmp(msh->err, -22); #endif       }       else if(!(msh->hdl = fopen(msh->FilNam, ""wb"")))          longjmp(msh->err, -23);         /*------------*/       /* KW WRITING */       /*------------*/        // Write the mesh version and dimension       if(msh->typ & Asc)       {          fprintf(msh->hdl, ""%s %d\n\n"",                GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);          fprintf(msh->hdl, ""%s %d\n"",                GmfKwdFmt[ GmfDimension ][0], msh->dim);       }       else       {          RecWrd(msh, (unsigned char *)&msh->cod);          RecWrd(msh, (unsigned char *)&msh->ver);          GmfSetKwd(MshIdx, GmfDimension, 0);          RecWrd(msh, (unsigned char *)&msh->dim);       }        return(MshIdx);    }    else    {       free(msh);       return(0);    } }"
"217551_CWE-125.cpp","CWE-125","int parse(char *elf) {     int fd;     struct stat st;     uint8_t *elf_map;     int count;     char *tmp;     char *name;     char flag[4];      MODE = get_elf_class(elf);      fd = open(elf, O_RDONLY);     if (fd < 0) {         perror(""open"");         return -1;     }      if (fstat(fd, &st) < 0) {         perror(""fstat"");         return -1;     }      elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);     if (elf_map == MAP_FAILED) {         perror(""mmap"");         return -1;     }      /* 32bit */     if (MODE == ELFCLASS32) {         /* ELF Header Information */         Elf32_Ehdr *ehdr;         ehdr = (Elf32_Ehdr *)elf_map;          INFO(""ELF Header\n"");                 switch (ehdr->e_type) {             case ET_NONE:                 tmp = ""An unknown type"";                 break;              case ET_REL:                 tmp = ""A relocatable file"";                 break;              case ET_EXEC:                 tmp = ""An executable file"";                 break;              case ET_DYN:                 tmp = ""A shared object"";                 break;              case ET_CORE:                 tmp = ""A core file"";                 break;                          default:                 tmp = ""An unknown type"";                 break;         }         PRINT_HEADER_EXP(""e_type:"", ehdr->e_type, tmp);          switch (ehdr->e_type) {             case EM_NONE:                 tmp = ""An unknown machine"";                 break;              case EM_M32:                 tmp = ""AT&T WE 32100"";                 break;              case EM_SPARC:                 tmp = ""Sun Microsystems SPARC"";                 break;              case EM_386:                 tmp = ""Intel 80386"";                 break;              case EM_68K:                 tmp = ""Motorola 68000"";                 break;                          case EM_88K:                 tmp = ""Motorola 88000"";                 break;              case EM_860:                 tmp = ""Intel 80860"";                 break;              case EM_MIPS:                 tmp = ""MIPS RS3000 (big-endian only)"";                 break;              case EM_PARISC:                 tmp = ""HP/PA"";                 break;              case EM_SPARC32PLUS:                 tmp = ""SPARC with enhanced instruction set"";                 break;                          case EM_PPC:                 tmp = ""PowerPC"";                 break;              case EM_PPC64:                 tmp = ""PowerPC 64-bit"";                 break;              case EM_S390:                 tmp = ""IBM S/390"";                 break;              case EM_ARM:                 tmp = ""Advanced RISC Machines"";                 break;              case EM_SH:                 tmp = ""Renesas SuperH"";                 break;                          case EM_SPARCV9:                 tmp = ""SPARC v9 64-bit"";                 break;              case EM_IA_64:                 tmp = ""Intel Itanium"";                 break;              case EM_X86_64:                 tmp = ""AMD x86-64"";                 break;              case EM_VAX:                 tmp = ""DEC Vax"";                 break;                          default:                 tmp = ""An unknown machine"";                 break;         }         PRINT_HEADER_EXP(""e_machine:"", ehdr->e_machine, tmp);          switch (ehdr->e_version) {             case EV_NONE:                 tmp = ""Invalid version"";                 break;              case EV_CURRENT:                 tmp = ""Current version"";                 break;              default:                 tmp = ""Known version"";                 break;         }         PRINT_HEADER_EXP(""e_version:"", ehdr->e_version, tmp);         PRINT_HEADER(""e_entry:"", ehdr->e_entry);         PRINT_HEADER(""e_phoff:"", ehdr->e_phoff);         PRINT_HEADER(""e_shoff:"", ehdr->e_shoff);         PRINT_HEADER(""e_flags:"", ehdr->e_flags);         PRINT_HEADER(""e_ehsize:"", ehdr->e_ehsize);         PRINT_HEADER(""e_phentsize:"", ehdr->e_phentsize);         PRINT_HEADER(""e_phnum:"", ehdr->e_phnum);         PRINT_HEADER(""e_shentsize:"", ehdr->e_shentsize);         PRINT_HEADER(""e_shentsize:"", ehdr->e_shentsize);         PRINT_HEADER(""e_shstrndx:"", ehdr->e_shstrndx);          /* Section Information */         Elf32_Shdr *shdr;         Elf32_Phdr *phdr;         Elf32_Shdr shstrtab;          shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];         phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];         shstrtab = shdr[ehdr->e_shstrndx];          INFO(""Section Header Table\n"");         PRINT_SECTION_TITLE(""Nr"", ""Name"", ""Type"", ""Addr"", ""Off"", ""Size"", ""Es"", ""Flg"", ""Lk"", ""Inf"", ""Al"");         for (int i = 0; i < ehdr->e_shnum; i++) {             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;              switch (shdr[i].sh_type) {                 case SHT_NULL:                     tmp = ""SHT_NULL"";                     break;                                  case SHT_PROGBITS:                     tmp = ""SHT_PROGBITS"";                     break;                  case SHT_SYMTAB:                     tmp = ""SHT_SYMTAB"";                     break;                  case SHT_STRTAB:                     tmp = ""SHT_STRTAB"";                     break;                  case SHT_RELA:                     tmp = ""SHT_RELA"";                     break;                  case SHT_HASH:                     tmp = ""SHT_HASH"";                     break;                  case SHT_DYNAMIC:                     tmp = ""SHT_DYNAMIC"";                     break;                  case SHT_NOTE:                     tmp = ""SHT_NOTE"";                     break;                  case SHT_NOBITS:                     tmp = ""SHT_NOBITS"";                     break;                  case SHT_REL:                     tmp = ""SHT_REL"";                     break;                  case SHT_SHLIB:                     tmp = ""SHT_SHLIB"";                     break;                  case SHT_DYNSYM:                     tmp = ""SHT_DYNSYM"";                     break;                  case SHT_LOPROC:                     tmp = ""SHT_LOPROC"";                     break;                  case SHT_HIPROC:                     tmp = ""SHT_HIPROC"";                     break;                  case SHT_LOUSER:                     tmp = ""SHT_LOUSER"";                     break;                  case SHT_HIUSER:                     tmp = ""SHT_HIUSER"";                     break;                                  default:                     break;             }              if (strlen(name) > 15) {                 strcpy(&name[15 - 6], ""[...]"");             }             strcpy(flag, ""   "");             flag2str_sh(shdr[i].sh_flags, flag);             PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \                             flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);         }          INFO(""Program Header Table\n"");         PRINT_PROGRAM_TITLE(""Nr"", ""Type"", ""Offset"", ""Virtaddr"", ""Physaddr"", ""Filesiz"", ""Memsiz"", ""Flg"", ""Align"");         for (int i = 0; i < ehdr->e_phnum; i++) {             switch (phdr[i].p_type) {                 case PT_NULL:                     tmp = ""PT_NULL"";                     break;                                  case PT_LOAD:                     tmp = ""PT_LOAD"";                     break;                  case PT_DYNAMIC:                     tmp = ""PT_DYNAMIC"";                     break;                  case PT_INTERP:                     tmp = ""PT_INTERP"";                     break;                  case PT_NOTE:                     tmp = ""PT_NOTE"";                     break;                  case PT_SHLIB:                     tmp = ""PT_SHLIB"";                     break;                  case PT_PHDR:                     tmp = ""PT_PHDR"";                     break;                  case PT_LOPROC:                     tmp = ""PT_LOPROC"";                     break;                  case PT_HIPROC:                     tmp = ""PT_HIPROC"";                     break;                  case PT_GNU_STACK:                     tmp = ""PT_GNU_STACK"";                     break;                                  default:                     break;             }             strcpy(flag, ""   "");             flag2str(phdr[i].p_flags, flag);             PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align);          }          INFO(""Section to segment mapping\n"");         for (int i = 0; i < ehdr->e_phnum; i++) {             printf(""     [%2d]"", i);             for (int j = 0; j < ehdr->e_shnum; j++) {                 name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;                 if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {                     if (shdr[j].sh_flags >> 1 & 0x1) {                         printf("" %s"", name);                     }                 }                 }             printf(""\n"");         }          INFO(""Dynamic link information\n"");         int dynstr;         int dynamic;         Elf32_Dyn *dyn;         for (int i = 0; i < ehdr->e_shnum; i++) {             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;             if (!strcmp(name, "".dynstr"")) {                 dynstr = i;             }             if (!strcmp(name, "".dynamic"")) {                 dynamic = i;             }         }          char value[50];         name = """";         dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];         count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);         INFO(""Dynamic section at offset 0x%x contains %d entries\n"", shdr[dynamic].sh_offset, count);         PRINT_DYN_TITLE(""Tag"", ""Type"", ""Name/Value"");                  for(int i = 0; i < count; i++) {             tmp = """";             memset(value, 0, 50);             snprintf(value, 50, ""0x%x"", dyn[i].d_un.d_val);             switch (dyn[i].d_tag) {                 /* Legal values for d_tag (dynamic entry type).  */                 case DT_NULL:                     tmp = ""DT_NULL"";                     break;                  case DT_NEEDED:                     tmp = ""DT_NEEDED"";                     name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;                     snprintf(value, 50, ""Shared library: [%s]"", name);                     break;                                  case DT_PLTRELSZ:                     tmp = ""DT_PLTRELSZ"";                     break;                  case DT_PLTGOT:                     tmp = ""DT_PLTGOT"";                     break;                  case DT_HASH:                     tmp = ""DT_HASH"";                     break;                  case DT_STRTAB:                     tmp = ""DT_STRTAB"";                     break;                  case DT_SYMTAB:                     tmp = ""DT_SYMTAB"";                     break;                  case DT_RELA:                     tmp = ""DT_RELA"";                     break;                  case DT_RELASZ:                     tmp = ""DT_RELASZ"";                     break;                  case DT_RELAENT:                     tmp = ""DT_RELAENT"";                     break;                  case DT_STRSZ:                     tmp = ""DT_STRSZ"";                     break;                  case DT_SYMENT:                     tmp = ""DT_SYMENT"";                     break;                  case DT_INIT:                     tmp = ""DT_INIT"";                     break;                  case DT_FINI:                     tmp = ""DT_FINI"";                     break;                  case DT_SONAME:                     tmp = ""DT_SONAME"";                     break;                  case DT_RPATH:                     tmp = ""DT_RPATH"";                     break;                  case DT_SYMBOLIC:                     tmp = ""DT_SYMBOLIC"";                     break;                  case DT_REL:                     tmp = ""DT_REL"";                     break;                  case DT_RELSZ:                     tmp = ""DT_RELSZ"";                     break;                  case DT_RELENT:                     tmp = ""DT_RELENT"";                     break;                                      case DT_PLTREL:                     tmp = ""DT_PLTREL"";                     break;                  case DT_DEBUG:                     tmp = ""DT_DEBUG"";                     break;                  case DT_TEXTREL:                     tmp = ""DT_TEXTREL"";                     break;                  case DT_JMPREL:                     tmp = ""DT_JMPREL"";                     break;                  case DT_BIND_NOW:                     tmp = ""DT_BIND_NOW"";                     break;                  case DT_INIT_ARRAY:                     tmp = ""DT_INIT_ARRAY"";                     break;                  case DT_FINI_ARRAY:                     tmp = ""DT_FINI_ARRAY"";                     break;                  case DT_INIT_ARRAYSZ:                     tmp = ""DT_INIT_ARRAYSZ"";                     break;                                  case DT_FINI_ARRAYSZ:                     tmp = ""DT_FINI_ARRAYSZ"";                     break;                  case DT_RUNPATH:                     tmp = ""DT_RUNPATH"";                     break;                  case DT_FLAGS:                     tmp = ""DT_FLAGS"";                     snprintf(value, 50, ""Flags: %d"", dyn[i].d_un.d_val);                     break;                                  case DT_ENCODING:                     tmp = ""DT_ENCODING"";                     break;                  case DT_PREINIT_ARRAYSZ:                     tmp = ""DT_PREINIT_ARRAYSZ"";                     break;                  case DT_SYMTAB_SHNDX:                     tmp = ""DT_SYMTAB_SHNDX"";                     break;                                  case DT_NUM:                     tmp = ""DT_NUM"";                     break;                  case DT_LOOS:                     tmp = ""DT_LOOS"";                     break;                  case DT_HIOS:                     tmp = ""DT_HIOS"";                     break;                  case DT_LOPROC:                     tmp = ""DT_LOPROC"";                     break;                  case DT_HIPROC:                     tmp = ""DT_HIPROC"";                     break;                  case DT_PROCNUM:                     tmp = ""DT_LOPROC"";                     break;                  /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the                  * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's                  * approach. */                  case DT_VALRNGLO:                     tmp = ""DT_VALRNGLO"";                     break;                  case DT_GNU_PRELINKED:                     tmp = ""DT_GNU_PRELINKED"";                     break;                                  case DT_GNU_CONFLICTSZ:                     tmp = ""DT_GNU_CONFLICTSZ"";                     break;                  case DT_GNU_LIBLISTSZ:                     tmp = ""DT_GNU_LIBLISTSZ"";                     break;                  case DT_CHECKSUM:                     tmp = ""DT_CHECKSUM"";                     break;                  case DT_PLTPADSZ:                     tmp = ""DT_PLTPADSZ"";                     break;                  case DT_MOVEENT:                     tmp = ""DT_MOVEENT"";                     break;                  case DT_MOVESZ:                     tmp = ""DT_MOVESZ"";                     break;                  case DT_FEATURE_1:                     tmp = ""DT_FEATURE_1"";                     break;                  case DT_POSFLAG_1:                     tmp = ""DT_POSFLAG_1"";                     break;                  case DT_SYMINSZ:                     tmp = ""DT_SYMINSZ"";                     break;                  case DT_SYMINENT:                     tmp = ""DT_SYMINENT"";                     break;                  /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the                  * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.                  * If any adjustment is made to the ELF object after it has been                  * built these entries will need to be adjusted.  */                 case DT_ADDRRNGLO:                     tmp = ""DT_ADDRRNGLO"";                     break;                  case DT_GNU_HASH:                     tmp = ""DT_GNU_HASH"";                     break;                  case DT_TLSDESC_PLT:                     tmp = ""DT_TLSDESC_PLT"";                     break;                  case DT_TLSDESC_GOT:                     tmp = ""DT_TLSDESC_GOT"";                     break;                  case DT_GNU_CONFLICT:                     tmp = ""DT_GNU_CONFLICT"";                     break;                  case DT_GNU_LIBLIST:                     tmp = ""DT_GNU_LIBLIST"";                     break;                  case DT_CONFIG:                     tmp = ""DT_CONFIG"";                     break;                  case DT_DEPAUDIT:                     tmp = ""DT_DEPAUDIT"";                     break;                  case DT_AUDIT:                     tmp = ""DT_AUDIT"";                     break;                  case DT_PLTPAD:                     tmp = ""DT_PLTPAD"";                     break;                  case DT_MOVETAB:                     tmp = ""DT_MOVETAB"";                     break;                  case DT_SYMINFO:                     tmp = ""DT_SYMINFO"";                     break;                                      /* The versioning entry types.  The next are defined as part of the                  * GNU extension.  */                 case DT_VERSYM:                     tmp = ""DT_VERSYM"";                     break;                  case DT_RELACOUNT:                     tmp = ""DT_RELACOUNT"";                     break;                  case DT_RELCOUNT:                     tmp = ""DT_RELCOUNT"";                     break;                                  /* These were chosen by Sun.  */                 case DT_FLAGS_1:                     tmp = ""DT_FLAGS_1"";                     switch (dyn[i].d_un.d_val) {                         case DF_1_PIE:                             snprintf(value, 50, ""Flags: %s"", ""PIE"");                             break;                                                  default:                             snprintf(value, 50, ""Flags: %d"", dyn[i].d_un.d_val);                             break;                     }                                          break;                  case DT_VERDEF:                     tmp = ""DT_VERDEF"";                     break;                  case DT_VERDEFNUM:                     tmp = ""DT_VERDEFNUM"";                     break;                  case DT_VERNEED:                     tmp = ""DT_VERNEED"";                     break;                  case DT_VERNEEDNUM:                     tmp = ""DT_VERNEEDNUM"";                     break;                                  default:                     break;             }             PRINT_DYN(dyn[i].d_tag, tmp, value);         }             }      /* 64bit */     if (MODE == ELFCLASS64) {         /* ELF Header Information */         Elf64_Ehdr *ehdr;         ehdr = (Elf64_Ehdr *)elf_map;          INFO(""ELF Header\n"");                 switch (ehdr->e_type) {             case ET_NONE:                 tmp = ""An unknown type"";                 break;              case ET_REL:                 tmp = ""A relocatable file"";                 break;              case ET_EXEC:                 tmp = ""An executable file"";                 break;              case ET_DYN:                 tmp = ""A shared object"";                 break;              case ET_CORE:                 tmp = ""A core file"";                 break;                          default:                 tmp = ""An unknown type"";                 break;         }         PRINT_HEADER_EXP(""e_type:"", ehdr->e_type, tmp);          switch (ehdr->e_type) {             case EM_NONE:                 tmp = ""An unknown machine"";                 break;              case EM_M32:                 tmp = ""AT&T WE 32100"";                 break;              case EM_SPARC:                 tmp = ""Sun Microsystems SPARC"";                 break;              case EM_386:                 tmp = ""Intel 80386"";                 break;              case EM_68K:                 tmp = ""Motorola 68000"";                 break;                          case EM_88K:                 tmp = ""Motorola 88000"";                 break;              case EM_860:                 tmp = ""Intel 80860"";                 break;              case EM_MIPS:                 tmp = ""MIPS RS3000 (big-endian only)"";                 break;              case EM_PARISC:                 tmp = ""HP/PA"";                 break;              case EM_SPARC32PLUS:                 tmp = ""SPARC with enhanced instruction set"";                 break;                          case EM_PPC:                 tmp = ""PowerPC"";                 break;              case EM_PPC64:                 tmp = ""PowerPC 64-bit"";                 break;              case EM_S390:                 tmp = ""IBM S/390"";                 break;              case EM_ARM:                 tmp = ""Advanced RISC Machines"";                 break;              case EM_SH:                 tmp = ""Renesas SuperH"";                 break;                          case EM_SPARCV9:                 tmp = ""SPARC v9 64-bit"";                 break;              case EM_IA_64:                 tmp = ""Intel Itanium"";                 break;              case EM_X86_64:                 tmp = ""AMD x86-64"";                 break;              case EM_VAX:                 tmp = ""DEC Vax"";                 break;                          default:                 tmp = ""An unknown machine"";                 break;         }         PRINT_HEADER_EXP(""e_machine:"", ehdr->e_machine, tmp);          switch (ehdr->e_version) {             case EV_NONE:                 tmp = ""Invalid version"";                 break;              case EV_CURRENT:                 tmp = ""Current version"";                 break;              default:                 tmp = ""Known version"";                 break;         }         PRINT_HEADER_EXP(""e_version:"", ehdr->e_version, tmp);         PRINT_HEADER(""e_entry:"", ehdr->e_entry);         PRINT_HEADER(""e_phoff:"", ehdr->e_phoff);         PRINT_HEADER(""e_shoff:"", ehdr->e_shoff);         PRINT_HEADER(""e_flags:"", ehdr->e_flags);         PRINT_HEADER(""e_ehsize:"", ehdr->e_ehsize);         PRINT_HEADER(""e_phentsize:"", ehdr->e_phentsize);         PRINT_HEADER(""e_phnum:"", ehdr->e_phnum);         PRINT_HEADER(""e_shentsize:"", ehdr->e_shentsize);         PRINT_HEADER(""e_shentsize:"", ehdr->e_shentsize);         PRINT_HEADER(""e_shstrndx:"", ehdr->e_shstrndx);          /* Section Information */         Elf64_Shdr *shdr;         Elf64_Phdr *phdr;         Elf64_Shdr shstrtab;          shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];         phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];         shstrtab = shdr[ehdr->e_shstrndx];          INFO(""Section Header Table\n"");         PRINT_SECTION_TITLE(""Nr"", ""Name"", ""Type"", ""Addr"", ""Off"", ""Size"", ""Es"", ""Flg"", ""Lk"", ""Inf"", ""Al"");         for (int i = 0; i < ehdr->e_shnum; i++) {             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;              switch (shdr[i].sh_type) {                 case SHT_NULL:                     tmp = ""SHT_NULL"";                     break;                                  case SHT_PROGBITS:                     tmp = ""SHT_PROGBITS"";                     break;                  case SHT_SYMTAB:                     tmp = ""SHT_SYMTAB"";                     break;                  case SHT_STRTAB:                     tmp = ""SHT_STRTAB"";                     break;                  case SHT_RELA:                     tmp = ""SHT_RELA"";                     break;                  case SHT_HASH:                     tmp = ""SHT_HASH"";                     break;                  case SHT_DYNAMIC:                     tmp = ""SHT_DYNAMIC"";                     break;                  case SHT_NOTE:                     tmp = ""SHT_NOTE"";                     break;                  case SHT_NOBITS:                     tmp = ""SHT_NOBITS"";                     break;                  case SHT_REL:                     tmp = ""SHT_REL"";                     break;                  case SHT_SHLIB:                     tmp = ""SHT_SHLIB"";                     break;                  case SHT_DYNSYM:                     tmp = ""SHT_DYNSYM"";                     break;                  case SHT_LOPROC:                     tmp = ""SHT_LOPROC"";                     break;                  case SHT_HIPROC:                     tmp = ""SHT_HIPROC"";                     break;                  case SHT_LOUSER:                     tmp = ""SHT_LOUSER"";                     break;                  case SHT_HIUSER:                     tmp = ""SHT_HIUSER"";                     break;                                  default:                     break;             }              if (strlen(name) > 15) {                 strcpy(&name[15 - 6], ""[...]"");             }             strcpy(flag, ""   "");             flag2str_sh(shdr[i].sh_flags, flag);             PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \                             flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);         }          INFO(""Program Header Table\n"");         PRINT_PROGRAM_TITLE(""Nr"", ""Type"", ""Offset"", ""Virtaddr"", ""Physaddr"", ""Filesiz"", ""Memsiz"", ""Flg"", ""Align"");         for (int i = 0; i < ehdr->e_phnum; i++) {             switch (phdr[i].p_type) {                 case PT_NULL:                     tmp = ""PT_NULL"";                     break;                                  case PT_LOAD:                     tmp = ""PT_LOAD"";                     break;                  case PT_DYNAMIC:                     tmp = ""PT_DYNAMIC"";                     break;                  case PT_INTERP:                     tmp = ""PT_INTERP"";                     break;                  case PT_NOTE:                     tmp = ""PT_NOTE"";                     break;                  case PT_SHLIB:                     tmp = ""PT_SHLIB"";                     break;                  case PT_PHDR:                     tmp = ""PT_PHDR"";                     break;                  case PT_LOPROC:                     tmp = ""PT_LOPROC"";                     break;                  case PT_HIPROC:                     tmp = ""PT_HIPROC"";                     break;                  case PT_GNU_STACK:                     tmp = ""PT_GNU_STACK"";                     break;                                  default:                     break;             }             strcpy(flag, ""   "");             flag2str(phdr[i].p_flags, flag);             PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align);          }          INFO(""Section to segment mapping\n"");         for (int i = 0; i < ehdr->e_phnum; i++) {             printf(""     [%2d]"", i);             for (int j = 0; j < ehdr->e_shnum; j++) {                 name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;                 if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {                     if (shdr[j].sh_flags >> 1 & 0x1) {                         printf("" %s"", name);                     }                 }                 }             printf(""\n"");         }          INFO(""Dynamic link information\n"");         int dynstr;         int dynamic;         Elf64_Dyn *dyn;         for (int i = 0; i < ehdr->e_shnum; i++) {             name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;             if (!strcmp(name, "".dynstr"")) {                 dynstr = i;             }             if (!strcmp(name, "".dynamic"")) {                 dynamic = i;             }         }          char value[50];         name = """";         dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];         count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);         INFO(""Dynamic section at offset 0x%x contains %d entries\n"", shdr[dynamic].sh_offset, count);         PRINT_DYN_TITLE(""Tag"", ""Type"", ""Name/Value"");                  for(int i = 0; i < count; i++) {             tmp = """";             memset(value, 0, 50);             snprintf(value, 50, ""0x%x"", dyn[i].d_un.d_val);             switch (dyn[i].d_tag) {                 /* Legal values for d_tag (dynamic entry type).  */                 case DT_NULL:                     tmp = ""DT_NULL"";                     break;                  case DT_NEEDED:                     tmp = ""DT_NEEDED"";                     name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;                     snprintf(value, 50, ""Shared library: [%s]"", name);                     break;                                  case DT_PLTRELSZ:                     tmp = ""DT_PLTRELSZ"";                     break;                  case DT_PLTGOT:                     tmp = ""DT_PLTGOT"";                     break;                  case DT_HASH:                     tmp = ""DT_HASH"";                     break;                  case DT_STRTAB:                     tmp = ""DT_STRTAB"";                     break;                  case DT_SYMTAB:                     tmp = ""DT_SYMTAB"";                     break;                  case DT_RELA:                     tmp = ""DT_RELA"";                     break;                  case DT_RELASZ:                     tmp = ""DT_RELASZ"";                     break;                  case DT_RELAENT:                     tmp = ""DT_RELAENT"";                     break;                  case DT_STRSZ:                     tmp = ""DT_STRSZ"";                     break;                  case DT_SYMENT:                     tmp = ""DT_SYMENT"";                     break;                  case DT_INIT:                     tmp = ""DT_INIT"";                     break;                  case DT_FINI:                     tmp = ""DT_FINI"";                     break;                  case DT_SONAME:                     tmp = ""DT_SONAME"";                     break;                  case DT_RPATH:                     tmp = ""DT_RPATH"";                     break;                  case DT_SYMBOLIC:                     tmp = ""DT_SYMBOLIC"";                     break;                  case DT_REL:                     tmp = ""DT_REL"";                     break;                  case DT_RELSZ:                     tmp = ""DT_RELSZ"";                     break;                  case DT_RELENT:                     tmp = ""DT_RELENT"";                     break;                                      case DT_PLTREL:                     tmp = ""DT_PLTREL"";                     break;                  case DT_DEBUG:                     tmp = ""DT_DEBUG"";                     break;                  case DT_TEXTREL:                     tmp = ""DT_TEXTREL"";                     break;                  case DT_JMPREL:                     tmp = ""DT_JMPREL"";                     break;                  case DT_BIND_NOW:                     tmp = ""DT_BIND_NOW"";                     break;                  case DT_INIT_ARRAY:                     tmp = ""DT_INIT_ARRAY"";                     break;                  case DT_FINI_ARRAY:                     tmp = ""DT_FINI_ARRAY"";                     break;                  case DT_INIT_ARRAYSZ:                     tmp = ""DT_INIT_ARRAYSZ"";                     break;                                  case DT_FINI_ARRAYSZ:                     tmp = ""DT_FINI_ARRAYSZ"";                     break;                  case DT_RUNPATH:                     tmp = ""DT_RUNPATH"";                     break;                  case DT_FLAGS:                     tmp = ""DT_FLAGS"";                     snprintf(value, 50, ""Flags: %d"", dyn[i].d_un.d_val);                     break;                                  case DT_ENCODING:                     tmp = ""DT_ENCODING"";                     break;                  case DT_PREINIT_ARRAYSZ:                     tmp = ""DT_PREINIT_ARRAYSZ"";                     break;                  case DT_SYMTAB_SHNDX:                     tmp = ""DT_SYMTAB_SHNDX"";                     break;                                  case DT_NUM:                     tmp = ""DT_NUM"";                     break;                  case DT_LOOS:                     tmp = ""DT_LOOS"";                     break;                  case DT_HIOS:                     tmp = ""DT_HIOS"";                     break;                  case DT_LOPROC:                     tmp = ""DT_LOPROC"";                     break;                  case DT_HIPROC:                     tmp = ""DT_HIPROC"";                     break;                  case DT_PROCNUM:                     tmp = ""DT_LOPROC"";                     break;                  /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the                  * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's                  * approach. */                  case DT_VALRNGLO:                     tmp = ""DT_VALRNGLO"";                     break;                  case DT_GNU_PRELINKED:                     tmp = ""DT_GNU_PRELINKED"";                     break;                                  case DT_GNU_CONFLICTSZ:                     tmp = ""DT_GNU_CONFLICTSZ"";                     break;                  case DT_GNU_LIBLISTSZ:                     tmp = ""DT_GNU_LIBLISTSZ"";                     break;                  case DT_CHECKSUM:                     tmp = ""DT_CHECKSUM"";                     break;                  case DT_PLTPADSZ:                     tmp = ""DT_PLTPADSZ"";                     break;                  case DT_MOVEENT:                     tmp = ""DT_MOVEENT"";                     break;                  case DT_MOVESZ:                     tmp = ""DT_MOVESZ"";                     break;                  case DT_FEATURE_1:                     tmp = ""DT_FEATURE_1"";                     break;                  case DT_POSFLAG_1:                     tmp = ""DT_POSFLAG_1"";                     break;                  case DT_SYMINSZ:                     tmp = ""DT_SYMINSZ"";                     break;                  case DT_SYMINENT:                     tmp = ""DT_SYMINENT"";                     break;                  /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the                  * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.                  * If any adjustment is made to the ELF object after it has been                  * built these entries will need to be adjusted.  */                 case DT_ADDRRNGLO:                     tmp = ""DT_ADDRRNGLO"";                     break;                  case DT_GNU_HASH:                     tmp = ""DT_GNU_HASH"";                     break;                  case DT_TLSDESC_PLT:                     tmp = ""DT_TLSDESC_PLT"";                     break;                  case DT_TLSDESC_GOT:                     tmp = ""DT_TLSDESC_GOT"";                     break;                  case DT_GNU_CONFLICT:                     tmp = ""DT_GNU_CONFLICT"";                     break;                  case DT_GNU_LIBLIST:                     tmp = ""DT_GNU_LIBLIST"";                     break;                  case DT_CONFIG:                     tmp = ""DT_CONFIG"";                     break;                  case DT_DEPAUDIT:                     tmp = ""DT_DEPAUDIT"";                     break;                  case DT_AUDIT:                     tmp = ""DT_AUDIT"";                     break;                  case DT_PLTPAD:                     tmp = ""DT_PLTPAD"";                     break;                  case DT_MOVETAB:                     tmp = ""DT_MOVETAB"";                     break;                  case DT_SYMINFO:                     tmp = ""DT_SYMINFO"";                     break;                                      /* The versioning entry types.  The next are defined as part of the                  * GNU extension.  */                 case DT_VERSYM:                     tmp = ""DT_VERSYM"";                     break;                  case DT_RELACOUNT:                     tmp = ""DT_RELACOUNT"";                     break;                  case DT_RELCOUNT:                     tmp = ""DT_RELCOUNT"";                     break;                                  /* These were chosen by Sun.  */                 case DT_FLAGS_1:                     tmp = ""DT_FLAGS_1"";                     switch (dyn[i].d_un.d_val) {                         case DF_1_PIE:                             snprintf(value, 50, ""Flags: %s"", ""PIE"");                             break;                                                  default:                             snprintf(value, 50, ""Flags: %d"", dyn[i].d_un.d_val);                             break;                     }                                          break;                  case DT_VERDEF:                     tmp = ""DT_VERDEF"";                     break;                  case DT_VERDEFNUM:                     tmp = ""DT_VERDEFNUM"";                     break;                  case DT_VERNEED:                     tmp = ""DT_VERNEED"";                     break;                  case DT_VERNEEDNUM:                     tmp = ""DT_VERNEEDNUM"";                     break;                                  default:                     break;             }             PRINT_DYN(dyn[i].d_tag, tmp, value);         }             }      return 0; }"
"219902_not_vulnerable.c","not_vulnerable","GF_Err gf_isom_sdp_clean_track(GF_ISOFile *the_file, u32 trackNumber) { 	GF_TrackBox *trak; 	GF_UserDataMap *map; 	GF_HintTrackInfoBox *hnti;  	trak = gf_isom_get_track_from_file(the_file, trackNumber); 	if (!trak) return GF_BAD_PARAM;  	//currently, only RTP hinting supports SDP 	if (!CheckHintFormat(trak, GF_ISOM_HINT_RTP)) return GF_BAD_PARAM;  	map = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_HNTI, NULL); 	if (!map) return GF_ISOM_INVALID_FILE;  	//we should have only one HNTI in the UDTA 	if (gf_list_count(map->boxes) != 1) return GF_ISOM_INVALID_FILE;  	hnti = (GF_HintTrackInfoBox *)gf_list_get(map->boxes, 0); 	if (!hnti->SDP) return GF_OK; 	//and free the SDP 	gf_free(((GF_SDPBox *)hnti->SDP)->sdpText); 	((GF_SDPBox *)hnti->SDP)->sdpText = NULL; 	return GF_OK; }"
"219949_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_user_update_password (const struct _u_request * request, struct _u_response * response, void * user_data) {   struct config_elements * config = (struct config_elements *)user_data;   json_t * j_session, * j_password, * j_element = NULL;   char * session_uid = get_session_id(config, request);   const char ** passwords = NULL;   int res;   struct _user_module_instance * user_module;   size_t index = 0;    if (session_uid != NULL && o_strlen(session_uid)) {     j_session = get_current_user_for_session(config, session_uid);     if (check_result_value(j_session, G_OK)) {       j_password = ulfius_get_json_body_request(request, NULL);       user_module = get_user_module_instance(config, json_string_value(json_object_get(json_object_get(j_session, ""user""), ""source"")));       if (user_module && user_module->multiple_passwords) {         if (json_string_length(json_object_get(j_password, ""old_password"")) && json_is_array(json_object_get(j_password, ""password""))) {           if ((passwords = o_malloc(json_array_size(json_object_get(j_password, ""password"")) * sizeof(char *))) != NULL) {             json_array_foreach(json_object_get(j_password, ""password""), index, j_element) {               passwords[index] = json_string_value(j_element);             }             if ((res = user_update_password(config, json_string_value(json_object_get(json_object_get(j_session, ""user""), ""username"")), json_string_value(json_object_get(j_password, ""old_password"")), passwords, json_array_size(json_object_get(j_password, ""password"")))) == G_ERROR_PARAM) {               response->status = 400;             } else if (res != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_update_password - Error user_update_password (1)"");               response->status = 500;             }           } else {             y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_update_password - Error allocating resources for passwords (1)"");             response->status = 500;           }           o_free(passwords);         } else {           response->status = 400;         }       } else {         if (json_string_length(json_object_get(j_password, ""old_password"")) && json_string_length(json_object_get(j_password, ""password""))) {           if ((passwords = o_malloc(sizeof(char *))) != NULL) {             passwords[0] = json_string_value(json_object_get(j_password, ""password""));             if ((res = user_update_password(config, json_string_value(json_object_get(json_object_get(j_session, ""user""), ""username"")), json_string_value(json_object_get(j_password, ""old_password"")), passwords, 1)) == G_ERROR_PARAM) {               response->status = 400;             } else if (res != G_OK) {               y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_update_password - Error user_update_password (2)"");               response->status = 500;             }           } else {             y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_update_password - Error allocating resources for passwords (2)"");             response->status = 500;           }           o_free(passwords);         } else {           response->status = 400;         }       }       json_decref(j_password);     } else if (check_result_value(j_session, G_ERROR_NOT_FOUND)) {       response->status = 401;     } else {       y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_update_password - Error get_current_user_for_session"");       response->status = 500;     }     json_decref(j_session);   } else {     response->status = 401;   }   o_free(session_uid);      return U_CALLBACK_CONTINUE; }"
"219960_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_get_user_middleware_module (const struct _u_request * request, struct _u_response * response, void * user_middleware_data) {   struct config_elements * config = (struct config_elements *)user_middleware_data;   json_t * j_module;      j_module = get_user_middleware_module(config, u_map_get(request->map_url, ""name""));   if (check_result_value(j_module, G_OK)) {     ulfius_set_json_body_response(response, 200, json_object_get(j_module, ""module""));   } else if (check_result_value(j_module, G_ERROR_NOT_FOUND)) {     response->status = 404;   } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_get_user_middleware_module - Error get_user_middleware_module"");     response->status = 500;   }   json_decref(j_module);   return U_CALLBACK_CONTINUE; }"
"219968_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_get_user_session_scope_grant (const struct _u_request * request, struct _u_response * response, void * user_data) {   struct config_elements * config = (struct config_elements *)user_data;   json_t * j_user = (json_t *)response->shared_data, * j_scope_list;      if (config != NULL && j_user != NULL) {     j_scope_list = get_granted_scopes_for_client(config, j_user, u_map_get(request->map_url, ""client_id""), u_map_get(request->map_url, ""scope_list""));     if (check_result_value(j_scope_list, G_OK)) {       ulfius_set_json_body_response(response, 200, json_object_get(j_scope_list, ""grant""));     } else if (check_result_value(j_scope_list, G_ERROR_NOT_FOUND)) {       response->status = 404;     } else {       y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_get_user_session_scope_grant - Error get_granted_scopes_for_client"");       response->status = 500;     }     json_decref(j_scope_list);   } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_get_user_session_scope_grant - Error config or j_user is NULL"");     response->status = 500;   }   return U_CALLBACK_CONTINUE; }"
"219978_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_get_plugin_module (const struct _u_request * request, struct _u_response * response, void * plugin_data) {   struct config_elements * config = (struct config_elements *)plugin_data;   json_t * j_module;      j_module = get_plugin_module(config, u_map_get(request->map_url, ""name""));   if (check_result_value(j_module, G_OK)) {     ulfius_set_json_body_response(response, 200, json_object_get(j_module, ""module""));   } else if (check_result_value(j_module, G_ERROR_NOT_FOUND)) {     response->status = 404;   } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_get_plugin_module - Error get_plugin_module"");     response->status = 500;   }   json_decref(j_module);   return U_CALLBACK_CONTINUE; }"
"219986_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_user_get_plugin_list (const struct _u_request * request, struct _u_response * response, void * user_data) {   UNUSED(request);   struct config_elements * config = (struct config_elements *)user_data;   json_t * j_plugin_list = get_plugin_module_list_for_user(config);      if (check_result_value(j_plugin_list, G_OK)) {     ulfius_set_json_body_response(response, 200, json_object_get(j_plugin_list, ""module""));   } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_user_get_plugin_list - Error j_plugin_list"");     response->status = 500;   }   json_decref(j_plugin_list);   return U_CALLBACK_CONTINUE; }"
"219996_not_vulnerable.c","not_vulnerable","int callback_glewlwyd_get_user_module (const struct _u_request * request, struct _u_response * response, void * user_data) {   struct config_elements * config = (struct config_elements *)user_data;   json_t * j_module;      j_module = get_user_module(config, u_map_get(request->map_url, ""name""));   if (check_result_value(j_module, G_OK)) {     ulfius_set_json_body_response(response, 200, json_object_get(j_module, ""module""));   } else if (check_result_value(j_module, G_ERROR_NOT_FOUND)) {     response->status = 404;   } else {     y_log_message(Y_LOG_LEVEL_ERROR, ""callback_glewlwyd_get_user_module - Error get_user_module"");     response->status = 500;   }   json_decref(j_module);   return U_CALLBACK_CONTINUE; }"
"220021_not_vulnerable.cc","not_vulnerable","  void Compute(OpKernelContext* context) override {     const Tensor* input_indices;     const Tensor* input_values;     const Tensor* input_shape;     SparseTensorsMap* map;      OP_REQUIRES_OK(context, context->input(""sparse_indices"", &input_indices));     OP_REQUIRES_OK(context, context->input(""sparse_values"", &input_values));     OP_REQUIRES_OK(context, context->input(""sparse_shape"", &input_shape));     OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),                 errors::InvalidArgument(                     ""Input indices should be a matrix but received shape "",                     input_indices->shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),                 errors::InvalidArgument(                     ""Input values should be a vector but received shape "",                     input_values->shape().DebugString()));     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),                 errors::InvalidArgument(                     ""Input shape should be a vector but received shape "",                     input_shape->shape().DebugString()));     OP_REQUIRES(         context,         input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),         errors::InvalidArgument(             ""Number of values must match first dimension of indices. "", ""Got "",             input_values->shape().dim_size(0),             "" values, indices shape: "", input_indices->shape().DebugString()));     OP_REQUIRES(         context,         input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),         errors::InvalidArgument(             ""Number of dimensions must match second dimension of indices. "",             ""Got "", input_shape->shape().dim_size(0),             "" dimensions, indices shape: "",             input_indices->shape().DebugString()));      int rank = input_shape->NumElements();      OP_REQUIRES(         context, rank > 1,         errors::InvalidArgument(             ""Rank of input SparseTensor should be > 1, but saw rank: "", rank));      auto input_shape_vec = input_shape->vec<int64_t>();      TensorShape tensor_input_shape;     OP_REQUIRES_OK(context, TensorShape::BuildTensorShape(input_shape_vec,                                                           &tensor_input_shape));     gtl::InlinedVector<int64_t, 8> std_order(rank);     std::iota(std_order.begin(), std_order.end(), 0);     SparseTensor input_st;     OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,                                                  tensor_input_shape, std_order,                                                  &input_st));      const int64_t N = input_shape_vec(0);      Tensor sparse_handles(DT_INT64, TensorShape({N}));     auto sparse_handles_t = sparse_handles.vec<int64_t>();      OP_REQUIRES_OK(context, input_st.IndicesValid());      // We can generate the output shape proto string now, for all     // minibatch entries.     TensorShape output_shape;     OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(                                 input_shape_vec.data() + 1,                                 input_shape->NumElements() - 1, &output_shape));      // Get groups by minibatch dimension     std::unordered_set<int64_t> visited;     sparse::GroupIterable minibatch = input_st.group({0});     for (const auto& subset : minibatch) {       const int64_t b = subset.group()[0];       visited.insert(b);       OP_REQUIRES(           context, b > -1 && b < N,           errors::InvalidArgument(               ""Received unexpected column 0 value in input SparseTensor: "", b,               "" < 0 or >= N (= "", N, "")""));        const auto indices = subset.indices();       const auto values = subset.values<T>();       const int64_t num_entries = values.size();        Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});       Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});        auto output_indices_t = output_indices.matrix<int64_t>();       auto output_values_t = output_values.vec<T>();        for (int i = 0; i < num_entries; ++i) {         for (int d = 1; d < rank; ++d) {           output_indices_t(i, d - 1) = indices(i, d);         }         output_values_t(i) = values(i);       }        SparseTensor st_i;       OP_REQUIRES_OK(context,                      SparseTensor::Create(output_indices, output_values,                                           output_shape, &st_i));       int64_t handle;       OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));       sparse_handles_t(b) = handle;     }      // Fill in any gaps; we must provide an empty ST for batch entries     // the grouper didn't find.     if (visited.size() < N) {       Tensor empty_indices(DT_INT64, {0, rank - 1});       Tensor empty_values(DataTypeToEnum<T>::value, {0});       SparseTensor empty_st;       OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,                                                    output_shape, &empty_st));        for (int64_t b = 0; b < N; ++b) {         // We skipped this batch entry.         if (visited.find(b) == visited.end()) {           int64_t handle;           OP_REQUIRES_OK(context,                          map->AddSparseTensor(context, empty_st, &handle));           sparse_handles_t(b) = handle;         }       }     }      context->set_output(0, sparse_handles);   }"
"220184_not_vulnerable.cc","not_vulnerable","Status Graph::AddWhileInputHack(Node* new_src, int new_src_index, Node* dst) {   if (!dst->IsWhileNode()) {     return errors::Internal(         ""dst argument to AddWhileEdgeHack should be a While op, got: "",         dst->DebugString());   }   TF_RETURN_IF_ERROR(IsValidOutputTensor(new_src, new_src_index));   // Find the current number of data inputs. We'll add the new edge to the next   // missing data input.   int dst_index = 0;   for (const Edge* edge : dst->in_edges()) {     if (edge->IsControlEdge()) continue;     ++dst_index;   }   TF_RETURN_IF_ERROR(IsValidInputTensor(dst, dst_index));   AddEdge(new_src, new_src_index, dst, dst_index);   dst->MaybeCopyOnWrite();   dst->props_->node_def.add_input(       strings::StrCat(new_src->name(), "":"", new_src_index));   return Status::OK(); }"
"220220_not_vulnerable.cc","not_vulnerable","void Graph::RemoveNode(Node* node) {   TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();   DCHECK(!node->IsSource());   DCHECK(!node->IsSink());    // Remove any edges involving this node.   for (const Edge* e : node->in_edges_) {     CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});     edges_[e->id_] = nullptr;     RecycleEdge(e);     --num_edges_;   }   node->in_edges_.clear();   for (const Edge* e : node->out_edges_) {     CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});     edges_[e->id_] = nullptr;     RecycleEdge(e);     --num_edges_;   }   node->out_edges_.clear();   ReleaseNode(node); }"
"220396_not_vulnerable.c","not_vulnerable","mrb_ary_aget(mrb_state *mrb, mrb_value self) {   struct RArray *a = mrb_ary_ptr(self);   mrb_int i;   mrb_int len, alen;   mrb_value index;    if (mrb_get_argc(mrb) == 1) {     index = mrb_get_arg1(mrb);     switch (mrb_type(index)) {       /* a[n..m] */     case MRB_TT_RANGE:       if (mrb_range_beg_len(mrb, index, &i, &len, ARY_LEN(a), TRUE) == MRB_RANGE_OK) {         return ary_subseq(mrb, a, i, len);       }       else {         return mrb_nil_value();       }     case MRB_TT_INTEGER:       return mrb_ary_ref(mrb, self, mrb_integer(index));     default:       return mrb_ary_ref(mrb, self, aget_index(mrb, index));     }   }    mrb_get_args(mrb, ""oi"", &index, &len);   i = aget_index(mrb, index);   alen = ARY_LEN(a);   if (i < 0) i += alen;   if (i < 0 || alen < i) return mrb_nil_value();   if (len < 0) return mrb_nil_value();   if (alen == i) return mrb_ary_new(mrb);   if (len > alen - i) len = alen - i;    return ary_subseq(mrb, a, i, len); }"
"220417_not_vulnerable.c","not_vulnerable","mrb_ary_concat(mrb_state *mrb, mrb_value self, mrb_value other) {   struct RArray *a2 = mrb_ary_ptr(other);    ary_concat(mrb, mrb_ary_ptr(self), a2); }"
"220419_not_vulnerable.c","not_vulnerable","mrb_ary_entry(mrb_value ary, mrb_int n) {   struct RArray *a = mrb_ary_ptr(ary);   mrb_int len = ARY_LEN(a);    /* range check */   if (n < 0) n += len;   if (n < 0 || len <= n) return mrb_nil_value();    return ARY_PTR(a)[n]; }"
"220425_not_vulnerable.c","not_vulnerable","mrb_ary_join(mrb_state *mrb, mrb_value ary, mrb_value sep) {   if (!mrb_nil_p(sep)) {     sep = mrb_obj_as_string(mrb, sep);   }   return join_ary(mrb, ary, sep, mrb_ary_new(mrb)); }"
"220458_not_vulnerable.cc","not_vulnerable","void LaunchConv2DOp<GPUDevice, T>::operator()(     OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,     const Tensor& input_param, const Tensor& filter, int row_dilation,     int col_dilation, int row_stride, int col_stride, const Padding& padding,     const std::vector<int64_t>& explicit_paddings, Tensor* output,     TensorFormat data_format) {   using se::dnn::AlgorithmConfig;   using se::dnn::AlgorithmDesc;   using se::dnn::ProfileResult;   auto* stream = ctx->op_device_context()->stream();   OP_REQUIRES(ctx, stream, errors::Internal(""No GPU stream available.""));    if (!use_cudnn) {     ctx->SetStatus(         errors::Unimplemented(""Conv2D for GPU is not currently supported ""                               ""without cudnn""));     return;   }    Tensor input = input_param;   const int64_t in_batch = GetTensorDim(input, data_format, 'N');   int64_t in_rows = GetTensorDim(input, data_format, 'H');   int64_t in_cols = GetTensorDim(input, data_format, 'W');   const int64_t in_depths = GetTensorDim(input, data_format, 'C');   const int64_t patch_rows = filter.dim_size(0);   const int64_t patch_cols = filter.dim_size(1);   const int64_t patch_depths = filter.dim_size(2);    OP_REQUIRES(       ctx, filter.NumElements() > 0,       errors::InvalidArgument(""filter must not have zero elements ""                               ""(i.e. all dimensions must be non-zero)""));    // If the filter in-depth (patch_depths) is 1 and smaller than the input   // depth, it's a depthwise convolution. More generally, if the filter in-depth   // divides but is smaller than the input depth, it is a grouped convolution.   bool is_grouped_convolution = patch_depths != in_depths;   if (patch_rows == 1 && patch_cols == 1 && !is_grouped_convolution &&       row_dilation == 1 && col_dilation == 1 && row_stride == 1 &&       col_stride == 1 && data_format == FORMAT_NHWC &&       (padding == VALID || padding == SAME)) {     // 1x1 filter, so call cublas directly.     const uint64 m = in_batch * in_rows * in_cols;     const uint64 k = patch_depths;     const uint64 n = filter.dim_size(3);      auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),                                 input.template flat<T>().size());     auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),                                 filter.template flat<T>().size());     auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),                                 output->template flat<T>().size());      auto no_transpose = se::blas::Transpose::kNoTranspose;     OP_REQUIRES_OK(ctx, stream->ThenBlasGemm(no_transpose, no_transpose, n, m,                                              k, b_ptr, n, a_ptr, k, &c_ptr, n));     return;   } else if (patch_rows == in_rows && patch_cols == in_cols &&              !is_grouped_convolution && row_dilation == 1 &&              col_dilation == 1 && padding == VALID &&              data_format == FORMAT_NHWC) {     // The input data and filter have the same height/width, so call cublas     // directly.     const uint64 m = in_batch;     const uint64 k = patch_rows * patch_cols * patch_depths;     const uint64 n = filter.dim_size(3);      auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),                                 input.template flat<T>().size());     auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),                                 filter.template flat<T>().size());     auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),                                 output->template flat<T>().size());      auto no_transpose = se::blas::Transpose::kNoTranspose;     OP_REQUIRES_OK(ctx, stream->ThenBlasGemm(no_transpose, no_transpose, n, m,                                              k, b_ptr, n, a_ptr, k, &c_ptr, n));     return;   }  #if GOOGLE_CUDA   // Tensor Core (NVIDIA Volta+ GPUs) supports efficient convolution with fp16   // in NHWC data layout. In all other configurations it's more efficient to   // run computation in NCHW data format.   const bool compute_in_nhwc = DataTypeToEnum<T>::value == DT_HALF &&                                stream->GetCudaComputeCapability().IsAtLeast(                                    se::CudaComputeCapability::VOLTA); #else   // fast NHWC implementation is a CUDA only feature   const bool compute_in_nhwc = false; #endif    // We only do one directional conversion: NHWC->NCHW. We never convert in the   // other direction. Grappler layout optimizer selects preferred layout and   // adds necessary annotations to the graph.   // TODO(ezhulenev): Convert in other direction for fp16?   const TensorFormat compute_data_format =       (compute_in_nhwc && data_format == FORMAT_NHWC) ? FORMAT_NHWC                                                       : FORMAT_NCHW;    VLOG(3) << ""Compute Conv2D with cuDNN:""           << "" data_format="" << ToString(data_format)           << "" compute_data_format="" << ToString(compute_data_format);    const int64_t out_batch = GetTensorDim(*output, data_format, 'N');   const int64_t out_rows = GetTensorDim(*output, data_format, 'H');   const int64_t out_cols = GetTensorDim(*output, data_format, 'W');   const int64_t out_depths = GetTensorDim(*output, data_format, 'C');   int64_t padding_top = -1, padding_bottom = -1;   int64_t padding_left = -1, padding_right = -1;   if (padding == EXPLICIT) {     GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &padding_top,                              &padding_bottom);     GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &padding_left,                              &padding_right);   }   int64_t out_rows_check, out_cols_check;   Status status = GetWindowedOutputSizeVerboseV2(       in_rows, patch_rows, row_dilation, row_stride, padding, &out_rows_check,       &padding_top, &padding_bottom);   // The status is guaranteed to be OK because we checked the output and padding   // was valid earlier.   TF_CHECK_OK(status);   DCHECK_EQ(out_rows, out_rows_check);   status = GetWindowedOutputSizeVerboseV2(in_cols, patch_cols, col_dilation,                                           col_stride, padding, &out_cols_check,                                           &padding_left, &padding_right);   TF_CHECK_OK(status);   DCHECK_EQ(out_cols, out_cols_check);    const int64_t common_padding_rows = std::min(padding_top, padding_bottom);   const int64_t common_padding_cols = std::min(padding_left, padding_right);   if (padding_top != padding_bottom || padding_left != padding_right) {     // cuDNN only supports padding the same amount on the left and right sides,     // and on the top and bottom sides. So we manually create a new padded     // input tensor such that we can pass it to cuDNN.     VLOG(4) << ""Pad input tensor:""             << "" padding_top="" << padding_top             << "" padding_bottom="" << padding_bottom             << "" padding_left="" << padding_left             << "" padding_right="" << padding_right;      // TODO(reedwm): In some cases, we can avoid an allocation even if the two     // padding sides are different. For example, if the input is 2x2, the filter     // is 1x1, the stride is 2, and the padding is (1, 0, 1, 0), the result is     // equivalent to as if the padding is (1, 1, 1, 1). Changing the padding in     // such a way would allow us to avoid the allocation.     Tensor transformed_input;     const int64_t padding_rows_diff = std::abs(padding_bottom - padding_top);     const int64_t padding_cols_diff = std::abs(padding_right - padding_left);     const int64_t new_in_rows = in_rows + padding_rows_diff;     const int64_t new_in_cols = in_cols + padding_cols_diff;     OP_REQUIRES_OK(ctx, ctx->allocate_temp(                             DataTypeToEnum<T>::value,                             ShapeFromFormat(data_format, in_batch, new_in_rows,                                             new_in_cols, in_depths),                             &transformed_input));      const int64_t input_pad_top = padding_top - common_padding_rows;     const int64_t input_pad_bottom = padding_bottom - common_padding_rows;     const int64_t input_pad_left = padding_left - common_padding_cols;     const int64_t input_pad_right = padding_right - common_padding_cols;     bool in_bounds =         FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&         FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&         FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&         FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());     if (!in_bounds) {       ctx->SetStatus(errors::InvalidArgument(""Padding is too large.""));       return;     }     functor::PadInput<GPUDevice, T, int, 4>()(         ctx->eigen_device<GPUDevice>(), To32Bit(input_param.tensor<T, 4>()),         {{static_cast<int>(input_pad_top), static_cast<int>(input_pad_left)}},         {{static_cast<int>(input_pad_bottom),           static_cast<int>(input_pad_right)}},         To32Bit(transformed_input.tensor<T, 4>()), data_format, T{});      input = transformed_input;     in_rows = new_in_rows;     in_cols = new_in_cols;   }    if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {     VLOG(4) << ""Convert the input tensor from NHWC to NCHW."";      TensorShape nchw_shape =         ShapeFromFormat(FORMAT_NCHW, in_batch, in_rows, in_cols, in_depths);     if (in_depths > 1) {       Tensor transformed_input;       OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,                                              nchw_shape, &transformed_input));       functor::NHWCToNCHW<GPUDevice, T, 4>()(           ctx->eigen_device<GPUDevice>(),           const_cast<const Tensor&>(input).tensor<T, 4>(),           transformed_input.tensor<T, 4>());       input = transformed_input;     } else {       // If depth <= 1, then just reshape.       CHECK(input.CopyFrom(input, nchw_shape));     }   } else {     CHECK(data_format == compute_data_format)  // Crash OK         << ""Illegal data and compute format pair:""         << "" data_format="" << ToString(data_format)         << "" compute_data_format="" << ToString(compute_data_format);   }    CHECK(common_padding_rows >= 0 && common_padding_cols >= 0)  // Crash OK       << ""Negative row or col paddings: ("" << common_padding_rows << "", ""       << common_padding_cols << "")"";    constexpr auto kComputeInNHWC =       std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,                       se::dnn::FilterLayout::kOutputYXInput);   constexpr auto kComputeInNCHW =       std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,                       se::dnn::FilterLayout::kOutputInputYX);    se::dnn::DataLayout compute_data_layout;   se::dnn::FilterLayout filter_layout;    std::tie(compute_data_layout, filter_layout) =       compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;    se::dnn::BatchDescriptor input_desc;   input_desc.set_count(in_batch)       .set_feature_map_count(in_depths)       .set_height(in_rows)       .set_width(in_cols)       .set_layout(compute_data_layout);   se::dnn::BatchDescriptor output_desc;   output_desc.set_count(out_batch)       .set_height(out_rows)       .set_width(out_cols)       .set_feature_map_count(out_depths)       .set_layout(compute_data_layout);   se::dnn::FilterDescriptor filter_desc;   filter_desc.set_input_filter_height(patch_rows)       .set_input_filter_width(patch_cols)       .set_input_feature_map_count(patch_depths)       .set_output_feature_map_count(filter.dim_size(3))       .set_layout(filter_layout);   se::dnn::ConvolutionDescriptor conv_desc;   conv_desc.set_vertical_dilation_rate(row_dilation)       .set_horizontal_dilation_rate(col_dilation)       .set_vertical_filter_stride(row_stride)       .set_horizontal_filter_stride(col_stride)       .set_zero_padding_height(common_padding_rows)       .set_zero_padding_width(common_padding_cols)       .set_group_count(in_depths / patch_depths);    Tensor transformed_filter;    const auto transform_filter = [&](FilterTensorFormat dst_format) -> Status {     VLOG(4) << ""Transform filter tensor from "" << ToString(FORMAT_HWIO)             << "" to "" << ToString(dst_format);      TensorShape dst_shape =         dst_format == FORMAT_OIHW             ? TensorShape({filter.dim_size(3), filter.dim_size(2),                            filter.dim_size(0), filter.dim_size(1)})             : TensorShape({filter.dim_size(3), filter.dim_size(0),                            filter.dim_size(1), filter.dim_size(2)});      TF_RETURN_IF_ERROR(ctx->allocate_temp(DataTypeToEnum<T>::value, dst_shape,                                           &transformed_filter));     functor::TransformFilter<GPUDevice, T, int, 4>()(         ctx->eigen_device<GPUDevice>(), dst_format,         To32Bit(filter.tensor<T, 4>()),         To32Bit(transformed_filter.tensor<T, 4>()));      return Status::OK();   };    if (compute_data_format == FORMAT_NCHW) {     OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OIHW));   } else if (compute_data_format == FORMAT_NHWC) {     OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OHWI));   } else {     ctx->SetStatus(errors::InvalidArgument(""Invalid compute data format: "",                                            ToString(compute_data_format)));     return;   }    Tensor transformed_output;   if (data_format != compute_data_format) {     VLOG(4) << ""Allocate temporary memory for output in compute data format"";     OP_REQUIRES_OK(         ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,                                 ShapeFromFormat(compute_data_format, out_batch,                                                 out_rows, out_cols, out_depths),                                 &transformed_output));   } else {     transformed_output = *output;   }    auto input_ptr = AsDeviceMemory(input.template flat<T>().data(),                                   input.template flat<T>().size());   auto filter_ptr =       AsDeviceMemory(transformed_filter.template flat<T>().data(),                      transformed_filter.template flat<T>().size());   auto output_ptr =       AsDeviceMemory(transformed_output.template flat<T>().data(),                      transformed_output.template flat<T>().size());    static int64_t ConvolveScratchSize = GetDnnWorkspaceLimit(       // default value is in bytes despite the name of the environment variable       ""TF_CUDNN_WORKSPACE_LIMIT_IN_MB"", 1LL << 32  // 4GB   );    int device_id = stream->parent()->device_ordinal();   DataType dtype = input.dtype();   ConvParameters conv_parameters = {in_batch,             // batch                                     in_depths,            // in_depths                                     {{in_rows,            // in_rows                                       in_cols}},          // in_cols                                     compute_data_format,  // compute_data_format                                     out_depths,           // out_depths                                     {{patch_rows,         // filter_rows                                       patch_cols,         // filter_cols                                       patch_depths}},     // filter_depths                                     {{row_dilation,       // dilation_rows                                       col_dilation}},     // dilation_cols                                     {{row_stride,         // stride_rows                                       col_stride}},       // stride_cols                                     {{common_padding_rows,    // padding_rows                                       common_padding_cols}},  // padding_cols                                     dtype,                    // tensor datatype                                     device_id,                // device_id                                     conv_desc.group_count()};    auto entry_or = AutotuneUnfusedConv(       cudnn_use_autotune, ConvAutotuneMap::GetInstance(), conv_parameters, ctx,       se::dnn::ConvolutionKind::FORWARD, input_desc, input_ptr, filter_desc,       filter_ptr, conv_desc, output_desc, output_ptr, ConvolveScratchSize);   OP_REQUIRES_OK(ctx, entry_or.status());   auto autotune_entry = entry_or.ConsumeValueOrDie();    DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);   Status cudnn_launch_status = LaunchAutotunedConv(       autotune_entry, &scratch_allocator, se::dnn::ConvolutionKind::FORWARD,       stream, input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,       output_desc, output_ptr);   if (!cudnn_launch_status.ok()) {     ctx->SetStatus(cudnn_launch_status);     return;   }    if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {     VLOG(4) << ""Convert the output tensor back from NCHW to NHWC."";     functor::NCHWToNHWC<GPUDevice, T, 4>()(         ctx->eigen_device<GPUDevice>(),         const_cast<const Tensor&>(transformed_output).tensor<T, 4>(),         output->tensor<T, 4>());   } }"
"220851_not_vulnerable.h","not_vulnerable","inline int32_t MultiplyByQuantizedMultiplierSmallerThanOneExp(     int32_t x, int32_t quantized_multiplier, int shift) {   TFLITE_DCHECK_LE(shift, 0);   return MultiplyByQuantizedMultiplier(x, quantized_multiplier, shift); }"
"220927_not_vulnerable.c","not_vulnerable","static GFINLINE void mpgviddmx_update_time(GF_MPGVidDmxCtx *ctx) { 	assert(ctx->cur_fps.num);  	if (ctx->timescale) { 		u64 inc = 3000; 		if (ctx->cur_fps.den && ctx->cur_fps.num) { 			inc = ctx->cur_fps.den; 			if (ctx->cur_fps.num != ctx->timescale) { 				inc *= ctx->timescale; 				inc /= ctx->cur_fps.num; 			} 		} 		ctx->cts += inc; 		ctx->dts += inc; 	} else { 		assert(ctx->cur_fps.den); 		ctx->cts += ctx->cur_fps.den; 		ctx->dts += ctx->cur_fps.den; 	} }"
"221159_not_vulnerable.c","not_vulnerable","GF_Err gf_odf_del_tx3g(GF_TextSampleDescriptor *sd) { 	u32 i; 	for (i=0; i<sd->font_count; i++) 		if (sd->fonts[i].fontName) gf_free(sd->fonts[i].fontName); 	gf_free(sd->fonts); 	gf_free(sd); 	return GF_OK; }"
"221394_not_vulnerable.c","not_vulnerable","static bool nested_vmcb_check_cr3_cr4(struct kvm_vcpu *vcpu, 				      struct vmcb_save_area *save) { 	/* 	 * These checks are also performed by KVM_SET_SREGS, 	 * except that EFER.LMA is not checked by SVM against 	 * CR0.PG && EFER.LME. 	 */ 	if ((save->efer & EFER_LME) && (save->cr0 & X86_CR0_PG)) { 		if (CC(!(save->cr4 & X86_CR4_PAE)) || 		    CC(!(save->cr0 & X86_CR0_PE)) || 		    CC(kvm_vcpu_is_illegal_gpa(vcpu, save->cr3))) 			return false; 	}  	if (CC(!kvm_is_valid_cr4(vcpu, save->cr4))) 		return false;  	return true; }"
"221514_not_vulnerable.c","not_vulnerable","flatpak_run_add_environment_args (FlatpakBwrap    *bwrap,                                   const char      *app_info_path,                                   FlatpakRunFlags  flags,                                   const char      *app_id,                                   FlatpakContext  *context,                                   GFile           *app_id_dir,                                   GPtrArray       *previous_app_id_dirs,                                   int              per_app_dir_lock_fd,                                   FlatpakExports **exports_out,                                   GCancellable    *cancellable,                                   GError         **error) {   g_autoptr(GError) my_error = NULL;   g_autoptr(FlatpakExports) exports = NULL;   g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);   g_autofree char *xdg_dirs_conf = NULL;   gboolean has_wayland = FALSE;   gboolean allow_x11 = FALSE;   gboolean home_access = FALSE;   gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;    if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)     {       g_debug (""Disallowing ipc access"");       flatpak_bwrap_add_args (bwrap, ""--unshare-ipc"", NULL);     }    if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)     {       g_debug (""Disallowing network access"");       flatpak_bwrap_add_args (bwrap, ""--unshare-net"", NULL);     }    if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)     {       flatpak_bwrap_add_args (bwrap,                               ""--dev-bind"", ""/dev"", ""/dev"",                               NULL);       /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */       if (g_file_test (""/dev/shm"", G_FILE_TEST_IS_DIR))         {           if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)             {               /* Don't do anything special: include shm in the                * shared /dev. The host and all sandboxes and subsandboxes                * all share /dev/shm */             }           else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)                    && per_app_dir_lock_fd >= 0)             {               g_autofree char *shared_dev_shm = NULL;                /* The host and the original sandbox have separate /dev/shm,                * but we want other instances to be able to share /dev/shm with                * the first sandbox (except for subsandboxes run with                * flatpak-spawn --sandbox, which will have their own). */               if (!flatpak_instance_ensure_per_app_dev_shm (app_id,                                                             per_app_dir_lock_fd,                                                             &shared_dev_shm,                                                             error))                 return FALSE;                flatpak_bwrap_add_args (bwrap,                                       ""--bind"", shared_dev_shm, ""/dev/shm"",                                       NULL);             }           else             {               /* The host, the original sandbox and each subsandbox                * each have a separate /dev/shm. */               flatpak_bwrap_add_args (bwrap,                                       ""--tmpfs"", ""/dev/shm"",                                       NULL);             }         }       else if (g_file_test (""/dev/shm"", G_FILE_TEST_IS_SYMLINK))         {           g_autofree char *link = flatpak_readlink (""/dev/shm"", NULL);            /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't              mount on top of it. */           if (g_strcmp0 (link, ""/run/shm"") == 0)             {               if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&                   g_file_test (""/run/shm"", G_FILE_TEST_IS_DIR))                 {                   flatpak_bwrap_add_args (bwrap,                                           ""--bind"", ""/run/shm"", ""/run/shm"",                                           NULL);                 }               else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)                        && per_app_dir_lock_fd >= 0)                 {                   g_autofree char *shared_dev_shm = NULL;                    /* The host and the original sandbox have separate /dev/shm,                    * but we want other instances to be able to share /dev/shm,                    * except for flatpak-spawn --subsandbox. */                   if (!flatpak_instance_ensure_per_app_dev_shm (app_id,                                                                 per_app_dir_lock_fd,                                                                 &shared_dev_shm,                                                                 error))                     return FALSE;                    flatpak_bwrap_add_args (bwrap,                                           ""--bind"", shared_dev_shm, ""/run/shm"",                                           NULL);                 }               else                 {                   flatpak_bwrap_add_args (bwrap,                                           ""--dir"", ""/run/shm"",                                           NULL);                 }             }           else             g_warning (""Unexpected /dev/shm symlink %s"", link);         }     }   else     {       flatpak_bwrap_add_args (bwrap,                               ""--dev"", ""/dev"",                               NULL);       if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)         {           g_debug (""Allowing dri access"");           int i;           char *dri_devices[] = {             ""/dev/dri"",             /* mali */             ""/dev/mali"",             ""/dev/mali0"",             ""/dev/umplock"",             /* nvidia */             ""/dev/nvidiactl"",             ""/dev/nvidia-modeset"",             /* nvidia OpenCL/CUDA */             ""/dev/nvidia-uvm"",             ""/dev/nvidia-uvm-tools"",           };            for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)             {               if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))                 flatpak_bwrap_add_args (bwrap, ""--dev-bind"", dri_devices[i], dri_devices[i], NULL);             }            /* Each Nvidia card gets its own device.              This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */           char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */           for (i = 0; i < 20; i++)             {               g_snprintf (nvidia_dev, sizeof (nvidia_dev), ""/dev/nvidia%d"", i);               if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))                 flatpak_bwrap_add_args (bwrap, ""--dev-bind"", nvidia_dev, nvidia_dev, NULL);             }         }        if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)         {           g_debug (""Allowing kvm access"");           if (g_file_test (""/dev/kvm"", G_FILE_TEST_EXISTS))             flatpak_bwrap_add_args (bwrap, ""--dev-bind"", ""/dev/kvm"", ""/dev/kvm"", NULL);         }        if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)         {           /* This is a symlink to /run/shm on debian, so bind to real target */           g_autofree char *real_dev_shm = realpath (""/dev/shm"", NULL);            g_debug (""Allowing /dev/shm access (as %s)"", real_dev_shm);           if (real_dev_shm != NULL)               flatpak_bwrap_add_args (bwrap, ""--bind"", real_dev_shm, ""/dev/shm"", NULL);         }       else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)                && per_app_dir_lock_fd >= 0)         {           g_autofree char *shared_dev_shm = NULL;            if (!flatpak_instance_ensure_per_app_dev_shm (app_id,                                                         per_app_dir_lock_fd,                                                         &shared_dev_shm,                                                         error))             return FALSE;            flatpak_bwrap_add_args (bwrap,                                   ""--bind"", shared_dev_shm, ""/dev/shm"",                                   NULL);         }     }    exports = flatpak_context_get_exports_full (context,                                               app_id_dir, previous_app_id_dirs,                                               TRUE, TRUE,                                               &xdg_dirs_conf, &home_access);    if (flatpak_exports_path_is_visible (exports, ""/tmp""))     {       /* The original sandbox and any subsandboxes are both already        * going to share /tmp with the host, so by transitivity they will        * also share it with each other, and with all other instances. */     }   else if (per_app_dir_lock_fd >= 0 && !sandboxed)     {       g_autofree char *shared_tmp = NULL;        /* The host and the original sandbox have separate /tmp,        * but we want other instances to be able to share /tmp with the        * first sandbox, unless they were created by        * flatpak-spawn --sandbox.        *        * In apply_extra and `flatpak build`, per_app_dir_lock_fd is        * negative and we skip this. */       if (!flatpak_instance_ensure_per_app_tmp (app_id,                                                 per_app_dir_lock_fd,                                                 &shared_tmp,                                                 error))         return FALSE;        flatpak_bwrap_add_args (bwrap,                               ""--bind"", shared_tmp, ""/tmp"",                               NULL);     }    flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir,                                            exports, xdg_dirs_conf, home_access);    if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)     {       g_debug (""Allowing wayland access"");       has_wayland = flatpak_run_add_wayland_args (bwrap);     }    if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)     allow_x11 = !has_wayland;   else     allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;    flatpak_run_add_x11_args (bwrap, allow_x11);    if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)     {       flatpak_run_add_ssh_args (bwrap);     }    if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)     {       g_debug (""Allowing pulseaudio access"");       flatpak_run_add_pulseaudio_args (bwrap);     }    if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)     {       flatpak_run_add_pcsc_args (bwrap);     }    if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)     {       flatpak_run_add_cups_args (bwrap);     }    flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);   flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);   flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);    /* Must run this before spawning the dbus proxy, to ensure it      ends up in the app cgroup */   if (!flatpak_run_in_transient_unit (app_id, &my_error))     {       /* We still run along even if we don't get a cgroup, as nothing          really depends on it. Its just nice to have */       g_debug (""Failed to run in transient scope: %s"", my_error->message);       g_clear_error (&my_error);     }    if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&       !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))     return FALSE;    if (exports_out)     *exports_out = g_steal_pointer (&exports);    return TRUE; }"
"221518_not_vulnerable.c","not_vulnerable","flatpak_run_add_x11_args (FlatpakBwrap *bwrap,                           gboolean      allowed) {   g_autofree char *x11_socket = NULL;   const char *display;    /* Always cover /tmp/.X11-unix, that way we never see the host one in case    * we have access to the host /tmp. If you request X access we'll put the right    * thing in this anyway.    *    * We need to be a bit careful here, because there are two situations in    * which potentially hostile processes have access to /tmp and could    * create symlinks, which in principle could cause us to create the    * directory and mount the tmpfs at the target of the symlink instead    * of in the intended place:    *    * - With --filesystem=/tmp, it's the host /tmp - but because of the    *   special historical status of /tmp/.X11-unix, we can assume that    *   it is pre-created by the host system before user code gets to run.    *    * - When /tmp is shared between all instances of the same app ID,    *   in principle the app has control over what's in /tmp, but in    *   practice it can't interfere with /tmp/.X11-unix, because we do    *   this unconditionally - therefore by the time app code runs,    *   /tmp/.X11-unix is already a mount point, meaning the app cannot    *   rename or delete it.    */   flatpak_bwrap_add_args (bwrap,                           ""--tmpfs"", ""/tmp/.X11-unix"",                           NULL);    if (!allowed)     {       flatpak_bwrap_unset_env (bwrap, ""DISPLAY"");       return;     }    g_debug (""Allowing x11 access"");    display = g_getenv (""DISPLAY"");   if (display && display[0] == ':' && g_ascii_isdigit (display[1]))     {       const char *display_nr = &display[1];       const char *display_nr_end = display_nr;       g_autofree char *d = NULL;        while (g_ascii_isdigit (*display_nr_end))         display_nr_end++;        d = g_strndup (display_nr, display_nr_end - display_nr);       x11_socket = g_strdup_printf (""/tmp/.X11-unix/X%s"", d);        flatpak_bwrap_add_args (bwrap,                               ""--ro-bind"", x11_socket, ""/tmp/.X11-unix/X99"",                               NULL);       flatpak_bwrap_set_env (bwrap, ""DISPLAY"", "":99.0"", TRUE);  #ifdef ENABLE_XAUTH       g_auto(GLnxTmpfile) xauth_tmpf  = { 0, };        if (glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, ""/tmp"", &xauth_tmpf, NULL))         {           FILE *output = fdopen (xauth_tmpf.fd, ""wb"");           if (output != NULL)             {               /* fd is now owned by output, steal it from the tmpfile */               int tmp_fd = dup (glnx_steal_fd (&xauth_tmpf.fd));               if (tmp_fd != -1)                 {                   static const char dest[] = ""/run/flatpak/Xauthority"";                    write_xauth (d, output);                   flatpak_bwrap_add_args_data_fd (bwrap, ""--ro-bind-data"", tmp_fd, dest);                    flatpak_bwrap_set_env (bwrap, ""XAUTHORITY"", dest, TRUE);                 }                fclose (output);                if (tmp_fd != -1)                 lseek (tmp_fd, 0, SEEK_SET);             }         } #endif     }   else     {       flatpak_bwrap_unset_env (bwrap, ""DISPLAY"");     } }"
"221671_not_vulnerable.cpp","not_vulnerable","int Socket::bind(int port) {     int len = sizeof my_adr;     int i = 1;      setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));      my_adr.sin_port = htons(port);     my_port = port;      return ::bind(sck, (struct sockaddr *) &my_adr, len); }"
"222504_not_vulnerable.cc","not_vulnerable","Status FunctionLibraryDefinition::AddFunctionDefHelper(     const FunctionDef& fdef, const StackTracesMap& stack_traces, bool* added) {   *added = false;   std::shared_ptr<FunctionDefAndOpRegistration>& entry =       function_defs_[fdef.signature().name()];   if (entry) {     if (!FunctionDefsEqual(entry->fdef, fdef)) {       return errors::InvalidArgument(           ""Cannot add function '"", fdef.signature().name(),           ""' because a different function with the same name already ""           ""exists."");     }     // Ignore duplicate FunctionDefs.     return Status::OK();   }   const OpDef* op_def;   if (default_registry_->LookUpOpDef(fdef.signature().name(), &op_def).ok()) {     return errors::InvalidArgument(         ""Cannot add function '"", fdef.signature().name(),         ""' because an op with the same name already exists."");   }   entry = std::make_shared<FunctionDefAndOpRegistration>(fdef, stack_traces);   *added = true;   return Status::OK(); }"
"222525_not_vulnerable.cc","not_vulnerable","Status FunctionLibraryDefinition::Remove(     const std::vector<string>& funcs,     const std::vector<string>& funcs_with_grads) {   Status s;   for (const string& f : funcs) {     s = RemoveFunctionHelper(f);     if (!s.ok()) {       return s;     }   }   for (const string& f : funcs_with_grads) {     s = RemoveGradient(f);     if (!s.ok()) {       return s;     }   }   return Status::OK(); }"
"222596_not_vulnerable.c","not_vulnerable","gen_values(codegen_scope *s, node *t, int val, int limit) {   int n = 0;   int first = 1;   int slimit = GEN_VAL_STACK_MAX;    if (limit == 0) limit = GEN_LIT_ARY_MAX;   if (cursp() >= slimit) slimit = INT16_MAX;    if (!val) {     while (t) {       codegen(s, t->car, NOVAL);       n++;       t = t->cdr;     }     return n;   }    while (t) {     int is_splat = nint(t->car->car) == NODE_SPLAT;      if (is_splat || n >= limit-1 || cursp() >= slimit) { /* flush stack */       pop_n(n);       if (first) {         if (n == 0) {           genop_1(s, OP_LOADNIL, cursp());         }         else {           genop_2(s, OP_ARRAY, cursp(), n);         }         push();         first = 0;         limit = GEN_LIT_ARY_MAX;       }       else if (n > 0) {         pop();         genop_2(s, OP_ARYPUSH, cursp(), n);         push();       }       n = 0;     }     codegen(s, t->car, val);     if (is_splat) {       pop(); pop();       genop_1(s, OP_ARYCAT, cursp());       push();     }     else {       n++;     }     t = t->cdr;   }   if (!first) {     pop();     if (n > 0) {       pop_n(n);       genop_2(s, OP_ARYPUSH, cursp(), n);     }     return -1;                  /* variable length */   }   return n; }"
"222896_not_vulnerable.cc","not_vulnerable","Status GraphProperties::InferFromCostGraph(const CostGraphDef& cost_graph) {   if (cost_graph.node_size() == 0) {     LOG(WARNING) << ""cost_graph is empty: nothing can be inferred!"";   }   std::unordered_map<string, const CostGraphDef::Node*> name_to_cost;   std::unordered_map<string, const NodeDef*> name_to_node;  // Empty   for (auto& node : cost_graph.node()) {     name_to_cost[node.name()] = &node;      std::vector<OpInfo::TensorProperties> output_properties;     for (const auto& out : node.output_info()) {       OpInfo::TensorProperties properties;       properties.set_dtype(out.dtype());       *properties.mutable_shape() = out.shape();       output_properties.push_back(properties);     }     output_properties_[node.name()] = output_properties;   }    for (const auto& node : item_.graph.node()) {     // Skip the nodes that are not in the cost graph: these are nodes that     // aren't run, because they aren't in the intersection of transitive fan-in     // of a fetch node and the transitive fan-out of an input, or nodes that     // were optimized away by the optimizer.     auto it = name_to_cost.find(node.name());     if (it == name_to_cost.end()) {       continue;     }     std::vector<OpInfo::TensorProperties> inputs =         FindInputFeatures(node, name_to_cost, name_to_node);      input_properties_[node.name()] = inputs;   }   return Status::OK(); }"
"223090_not_vulnerable.c","not_vulnerable","static size_t PCLPackbitsCompressImage(const size_t length,   const unsigned char *pixels,unsigned char *compress_pixels) {   int     count;    ssize_t     x;    unsigned char     *q;    ssize_t     j;    unsigned char     packbits[128];    /*     Compress pixels with Packbits encoding.   */   q=compress_pixels;   for (x=(ssize_t) length; x != 0; )   {     switch (x)     {       case 1:       {         x--;         *q++=0;         *q++=(*pixels);         break;       }       case 2:       {         x-=2;         *q++=1;         *q++=(*pixels);         *q++=pixels[1];         break;       }       case 3:       {         x-=3;         if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))           {             *q++=(unsigned char) ((256-3)+1);             *q++=(*pixels);             break;           }         *q++=2;         *q++=(*pixels);         *q++=pixels[1];         *q++=pixels[2];         break;       }       default:       {         if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))           {             /*               Packed run.             */             count=3;             while (((ssize_t) count < x) && (*pixels == *(pixels+count)))             {               count++;               if (count >= 127)                 break;             }             x-=count;             *q++=(unsigned char) ((256-count)+1);             *q++=(*pixels);             pixels+=count;             break;           }         /*           Literal run.         */         count=0;         while ((*(pixels+count) != *(pixels+count+1)) ||                (*(pixels+count+1) != *(pixels+count+2)))         {           packbits[count+1]=pixels[count];           count++;           if (((ssize_t) count >= (x-3)) || (count >= 127))             break;         }         x-=count;         *packbits=(unsigned char) (count-1);         for (j=0; j <= (ssize_t) count; j++)           *q++=packbits[j];         pixels+=count;         break;       }     }   }   *q++=128; /* EOD marker */   return((size_t) (q-compress_pixels)); }"
"223385_not_vulnerable.c","not_vulnerable","static void check_anynewline(compiler_common *common) { /* Check whether TMP1 contains a newline character. TMP2 destroyed. */ DEFINE_COMPILER;  sljit_emit_fast_enter(compiler, RETURN_ADDR, 0);  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a); OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a); OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL); OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a); #if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32 #if PCRE2_CODE_UNIT_WIDTH == 8 if (common->utf)   { #endif   OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);   OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);   OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a); #if PCRE2_CODE_UNIT_WIDTH == 8   } #endif #endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */ OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL); OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0); }"
"223404_not_vulnerable.c","not_vulnerable","static int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head) { int length = 0; int possessive = 0; BOOL stack_restore = FALSE; BOOL setsom_found = recursive; BOOL setmark_found = recursive; /* The last capture is a local variable even for recursions. */ BOOL capture_last_found = FALSE;  #if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD SLJIT_ASSERT(common->control_head_ptr != 0); *needs_control_head = TRUE; #else *needs_control_head = FALSE; #endif  if (ccend == NULL)   {   ccend = bracketend(cc) - (1 + LINK_SIZE);   if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))     {     possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;     /* This is correct regardless of common->capture_last_ptr. */     capture_last_found = TRUE;     }   cc = next_opcode(common, cc);   }  SLJIT_ASSERT(cc != NULL); while (cc < ccend)   switch(*cc)     {     case OP_SET_SOM:     SLJIT_ASSERT(common->has_set_som);     stack_restore = TRUE;     if (!setsom_found)       {       length += 2;       setsom_found = TRUE;       }     cc += 1;     break;      case OP_MARK:     case OP_COMMIT_ARG:     case OP_PRUNE_ARG:     case OP_THEN_ARG:     SLJIT_ASSERT(common->mark_ptr != 0);     stack_restore = TRUE;     if (!setmark_found)       {       length += 2;       setmark_found = TRUE;       }     if (common->control_head_ptr != 0)       *needs_control_head = TRUE;     cc += 1 + 2 + cc[1];     break;      case OP_RECURSE:     stack_restore = TRUE;     if (common->has_set_som && !setsom_found)       {       length += 2;       setsom_found = TRUE;       }     if (common->mark_ptr != 0 && !setmark_found)       {       length += 2;       setmark_found = TRUE;       }     if (common->capture_last_ptr != 0 && !capture_last_found)       {       length += 2;       capture_last_found = TRUE;       }     cc += 1 + LINK_SIZE;     break;      case OP_CBRA:     case OP_CBRAPOS:     case OP_SCBRA:     case OP_SCBRAPOS:     stack_restore = TRUE;     if (common->capture_last_ptr != 0 && !capture_last_found)       {       length += 2;       capture_last_found = TRUE;       }     length += 3;     cc += 1 + LINK_SIZE + IMM2_SIZE;     break;      case OP_THEN:     stack_restore = TRUE;     if (common->control_head_ptr != 0)       *needs_control_head = TRUE;     cc ++;     break;      default:     stack_restore = TRUE;     /* Fall through. */      case OP_NOT_WORD_BOUNDARY:     case OP_WORD_BOUNDARY:     case OP_NOT_DIGIT:     case OP_DIGIT:     case OP_NOT_WHITESPACE:     case OP_WHITESPACE:     case OP_NOT_WORDCHAR:     case OP_WORDCHAR:     case OP_ANY:     case OP_ALLANY:     case OP_ANYBYTE:     case OP_NOTPROP:     case OP_PROP:     case OP_ANYNL:     case OP_NOT_HSPACE:     case OP_HSPACE:     case OP_NOT_VSPACE:     case OP_VSPACE:     case OP_EXTUNI:     case OP_EODN:     case OP_EOD:     case OP_CIRC:     case OP_CIRCM:     case OP_DOLL:     case OP_DOLLM:     case OP_CHAR:     case OP_CHARI:     case OP_NOT:     case OP_NOTI:      case OP_EXACT:     case OP_POSSTAR:     case OP_POSPLUS:     case OP_POSQUERY:     case OP_POSUPTO:      case OP_EXACTI:     case OP_POSSTARI:     case OP_POSPLUSI:     case OP_POSQUERYI:     case OP_POSUPTOI:      case OP_NOTEXACT:     case OP_NOTPOSSTAR:     case OP_NOTPOSPLUS:     case OP_NOTPOSQUERY:     case OP_NOTPOSUPTO:      case OP_NOTEXACTI:     case OP_NOTPOSSTARI:     case OP_NOTPOSPLUSI:     case OP_NOTPOSQUERYI:     case OP_NOTPOSUPTOI:      case OP_TYPEEXACT:     case OP_TYPEPOSSTAR:     case OP_TYPEPOSPLUS:     case OP_TYPEPOSQUERY:     case OP_TYPEPOSUPTO:      case OP_CLASS:     case OP_NCLASS:     case OP_XCLASS:      case OP_CALLOUT:     case OP_CALLOUT_STR:      cc = next_opcode(common, cc);     SLJIT_ASSERT(cc != NULL);     break;     }  /* Possessive quantifiers can use a special case. */ if (SLJIT_UNLIKELY(possessive == length))   return stack_restore ? no_frame : no_stack;  if (length > 0)   return length + 1; return stack_restore ? no_frame : no_stack; }"
"223407_not_vulnerable.c","not_vulnerable","static PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc) { PCRE2_SPTR start_subject = args->begin; PCRE2_SPTR end_subject = args->end; int lgb, rgb, ricount; PCRE2_SPTR prevcc, endcc, bptr; BOOL first = TRUE; uint32_t c;  prevcc = cc; endcc = NULL; do   {   GETCHARINC(c, cc);   rgb = UCD_GRAPHBREAK(c);    if (first)     {     lgb = rgb;     endcc = cc;     first = FALSE;     continue;     }    if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)     break;    /* Not breaking between Regional Indicators is allowed only if there   are an even number of preceding RIs. */    if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)     {     ricount = 0;     bptr = prevcc;      /* bptr is pointing to the left-hand character */     while (bptr > start_subject)       {       bptr--;       BACKCHAR(bptr);       GETCHAR(c, bptr);        if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)         break;        ricount++;       }      if ((ricount & 1) != 0) break;  /* Grapheme break required */     }    /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this   allows any number of them before a following Extended_Pictographic. */    if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||        lgb != ucp_gbExtended_Pictographic)     lgb = rgb;    prevcc = endcc;   endcc = cc;   } while (cc < end_subject);  return endcc; }"
"223421_not_vulnerable.c","not_vulnerable","static void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch) { /* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */ DEFINE_COMPILER; struct sljit_jump *jump;  if (nltype == NLTYPE_ANY)   {   add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));   sljit_set_current_flags(compiler, SLJIT_SET_Z);   add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));   } else if (nltype == NLTYPE_ANYCRLF)   {   if (jumpifmatch)     {     add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));     add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));     }   else     {     jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);     add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));     JUMPHERE(jump);     }   } else   {   SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);   add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));   } }"
"223466_not_vulnerable.c","not_vulnerable","static SLJIT_INLINE void fast_forward_first_char(compiler_common *common) { PCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit); PCRE2_UCHAR oc;  oc = first_char; if ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)   {   oc = TABLE_GET(first_char, common->fcc, first_char); #if defined SUPPORT_UNICODE   if (first_char > 127 && (common->utf || common->ucp))     oc = UCD_OTHERCASE(first_char); #endif   }  fast_forward_first_char2(common, first_char, oc, 0); }"
"224155_not_vulnerable.cpp","not_vulnerable","codegen(codegen_scope *s, node *tree, int val) {   int nt;   int rlev = s->rlev;    if (!tree) {     if (val) {       genop_1(s, OP_LOADNIL, cursp());       push();     }     return;   }    s->rlev++;   if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {     codegen_error(s, ""too complex expression"");   }   if (s->irep && s->filename_index != tree->filename_index) {     mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);     const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);      mrb_debug_info_append_file(s->mrb, s->irep->debug_info,                                filename, s->lines, s->debug_start_pos, s->pc);     s->debug_start_pos = s->pc;     s->filename_index = tree->filename_index;     s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);   }    nt = nint(tree->car);   s->lineno = tree->lineno;   tree = tree->cdr;   switch (nt) {   case NODE_BEGIN:     if (val && !tree) {       genop_1(s, OP_LOADNIL, cursp());       push();     }     while (tree) {       codegen(s, tree->car, tree->cdr ? NOVAL : val);       tree = tree->cdr;     }     break;    case NODE_RESCUE:     {       int noexc;       uint32_t exend, pos1, pos2, tmp;       struct loopinfo *lp;       int catch_entry, begin, end;        if (tree->car == NULL) goto exit;       lp = loop_push(s, LOOP_BEGIN);       lp->pc0 = new_label(s);       catch_entry = catch_handler_new(s);       begin = s->pc;       codegen(s, tree->car, VAL);       pop();       lp->type = LOOP_RESCUE;       end = s->pc;       noexc = genjmp_0(s, OP_JMP);       catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);       tree = tree->cdr;       exend = JMPLINK_START;       pos1 = JMPLINK_START;       if (tree->car) {         node *n2 = tree->car;         int exc = cursp();          genop_1(s, OP_EXCEPT, exc);         push();         while (n2) {           node *n3 = n2->car;           node *n4 = n3->car;            dispatch(s, pos1);           pos2 = JMPLINK_START;           do {             if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {               codegen(s, n4->car, VAL);               gen_move(s, cursp(), exc, 0);               push_n(2); pop_n(2); /* space for one arg and a block */               pop();               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);             }             else {               if (n4) {                 codegen(s, n4->car, VAL);               }               else {                 genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));                 push();               }               pop();               genop_2(s, OP_RESCUE, exc, cursp());             }             tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);             pos2 = tmp;             if (n4) {               n4 = n4->cdr;             }           } while (n4);           pos1 = genjmp_0(s, OP_JMP);           dispatch_linked(s, pos2);            pop();           if (n3->cdr->car) {             gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);           }           if (n3->cdr->cdr->car) {             codegen(s, n3->cdr->cdr->car, val);             if (val) pop();           }           tmp = genjmp(s, OP_JMP, exend);           exend = tmp;           n2 = n2->cdr;           push();         }         if (pos1 != JMPLINK_START) {           dispatch(s, pos1);           genop_1(s, OP_RAISEIF, exc);         }       }       pop();       tree = tree->cdr;       dispatch(s, noexc);       if (tree->car) {         codegen(s, tree->car, val);       }       else if (val) {         push();       }       dispatch_linked(s, exend);       loop_pop(s, NOVAL);     }     break;    case NODE_ENSURE:     if (!tree->cdr || !tree->cdr->cdr ||         (nint(tree->cdr->cdr->car) == NODE_BEGIN &&          tree->cdr->cdr->cdr)) {       int catch_entry, begin, end, target;       int idx;        catch_entry = catch_handler_new(s);       begin = s->pc;       codegen(s, tree->car, val);       end = target = s->pc;       push();       idx = cursp();       genop_1(s, OP_EXCEPT, idx);       push();       codegen(s, tree->cdr->cdr, NOVAL);       pop();       genop_1(s, OP_RAISEIF, idx);       pop();       catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);     }     else {                      /* empty ensure ignored */       codegen(s, tree->car, val);     }     break;    case NODE_LAMBDA:     if (val) {       int idx = lambda_body(s, tree, 1);        genop_2(s, OP_LAMBDA, cursp(), idx);       push();     }     break;    case NODE_BLOCK:     if (val) {       int idx = lambda_body(s, tree, 1);        genop_2(s, OP_BLOCK, cursp(), idx);       push();     }     break;    case NODE_IF:     {       uint32_t pos1, pos2;       mrb_bool nil_p = FALSE;       node *elsepart = tree->cdr->cdr->car;        if (!tree->car) {         codegen(s, elsepart, val);         goto exit;       }       if (true_always(tree->car)) {         codegen(s, tree->cdr->car, val);         goto exit;       }       if (false_always(tree->car)) {         codegen(s, elsepart, val);         goto exit;       }       if (nint(tree->car->car) == NODE_CALL) {         node *n = tree->car->cdr;         mrb_sym mid = nsym(n->cdr->car);         mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);         if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {           nil_p = TRUE;           codegen(s, n->car, VAL);         }       }       if (!nil_p) {         codegen(s, tree->car, VAL);       }       pop();       if (val || tree->cdr->car) {         if (nil_p) {           pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);           pos1 = genjmp_0(s, OP_JMP);           dispatch(s, pos2);         }         else {           pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);         }         codegen(s, tree->cdr->car, val);         if (val) pop();         if (elsepart || val) {           pos2 = genjmp_0(s, OP_JMP);           dispatch(s, pos1);           codegen(s, elsepart, val);           dispatch(s, pos2);         }         else {           dispatch(s, pos1);         }       }       else {                    /* empty then-part */         if (elsepart) {           if (nil_p) {             pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);           }           else {             pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);           }           codegen(s, elsepart, val);           dispatch(s, pos1);         }         else if (val && !nil_p) {           genop_1(s, OP_LOADNIL, cursp());           push();         }       }     }     break;    case NODE_AND:     {       uint32_t pos;        if (true_always(tree->car)) {         codegen(s, tree->cdr, val);         goto exit;       }       if (false_always(tree->car)) {         codegen(s, tree->car, val);         goto exit;       }       codegen(s, tree->car, VAL);       pop();       pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);       codegen(s, tree->cdr, val);       dispatch(s, pos);     }     break;    case NODE_OR:     {       uint32_t pos;        if (true_always(tree->car)) {         codegen(s, tree->car, val);         goto exit;       }       if (false_always(tree->car)) {         codegen(s, tree->cdr, val);         goto exit;       }       codegen(s, tree->car, VAL);       pop();       pos = genjmp2_0(s, OP_JMPIF, cursp(), val);       codegen(s, tree->cdr, val);       dispatch(s, pos);     }     break;    case NODE_WHILE:   case NODE_UNTIL:     {       if (true_always(tree->car)) {         if (nt == NODE_UNTIL) {           if (val) {             genop_1(s, OP_LOADNIL, cursp());             push();           }           goto exit;         }       }       else if (false_always(tree->car)) {         if (nt == NODE_WHILE) {           if (val) {             genop_1(s, OP_LOADNIL, cursp());             push();           }           goto exit;         }       }        uint32_t pos = JMPLINK_START;       struct loopinfo *lp = loop_push(s, LOOP_NORMAL);        if (!val) lp->reg = -1;       lp->pc0 = new_label(s);       codegen(s, tree->car, VAL);       pop();       if (nt == NODE_WHILE) {         pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);       }       else {         pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);       }       lp->pc1 = new_label(s);       codegen(s, tree->cdr, NOVAL);       genjmp(s, OP_JMP, lp->pc0);       dispatch(s, pos);       loop_pop(s, val);     }     break;    case NODE_FOR:     for_body(s, tree);     if (val) push();     break;    case NODE_CASE:     {       int head = 0;       uint32_t pos1, pos2, pos3, tmp;       node *n;        pos3 = JMPLINK_START;       if (tree->car) {         head = cursp();         codegen(s, tree->car, VAL);       }       tree = tree->cdr;       while (tree) {         n = tree->car->car;         pos1 = pos2 = JMPLINK_START;         while (n) {           codegen(s, n->car, VAL);           if (head) {             gen_move(s, cursp(), head, 0);             push(); push(); pop(); pop(); pop();             if (nint(n->car->car) == NODE_SPLAT) {               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);             }             else {               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);             }           }           else {             pop();           }           tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);           pos2 = tmp;           n = n->cdr;         }         if (tree->car->car) {           pos1 = genjmp_0(s, OP_JMP);           dispatch_linked(s, pos2);         }         codegen(s, tree->car->cdr, val);         if (val) pop();         tmp = genjmp(s, OP_JMP, pos3);         pos3 = tmp;         dispatch(s, pos1);         tree = tree->cdr;       }       if (val) {         uint32_t pos = cursp();         genop_1(s, OP_LOADNIL, cursp());         if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);         if (head) pop();         if (cursp() != pos) {           gen_move(s, cursp(), pos, 0);         }         push();       }       else {         if (pos3 != JMPLINK_START) {           dispatch_linked(s, pos3);         }         if (head) {           pop();         }       }     }     break;    case NODE_SCOPE:     scope_body(s, tree, NOVAL);     break;    case NODE_FCALL:   case NODE_CALL:     gen_call(s, tree, val, 0);     break;   case NODE_SCALL:     gen_call(s, tree, val, 1);     break;    case NODE_DOT2:     codegen(s, tree->car, val);     codegen(s, tree->cdr, val);     if (val) {       pop(); pop();       genop_1(s, OP_RANGE_INC, cursp());       push();     }     break;    case NODE_DOT3:     codegen(s, tree->car, val);     codegen(s, tree->cdr, val);     if (val) {       pop(); pop();       genop_1(s, OP_RANGE_EXC, cursp());       push();     }     break;    case NODE_COLON2:     {       int sym = new_sym(s, nsym(tree->cdr));        codegen(s, tree->car, VAL);       pop();       genop_2(s, OP_GETMCNST, cursp(), sym);       if (val) push();     }     break;    case NODE_COLON3:     {       int sym = new_sym(s, nsym(tree));        genop_1(s, OP_OCLASS, cursp());       genop_2(s, OP_GETMCNST, cursp(), sym);       if (val) push();     }     break;    case NODE_ARRAY:     {       int n;        n = gen_values(s, tree, val, 0);       if (val) {         if (n >= 0) {           pop_n(n);           genop_2(s, OP_ARRAY, cursp(), n);         }         push();       }     }     break;    case NODE_HASH:   case NODE_KW_HASH:     {       int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);       if (val && nk >= 0) {         pop_n(nk*2);         genop_2(s, OP_HASH, cursp(), nk);         push();       }     }     break;    case NODE_SPLAT:     codegen(s, tree, val);     break;    case NODE_ASGN:     gen_assignment(s, tree->car, tree->cdr, 0, val);     break;    case NODE_MASGN:     {       int len = 0, n = 0, post = 0;       node *t = tree->cdr, *p;       int rhs = cursp();        if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {         /* fixed rhs */         t = t->cdr;         while (t) {           codegen(s, t->car, VAL);           len++;           t = t->cdr;         }         tree = tree->car;         if (tree->car) {                /* pre */           t = tree->car;           n = 0;           while (t) {             if (n < len) {               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);               n++;             }             else {               genop_1(s, OP_LOADNIL, rhs+n);               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);             }             t = t->cdr;           }         }         t = tree->cdr;         if (t) {           if (t->cdr) {         /* post count */             p = t->cdr->car;             while (p) {               post++;               p = p->cdr;             }           }           if (t->car) {         /* rest (len - pre - post) */             int rn;              if (len < post + n) {               rn = 0;             }             else {               rn = len - post - n;             }             genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);             gen_assignment(s, t->car, NULL, cursp(), NOVAL);             n += rn;           }           if (t->cdr && t->cdr->car) {             t = t->cdr->car;             while (n<len) {               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);               t = t->cdr;               n++;             }           }         }         pop_n(len);         if (val) {           genop_2(s, OP_ARRAY, rhs, len);           push();         }       }       else {         /* variable rhs */         codegen(s, t, VAL);         gen_vmassignment(s, tree->car, rhs, val);         if (!val) {           pop();         }       }     }     break;    case NODE_OP_ASGN:     {       mrb_sym sym = nsym(tree->cdr->car);       mrb_int len;       const char *name = mrb_sym_name_len(s->mrb, sym, &len);       int idx, callargs = -1, vsp = -1;        if ((len == 2 && name[0] == '|' && name[1] == '|') &&           (nint(tree->car->car) == NODE_CONST ||            nint(tree->car->car) == NODE_CVAR)) {         int catch_entry, begin, end;         int noexc, exc;         struct loopinfo *lp;          lp = loop_push(s, LOOP_BEGIN);         lp->pc0 = new_label(s);         catch_entry = catch_handler_new(s);         begin = s->pc;         exc = cursp();         codegen(s, tree->car, VAL);         end = s->pc;         noexc = genjmp_0(s, OP_JMP);         lp->type = LOOP_RESCUE;         catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);         genop_1(s, OP_EXCEPT, exc);         genop_1(s, OP_LOADF, exc);         dispatch(s, noexc);         loop_pop(s, NOVAL);       }       else if (nint(tree->car->car) == NODE_CALL) {         node *n = tree->car->cdr;         int base, i, nargs = 0;         callargs = 0;          if (val) {           vsp = cursp();           push();         }         codegen(s, n->car, VAL);   /* receiver */         idx = new_sym(s, nsym(n->cdr->car));         base = cursp()-1;         if (n->cdr->cdr->car) {           nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);           if (nargs >= 0) {             callargs = nargs;           }           else { /* varargs */             push();             nargs = 1;             callargs = CALL_MAXARGS;           }         }         /* copy receiver and arguments */         gen_move(s, cursp(), base, 1);         for (i=0; i<nargs; i++) {           gen_move(s, cursp()+i+1, base+i+1, 1);         }         push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */         genop_3(s, OP_SEND, cursp(), idx, callargs);         push();       }       else {         codegen(s, tree->car, VAL);       }       if (len == 2 &&           ((name[0] == '|' && name[1] == '|') ||            (name[0] == '&' && name[1] == '&'))) {         uint32_t pos;          pop();         if (val) {           if (vsp >= 0) {             gen_move(s, vsp, cursp(), 1);           }           pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);         }         else {           pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);         }         codegen(s, tree->cdr->cdr->car, VAL);         pop();         if (val && vsp >= 0) {           gen_move(s, vsp, cursp(), 1);         }         if (nint(tree->car->car) == NODE_CALL) {           if (callargs == CALL_MAXARGS) {             pop();             genop_2(s, OP_ARYPUSH, cursp(), 1);           }           else {             pop_n(callargs);             callargs++;           }           pop();           idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));           genop_3(s, OP_SEND, cursp(), idx, callargs);         }         else {           gen_assignment(s, tree->car, NULL, cursp(), val);         }         dispatch(s, pos);         goto exit;       }       codegen(s, tree->cdr->cdr->car, VAL);       push(); pop();       pop(); pop();        if (len == 1 && name[0] == '+')  {         gen_addsub(s, OP_ADD, cursp());       }       else if (len == 1 && name[0] == '-')  {         gen_addsub(s, OP_SUB, cursp());       }       else if (len == 1 && name[0] == '*')  {         genop_1(s, OP_MUL, cursp());       }       else if (len == 1 && name[0] == '/')  {         genop_1(s, OP_DIV, cursp());       }       else if (len == 1 && name[0] == '<')  {         genop_1(s, OP_LT, cursp());       }       else if (len == 2 && name[0] == '<' && name[1] == '=')  {         genop_1(s, OP_LE, cursp());       }       else if (len == 1 && name[0] == '>')  {         genop_1(s, OP_GT, cursp());       }       else if (len == 2 && name[0] == '>' && name[1] == '=')  {         genop_1(s, OP_GE, cursp());       }       else {         idx = new_sym(s, sym);         genop_3(s, OP_SEND, cursp(), idx, 1);       }       if (callargs < 0) {         gen_assignment(s, tree->car, NULL, cursp(), val);       }       else {         if (val && vsp >= 0) {           gen_move(s, vsp, cursp(), 0);         }         if (callargs == CALL_MAXARGS) {           pop();           genop_2(s, OP_ARYPUSH, cursp(), 1);         }         else {           pop_n(callargs);           callargs++;         }         pop();         idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));         genop_3(s, OP_SEND, cursp(), idx, callargs);       }     }     break;    case NODE_SUPER:     {       codegen_scope *s2 = s;       int lv = 0;       int n = 0, nk = 0, st = 0;        push();       while (!s2->mscope) {         lv++;         s2 = s2->prev;         if (!s2) break;       }       if (tree) {         node *args = tree->car;         if (args) {           st = n = gen_values(s, args, VAL, 14);           if (n < 0) {             st = 1; n = 15;             push();           }         }         /* keyword arguments */         if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {           nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);           if (nk < 0) {st++; nk = 15;}           else st += nk*2;           n |= nk<<4;         }         /* block arguments */         if (tree->cdr->cdr) {           codegen(s, tree->cdr->cdr, VAL);         }         else if (!s2) {/* super at top-level */           push();      /* no need to push block */         }         else {           gen_blkmove(s, s2->ainfo, lv);         }         st++;       }       else {         if (!s2) push();         else gen_blkmove(s, s2->ainfo, lv);         st++;       }       pop_n(st+1);       genop_2(s, OP_SUPER, cursp(), n);       if (val) push();     }     break;    case NODE_ZSUPER:     {       codegen_scope *s2 = s;       int lv = 0;       size_t ainfo = 0;       int n = CALL_MAXARGS;       int sp = cursp();        push();        /* room for receiver */       while (!s2->mscope) {         lv++;         s2 = s2->prev;         if (!s2) break;       }       if (s2 && s2->ainfo > 0) {         ainfo = s2->ainfo;       }       if (ainfo > 0) {         genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));         push(); push(); push();   /* ARGARY pushes 3 values at most */         pop(); pop(); pop();         /* keyword arguments */         if (ainfo & 0x1) {           n |= CALL_MAXARGS<<4;           push();         }         /* block argument */         if (tree && tree->cdr && tree->cdr->cdr) {           push();           codegen(s, tree->cdr->cdr, VAL);         }       }       else {         /* block argument */         if (tree && tree->cdr && tree->cdr->cdr) {           codegen(s, tree->cdr->cdr, VAL);         }         else {           gen_blkmove(s, 0, lv);         }         n = 0;       }       s->sp = sp;       genop_2(s, OP_SUPER, cursp(), n);       if (val) push();     }     break;    case NODE_RETURN:     if (tree) {       gen_retval(s, tree);     }     else {       genop_1(s, OP_LOADNIL, cursp());     }     if (s->loop) {       gen_return(s, OP_RETURN_BLK, cursp());     }     else {       gen_return(s, OP_RETURN, cursp());     }     if (val) push();     break;    case NODE_YIELD:     {       codegen_scope *s2 = s;       int lv = 0, ainfo = -1;       int n = 0, sendv = 0;        while (!s2->mscope) {         lv++;         s2 = s2->prev;         if (!s2) break;       }       if (s2) {         ainfo = (int)s2->ainfo;       }       if (ainfo < 0) codegen_error(s, ""invalid yield (SyntaxError)"");       push();       if (tree) {         n = gen_values(s, tree, VAL, 14);         if (n < 0) {           n = sendv = 1;           push();         }       }       push();pop(); /* space for a block */       pop_n(n+1);       genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));       if (sendv) n = CALL_MAXARGS;       genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);       if (val) push();     }     break;    case NODE_BREAK:     loop_break(s, tree);     if (val) push();     break;    case NODE_NEXT:     if (!s->loop) {       raise_error(s, ""unexpected next"");     }     else if (s->loop->type == LOOP_NORMAL) {       codegen(s, tree, NOVAL);       genjmp(s, OP_JMPUW, s->loop->pc0);     }     else {       if (tree) {         codegen(s, tree, VAL);         pop();       }       else {         genop_1(s, OP_LOADNIL, cursp());       }       gen_return(s, OP_RETURN, cursp());     }     if (val) push();     break;    case NODE_REDO:     if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {       raise_error(s, ""unexpected redo"");     }     else {       genjmp(s, OP_JMPUW, s->loop->pc1);     }     if (val) push();     break;    case NODE_RETRY:     {       const char *msg = ""unexpected retry"";       const struct loopinfo *lp = s->loop;        while (lp && lp->type != LOOP_RESCUE) {         lp = lp->prev;       }       if (!lp) {         raise_error(s, msg);       }       else {         genjmp(s, OP_JMPUW, lp->pc0);       }       if (val) push();     }     break;    case NODE_LVAR:     if (val) {       int idx = lv_idx(s, nsym(tree));        if (idx > 0) {         gen_move(s, cursp(), idx, val);       }       else {         gen_getupvar(s, cursp(), nsym(tree));       }       push();     }     break;    case NODE_NVAR:     if (val) {       int idx = nint(tree);        gen_move(s, cursp(), idx, val);        push();     }     break;    case NODE_GVAR:     {       int sym = new_sym(s, nsym(tree));        genop_2(s, OP_GETGV, cursp(), sym);       if (val) push();     }     break;    case NODE_IVAR:     {       int sym = new_sym(s, nsym(tree));        genop_2(s, OP_GETIV, cursp(), sym);       if (val) push();     }     break;    case NODE_CVAR:     {       int sym = new_sym(s, nsym(tree));        genop_2(s, OP_GETCV, cursp(), sym);       if (val) push();     }     break;    case NODE_CONST:     {       int sym = new_sym(s, nsym(tree));        genop_2(s, OP_GETCONST, cursp(), sym);       if (val) push();     }     break;    case NODE_BACK_REF:     if (val) {       char buf[] = {'$', nchar(tree)};       int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));        genop_2(s, OP_GETGV, cursp(), sym);       push();     }     break;    case NODE_NTH_REF:     if (val) {       mrb_state *mrb = s->mrb;       mrb_value str;       int sym;        str = mrb_format(mrb, ""$%d"", nint(tree));       sym = new_sym(s, mrb_intern_str(mrb, str));       genop_2(s, OP_GETGV, cursp(), sym);       push();     }     break;    case NODE_ARG:     /* should not happen */     break;    case NODE_BLOCK_ARG:     if (!tree) {       int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));        if (idx == 0) {         codegen_error(s, ""no anonymous block argument"");       }       gen_move(s, cursp(), idx, val);     }     else {       codegen(s, tree, val);     }     break;    case NODE_INT:     if (val) {       char *p = (char*)tree->car;       int base = nint(tree->cdr->car);       mrb_int i;       mrb_bool overflow;        i = readint(s, p, base, FALSE, &overflow);       if (overflow) {         int off = new_litbn(s, p, base, FALSE);         genop_2(s, OP_LOADL, cursp(), off);       }       else {         gen_int(s, cursp(), i);       }       push();     }     break;  #ifndef MRB_NO_FLOAT   case NODE_FLOAT:     if (val) {       char *p = (char*)tree;       mrb_float f = mrb_float_read(p, NULL);       int off = new_lit(s, mrb_float_value(s->mrb, f));        genop_2(s, OP_LOADL, cursp(), off);       push();     }     break; #endif    case NODE_NEGATE:     {       nt = nint(tree->car);       switch (nt) { #ifndef MRB_NO_FLOAT       case NODE_FLOAT:         if (val) {           char *p = (char*)tree->cdr;           mrb_float f = mrb_float_read(p, NULL);           int off = new_lit(s, mrb_float_value(s->mrb, -f));            genop_2(s, OP_LOADL, cursp(), off);           push();         }         break; #endif        case NODE_INT:         if (val) {           char *p = (char*)tree->cdr->car;           int base = nint(tree->cdr->cdr->car);           mrb_int i;           mrb_bool overflow;            i = readint(s, p, base, TRUE, &overflow);           if (overflow) {             int off = new_litbn(s, p, base, TRUE);             genop_2(s, OP_LOADL, cursp(), off);           }           else {             gen_int(s, cursp(), i);           }           push();         }         break;        default:         if (val) {           codegen(s, tree, VAL);           pop();           push_n(2);pop_n(2); /* space for receiver&block */           mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);           if (!gen_uniop(s, minus, cursp())) {             genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);           }           push();         }         else {           codegen(s, tree, NOVAL);         }         break;       }     }     break;    case NODE_STR:     if (val) {       char *p = (char*)tree->car;       size_t len = (intptr_t)tree->cdr;       int ai = mrb_gc_arena_save(s->mrb);       int off = new_lit(s, mrb_str_new(s->mrb, p, len));        mrb_gc_arena_restore(s->mrb, ai);       genop_2(s, OP_STRING, cursp(), off);       push();     }     break;    case NODE_HEREDOC:     tree = ((struct mrb_parser_heredoc_info *)tree)->doc;     /* fall through */   case NODE_DSTR:     if (val) {       node *n = tree;        if (!n) {         genop_1(s, OP_LOADNIL, cursp());         push();         break;       }       codegen(s, n->car, VAL);       n = n->cdr;       while (n) {         codegen(s, n->car, VAL);         pop(); pop();         genop_1(s, OP_STRCAT, cursp());         push();         n = n->cdr;       }     }     else {       node *n = tree;        while (n) {         if (nint(n->car->car) != NODE_STR) {           codegen(s, n->car, NOVAL);         }         n = n->cdr;       }     }     break;    case NODE_WORDS:     gen_literal_array(s, tree, FALSE, val);     break;    case NODE_SYMBOLS:     gen_literal_array(s, tree, TRUE, val);     break;    case NODE_DXSTR:     {       node *n;       int ai = mrb_gc_arena_save(s->mrb);       int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));        genop_1(s, OP_LOADSELF, cursp());       push();       codegen(s, tree->car, VAL);       n = tree->cdr;       while (n) {         if (nint(n->car->car) == NODE_XSTR) {           n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;           mrb_assert(!n->cdr); /* must be the end */         }         codegen(s, n->car, VAL);         pop(); pop();         genop_1(s, OP_STRCAT, cursp());         push();         n = n->cdr;       }       push();                   /* for block */       pop_n(3);       sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */       genop_3(s, OP_SEND, cursp(), sym, 1);       if (val) push();       mrb_gc_arena_restore(s->mrb, ai);     }     break;    case NODE_XSTR:     {       char *p = (char*)tree->car;       size_t len = (intptr_t)tree->cdr;       int ai = mrb_gc_arena_save(s->mrb);       int off = new_lit(s, mrb_str_new(s->mrb, p, len));       int sym;        genop_1(s, OP_LOADSELF, cursp());       push();       genop_2(s, OP_STRING, cursp(), off);       push(); push();       pop_n(3);       sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */       genop_3(s, OP_SEND, cursp(), sym, 1);       if (val) push();       mrb_gc_arena_restore(s->mrb, ai);     }     break;    case NODE_REGX:     if (val) {       char *p1 = (char*)tree->car;       char *p2 = (char*)tree->cdr->car;       char *p3 = (char*)tree->cdr->cdr;       int ai = mrb_gc_arena_save(s->mrb);       int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));       int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));       int argc = 1;        genop_1(s, OP_OCLASS, cursp());       genop_2(s, OP_GETMCNST, cursp(), sym);       push();       genop_2(s, OP_STRING, cursp(), off);       push();       if (p2 || p3) {         if (p2) { /* opt */           off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));           genop_2(s, OP_STRING, cursp(), off);         }         else {           genop_1(s, OP_LOADNIL, cursp());         }         push();         argc++;         if (p3) { /* enc */           off = new_lit(s, mrb_str_new(s->mrb, p3, 1));           genop_2(s, OP_STRING, cursp(), off);           push();           argc++;         }       }       push(); /* space for a block */       pop_n(argc+2);       sym = new_sym(s, MRB_SYM_2(s->mrb, compile));       genop_3(s, OP_SEND, cursp(), sym, argc);       mrb_gc_arena_restore(s->mrb, ai);       push();     }     break;    case NODE_DREGX:     if (val) {       node *n = tree->car;       int ai = mrb_gc_arena_save(s->mrb);       int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));       int argc = 1;       int off;       char *p;        genop_1(s, OP_OCLASS, cursp());       genop_2(s, OP_GETMCNST, cursp(), sym);       push();       codegen(s, n->car, VAL);       n = n->cdr;       while (n) {         codegen(s, n->car, VAL);         pop(); pop();         genop_1(s, OP_STRCAT, cursp());         push();         n = n->cdr;       }       n = tree->cdr->cdr;       if (n->car) { /* tail */         p = (char*)n->car;         off = new_lit(s, mrb_str_new_cstr(s->mrb, p));         codegen(s, tree->car, VAL);         genop_2(s, OP_STRING, cursp(), off);         pop();         genop_1(s, OP_STRCAT, cursp());         push();       }       if (n->cdr->car) { /* opt */         char *p2 = (char*)n->cdr->car;         off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));         genop_2(s, OP_STRING, cursp(), off);         push();         argc++;       }       if (n->cdr->cdr) { /* enc */         char *p2 = (char*)n->cdr->cdr;         off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));         genop_2(s, OP_STRING, cursp(), off);         push();         argc++;       }       push(); /* space for a block */       pop_n(argc+2);       sym = new_sym(s, MRB_SYM_2(s->mrb, compile));       genop_3(s, OP_SEND, cursp(), sym, argc);       mrb_gc_arena_restore(s->mrb, ai);       push();     }     else {       node *n = tree->car;        while (n) {         if (nint(n->car->car) != NODE_STR) {           codegen(s, n->car, NOVAL);         }         n = n->cdr;       }     }     break;    case NODE_SYM:     if (val) {       int sym = new_sym(s, nsym(tree));        genop_2(s, OP_LOADSYM, cursp(), sym);       push();     }     break;    case NODE_DSYM:     codegen(s, tree, val);     if (val) {       gen_intern(s);     }     break;    case NODE_SELF:     if (val) {       genop_1(s, OP_LOADSELF, cursp());       push();     }     break;    case NODE_NIL:     if (val) {       genop_1(s, OP_LOADNIL, cursp());       push();     }     break;    case NODE_TRUE:     if (val) {       genop_1(s, OP_LOADT, cursp());       push();     }     break;    case NODE_FALSE:     if (val) {       genop_1(s, OP_LOADF, cursp());       push();     }     break;    case NODE_ALIAS:     {       int a = new_sym(s, nsym(tree->car));       int b = new_sym(s, nsym(tree->cdr));        genop_2(s, OP_ALIAS, a, b);       if (val) {         genop_1(s, OP_LOADNIL, cursp());         push();       }     }    break;    case NODE_UNDEF:     {       node *t = tree;        while (t) {         int symbol = new_sym(s, nsym(t->car));         genop_1(s, OP_UNDEF, symbol);         t = t->cdr;       }       if (val) {         genop_1(s, OP_LOADNIL, cursp());         push();       }     }     break;    case NODE_CLASS:     {       int idx;       node *body;        if (tree->car->car == (node*)0) {         genop_1(s, OP_LOADNIL, cursp());         push();       }       else if (tree->car->car == (node*)1) {         genop_1(s, OP_OCLASS, cursp());         push();       }       else {         codegen(s, tree->car->car, VAL);       }       if (tree->cdr->car) {         codegen(s, tree->cdr->car, VAL);       }       else {         genop_1(s, OP_LOADNIL, cursp());         push();       }       pop(); pop();       idx = new_sym(s, nsym(tree->car->cdr));       genop_2(s, OP_CLASS, cursp(), idx);       body = tree->cdr->cdr->car;       if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {         genop_1(s, OP_LOADNIL, cursp());       }       else {         idx = scope_body(s, body, val);         genop_2(s, OP_EXEC, cursp(), idx);       }       if (val) {         push();       }     }     break;    case NODE_MODULE:     {       int idx;        if (tree->car->car == (node*)0) {         genop_1(s, OP_LOADNIL, cursp());         push();       }       else if (tree->car->car == (node*)1) {         genop_1(s, OP_OCLASS, cursp());         push();       }       else {         codegen(s, tree->car->car, VAL);       }       pop();       idx = new_sym(s, nsym(tree->car->cdr));       genop_2(s, OP_MODULE, cursp(), idx);       if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&           tree->cdr->car->cdr->cdr == NULL) {         genop_1(s, OP_LOADNIL, cursp());       }       else {         idx = scope_body(s, tree->cdr->car, val);         genop_2(s, OP_EXEC, cursp(), idx);       }       if (val) {         push();       }     }     break;    case NODE_SCLASS:     {       int idx;        codegen(s, tree->car, VAL);       pop();       genop_1(s, OP_SCLASS, cursp());       if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&           tree->cdr->car->cdr->cdr == NULL) {         genop_1(s, OP_LOADNIL, cursp());       }       else {         idx = scope_body(s, tree->cdr->car, val);         genop_2(s, OP_EXEC, cursp(), idx);       }       if (val) {         push();       }     }     break;    case NODE_DEF:     {       int sym = new_sym(s, nsym(tree->car));       int idx = lambda_body(s, tree->cdr, 0);        genop_1(s, OP_TCLASS, cursp());       push();       genop_2(s, OP_METHOD, cursp(), idx);       push(); pop();       pop();       genop_2(s, OP_DEF, cursp(), sym);       if (val) push();     }     break;    case NODE_SDEF:     {       node *recv = tree->car;       int sym = new_sym(s, nsym(tree->cdr->car));       int idx = lambda_body(s, tree->cdr->cdr, 0);        codegen(s, recv, VAL);       pop();       genop_1(s, OP_SCLASS, cursp());       push();       genop_2(s, OP_METHOD, cursp(), idx);       pop();       genop_2(s, OP_DEF, cursp(), sym);       if (val) push();     }     break;    case NODE_POSTEXE:     codegen(s, tree, NOVAL);     break;    default:     break;   }  exit:   s->rlev = rlev; }"
"224161_not_vulnerable.cc","not_vulnerable","  void Compute(OpKernelContext* ctx) override {     StagingMap<Ordered>* map = nullptr;     OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));     core::ScopedUnref scope(map);      OP_REQUIRES_OK(ctx, map->clear());   }"
"224229_not_vulnerable.c","not_vulnerable","R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) { 	RIOBank *bank = r_io_bank_get (io, bankid); 	r_return_val_if_fail (io && bank, false); 	RIOSubMap fake_sm; 	memset (&fake_sm, 0x00, sizeof(RIOSubMap)); 	fake_sm.itv.addr = addr; 	fake_sm.itv.size = len; 	RRBNode *node; 	if (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) { 		node = bank->last_used; 	} else { 		node = _find_entry_submap_node (bank, &fake_sm); 	} 	memset (buf, io->Oxff, len); 	RIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL; 	bool ret = true; 	while (sm && r_io_submap_overlap ((&fake_sm), sm)) { 		bank->last_used = node; 		RIOMap *map = r_io_map_get_by_ref (io, &sm->mapref); 		if (!map) { 			// mapref doesn't belong to map 			return false; 		} 		if (!(map->perm & R_PERM_R)) { 			node = r_rbnode_next (node); 			sm = node ? (RIOSubMap *)node->data : NULL; 			continue; 		} 		const ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr; 		const int read_len = R_MIN (r_io_submap_to ((&fake_sm)), 					     r_io_submap_to (sm)) - (addr + buf_off) + 1; 		const ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta; 		ret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len); 		// check return value here? 		node = r_rbnode_next (node); 		sm = node ? (RIOSubMap *)node->data : NULL; 	} 	return ret; }"
"224452_not_vulnerable.c","not_vulnerable","static GF_Err gf_text_guess_format(const char *filename, u32 *fmt) { 	char szLine[2048]; 	u32 val; 	s32 uni_type; 	FILE *test = gf_fopen(filename, ""rb""); 	if (!test) return GF_URL_ERROR; 	uni_type = gf_text_get_utf_type(test);  	if (uni_type>1) { 		const u16 *sptr; 		char szUTF[1024]; 		u32 read = (u32) gf_fread(szUTF, 1023, test); 		if ((s32) read < 0) { 			gf_fclose(test); 			return GF_IO_ERR; 		} 		szUTF[read]=0; 		sptr = (u16*)szUTF; 		/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr); 	} else { 		val = (u32) gf_fread(szLine, 1024, test); 		if ((s32) val<0) return GF_IO_ERR; 		 		szLine[val]=0; 	} 	REM_TRAIL_MARKS(szLine, ""\r\n\t "")  	*fmt = GF_TXTIN_MODE_NONE; 	if ((szLine[0]=='{') && strstr(szLine, ""}{"")) *fmt = GF_TXTIN_MODE_SUB; 	else if (szLine[0] == '<') { 		char *ext = gf_file_ext_start(filename); 		if (!strnicmp(ext, "".ttxt"", 5)) *fmt = GF_TXTIN_MODE_TTXT; 		else if (!strnicmp(ext, "".ttml"", 5)) *fmt = GF_TXTIN_MODE_TTML; 		ext = strstr(szLine, ""?>""); 		if (ext) ext += 2; 		if (ext && !ext[0]) { 			if (!gf_fgets(szLine, 2048, test)) 				szLine[0] = '\0'; 		} 		if (strstr(szLine, ""x-quicktime-tx3g"") || strstr(szLine, ""text3GTrack"")) *fmt = GF_TXTIN_MODE_TEXML; 		else if (strstr(szLine, ""TextStream"")) *fmt = GF_TXTIN_MODE_TTXT; 		else if (strstr(szLine, ""tt"")) *fmt = GF_TXTIN_MODE_TTML; 	} 	else if (strstr(szLine, ""WEBVTT"") ) 		*fmt = GF_TXTIN_MODE_WEBVTT; 	else if (strstr(szLine, "" --> "") ) 		*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */  	else if (!strncmp(szLine, ""FWS"", 3) || !strncmp(szLine, ""CWS"", 3)) 		*fmt = GF_TXTIN_MODE_SWF_SVG;  	gf_fclose(test); 	return GF_OK; }"
"224565_not_vulnerable.cc","not_vulnerable","Status CheckFormatConstraintsOnShape(const TensorFormat tensor_format,                                      const ShapeHandle shape_handle,                                      const string& tensor_name,                                      shape_inference::InferenceContext* c) {   if (tensor_format == FORMAT_NCHW_VECT_C) {     // Check that the vect dim has size 4 or 32.     const int num_dims = c->Rank(shape_handle);     DimensionHandle vect_dim = c->Dim(         shape_handle, GetTensorInnerFeatureDimIndex(num_dims, tensor_format));     int64_t vect_dim_val = c->Value(vect_dim);     if (vect_dim_val != 4 && vect_dim_val != 32) {       return errors::InvalidArgument(           ""VECT_C dimension must be 4 or 32, but is "", vect_dim_val);     }   }    return Status::OK(); }"
"224574_not_vulnerable.cc","not_vulnerable","Status FusedBatchNormGradShape(shape_inference::InferenceContext* c) {   string data_format_str;   TF_RETURN_IF_ERROR(c->GetAttr(""data_format"", &data_format_str));   TensorFormat data_format;   if (!FormatFromString(data_format_str, &data_format)) {     return errors::InvalidArgument(""Invalid data format string: "",                                    data_format_str);   }   const int rank =       (data_format_str == ""NDHWC"" || data_format_str == ""NCDHW"") ? 5 : 4;   ShapeHandle y_backprop;   TF_RETURN_IF_ERROR(c->WithRank(c->input(0), rank, &y_backprop));   ShapeHandle x;   TF_RETURN_IF_ERROR(c->WithRank(c->input(1), rank, &x));    bool is_training;   TF_RETURN_IF_ERROR(c->GetAttr(""is_training"", &is_training));    int channel_dim_index = GetTensorFeatureDimIndex(rank, data_format);   DimensionHandle channel_dim = c->Dim(y_backprop, channel_dim_index);   TF_RETURN_IF_ERROR(       c->Merge(channel_dim, c->Dim(x, channel_dim_index), &channel_dim));    // covers scale, mean (reserve_space_1), variance (reserve_space_2)   for (int i = 2; i < 5; ++i) {     ShapeHandle vec;     TF_RETURN_IF_ERROR(c->WithRank(c->input(i), 1, &vec));     TF_RETURN_IF_ERROR(c->Merge(channel_dim, c->Dim(vec, 0), &channel_dim));   }    ShapeHandle x_backprop;   TF_RETURN_IF_ERROR(       c->ReplaceDim(y_backprop, channel_dim_index, channel_dim, &x_backprop));   c->set_output(0, x_backprop);   c->set_output(1, c->Vector(channel_dim));   c->set_output(2, c->Vector(channel_dim));   c->set_output(3, c->Vector(0));   c->set_output(4, c->Vector(0));   return Status::OK(); }"
"224714_not_vulnerable.c","not_vulnerable","GF_Err ireftype_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 i; 	GF_ItemReferenceTypeBox *ptr = (GF_ItemReferenceTypeBox *)s;  	ISOM_DECREASE_SIZE(ptr, 4) 	ptr->from_item_id = gf_bs_read_u16(bs); 	ptr->reference_count = gf_bs_read_u16(bs); 	if (ptr->size / 2 < ptr->reference_count) 		return GF_ISOM_INVALID_FILE;  	ptr->to_item_IDs = (u32 *)gf_malloc(ptr->reference_count * sizeof(u32)); 	if (!ptr->to_item_IDs) return GF_OUT_OF_MEM;  	for (i=0; i < ptr->reference_count; i++) { 		ISOM_DECREASE_SIZE(ptr, 2) 		ptr->to_item_IDs[i] = gf_bs_read_u16(bs); 	} 	return GF_OK; }"
"225010_not_vulnerable.c","not_vulnerable","conninfo_uri_decode(const char *str, PQExpBuffer errorMessage) { 	char	   *buf; 	char	   *p; 	const char *q = str;  	buf = malloc(strlen(str) + 1); 	if (buf == NULL) 	{ 		appendPQExpBufferStr(errorMessage, libpq_gettext(""out of memory\n"")); 		return NULL; 	} 	p = buf;  	for (;;) 	{ 		if (*q != '%') 		{ 			/* copy and check for NUL terminator */ 			if (!(*(p++) = *(q++))) 				break; 		} 		else 		{ 			int			hi; 			int			lo; 			int			c;  			++q;				/* skip the percent sign itself */  			/* 			 * Possible EOL will be caught by the first call to 			 * get_hexdigit(), so we never dereference an invalid q pointer. 			 */ 			if (!(get_hexdigit(*q++, &hi) && get_hexdigit(*q++, &lo))) 			{ 				appendPQExpBuffer(errorMessage, 								  libpq_gettext(""invalid percent-encoded token: \""%s\""\n""), 								  str); 				free(buf); 				return NULL; 			}  			c = (hi << 4) | lo; 			if (c == 0) 			{ 				appendPQExpBuffer(errorMessage, 								  libpq_gettext(""forbidden value %%00 in percent-encoded value: \""%s\""\n""), 								  str); 				free(buf); 				return NULL; 			} 			*(p++) = c; 		} 	}  	return buf; }"
"225034_not_vulnerable.c","not_vulnerable","PQconnectdb(const char *conninfo) { 	PGconn	   *conn = PQconnectStart(conninfo);  	if (conn && conn->status != CONNECTION_BAD) 		(void) connectDBComplete(conn);  	return conn; }"
"225035_not_vulnerable.c","not_vulnerable","PQping(const char *conninfo) { 	PGconn	   *conn = PQconnectStart(conninfo); 	PGPing		ret;  	ret = internal_ping(conn); 	PQfinish(conn);  	return ret; }"
"225064_not_vulnerable.c","not_vulnerable","get_hexdigit(char digit, int *value) { 	if ('0' <= digit && digit <= '9') 		*value = digit - '0'; 	else if ('A' <= digit && digit <= 'F') 		*value = digit - 'A' + 10; 	else if ('a' <= digit && digit <= 'f') 		*value = digit - 'a' + 10; 	else 		return false;  	return true; }"
"225069_not_vulnerable.c","not_vulnerable","setKeepalivesIdle(PGconn *conn) { 	int			idle;  	if (conn->keepalives_idle == NULL) 		return 1;  	if (!parse_int_param(conn->keepalives_idle, &idle, conn, 						 ""keepalives_idle"")) 		return 0; 	if (idle < 0) 		idle = 0;  #ifdef PG_TCP_KEEPALIVE_IDLE 	if (setsockopt(conn->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE, 				   (char *) &idle, sizeof(idle)) < 0) 	{ 		char		sebuf[PG_STRERROR_R_BUFLEN];  		appendPQExpBuffer(&conn->errorMessage, 						  libpq_gettext(""%s(%s) failed: %s\n""), 						  ""setsockopt"", 						  PG_TCP_KEEPALIVE_IDLE_STR, 						  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf))); 		return 0; 	} #endif  	return 1; }"
"225470_not_vulnerable.cc","not_vulnerable","bool IsTensorIdPortValid(const TensorId& tensor_id) {   return tensor_id.index() >= Graph::kControlSlot; }"
"225555_not_vulnerable.c","not_vulnerable","void TfLiteTensorReset(TfLiteType type, const char* name, TfLiteIntArray* dims,                        TfLiteQuantizationParams quantization, char* buffer,                        size_t size, TfLiteAllocationType allocation_type,                        const void* allocation, bool is_variable,                        TfLiteTensor* tensor) {   TfLiteTensorFree(tensor);   tensor->type = type;   tensor->name = name;   tensor->dims = dims;   tensor->params = quantization;   tensor->data.raw = buffer;   tensor->bytes = size;   tensor->allocation_type = allocation_type;   tensor->allocation = allocation;   tensor->is_variable = is_variable;    tensor->quantization.type = kTfLiteNoQuantization;   tensor->quantization.params = NULL; }"
"225619_not_vulnerable.c","not_vulnerable","GF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs) { 	GF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;  	ISOM_DECREASE_SIZE(ptr, 4); 	ptr->container_size = gf_bs_read_u32(bs); 	return GF_OK; }"
"225652_not_vulnerable.c","not_vulnerable","GF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs) { 	GF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s; 	ISOM_DECREASE_SIZE(ptr, 4) 	ptr->ssrc = gf_bs_read_u32(bs); 	return GF_OK; }"
"225666_not_vulnerable.c","not_vulnerable","GF_Box *mdhd_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);  	tmp->packedLanguage[0] = 'u'; 	tmp->packedLanguage[1] = 'n'; 	tmp->packedLanguage[2] = 'd'; 	return (GF_Box *)tmp; }"
"225772_not_vulnerable.c","not_vulnerable"," GF_Err leva_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 i; 	GF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;  	ISOM_DECREASE_SIZE(ptr, 1) 	ptr->level_count = gf_bs_read_u8(bs); 	//each level is at least 5 bytes 	if (ptr->size / 5 < ptr->level_count) 		return GF_ISOM_INVALID_FILE;  	GF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment); 	if (!ptr->levels) return GF_OUT_OF_MEM;  	for (i = 0; i < ptr->level_count; i++) { 		GF_LevelAssignment *level = &ptr->levels[i]; 		u8 tmp; 		if (!level || ptr->size < 5) return GF_BAD_PARAM; 		ISOM_DECREASE_SIZE(ptr, 5)  		level->track_id = gf_bs_read_u32(bs); 		tmp = gf_bs_read_u8(bs); 		level->padding_flag = tmp >> 7; 		level->type = tmp & 0x7F; 		if (level->type == 0) { 			ISOM_DECREASE_SIZE(ptr, 4) 			level->grouping_type = gf_bs_read_u32(bs); 		} 		else if (level->type == 1) { 			ISOM_DECREASE_SIZE(ptr, 8) 			level->grouping_type = gf_bs_read_u32(bs); 			level->grouping_type_parameter = gf_bs_read_u32(bs); 		} 		else if (level->type == 4) { 			ISOM_DECREASE_SIZE(ptr, 4) 			level->sub_track_id = gf_bs_read_u32(bs); 		} 	} 	return GF_OK;"
"225780_not_vulnerable.c","not_vulnerable"," GF_Box *fiin_box_new() { 	ISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN); 	return (GF_Box *)tmp;"
"225832_not_vulnerable.c","not_vulnerable","GF_Err hmhd_box_size(GF_Box *s) { 	GF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s; 	ptr->size += 16; 	return GF_OK; }"
"225911_not_vulnerable.c","not_vulnerable"," GF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 i; 	FECReservoirBox *ptr = (FECReservoirBox *)s;  	ISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) ); 	ptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);  	if (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) { 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid number of entries %d in fecr\n"", ptr->nb_entries)); 		return GF_ISOM_INVALID_FILE; 	}  	ISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) ); 	GF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry); 	if (!ptr->entries) return GF_OUT_OF_MEM;  	for (i=0; i<ptr->nb_entries; i++) { 		ptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16); 		ptr->entries[i].symbol_count = gf_bs_read_u32(bs); 	} 	return GF_OK;"
"225950_not_vulnerable.c","not_vulnerable"," GF_Err extr_box_write(GF_Box *s, GF_BitStream *bs) { 	GF_Err e; 	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s; 	if (!s) return GF_BAD_PARAM;  	e = gf_isom_box_write_header(s, bs); 	if (e) return e;  	if (ptr->feci) { 		e = gf_isom_box_write((GF_Box *)ptr->feci, bs); 		if (e) return e; 	} 	gf_bs_write_data(bs, ptr->data, ptr->data_length); 	return GF_OK;"
"226007_not_vulnerable.c","not_vulnerable","GF_Box *srpp_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP); 	return (GF_Box *)tmp; }"
"226120_not_vulnerable.c","not_vulnerable"," void extr_box_del(GF_Box *s) { 	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s; 	if (ptr == NULL) return; 	if (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci); 	if (ptr->data) gf_free(ptr->data); 	gf_free(ptr);"
"226124_not_vulnerable.c","not_vulnerable"," void vwid_box_del(GF_Box *s) { 	u32 i; 	GF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s; 	if (ptr->views) { 		for (i=0; i<ptr->num_views; i++) { 			if (ptr->views[i].view_refs) 				gf_free(ptr->views[i].view_refs); 		} 		gf_free(ptr->views); 	} 	gf_free(ptr);"
"226126_not_vulnerable.c","not_vulnerable"," GF_Err reftype_box_size(GF_Box *s) { 	GF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s; 	if (ptr->trackIDCount) 		ptr->size += (ptr->trackIDCount * sizeof(u32)); 	return GF_OK;"
"226143_not_vulnerable.c","not_vulnerable"," void mhac_box_del(GF_Box *s) { 	GF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s; 	if (ptr->mha_config) gf_free(ptr->mha_config); 	gf_free(s);"
"226263_not_vulnerable.c","not_vulnerable"," GF_Err trgr_box_size(GF_Box *s) { 	u32 pos=0; 	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s; 	gf_isom_check_position_list(s, ptr->groups, &pos); 	return GF_OK;"
"226305_not_vulnerable.c","not_vulnerable"," void dmlp_box_del(GF_Box *s) { 	gf_free(s);"
"226347_not_vulnerable.c","not_vulnerable"," GF_Err trun_box_read(GF_Box *s, GF_BitStream *bs) { 	u32 i; 	GF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;  #ifdef GF_ENABLE_CTRN 	if (ptr->type == GF_ISOM_BOX_TYPE_CTRN) { 		ptr->type = GF_ISOM_BOX_TYPE_TRUN; 		ptr->use_ctrn = GF_TRUE; 		return ctrn_box_read(s, bs); 	} #endif  	//check this is a good file 	if ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS)) 		return GF_ISOM_INVALID_FILE;  	ISOM_DECREASE_SIZE(ptr, 4); 	ptr->sample_count = gf_bs_read_u32(bs);  	//The rest depends on the flags 	if (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) { 		ISOM_DECREASE_SIZE(ptr, 4); 		ptr->data_offset = gf_bs_read_u32(bs); 	} 	if (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) { 		ISOM_DECREASE_SIZE(ptr, 4); 		ptr->first_sample_flags = gf_bs_read_u32(bs); 	} 	if (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) { 		ptr->samples = gf_malloc(sizeof(GF_TrunEntry)); 		if (!ptr->samples) return GF_OUT_OF_MEM; 		//memset to 0 !! 		memset(ptr->samples, 0, sizeof(GF_TrunEntry)); 		ptr->sample_alloc = ptr->nb_samples = 1; 		ptr->samples[0].nb_pack = ptr->sample_count; 	} else { 		//if we get here, at least one flag (so at least 4 bytes) is set, check size 		if (ptr->sample_count * 4 > ptr->size) { 			ISOM_DECREASE_SIZE(ptr, ptr->sample_count*4); 		} 		if ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid number of samples %d in trun\n"", ptr->sample_count)); 			return GF_ISOM_INVALID_FILE; 		} 		ptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count); 		if (!ptr->samples) return GF_OUT_OF_MEM; 		ptr->sample_alloc = ptr->nb_samples = ptr->sample_count; 		//memset to 0 upfront 		memset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));  		//read each entry (even though nothing may be written) 		for (i=0; i<ptr->sample_count; i++) { 			u32 trun_size = 0; 			GF_TrunEntry *p = &ptr->samples[i];  			if (ptr->flags & GF_ISOM_TRUN_DURATION) { 				p->Duration = gf_bs_read_u32(bs); 				trun_size += 4; 			} 			if (ptr->flags & GF_ISOM_TRUN_SIZE) { 				p->size = gf_bs_read_u32(bs); 				trun_size += 4; 			} 			//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED 			if (ptr->flags & GF_ISOM_TRUN_FLAGS) { 				p->flags = gf_bs_read_u32(bs); 				trun_size += 4; 			} 			if (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) { 				if (ptr->version==0) { 					p->CTS_Offset = (u32) gf_bs_read_u32(bs); 				} else { 					p->CTS_Offset = (s32) gf_bs_read_u32(bs); 				} 				trun_size += 4; 			} 			ISOM_DECREASE_SIZE(ptr, trun_size); 		} 	} 	/*todo parse sample reorder*/ 	if (ptr->size) { 		gf_bs_skip_bytes(bs, ptr->size); 		ptr->size = 0; 	} 	return GF_OK;"
"226353_not_vulnerable.c","not_vulnerable"," GF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid) { 	u32 i; 	GF_UserDataMap *map; 	if (ptr == NULL) return NULL; 	i=0; 	while ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) { 		if (map->boxType == box_type) { 			if ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map; 			if (!memcmp(map->uuid, *uuid, 16)) return map; 		} 	} 	return NULL;"
"226975_not_vulnerable.c","not_vulnerable","IRC_PROTOCOL_CALLBACK(303) {     IRC_PROTOCOL_MIN_ARGS(4);      weechat_printf_date_tags (         irc_msgbuffer_get_target_buffer (server, NULL, command, NULL, NULL),         date,         irc_protocol_tags (command, ""irc_numeric"", NULL, NULL),         _(""%sUsers online: %s%s""),         weechat_prefix (""network""),         IRC_COLOR_CHAT_NICK,         (argv_eol[3][0] == ':') ? argv_eol[3] + 1 : argv_eol[3]);      return WEECHAT_RC_OK; }"
"229151_not_vulnerable.c","not_vulnerable","size_t virtio_serial_guest_ready(VirtIOSerialPort *port) {     VirtIODevice *vdev = VIRTIO_DEVICE(port->vser);     VirtQueue *vq = port->ivq;     unsigned int bytes;      if (!virtio_queue_ready(vq) ||         !(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK) ||         virtio_queue_empty(vq)) {         return 0;     }     if (use_multiport(port->vser) && !port->guest_connected) {         return 0;     }     virtqueue_get_avail_bytes(vq, &bytes, NULL, 4096, 0);     return bytes; }"
"229239_not_vulnerable.cc","not_vulnerable","void cql_server::response::write_bytes_as_string(bytes_view s) {     write_short(cast_if_fits<uint16_t>(s.size()));     _body.write(s); }"
"229247_not_vulnerable.cc","not_vulnerable","static inline cql_server::result_with_foreign_response_ptr convert_error_message_to_coordinator_result(messages::result_message* msg) {     return std::move(*dynamic_cast<messages::result_message::exception*>(msg)).get_exception(); }"
"229253_not_vulnerable.cc","not_vulnerable","std::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const {     std::multimap<sstring, sstring> opts;     opts.insert({""CQL_VERSION"", cql3::query_processor::CQL_VERSION});     opts.insert({""COMPRESSION"", ""lz4""});     opts.insert({""COMPRESSION"", ""snappy""});     if (_server._config.allow_shard_aware_drivers) {         opts.insert({""SCYLLA_SHARD"", format(""{:d}"", this_shard_id())});         opts.insert({""SCYLLA_NR_SHARDS"", format(""{:d}"", smp::count)});         opts.insert({""SCYLLA_SHARDING_ALGORITHM"", dht::cpu_sharding_algorithm_name()});         if (_server._config.shard_aware_transport_port) {             opts.insert({""SCYLLA_SHARD_AWARE_PORT"", format(""{:d}"", *_server._config.shard_aware_transport_port)});         }         if (_server._config.shard_aware_transport_port_ssl) {             opts.insert({""SCYLLA_SHARD_AWARE_PORT_SSL"", format(""{:d}"", *_server._config.shard_aware_transport_port_ssl)});         }         opts.insert({""SCYLLA_SHARDING_IGNORE_MSB"", format(""{:d}"", _server._config.sharding_ignore_msb)});         opts.insert({""SCYLLA_PARTITIONER"", _server._config.partitioner_name});     }     for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {         const sstring ext_key_name = protocol_extension_name(ext);         std::vector<sstring> params = additional_options_for_proto_ext(ext);         if (params.empty()) {             opts.emplace(ext_key_name, """");         } else {             for (sstring val : params) {                 opts.emplace(ext_key_name, std::move(val));             }         }     }     auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);     response->write_string_multimap(std::move(opts));     return response; }"
"229328_not_vulnerable.cc","not_vulnerable","void CollectGraphs(EagerContext* ctx) {   mutex_lock ml(*ctx->MetadataMu());    GraphCollector* collector = ctx->GetGraphCollector();   mutex_lock mll(collector->mu);    // Adding to partition graphs for backward compatibility.   for (const auto& graph : collector->partitioned_graphs) {     *ctx->RunMetadataProto()->add_partition_graphs() = graph;   }    if (collector->dirty) {     auto* function_graphs = ctx->RunMetadataProto()->add_function_graphs();     *function_graphs->mutable_post_optimization_graph() =         collector->optimized_graph;     *function_graphs->mutable_pre_optimization_graph() = collector->raw_graph;     for (const auto& graph : collector->partitioned_graphs) {       *function_graphs->add_partition_graphs() = graph;     }   }    collector->ClearGraphs(); }"
"230389_not_vulnerable.c","not_vulnerable","PJ_DEF(void) pj_xml_add_node( pj_xml_node *parent, pj_xml_node *node ) {     pj_list_push_back(&parent->node_head, node); }"
"230457_not_vulnerable.c","not_vulnerable","create_llao(uint8_t *llao, uint8_t type) {   llao[UIP_ND6_OPT_TYPE_OFFSET] = type;   llao[UIP_ND6_OPT_LEN_OFFSET] = UIP_ND6_OPT_LLAO_LEN >> 3;   memcpy(&llao[UIP_ND6_OPT_DATA_OFFSET], &uip_lladdr, UIP_LLADDR_LEN);   /* padding on some */   memset(&llao[UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN], 0,          UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN); }"
"230988_not_vulnerable.c","not_vulnerable","mrb_stack_extend(mrb_state *mrb, mrb_int room) {   if (!mrb->c->ci->stack || mrb->c->ci->stack + room >= mrb->c->stend) {     stack_extend_alloc(mrb, room);   } }"
"231062_not_vulnerable.c","not_vulnerable","BaseType_t xQueueReceive( QueueHandle_t xQueue,                            void * const pvBuffer,                            TickType_t xTicksToWait )  {      BaseType_t xEntryTimeSet = pdFALSE;      TimeOut_t xTimeOut;      Queue_t * const pxQueue = xQueue;        /* Check the pointer is not NULL. */      configASSERT( ( pxQueue ) );        /* The buffer into which data is received can only be NULL if the data size       * is zero (so no data is copied into the buffer). */      configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );        /* Cannot block if the scheduler is suspended. */      #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )          {              configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );          }      #endif        /*lint -save -e904  This function relaxes the coding standard somewhat to       * allow return statements within the function itself.  This is done in the       * interest of execution time efficiency. */      for( ; ; )      {          taskENTER_CRITICAL();          {              const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;                /* Is there data in the queue now?  To be running the calling task               * must be the highest priority task wanting to access the queue. */              if( uxMessagesWaiting > ( UBaseType_t ) 0 )              {                  /* Data available, remove one item. */                  prvCopyDataFromQueue( pxQueue, pvBuffer );                  traceQUEUE_RECEIVE( pxQueue );                  pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;                    /* There is now space in the queue, were any tasks waiting to                   * post to the queue?  If so, unblock the highest priority waiting                   * task. */                  if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )                  {                      if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )                      {                          queueYIELD_IF_USING_PREEMPTION();                      }                      else                      {                          mtCOVERAGE_TEST_MARKER();                      }                  }                  else                  {                      mtCOVERAGE_TEST_MARKER();                  }                    taskEXIT_CRITICAL();                  return pdPASS;              }              else              {                  if( xTicksToWait == ( TickType_t ) 0 )                  {                      /* The queue was empty and no block time is specified (or                       * the block time has expired) so leave now. */                      taskEXIT_CRITICAL();                      traceQUEUE_RECEIVE_FAILED( pxQueue );                      return errQUEUE_EMPTY;                  }                  else if( xEntryTimeSet == pdFALSE )                  {                      /* The queue was empty and a block time was specified so                       * configure the timeout structure. */                      vTaskInternalSetTimeOutState( &xTimeOut );                      xEntryTimeSet = pdTRUE;                  }                  else                  {                      /* Entry time was already set. */                      mtCOVERAGE_TEST_MARKER();                  }              }          }          taskEXIT_CRITICAL();            /* Interrupts and other tasks can send to and receive from the queue           * now the critical section has been exited. */            vTaskSuspendAll();          prvLockQueue( pxQueue );            /* Update the timeout state to see if it has expired yet. */          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )          {              /* The timeout has not expired.  If the queue is still empty place               * the task on the list of tasks waiting to receive from the queue. */              if( prvIsQueueEmpty( pxQueue ) != pdFALSE )              {                  traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );                  vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );                  prvUnlockQueue( pxQueue );                    if( xTaskResumeAll() == pdFALSE )                  {                      portYIELD_WITHIN_API();                  }                  else                  {                      mtCOVERAGE_TEST_MARKER();                  }              }              else              {                  /* The queue contains data again.  Loop back to try and read the                   * data. */                  prvUnlockQueue( pxQueue );                  ( void ) xTaskResumeAll();              }          }          else          {              /* Timed out.  If there is no data in the queue exit, otherwise loop               * back and attempt to read the data. */              prvUnlockQueue( pxQueue );              ( void ) xTaskResumeAll();                if( prvIsQueueEmpty( pxQueue ) != pdFALSE )              {                  traceQUEUE_RECEIVE_FAILED( pxQueue );                  return errQUEUE_EMPTY;              }              else              {                  mtCOVERAGE_TEST_MARKER();              }          }      } /*lint -restore */  } "
"231632_not_vulnerable.cpp","not_vulnerable","CongestionAndRttState moveCurrentCongestionAndRttState(     QuicServerConnectionState& conn) {   CongestionAndRttState state;   state.peerAddress = conn.peerAddress;   state.recordTime = Clock::now();   state.congestionController = std::move(conn.congestionController);   state.srtt = conn.lossState.srtt;   state.lrtt = conn.lossState.lrtt;   state.rttvar = conn.lossState.rttvar;   state.mrtt = conn.lossState.mrtt;   return state; }"
"231687_not_vulnerable.cpp","not_vulnerable","TEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterCloseStream) {   server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;   std::array<std::string, 4> words = {       ""Hey Bob, this is Alice, for real."",       ""What message did I send you last time?"",       ""You don't sound like Alice"",       ""You are a liar!"",   };    StreamId streamId = 0x00;   auto stream = server->getNonConstConn().streamManager->getStream(streamId);   stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);   stream->readBuffer.emplace_back(       IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);   stream->retransmissionBuffer.emplace(       std::piecewise_construct,       std::forward_as_tuple(0),       std::forward_as_tuple(std::make_unique<StreamBuffer>(           IOBuf::copyBuffer(words.at(2)), 0, false)));   stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));   stream->currentWriteOffset = words.at(2).length() + words.at(3).length();   stream->currentReadOffset = words.at(0).length() + words.at(1).length();   server->getNonConstConn().flowControlState.sumCurStreamBufferLen = 100;    server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;   ShortHeader header(       ProtectionType::KeyPhaseZero,       *server->getConn().serverConnectionId,       clientNextAppDataPacketNum++);   RegularQuicPacketBuilder builder(       server->getConn().udpSendPacketLen,       std::move(header),       0 /* largestAcked */);   builder.encodePacketHeader();    StopSendingFrame stopSendingFrame(       streamId, GenericApplicationErrorCode::UNKNOWN);   ASSERT_TRUE(builder.canBuildPacket());   writeFrame(QuicSimpleFrame(stopSendingFrame), builder);   auto packet = std::move(builder).buildPacket();   server->resetStream(streamId, GenericApplicationErrorCode::UNKNOWN);   EXPECT_CALL(connCallback, onStopSending(_, _)).Times(0);   deliverData(packetToBuf(packet)); }"
"231690_not_vulnerable.cpp","not_vulnerable","void onServerReadDataFromOpen(     QuicServerConnectionState& conn,     ServerEvents::ReadData& readData) {   CHECK_EQ(conn.state, ServerState::Open);   // Don't bother parsing if the data is empty.   if (!readData.networkData.data ||       readData.networkData.data->computeChainDataLength() == 0) {     return;   }   if (!conn.readCodec) {     // First packet from the peer     folly::io::Cursor cursor(readData.networkData.data.get());     auto initialByte = cursor.readBE<uint8_t>();     auto parsedLongHeader = parseLongHeaderInvariant(initialByte, cursor);     if (!parsedLongHeader) {       VLOG(4) << ""Could not parse initial packet header"";       if (conn.qLogger) {         conn.qLogger->addPacketDrop(             0,             QuicTransportStatsCallback::toString(                 PacketDropReason::PARSE_ERROR));       }       QUIC_STATS(           conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);       return;     }     QuicVersion version = parsedLongHeader->invariant.version;     if (version == QuicVersion::VERSION_NEGOTIATION) {       VLOG(4) << ""Server droppiong VN packet"";       if (conn.qLogger) {         conn.qLogger->addPacketDrop(             0,             QuicTransportStatsCallback::toString(                 PacketDropReason::INVALID_PACKET));       }       QUIC_STATS(           conn.statsCallback,           onPacketDropped,           PacketDropReason::INVALID_PACKET);       return;     }      const auto& clientConnectionId = parsedLongHeader->invariant.srcConnId;     const auto& initialDestinationConnectionId =         parsedLongHeader->invariant.dstConnId;      if (initialDestinationConnectionId.size() < kDefaultConnectionIdSize) {       VLOG(4) << ""Initial connectionid too small"";       if (conn.qLogger) {         conn.qLogger->addPacketDrop(             0,             QuicTransportStatsCallback::toString(                 PacketDropReason::INITIAL_CONNID_SMALL));       }       QUIC_STATS(           conn.statsCallback,           onPacketDropped,           PacketDropReason::INITIAL_CONNID_SMALL);       return;     }      CHECK(conn.connIdAlgo) << ""ConnectionIdAlgo is not set."";     CHECK(!conn.serverConnectionId.has_value());     // serverConnIdParams must be set by the QuicServerTransport     CHECK(conn.serverConnIdParams);      auto newServerConnIdData = conn.createAndAddNewSelfConnId();     CHECK(newServerConnIdData.has_value());     conn.serverConnectionId = newServerConnIdData->connId;      QUIC_STATS(conn.statsCallback, onStatelessReset);     conn.serverHandshakeLayer->accept(         std::make_shared<ServerTransportParametersExtension>(             version,             conn.transportSettings.advertisedInitialConnectionWindowSize,             conn.transportSettings.advertisedInitialBidiLocalStreamWindowSize,             conn.transportSettings.advertisedInitialBidiRemoteStreamWindowSize,             conn.transportSettings.advertisedInitialUniStreamWindowSize,             conn.transportSettings.advertisedInitialMaxStreamsBidi,             conn.transportSettings.advertisedInitialMaxStreamsUni,             conn.transportSettings.idleTimeout,             conn.transportSettings.ackDelayExponent,             conn.transportSettings.maxRecvPacketSize,             conn.transportSettings.partialReliabilityEnabled,             *newServerConnIdData->token,             conn.serverConnectionId.value(),             initialDestinationConnectionId));     conn.transportParametersEncoded = true;     const CryptoFactory& cryptoFactory =         conn.serverHandshakeLayer->getCryptoFactory();     conn.readCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Server);     conn.readCodec->setInitialReadCipher(cryptoFactory.getClientInitialCipher(         initialDestinationConnectionId, version));     conn.readCodec->setClientConnectionId(clientConnectionId);     conn.readCodec->setServerConnectionId(*conn.serverConnectionId);     if (conn.qLogger) {       conn.qLogger->setScid(conn.serverConnectionId);       conn.qLogger->setDcid(initialDestinationConnectionId);     }     conn.readCodec->setCodecParameters(         CodecParameters(conn.peerAckDelayExponent, version));     conn.initialWriteCipher = cryptoFactory.getServerInitialCipher(         initialDestinationConnectionId, version);      conn.readCodec->setInitialHeaderCipher(         cryptoFactory.makeClientInitialHeaderCipher(             initialDestinationConnectionId, version));     conn.initialHeaderCipher = cryptoFactory.makeServerInitialHeaderCipher(         initialDestinationConnectionId, version);     conn.peerAddress = conn.originalPeerAddress;   }   BufQueue udpData;   udpData.append(std::move(readData.networkData.data));   for (uint16_t processedPackets = 0;        !udpData.empty() && processedPackets < kMaxNumCoalescedPackets;        processedPackets++) {     size_t dataSize = udpData.chainLength();     auto parsedPacket = conn.readCodec->parsePacket(udpData, conn.ackStates);     size_t packetSize = dataSize - udpData.chainLength();      switch (parsedPacket.type()) {       case CodecResult::Type::CIPHER_UNAVAILABLE: {         handleCipherUnavailable(             parsedPacket.cipherUnavailable(), conn, packetSize, readData);         break;       }       case CodecResult::Type::RETRY: {         VLOG(10) << ""drop because the server is not supposed to ""                  << ""receive a retry "" << conn;         if (conn.qLogger) {           conn.qLogger->addPacketDrop(packetSize, kRetry);         }         QUIC_TRACE(packet_drop, conn, ""retry"");         break;       }       case CodecResult::Type::STATELESS_RESET: {         VLOG(10) << ""drop because reset "" << conn;         if (conn.qLogger) {           conn.qLogger->addPacketDrop(packetSize, kReset);         }         QUIC_TRACE(packet_drop, conn, ""reset"");         break;       }       case CodecResult::Type::NOTHING: {         VLOG(10) << ""drop cipher unavailable, no data "" << conn;         if (conn.qLogger) {           conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);         }         QUIC_TRACE(packet_drop, conn, ""cipher_unavailable"");         break;       }       case CodecResult::Type::REGULAR_PACKET:         break;     }      RegularQuicPacket* regularOptional = parsedPacket.regularPacket();     if (!regularOptional) {       // We were unable to parse the packet, drop for now. All the drop reasons       // should have already been logged into QLogger and QuicTrace inside the       // previous switch-case block. We just need to update QUIC_STATS here.       VLOG(10) << ""Not able to parse QUIC packet "" << conn;       QUIC_STATS(           conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);       continue;     }      auto protectionLevel = regularOptional->header.getProtectionType();     auto encryptionLevel = protectionTypeToEncryptionLevel(protectionLevel);      auto packetNum = regularOptional->header.getPacketSequenceNum();     auto packetNumberSpace = regularOptional->header.getPacketNumberSpace();      // TODO: enforce constraints on other protection levels.     auto& regularPacket = *regularOptional;      bool isProtectedPacket = protectionLevel == ProtectionType::ZeroRtt ||         protectionLevel == ProtectionType::KeyPhaseZero ||         protectionLevel == ProtectionType::KeyPhaseOne;      if (!isProtectedPacket) {       for (auto& quicFrame : regularPacket.frames) {         auto isPadding = quicFrame.asPaddingFrame();         auto isAck = quicFrame.asReadAckFrame();         auto isClose = quicFrame.asConnectionCloseFrame();         auto isCrypto = quicFrame.asReadCryptoFrame();         auto isPing = quicFrame.asPingFrame();         // TODO: add path challenge and response         if (!isPadding && !isAck && !isClose && !isCrypto && !isPing) {           QUIC_STATS(               conn.statsCallback,               onPacketDropped,               PacketDropReason::PROTOCOL_VIOLATION);           if (conn.qLogger) {             conn.qLogger->addPacketDrop(                 packetSize,                 QuicTransportStatsCallback::toString(                     PacketDropReason::PROTOCOL_VIOLATION));           }           throw QuicTransportException(               ""Invalid frame"", TransportErrorCode::PROTOCOL_VIOLATION);         }       }     }      CHECK(conn.clientConnectionId);     if (conn.qLogger) {       conn.qLogger->addPacket(regularPacket, packetSize);     }     // We assume that the higher layer takes care of validating that the version     // is supported.     if (!conn.version) {       LongHeader* longHeader = regularPacket.header.asLong();       if (!longHeader) {         throw QuicTransportException(             ""Invalid packet type"", TransportErrorCode::PROTOCOL_VIOLATION);       }       conn.version = longHeader->getVersion();       if (conn.version == QuicVersion::MVFST_EXPERIMENTAL) {         setExperimentalSettings(conn);       }     }      if (conn.peerAddress != readData.peer) {       if (encryptionLevel != EncryptionLevel::AppData) {         if (conn.qLogger) {           conn.qLogger->addPacketDrop(               packetSize,               QuicTransportStatsCallback::toString(                   PacketDropReason::PEER_ADDRESS_CHANGE));         }         QUIC_STATS(             conn.statsCallback,             onPacketDropped,             PacketDropReason::PEER_ADDRESS_CHANGE);         throw QuicTransportException(             ""Migration not allowed during handshake"",             TransportErrorCode::INVALID_MIGRATION);       }        if (conn.transportSettings.disableMigration) {         if (conn.qLogger) {           conn.qLogger->addPacketDrop(               packetSize,               QuicTransportStatsCallback::toString(                   PacketDropReason::PEER_ADDRESS_CHANGE));         }         QUIC_STATS(             conn.statsCallback,             onPacketDropped,             PacketDropReason::PEER_ADDRESS_CHANGE);         throw QuicTransportException(             ""Migration disabled"", TransportErrorCode::INVALID_MIGRATION);       }     }      auto& ackState = getAckState(conn, packetNumberSpace);     bool outOfOrder = updateLargestReceivedPacketNum(         ackState, packetNum, readData.networkData.receiveTimePoint);     if (outOfOrder) {       QUIC_STATS(conn.statsCallback, onOutOfOrderPacketReceived);     }     DCHECK(hasReceivedPackets(conn));      bool pktHasRetransmittableData = false;     bool pktHasCryptoData = false;     bool isNonProbingPacket = false;     bool handshakeConfirmedThisLoop = false;      // TODO: possibly drop the packet here, but rolling back state of     // what we've already processed is difficult.     for (auto& quicFrame : regularPacket.frames) {       switch (quicFrame.type()) {         case QuicFrame::Type::ReadAckFrame: {           VLOG(10) << ""Server received ack frame packet="" << packetNum << "" ""                    << conn;           isNonProbingPacket = true;           ReadAckFrame& ackFrame = *quicFrame.asReadAckFrame();           processAckFrame(               conn,               packetNumberSpace,               ackFrame,               [&](const OutstandingPacket& packet,                   const QuicWriteFrame& packetFrame,                   const ReadAckFrame&) {                 switch (packetFrame.type()) {                   case QuicWriteFrame::Type::WriteStreamFrame: {                     const WriteStreamFrame& frame =                         *packetFrame.asWriteStreamFrame();                     VLOG(4)                         << ""Server received ack for stream="" << frame.streamId                         << "" offset="" << frame.offset << "" fin="" << frame.fin                         << "" len="" << frame.len << "" "" << conn;                     auto ackedStream =                         conn.streamManager->getStream(frame.streamId);                     if (ackedStream) {                       sendAckSMHandler(*ackedStream, frame);                     }                     break;                   }                   case QuicWriteFrame::Type::WriteCryptoFrame: {                     const WriteCryptoFrame& frame =                         *packetFrame.asWriteCryptoFrame();                     auto cryptoStream =                         getCryptoStream(*conn.cryptoState, encryptionLevel);                     processCryptoStreamAck(                         *cryptoStream, frame.offset, frame.len);                     break;                   }                   case QuicWriteFrame::Type::RstStreamFrame: {                     const RstStreamFrame& frame =                         *packetFrame.asRstStreamFrame();                     VLOG(4) << ""Server received ack for reset stream=""                             << frame.streamId << "" "" << conn;                     auto stream = conn.streamManager->getStream(frame.streamId);                     if (stream) {                       sendRstAckSMHandler(*stream);                     }                     break;                   }                   case QuicWriteFrame::Type::WriteAckFrame: {                     const WriteAckFrame& frame = *packetFrame.asWriteAckFrame();                     DCHECK(!frame.ackBlocks.empty());                     VLOG(4) << ""Server received ack for largestAcked=""                             << frame.ackBlocks.front().end << "" "" << conn;                     commonAckVisitorForAckFrame(ackState, frame);                     break;                   }                   case QuicWriteFrame::Type::PingFrame:                     if (!packet.metadata.isD6DProbe) {                       conn.pendingEvents.cancelPingTimeout = true;                     }                     return;                   case QuicWriteFrame::Type::QuicSimpleFrame: {                     const QuicSimpleFrame& frame =                         *packetFrame.asQuicSimpleFrame();                     // ACK of HandshakeDone is a server-specific behavior.                     if (frame.asHandshakeDoneFrame() &&                         conn.version != QuicVersion::MVFST_D24) {                       // Call handshakeConfirmed outside of the packet                       // processing loop to avoid a re-entrancy.                       handshakeConfirmedThisLoop = true;                     }                     break;                   }                   default: {                     break;                   }                 }               },               markPacketLoss,               readData.networkData.receiveTimePoint);           break;         }         case QuicFrame::Type::RstStreamFrame: {           RstStreamFrame& frame = *quicFrame.asRstStreamFrame();           VLOG(10) << ""Server received reset stream="" << frame.streamId << "" ""                    << conn;           pktHasRetransmittableData = true;           isNonProbingPacket = true;           auto stream = conn.streamManager->getStream(frame.streamId);           if (!stream) {             break;           }           receiveRstStreamSMHandler(*stream, frame);           break;         }         case QuicFrame::Type::ReadCryptoFrame: {           pktHasRetransmittableData = true;           pktHasCryptoData = true;           isNonProbingPacket = true;           ReadCryptoFrame& cryptoFrame = *quicFrame.asReadCryptoFrame();           VLOG(10) << ""Server received crypto data offset=""                    << cryptoFrame.offset                    << "" len="" << cryptoFrame.data->computeChainDataLength()                    << "" currentReadOffset=""                    << getCryptoStream(*conn.cryptoState, encryptionLevel)                           ->currentReadOffset                    << "" "" << conn;           appendDataToReadBuffer(               *getCryptoStream(*conn.cryptoState, encryptionLevel),               StreamBuffer(                   std::move(cryptoFrame.data), cryptoFrame.offset, false));           break;         }         case QuicFrame::Type::ReadStreamFrame: {           ReadStreamFrame& frame = *quicFrame.asReadStreamFrame();           VLOG(10) << ""Server received stream data for stream=""                    << frame.streamId << "", offset="" << frame.offset                    << "" len="" << frame.data->computeChainDataLength()                    << "" fin="" << frame.fin << "" "" << conn;           pktHasRetransmittableData = true;           isNonProbingPacket = true;           auto stream = conn.streamManager->getStream(frame.streamId);           // Ignore data from closed streams that we don't have the           // state for any more.           if (stream) {             receiveReadStreamFrameSMHandler(*stream, std::move(frame));           }           break;         }         case QuicFrame::Type::MaxDataFrame: {           MaxDataFrame& connWindowUpdate = *quicFrame.asMaxDataFrame();           VLOG(10) << ""Server received max data offset=""                    << connWindowUpdate.maximumData << "" "" << conn;           pktHasRetransmittableData = true;           isNonProbingPacket = true;           handleConnWindowUpdate(conn, connWindowUpdate, packetNum);           break;         }         case QuicFrame::Type::MaxStreamDataFrame: {           MaxStreamDataFrame& streamWindowUpdate =               *quicFrame.asMaxStreamDataFrame();           VLOG(10) << ""Server received max stream data stream=""                    << streamWindowUpdate.streamId                    << "" offset="" << streamWindowUpdate.maximumData << "" ""                    << conn;           if (isReceivingStream(conn.nodeType, streamWindowUpdate.streamId)) {             throw QuicTransportException(                 ""Received MaxStreamDataFrame for receiving stream."",                 TransportErrorCode::STREAM_STATE_ERROR);           }           pktHasRetransmittableData = true;           isNonProbingPacket = true;           auto stream =               conn.streamManager->getStream(streamWindowUpdate.streamId);           if (stream) {             handleStreamWindowUpdate(                 *stream, streamWindowUpdate.maximumData, packetNum);           }           break;         }         case QuicFrame::Type::DataBlockedFrame: {           VLOG(10) << ""Server received blocked "" << conn;           pktHasRetransmittableData = true;           isNonProbingPacket = true;           handleConnBlocked(conn);           break;         }         case QuicFrame::Type::StreamDataBlockedFrame: {           StreamDataBlockedFrame& blocked =               *quicFrame.asStreamDataBlockedFrame();           VLOG(10) << ""Server received blocked stream="" << blocked.streamId                    << "" "" << conn;           pktHasRetransmittableData = true;           isNonProbingPacket = true;           auto stream = conn.streamManager->getStream(blocked.streamId);           if (stream) {             handleStreamBlocked(*stream);           }           break;         }         case QuicFrame::Type::StreamsBlockedFrame: {           StreamsBlockedFrame& blocked = *quicFrame.asStreamsBlockedFrame();           // peer wishes to open a stream, but is unable to due to the maximum           // stream limit set by us           // TODO implement the handler           isNonProbingPacket = true;           VLOG(10) << ""Server received streams blocked limit=""                    << blocked.streamLimit << "", "" << conn;           break;         }         case QuicFrame::Type::ConnectionCloseFrame: {           isNonProbingPacket = true;           ConnectionCloseFrame& connFrame = *quicFrame.asConnectionCloseFrame();           auto errMsg = folly::to<std::string>(               ""Server closed by peer reason="", connFrame.reasonPhrase);           VLOG(4) << errMsg << "" "" << conn;           // we want to deliver app callbacks with the peer supplied error,           // but send a NO_ERROR to the peer.           QUIC_TRACE(recvd_close, conn, errMsg.c_str());           if (conn.qLogger) {             conn.qLogger->addTransportStateUpdate(getPeerClose(errMsg));           }           conn.peerConnectionError = std::make_pair(               QuicErrorCode(connFrame.errorCode), std::move(errMsg));           if (getSendConnFlowControlBytesWire(conn) == 0 &&               conn.flowControlState.sumCurStreamBufferLen) {             VLOG(2) << ""Client gives up a flow control blocked connection"";           }           throw QuicTransportException(               ""Peer closed"", TransportErrorCode::NO_ERROR);           break;         }         case QuicFrame::Type::PingFrame:           isNonProbingPacket = true;           // Ping isn't retransmittable data. But we would like to ack them           // early.           pktHasRetransmittableData = true;           break;         case QuicFrame::Type::PaddingFrame:           break;         case QuicFrame::Type::QuicSimpleFrame: {           pktHasRetransmittableData = true;           QuicSimpleFrame& simpleFrame = *quicFrame.asQuicSimpleFrame();           isNonProbingPacket |= updateSimpleFrameOnPacketReceived(               conn, simpleFrame, packetNum, readData.peer != conn.peerAddress);           break;         }         default: {           break;         }       }     }      if (handshakeConfirmedThisLoop) {       handshakeConfirmed(conn);     }      // Update writable limit before processing the handshake data. This is so     // that if we haven't decided whether or not to validate the peer, we won't     // increase the limit.     updateWritableByteLimitOnRecvPacket(conn);      if (conn.peerAddress != readData.peer) {       // TODO use new conn id, make sure the other endpoint has new conn id       if (isNonProbingPacket) {         if (packetNum == ackState.largestReceivedPacketNum) {           ShortHeader* shortHeader = regularPacket.header.asShort();           bool intentionalMigration = false;           if (shortHeader &&               shortHeader->getConnectionId() != conn.serverConnectionId) {             intentionalMigration = true;           }           onConnectionMigration(conn, readData.peer, intentionalMigration);         }       } else {         // Server will need to response with PathResponse to the new address         // while not updating peerAddress to new address         if (conn.qLogger) {           conn.qLogger->addPacketDrop(               packetSize,               QuicTransportStatsCallback::toString(                   PacketDropReason::PEER_ADDRESS_CHANGE));         }         QUIC_STATS(             conn.statsCallback,             onPacketDropped,             PacketDropReason::PEER_ADDRESS_CHANGE);         throw QuicTransportException(             ""Probing not supported yet"", TransportErrorCode::INVALID_MIGRATION);       }     }      // Try reading bytes off of crypto, and performing a handshake.     auto data = readDataFromCryptoStream(         *getCryptoStream(*conn.cryptoState, encryptionLevel));     if (data) {       conn.serverHandshakeLayer->doHandshake(std::move(data), encryptionLevel);        try {         updateHandshakeState(conn);       } catch (...) {         if (conn.qLogger) {           conn.qLogger->addPacketDrop(               packetSize,               QuicTransportStatsCallback::toString(                   PacketDropReason::TRANSPORT_PARAMETER_ERROR));         }         QUIC_STATS(             conn.statsCallback,             onPacketDropped,             QuicTransportStatsCallback::PacketDropReason::                 TRANSPORT_PARAMETER_ERROR);         throw;       }     }     updateAckSendStateOnRecvPacket(         conn,         ackState,         outOfOrder,         pktHasRetransmittableData,         pktHasCryptoData);     if (encryptionLevel == EncryptionLevel::Handshake &&         conn.version != QuicVersion::MVFST_D24 && conn.initialWriteCipher) {       conn.initialWriteCipher.reset();       conn.initialHeaderCipher.reset();       conn.readCodec->setInitialReadCipher(nullptr);       conn.readCodec->setInitialHeaderCipher(nullptr);       implicitAckCryptoStream(conn, EncryptionLevel::Initial);     }     QUIC_STATS(conn.statsCallback, onPacketProcessed);   }   VLOG_IF(4, !udpData.empty())       << ""Leaving "" << udpData.chainLength()       << "" bytes unprocessed after attempting to process ""       << kMaxNumCoalescedPackets << "" packets.""; }"
"231781_not_vulnerable.cpp","not_vulnerable","TEST_F(QuicUnencryptedServerTransportTest, TestSendHandshakeDone) {   getFakeHandshakeLayer()->allowZeroRttKeys();   setupClientReadCodec();   recvClientHello(true, QuicVersion::QUIC_DRAFT);   recvClientFinished(true, nullptr, QuicVersion::QUIC_DRAFT);   auto& packets = server->getConn().outstandings.packets;   ASSERT_FALSE(packets.empty());   int numHandshakeDone = 0;   for (auto& p : packets) {     for (auto& f : p.packet.frames) {       auto s = f.asQuicSimpleFrame();       if (s) {         if (s->asHandshakeDoneFrame()) {           numHandshakeDone++;         }       }     }   }   EXPECT_EQ(numHandshakeDone, 1); }"
"232294_not_vulnerable.cpp","not_vulnerable","bool SingleComponentLSScan::WriteMCU(void) { #if ACCUSOFT_CODE   int lines             = m_ulRemaining[0]; // total number of MCU lines processed.   UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();   struct Line *line     = CurrentLine(0);      assert(m_ucCount == 1);    //   // A ""MCU"" in respect to the code organization is eight lines.   if (lines > 8) {     lines = 8;   }   m_ulRemaining[0] -= lines;   assert(lines > 0);    // Loop over lines and columns   do {     LONG length = m_ulWidth[0];     LONG *lp    = line->m_pData;      BeginWriteMCU(m_Stream.ByteStreamOf()); // MCU is a single line.     StartLine(0);     do {       LONG a,b,c,d,x; // neighbouring values.       LONG d1,d2,d3;  // local gradients.              GetContext(0,a,b,c,d);       x   = *lp >> preshift;              d1  = d - b;    // compute local gradients       d2  = b - c;       d3  = c - a;        if (isRunMode(d1,d2,d3)) {         LONG runval = a;         LONG runcnt = 0;         do {           x  = *lp >> preshift;           if (x - runval < -m_lNear || x - runval > m_lNear)             break;           // Update so that the next process gets the correct value.           // Also updates the line pointers.           UpdateContext(0,runval);         } while(lp++,runcnt++,--length);         // Encode the run. Depends on whether the run was interrupted         // by the end of the line.         EncodeRun(runcnt,length == 0,m_lRunIndex[0]);         // Continue the encoding of the end of the run if there are more         // samples to encode.         if (length) {           bool negative; // the sign variable           bool rtype;    // run interruption type           LONG errval;   // the prediction error           LONG merr;     // the mapped error (symbol)           LONG rx;       // the reconstructed value           UBYTE k;       // golomb parameter           // Get the neighbourhood.           GetContext(0,a,b,c,d);           // Get the prediction mode.           rtype  = InterruptedPredictionMode(negative,a,b);           // Compute the error value.           errval = x - ((rtype)?(a):(b));           if (negative)             errval = -errval;           // Quantize the error.           errval = QuantizePredictionError(errval);           // Compute the reconstructed value.           rx     = Reconstruct(negative,rtype?a:b,errval);           // Update so that the next process gets the correct value.           UpdateContext(0,rx);           // Get the golomb parameter for run interruption coding.           k      = GolombParameter(rtype);           // Map the error into a symbol.           merr   = ErrorMapping(errval,ErrorMappingOffset(rtype,errval != 0,k)) - rtype;           // Golomb-coding of the error.           GolombCode(k,merr,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);           // Update the variables of the run mode.           UpdateState(rtype,errval);           // Update the run index now. This is not part of           // EncodeRun because the non-reduced run-index is           // required for the golomb coder length limit.           if (m_lRunIndex[0] > 0)             m_lRunIndex[0]--;         } else break; // Line ended, abort the loop over the line.       } else {          UWORD ctxt;         bool  negative; // the sign variable.         LONG  px;       // the predicted variable.         LONG  rx;       // the reconstructed value.         LONG  errval;   // the error value.         LONG  merr;     // the mapped error value.         UBYTE k;        // the Golomb parameter.         // Quantize the gradients.         d1     = QuantizedGradient(d1);         d2     = QuantizedGradient(d2);         d3     = QuantizedGradient(d3);         // Compute the context.         ctxt   = Context(negative,d1,d2,d3);          // Compute the predicted value.         px     = Predict(a,b,c);         // Correct the prediction.         px     = CorrectPrediction(ctxt,negative,px);         // Compute the error value.         errval = x - px;         if (negative)           errval = -errval;         // Quantize the prediction error if NEAR > 0         errval = QuantizePredictionError(errval);         // Compute the reconstructed value.         rx     = Reconstruct(negative,px,errval);         // Update so that the next process gets the correct value.         UpdateContext(0,rx);         // Compute the golomb parameter k from the context.         k      = GolombParameter(ctxt);         // Map the error into a symbol         merr   = ErrorMapping(errval,ErrorMappingOffset(ctxt,k));         // Golomb-coding of the error.         GolombCode(k,merr,m_lLimit);         // Update the variables.         UpdateState(ctxt,errval);       }     } while(++lp,--length);     EndLine(0);     line = line->m_pNext;   } while(--lines); #endif   return false; }"
"232329_not_vulnerable.cpp","not_vulnerable","static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode) { 	GF_Box *a; 	u64 totSize, mdat_end=0; 	GF_Err e = GF_OK;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 	if (mov->single_moof_mode && mov->single_moof_state == 2) { 		return e; 	}  	/*restart from where we stopped last*/ 	totSize = mov->current_top_box_start; 	if (mov->bytes_removed) { 		assert(totSize >= mov->bytes_removed); 		totSize -= mov->bytes_removed; 	} 	gf_bs_seek(mov->movieFileMap->bs, totSize); #endif   	/*while we have some data, parse our boxes*/ 	while (gf_bs_available(mov->movieFileMap->bs)) { 		*bytesMissing = 0; #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed; 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Parsing a top-level box at position %d\n"", mov->current_top_box_start)); #endif  		e = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);  		if (e >= 0) { 			//safety check, should never happen 			if (!a) return GF_ISOM_INVALID_FILE; 		} else if (e == GF_ISOM_INCOMPLETE_FILE) { 			/*our mdat is uncomplete, only valid for READ ONLY files...*/ 			if (mov->openMode != GF_ISOM_OPEN_READ) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			if ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete file while reading for dump - aborting parsing\n"")); 				break; 			} 			return e; 		} else { 			return e; 		}  		switch (a->type) { 		/*MOOV box*/ 		case GF_ISOM_BOX_TYPE_MOOV: 			if (mov->moov) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate MOOV detected!\n"")); 				gf_isom_box_del(a); 				return GF_ISOM_INVALID_FILE; 			} 			mov->moov = (GF_MovieBox *)a; 			mov->original_moov_offset = mov->current_top_box_start; 			/*set our pointer to the movie*/ 			mov->moov->mov = mov; #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (mov->moov->mvex) mov->moov->mvex->mov = mov;  #ifdef GF_ENABLE_CTRN 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				gf_isom_setup_traf_inheritance(mov); 			} #endif  #endif 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e;  			totSize += a->size;              if (!mov->moov->mvhd) {                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MovieHeaderBox\n""));                 return GF_ISOM_INVALID_FILE;             }              if (mov->meta) { 				gf_isom_meta_restore_items_ref(mov, mov->meta); 			}  			//dump senc info in dump mode 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				u32 k; 				for (k=0; k<gf_list_count(mov->moov->trackList); k++) { 					GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);  					if (trak->sample_encryption) { 						e = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption); 						if (e) return e; 					} 				} 			} else { 				u32 k; 				for (k=0; k<gf_list_count(mov->moov->trackList); k++) { 					GF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k); 					if (trak->Media->information->sampleTable->sampleGroups) { 						convert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups); 					} 				} 			}              if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {                 gf_isom_push_mdat_end(mov, mdat_end);                 mdat_end=0;             } 			break;  		/*META box*/ 		case GF_ISOM_BOX_TYPE_META: 			if (mov->meta) { 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate META detected!\n"")); 				gf_isom_box_del(a); 				return GF_ISOM_INVALID_FILE; 			} 			mov->meta = (GF_MetaBox *)a; 			mov->original_meta_offset = mov->current_top_box_start; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) { 				return e; 			} 			totSize += a->size; 			gf_isom_meta_restore_items_ref(mov, mov->meta); 			break;  		/*we only keep the MDAT in READ for dump purposes*/ 		case GF_ISOM_BOX_TYPE_MDAT: 			if (!mov->first_data_toplevel_offset) { 				mov->first_data_toplevel_offset = mov->current_top_box_start; 				mov->first_data_toplevel_size = a->size; 			} 			totSize += a->size;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 			if (mov->emsgs) { 				gf_isom_box_array_del(mov->emsgs); 				mov->emsgs = NULL; 			} #endif  			if (mov->openMode == GF_ISOM_OPEN_READ) { 				if (!mov->mdat) { 					mov->mdat = (GF_MediaDataBox *) a; 					e = gf_list_add(mov->TopBoxes, mov->mdat); 					if (e) { 						return e; 					} 				} #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 				else if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a); #endif 				else gf_isom_box_del(a); //in other modes we don't care   				if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {                     mdat_end = gf_bs_get_position(mov->movieFileMap->bs);                     if (mov->moov) {                         gf_isom_push_mdat_end(mov, mdat_end);                         mdat_end=0;                     } 				} 			} 			/*if we don't have any MDAT yet, create one (edit-write mode) 			We only work with one mdat, but we're puting it at the place 			of the first mdat found when opening a file for editing*/ 			else if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) { 				gf_isom_box_del(a); 				mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT); 				if (!mov->mdat) return GF_OUT_OF_MEM; 				e = gf_list_add(mov->TopBoxes, mov->mdat); 				if (e) { 					return e; 				} 			} else { 				gf_isom_box_del(a); 			} 			break; 		case GF_ISOM_BOX_TYPE_FTYP: 			/*ONE AND ONLY ONE FTYP*/ 			if (mov->brand) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'ftyp' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			mov->brand = (GF_FileTypeBox *)a; 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break;  		case GF_ISOM_BOX_TYPE_OTYP: 			/*ONE AND ONLY ONE FTYP*/ 			if (mov->otyp) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'otyp' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			}  			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				mov->otyp = (GF_Box *)a; 				totSize += a->size; 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} else { 				GF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP); 				if (brand) { 					s32 pos; 					gf_list_del_item(a->child_boxes, brand); 					pos = gf_list_del_item(mov->TopBoxes, mov->brand); 					gf_isom_box_del((GF_Box *) mov->brand); 					mov->brand = brand; 					if (pos<0) pos=0; 					gf_list_insert(mov->TopBoxes, brand, pos); 				} 				gf_isom_box_del(a); 			} 			break;  		case GF_ISOM_BOX_TYPE_PDIN: 			/*ONE AND ONLY ONE PDIN*/ 			if (mov->pdin) { 				gf_isom_box_del(a); 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Duplicate 'pdin'' detected!\n"")); 				return GF_ISOM_INVALID_FILE; 			} 			mov->pdin = (GF_ProgressiveDownloadBox *) a; 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break;   #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		case GF_ISOM_BOX_TYPE_STYP: 		{ 			u32 brand = ((GF_FileTypeBox *)a)->majorBrand; 			switch (brand) { 			case GF_ISOM_BRAND_SISX: 			case GF_ISOM_BRAND_RISX: 			case GF_ISOM_BRAND_SSSS: 				mov->is_index_segment = GF_TRUE; 				break; 			default: 				break; 			} 		} 		/*fall-through*/  		case GF_ISOM_BOX_TYPE_SIDX: 		case GF_ISOM_BOX_TYPE_SSIX: 			if (mov->moov && !mov->first_data_toplevel_offset) { 				mov->first_data_toplevel_offset = mov->current_top_box_start; 				mov->first_data_toplevel_size = a->size; 			} 			totSize += a->size; 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS) 			) { 				if (a->type==GF_ISOM_BOX_TYPE_SIDX) { 					if (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx); 					mov->root_sidx = (GF_SegmentIndexBox *) a; 					mov->sidx_start_offset = mov->current_top_box_start; 					mov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);  				} 				else if (a->type==GF_ISOM_BOX_TYPE_STYP) { 					mov->styp_start_offset = mov->current_top_box_start;  					if (mov->seg_styp) gf_isom_box_del(mov->seg_styp); 					mov->seg_styp = a; 				} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) { 					if (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix); 					mov->seg_ssix = a; 				} else { 					gf_isom_box_del(a); 				} 				gf_isom_push_mdat_end(mov, mov->current_top_box_start); 			} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) { 				if (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx); 				mov->main_sidx = (GF_SegmentIndexBox *) a; 				mov->main_sidx_end_pos = mov->current_top_box_start + a->size; 			} else { 				gf_isom_box_del(a); 			} 			break;  		case GF_ISOM_BOX_TYPE_MOOF: 			//no support for inplace rewrite for fragmented files 			gf_isom_disable_inplace_rewrite(mov); 			if (!mov->moov) { 				GF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\n"")); 			} 			if (mov->single_moof_mode) { 				mov->single_moof_state++; 				if (mov->single_moof_state > 1) { 					gf_isom_box_del(a); 					return GF_OK; 				} 			} 			((GF_MovieFragmentBox *)a)->mov = mov;  			totSize += a->size; 			mov->moof = (GF_MovieFragmentBox *) a;  			/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/ 			FixTrackID(mov); 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				FixSDTPInTRAF(mov->moof); 			} else { 				u32 k; 				for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 					GF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k); 					if (traf->sampleGroups) { 						convert_compact_sample_groups(traf->child_boxes, traf->sampleGroups); 					} 				} 			}  			/*read & debug: store at root level*/ 			if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) { 				u32 k; 				gf_list_add(mov->TopBoxes, a); 				/*also update pointers to trex for debug*/ 				if (mov->moov) { 					for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 						GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k); 						if (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) { 							GF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID); 							u32 j=0; 							while ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) { 								if (traf->trex->trackID == traf->tfhd->trackID) { 									if (!traf->trex->track) traf->trex->track = trak; 									break; 								} 								traf->trex = NULL; 							} 						} 						//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly 						if (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) { 							GF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID); 							if (trak) { 								trak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index; 								e = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption); 								if (e) return e; 								trak->current_traf_stsd_idx = 0; 							} 						} 					} 				} else { 					for (k=0; k<gf_list_count(mov->moof->TrackList); k++) { 						GF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k); 						if (traf->sample_encryption) { 							e = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption); 							if (e) return e; 						} 					}  				} 			} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) { 				mov->NextMoofNumber = mov->moof->mfhd->sequence_number+1; 				mov->moof = NULL; 				gf_isom_box_del(a); 			} else { 				/*merge all info*/ 				e = MergeFragment((GF_MovieFragmentBox *)a, mov); 				gf_isom_box_del(a); 				if (e) return e; 			}  			//done with moov 			if (mov->root_sidx) { 				gf_isom_box_del((GF_Box *) mov->root_sidx); 				mov->root_sidx = NULL; 			} 			if (mov->root_ssix) { 				gf_isom_box_del(mov->seg_ssix); 				mov->root_ssix = NULL; 			} 			if (mov->seg_styp) { 				gf_isom_box_del(mov->seg_styp); 				mov->seg_styp = NULL; 			} 			mov->sidx_start_offset = 0; 			mov->sidx_end_offset = 0; 			mov->styp_start_offset = 0; 			break; #endif 		case GF_ISOM_BOX_TYPE_UNKNOWN: 		{ 			GF_UnknownBox *box = (GF_UnknownBox*)a; 			if (box->original_4cc == GF_ISOM_BOX_TYPE_JP) { 				u8 *c = (u8 *) box->data; 				if ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A)) 					mov->is_jp2 = 1; 				gf_isom_box_del(a); 			} else { 				e = gf_list_add(mov->TopBoxes, a); 				if (e) return e; 			} 		} 		break;  		case GF_ISOM_BOX_TYPE_PRFT: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				//keep the last one read 				if (mov->last_producer_ref_time) 					gf_isom_box_del(a); 				else 					mov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a; 				break; 			} #endif 		//fallthrough 		case GF_ISOM_BOX_TYPE_EMSG: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				if (!mov->emsgs) mov->emsgs = gf_list_new(); 				gf_list_add(mov->emsgs, a); 				break; 			} #endif 		case GF_ISOM_BOX_TYPE_MFRA: 		case GF_ISOM_BOX_TYPE_MFRO: 			//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file 			if (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) { 				totSize += a->size; 				gf_isom_box_del(a); 				break; 			} 		default: 			totSize += a->size; 			e = gf_list_add(mov->TopBoxes, a); 			if (e) return e; 			break; 		}  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		/*remember where we left, in case we append an entire number of movie fragments*/ 		mov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed; #endif 	}  	/*we need at least moov or meta*/ 	if (!mov->moov && !mov->meta #ifndef GPAC_DISABLE_ISOM_FRAGMENTS 	        && !mov->moof && !mov->is_index_segment #endif 	   ) { 		return GF_ISOM_INCOMPLETE_FILE; 	} 	/*we MUST have movie header*/ 	if (!gf_opts_get_bool(""core"", ""no-check"")) { 		if (mov->moov && !mov->moov->mvhd) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing MVHD in MOOV!\n"")); 			return GF_ISOM_INVALID_FILE; 		}  		/*we MUST have meta handler*/ 		if (mov->meta && !mov->meta->handler) { 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing handler in META!\n"")); 			return GF_ISOM_INVALID_FILE; 		} 	}  #ifndef GPAC_DISABLE_ISOM_WRITE  	if (mov->moov) { 		/*set the default interleaving time*/ 		mov->interleavingTime = mov->moov->mvhd->timeScale;  #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS 		/*in edit mode with successfully loaded fragments, delete all fragment signaling since 		file is no longer fragmented*/ 		if ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) { 			gf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex); 			mov->moov->mvex = NULL; 		} #endif  	}  	//create a default mdat if none was found 	if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) { 		mov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT); 		if (!mov->mdat) return GF_OUT_OF_MEM; 		e = gf_list_add(mov->TopBoxes, mov->mdat); 		if (e) return e; 	} #endif /*GPAC_DISABLE_ISOM_WRITE*/  	return GF_OK; }"
"232940_not_vulnerable.c","not_vulnerable","static CURLcode zstd_unencode_write(struct Curl_easy *data,                                     struct contenc_writer *writer,                                     const char *buf, size_t nbytes) {   CURLcode result = CURLE_OK;   struct zstd_params *zp = (struct zstd_params *)&writer->params;   ZSTD_inBuffer in;   ZSTD_outBuffer out;   size_t errorCode;    if(!zp->decomp) {     zp->decomp = malloc(DSIZ);     if(!zp->decomp)       return CURLE_OUT_OF_MEMORY;   }   in.pos = 0;   in.src = buf;   in.size = nbytes;    for(;;) {     out.pos = 0;     out.dst = zp->decomp;     out.size = DSIZ;      errorCode = ZSTD_decompressStream(zp->zds, &out, &in);     if(ZSTD_isError(errorCode)) {       return CURLE_BAD_CONTENT_ENCODING;     }     if(out.pos > 0) {       result = Curl_unencode_write(data, writer->downstream,                                    zp->decomp, out.pos);       if(result)         break;     }     if((in.pos == nbytes) && (out.pos < out.size))       break;   }    return result; }"
"232943_not_vulnerable.c","not_vulnerable","static CURLcode zstd_init_writer(struct Curl_easy *data,                                  struct contenc_writer *writer) {   struct zstd_params *zp = (struct zstd_params *)&writer->params;   (void)data;    if(!writer->downstream)     return CURLE_WRITE_ERROR;    zp->zds = ZSTD_createDStream();   zp->decomp = NULL;   return zp->zds ? CURLE_OK : CURLE_OUT_OF_MEMORY; }"
"233823_not_vulnerable.c","not_vulnerable","void fmtutil_read_atari_palette(deark *c, dbuf *f, i64 pos, 	de_color *dstpal, i64 ncolors_to_read, i64 ncolors_used, unsigned int flags) { 	i64 i; 	unsigned int n; 	int pal_bits = 0; // 9, 12, or 15. 0 = not yet determined 	u8 cr, cg, cb; 	u8 cr1, cg1, cb1; 	char cbuf[32]; 	char tmps[64]; 	const char *s;  	s = de_get_ext_option(c, ""atari:palbits""); 	if(s) { 		pal_bits = de_atoi(s); 	}  	if(pal_bits==0 && (flags&DE_FLAG_ATARI_15BIT_PAL)) { 		pal_bits = 15; 	}  	if(pal_bits==0) { 		// Pre-scan the palette, and try to guess whether Atari STE-style 12-bit 		// colors are used, instead of the usual 9-bit colors. 		// I don't know the best way to do this. Sometimes the 4th bit in each 		// nibble is used for extra color detail, and sometimes it just seems to 		// contain garbage. Maybe the logic should also depend on the file 		// format, or the number of colors. 		int bit_3_used = 0; 		int nibble_3_used = 0;  		for(i=0; i<ncolors_to_read; i++) { 			n = (unsigned int)dbuf_getu16be(f, pos + i*2); 			if(n&0xf000) { 				nibble_3_used = 1; 			} 			if(n&0x0888) { 				bit_3_used = 1; 			} 		}  		if(bit_3_used && !nibble_3_used) { 			de_dbg(c, ""12-bit palette colors detected""); 			pal_bits = 12; 		} 	}  	if(pal_bits<12) { // Default to 9 if <12 		pal_bits = 9; 	} 	else if(pal_bits<15) { 		pal_bits = 12; 	} 	else { 		pal_bits = 15; 	}  	for(i=0; i<ncolors_to_read; i++) { 		n = (unsigned int)dbuf_getu16be(f, pos + 2*i);  		if(pal_bits==15) { 			cr1 = (u8)((n>>6)&0x1c); 			if(n&0x0800) cr1+=2; 			if(n&0x8000) cr1++; 			cg1 = (u8)((n>>2)&0x1c); 			if(n&0x0080) cg1+=2; 			if(n&0x4000) cg1++; 			cb1 = (u8)((n<<2)&0x1c); 			if(n&0x0008) cb1+=2; 			if(n&0x2000) cb1++; 			cr = de_scale_n_to_255(31, cr1); 			cg = de_scale_n_to_255(31, cg1); 			cb = de_scale_n_to_255(31, cb1); 			de_snprintf(cbuf, sizeof(cbuf), ""%2d,%2d,%2d"", 				(int)cr1, (int)cg1, (int)cb1); 		} 		else if(pal_bits==12) { 			cr1 = (u8)((n>>7)&0x0e); 			if(n&0x800) cr1++; 			cg1 = (u8)((n>>3)&0x0e); 			if(n&0x080) cg1++; 			cb1 = (u8)((n<<1)&0x0e); 			if(n&0x008) cb1++; 			cr = scale_15_to_255(cr1); 			cg = scale_15_to_255(cg1); 			cb = scale_15_to_255(cb1); 			de_snprintf(cbuf, sizeof(cbuf), ""%2d,%2d,%2d"", 				(int)cr1, (int)cg1, (int)cb1); 		} 		else { 			cr1 = (u8)((n>>8)&0x07); 			cg1 = (u8)((n>>4)&0x07); 			cb1 = (u8)(n&0x07); 			cr = scale_7_to_255(cr1); 			cg = scale_7_to_255(cg1); 			cb = scale_7_to_255(cb1); 			de_snprintf(cbuf, sizeof(cbuf), ""%d,%d,%d"", 				(int)cr1, (int)cg1, (int)cb1); 		}  		dstpal[i] = DE_MAKE_RGB(cr, cg, cb); 		de_snprintf(tmps, sizeof(tmps), ""0x%04x (%s) ""DE_CHAR_RIGHTARROW"" "", n, cbuf); 		de_dbg_pal_entry2(c, i, dstpal[i], tmps, NULL, 			(i>=ncolors_used)?"" [unused]"":""""); 	} }"
"234164_not_vulnerable.c","not_vulnerable","free_dwo_info (void) {   dwo_info * dwinfo;   dwo_info * next;    for (dwinfo = first_dwo_info; dwinfo != NULL; dwinfo = next)     {       next = dwinfo->next;       free (dwinfo);     }   first_dwo_info = NULL; }"
"234169_not_vulnerable.c","not_vulnerable","display_block (unsigned char *data, 	       dwarf_vma length, 	       const unsigned char * const end, char delimiter) {   dwarf_vma maxlen;    printf (_(""%c%s byte block: ""), delimiter, dwarf_vmatoa (""u"", length));   if (data > end)     return (unsigned char *) end;    maxlen = (dwarf_vma) (end - data);   length = length > maxlen ? maxlen : length;    while (length --)     printf (""%lx "", (unsigned long) byte_get (data++, 1));    return data; }"
"234192_not_vulnerable.c","not_vulnerable","init_dwarf_regnames_by_bfd_arch_and_mach (enum bfd_architecture arch, 					  unsigned long mach) {   dwarf_regnames_lookup_func = NULL;    switch (arch)     {     case bfd_arch_i386:       switch (mach) 	{ 	case bfd_mach_x86_64: 	case bfd_mach_x86_64_intel_syntax: 	case bfd_mach_x64_32: 	case bfd_mach_x64_32_intel_syntax: 	  init_dwarf_regnames_x86_64 (); 	  break;  	default: 	  init_dwarf_regnames_i386 (); 	  break; 	}       break;      case bfd_arch_iamcu:       init_dwarf_regnames_iamcu ();       break;      case bfd_arch_aarch64:       init_dwarf_regnames_aarch64();       break;      case bfd_arch_s390:       init_dwarf_regnames_s390 ();       break;      case bfd_arch_riscv:       init_dwarf_regnames_riscv ();       break;      default:       break;     } }"
"234225_not_vulnerable.c","not_vulnerable","init_dwarf_regnames_s390 (void) {   dwarf_regnames = dwarf_regnames_s390;   dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_s390);   dwarf_regnames_lookup_func = regname_internal_by_table_only; }"
"234256_not_vulnerable.c","not_vulnerable","display_augmentation_data (const unsigned char * data, const bfd_size_type len) {   bfd_size_type i;    i = printf (_(""  Augmentation data:    ""));   display_data (i, data, len); }"
"234779_not_vulnerable.c","not_vulnerable","static u64 dev_extent_search_start(struct btrfs_device *device, u64 start) { 	switch (device->fs_devices->chunk_alloc_policy) { 	case BTRFS_CHUNK_ALLOC_REGULAR: 		/* 		 * We don't want to overwrite the superblock on the drive nor 		 * any area used by the boot loader (grub for example), so we 		 * make sure to start at an offset of at least 1MB. 		 */ 		return max_t(u64, start, SZ_1M); 	case BTRFS_CHUNK_ALLOC_ZONED: 		/* 		 * We don't care about the starting region like regular 		 * allocator, because we anyway use/reserve the first two zones 		 * for superblock logging. 		 */ 		return ALIGN(start, device->zone_info->zone_size); 	default: 		BUG(); 	} }"
"234820_not_vulnerable.c","not_vulnerable","static struct btrfs_device *add_missing_dev(struct btrfs_fs_devices *fs_devices, 					    u64 devid, u8 *dev_uuid) { 	struct btrfs_device *device; 	unsigned int nofs_flag;  	/* 	 * We call this under the chunk_mutex, so we want to use NOFS for this 	 * allocation, however we don't want to change btrfs_alloc_device() to 	 * always do NOFS because we use it in a lot of other GFP_KERNEL safe 	 * places. 	 */ 	nofs_flag = memalloc_nofs_save(); 	device = btrfs_alloc_device(NULL, &devid, dev_uuid); 	memalloc_nofs_restore(nofs_flag); 	if (IS_ERR(device)) 		return device;  	list_add(&device->dev_list, &fs_devices->devices); 	device->fs_devices = fs_devices; 	fs_devices->num_devices++;  	set_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state); 	fs_devices->missing_devices++;  	return device; }"
"234842_not_vulnerable.c","not_vulnerable","static void btrfs_set_dev_stats_value(struct extent_buffer *eb, 				      struct btrfs_dev_stats_item *ptr, 				      int index, u64 val) { 	write_extent_buffer(eb, &val, 			    offsetof(struct btrfs_dev_stats_item, values) + 			     ((unsigned long)ptr) + (index * sizeof(u64)), 			    sizeof(val)); }"
"236136_not_vulnerable.c","not_vulnerable","GF_Box *hlit_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_TextHighlightBox, GF_ISOM_BOX_TYPE_HLIT); 	return (GF_Box *) tmp; }"
"238380_not_vulnerable.c","not_vulnerable","njs_function_prototype_bind(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,     njs_index_t unused) {     size_t              size;     njs_int_t           ret;     njs_value_t         *values, name;     njs_function_t      *function;     njs_lvlhsh_query_t  lhq;      if (!njs_is_function(&args[0])) {         njs_type_error(vm, ""\""this\"" argument is not a function"");         return NJS_ERROR;     }      function = njs_mp_alloc(vm->mem_pool, sizeof(njs_function_t));     if (njs_slow_path(function == NULL)) {         njs_memory_error(vm);         return NJS_ERROR;     }      *function = *njs_function(&args[0]);      njs_lvlhsh_init(&function->object.hash);      /* Bound functions have no ""prototype"" property. */     function->object.shared_hash = vm->shared->arrow_instance_hash;      function->object.__proto__ = &vm->prototypes[NJS_OBJ_TYPE_FUNCTION].object;     function->object.shared = 0;      function->u.bound_target = njs_function(&args[0]);      njs_object_property_init(&lhq, &njs_string_name, NJS_NAME_HASH);      ret = njs_object_property(vm, &args[0], &lhq, &name);     if (njs_slow_path(ret == NJS_ERROR)) {         return ret;     }      if (!njs_is_string(&name)) {         name = njs_string_empty;     }      ret = njs_function_name_set(vm, function, &name, ""bound"");     if (njs_slow_path(ret == NJS_ERROR)) {         return ret;     }      if (nargs == 1) {         args = njs_value_arg(&njs_value_undefined);      } else {         nargs--;         args++;     }      if (nargs > function->args_count) {         function->args_count = 0;      } else {         function->args_count -= nargs - 1;     }      function->args_offset = nargs;     size = nargs * sizeof(njs_value_t);      values = njs_mp_alloc(vm->mem_pool, size);     if (njs_slow_path(values == NULL)) {         njs_memory_error(vm);         njs_mp_free(vm->mem_pool, function);         return NJS_ERROR;     }      function->bound = values;      /* GC: ? retain args. */      memcpy(values, args, size);      njs_set_function(&vm->retval, function);      return NJS_OK; }"
"238418_not_vulnerable.c","not_vulnerable","static void mark_btf_ld_reg(struct bpf_verifier_env *env, 			    struct bpf_reg_state *regs, u32 regno, 			    enum bpf_reg_type reg_type, 			    struct btf *btf, u32 btf_id) { 	if (reg_type == SCALAR_VALUE) { 		mark_reg_unknown(env, regs, regno); 		return; 	} 	mark_reg_known_zero(env, regs, regno); 	regs[regno].type = PTR_TO_BTF_ID; 	regs[regno].btf = btf; 	regs[regno].btf_id = btf_id; }"
"238611_not_vulnerable.c","not_vulnerable","static struct bpf_verifier_state *push_async_cb(struct bpf_verifier_env *env, 						int insn_idx, int prev_insn_idx, 						int subprog) { 	struct bpf_verifier_stack_elem *elem; 	struct bpf_func_state *frame;  	elem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL); 	if (!elem) 		goto err;  	elem->insn_idx = insn_idx; 	elem->prev_insn_idx = prev_insn_idx; 	elem->next = env->head; 	elem->log_pos = env->log.len_used; 	env->head = elem; 	env->stack_size++; 	if (env->stack_size > BPF_COMPLEXITY_LIMIT_JMP_SEQ) { 		verbose(env, 			""The sequence of %d jumps is too complex for async cb.\n"", 			env->stack_size); 		goto err; 	} 	/* Unlike push_stack() do not copy_verifier_state(). 	 * The caller state doesn't matter. 	 * This is async callback. It starts in a fresh stack. 	 * Initialize it similar to do_check_common(). 	 */ 	elem->st.branches = 1; 	frame = kzalloc(sizeof(*frame), GFP_KERNEL); 	if (!frame) 		goto err; 	init_func_state(env, frame, 			BPF_MAIN_FUNC /* callsite */, 			0 /* frameno within this callchain */, 			subprog /* subprog number within this prog */); 	elem->st.frame[0] = frame; 	return &elem->st; err: 	free_verifier_state(env->cur_state, true); 	env->cur_state = NULL; 	/* pop all elements and return */ 	while (!pop_stack(env, NULL, NULL, false)); 	return NULL; }"
"238642_not_vulnerable.c","not_vulnerable","static void scalar_min_max_add(struct bpf_reg_state *dst_reg, 			       struct bpf_reg_state *src_reg) { 	s64 smin_val = src_reg->smin_value; 	s64 smax_val = src_reg->smax_value; 	u64 umin_val = src_reg->umin_value; 	u64 umax_val = src_reg->umax_value;  	if (signed_add_overflows(dst_reg->smin_value, smin_val) || 	    signed_add_overflows(dst_reg->smax_value, smax_val)) { 		dst_reg->smin_value = S64_MIN; 		dst_reg->smax_value = S64_MAX; 	} else { 		dst_reg->smin_value += smin_val; 		dst_reg->smax_value += smax_val; 	} 	if (dst_reg->umin_value + umin_val < umin_val || 	    dst_reg->umax_value + umax_val < umax_val) { 		dst_reg->umin_value = 0; 		dst_reg->umax_value = U64_MAX; 	} else { 		dst_reg->umin_value += umin_val; 		dst_reg->umax_value += umax_val; 	} }"
"240263_not_vulnerable.c","not_vulnerable","init_write_reg(     int		name,     yankreg_T	**old_y_previous,     yankreg_T	**old_y_current,     int		must_append,     int		*yank_type UNUSED) {     if (!valid_yank_reg(name, TRUE))	    // check for valid reg name     { 	emsg_invreg(name); 	return FAIL;     }      // Don't want to change the current (unnamed) register     *old_y_previous = y_previous;     *old_y_current = y_current;      get_yank_register(name, TRUE);     if (!y_append && !must_append) 	free_yank_all();     return OK; }"
"240612_not_vulnerable.cc","not_vulnerable","ReadVariablesOp::ReadVariablesOp(OpKernelConstruction* c) : OpKernel(c) {   int n;   OP_REQUIRES_OK(c, c->GetAttr(""N"", &n));   OP_REQUIRES_OK(c, c->GetAttr(""dtypes"", &dtypes_));   OP_REQUIRES(c, n == dtypes_.size(),               errors::InvalidArgument(                   ""Mismatched number of arguments to ReadVariablesOp ("", n,                   "" vs. "", dtypes_.size(), "")"")); }"
"242132_not_vulnerable.cpp","not_vulnerable","int LuaSettings::l_set_bool(lua_State* L) { 	NO_MAP_LOCK_REQUIRED; 	LuaSettings* o = checkobject(L, 1);  	std::string key = std::string(luaL_checkstring(L, 2)); 	bool value = readParam<bool>(L, 3);  	CHECK_SETTING_SECURITY(L, key);  	o->m_settings->setBool(key, value);  	return 0; }"
"242925_not_vulnerable.cc","not_vulnerable","  explicit SparseTensorDenseAddOp(OpKernelConstruction *ctx) : OpKernel(ctx) {}"
"242952_not_vulnerable.c","not_vulnerable","static int ssl_parse_inner_plaintext( unsigned char const *content,                                           size_t *content_size,                                           uint8_t *rec_type ) {     size_t remaining = *content_size;      /* Determine length of padding by skipping zeroes from the back. */     do     {         if( remaining == 0 )             return( -1 );         remaining--;     } while( content[ remaining ] == 0 );      *content_size = remaining;     *rec_type = content[ remaining ];      return( 0 ); }"
"242956_not_vulnerable.c","not_vulnerable","static int ssl_check_record_type( uint8_t record_type ) {     if( record_type != MBEDTLS_SSL_MSG_HANDSHAKE &&         record_type != MBEDTLS_SSL_MSG_ALERT &&         record_type != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&         record_type != MBEDTLS_SSL_MSG_APPLICATION_DATA )     {         return( MBEDTLS_ERR_SSL_INVALID_RECORD );     }      return( 0 ); }"
"243008_not_vulnerable.c","not_vulnerable","static int mbedtls_ssl_dtls_record_replay_check( mbedtls_ssl_context *ssl, uint8_t *record_in_ctr ) {     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;     unsigned char *original_in_ctr;      // save original in_ctr     original_in_ctr = ssl->in_ctr;      // use counter from record     ssl->in_ctr = record_in_ctr;      ret = mbedtls_ssl_dtls_replay_check( (mbedtls_ssl_context const *) ssl );      // restore the counter     ssl->in_ctr = original_in_ctr;      return ret; }"
"244031_not_vulnerable.c","not_vulnerable","GF_Box *xtra_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA); 	tmp->tags = gf_list_new(); 	return (GF_Box *)tmp; }"
"244053_not_vulnerable.c","not_vulnerable","GF_Box *lsr1_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1); 	gf_isom_sample_entry_init((GF_SampleEntryBox*)tmp); 	return (GF_Box *)tmp; }"
"244064_not_vulnerable.c","not_vulnerable","GF_Err saio_box_size(GF_Box *s) { 	GF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;  	if (ptr->aux_info_type || ptr->aux_info_type_parameter) { 		ptr->flags |= 1; 	}  	if (ptr->flags & 1) ptr->size += 8; 	ptr->size += 4; 	//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed 	switch (ptr->aux_info_type) { 	case GF_ISOM_CENC_SCHEME: 	case GF_ISOM_CBC_SCHEME: 	case GF_ISOM_CENS_SCHEME: 	case GF_ISOM_CBCS_SCHEME: 		if (ptr->offsets) gf_free(ptr->offsets); 		ptr->offsets = NULL; 		ptr->entry_alloc = 0; 		ptr->entry_count = 1; 		break; 	}  	ptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count; 	return GF_OK; }"
"244113_not_vulnerable.c","not_vulnerable","GF_Err pcmC_box_size(GF_Box *s) { 	s->size += 2; 	return GF_OK; }"
"244122_not_vulnerable.c","not_vulnerable","GF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs) { 	GF_Err e; 	GF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;  	e = gf_isom_full_box_write(s, bs); 	if (e) return e; 	if (ptr->string) 		gf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string)); 	gf_bs_write_u8(bs, 0); 	return GF_OK; }"
"244187_not_vulnerable.c","not_vulnerable","static void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size) { 	if (!field_size) return;  	if (field_size==8) flags = flags>>24; 	else if (field_size==16) flags = flags>>16; 	gf_bs_write_int(bs, flags, field_size); }"
"244218_not_vulnerable.c","not_vulnerable","GF_Box *void_box_new() { 	ISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID); 	return tmp; }"
"244245_not_vulnerable.c","not_vulnerable","GF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs) { 	GF_Err e; 	GF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;  	e = gf_isom_full_box_write(s, bs); 	if (e) return e; 	if (ptr->type==GF_ISOM_BOX_TYPE_CBMP) { 		gf_bs_write_u32(bs, ptr->layout); 		gf_bs_write_u32(bs, ptr->padding); 	} 	else if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) { 		gf_bs_write_u32(bs, ptr->bounds_top); 		gf_bs_write_u32(bs, ptr->bounds_bottom); 		gf_bs_write_u32(bs, ptr->bounds_left); 		gf_bs_write_u32(bs, ptr->bounds_right); 	} else { 		gf_bs_write_u32(bs, ptr->crc); 		gf_bs_write_u32(bs, ptr->encoding_4cc); 	} 	return GF_OK; }"
"244262_not_vulnerable.c","not_vulnerable","GF_Err lsrc_box_size(GF_Box *s) { 	GF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s; 	ptr->size += ptr->hdr_size; 	return GF_OK; }"
"244308_not_vulnerable.c","not_vulnerable","GF_Err vwid_box_size(GF_Box *s) { 	u32 i; 	GF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s; 	ptr->size += 3; 	for (i=0; i<ptr->num_views; i++) { 		ptr->size += 6 + 2 * ptr->views[i].num_ref_views; 	} 	return GF_OK; }"
"244344_not_vulnerable.c","not_vulnerable","GF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs) { 	GF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s; 	ptr->opcfg.version = gf_bs_read_u8(bs); 	if (ptr->opcfg.version) { 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] Opus config version not 0 !\n"", ptr->size)); 		return GF_NOT_SUPPORTED; 	} 	//force version to 1 as used in ogg/opus 	ptr->opcfg.version = 1; 	ptr->opcfg.OutputChannelCount = gf_bs_read_u8(bs); 	ptr->opcfg.PreSkip = gf_bs_read_u16(bs); 	ptr->opcfg.InputSampleRate = gf_bs_read_u32(bs); 	ptr->opcfg.OutputGain = gf_bs_read_u16(bs); 	ptr->opcfg.ChannelMappingFamily = gf_bs_read_u8(bs); 	ISOM_DECREASE_SIZE(ptr, 11) 	if (ptr->size) { 		ISOM_DECREASE_SIZE(ptr, 2+ptr->opcfg.OutputChannelCount); 		ptr->opcfg.StreamCount = gf_bs_read_u8(bs); 		ptr->opcfg.CoupledCount = gf_bs_read_u8(bs); 		gf_bs_read_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount); 	} 	return GF_OK; }"
"245195_not_vulnerable.cc","not_vulnerable","eat_sql_whitespace(const char *query) { 	bool comment = false;  	while (*query) { 		if (comment) { 			if (query[0] == '*' && query[1] == '/') { 				query += 2; 				comment = false; 				continue; 			} 			++query; 			continue; 		} 		if (query[0] == '/' && query[1] == '*') { 			query += 2; 			comment = true; 			continue; 		} 		if (strchr(""\t\n\r ("", query[0])) { 			++query; 			continue; 		} 		break; 	}  	return(query); }"
"246455_not_vulnerable.c","not_vulnerable","const char *r_bin_wasm_valuetype_to_string (r_bin_wasm_value_type_t type) { 	switch (type) { 	case R_BIN_WASM_VALUETYPE_i32: 		return ""i32""; 	case R_BIN_WASM_VALUETYPE_i64: 		return ""i62""; 	case R_BIN_WASM_VALUETYPE_f32: 		return ""f32""; 	case R_BIN_WASM_VALUETYPE_f64: 		return ""f64""; 	case R_BIN_WASM_VALUETYPE_REFTYPE: 		return ""ANYFUNC""; 	case R_BIN_WASM_VALUETYPE_FUNC: 		return ""FUNC""; 	default: 		return ""<?>""; 	} }"
"246465_not_vulnerable.c","not_vulnerable","static void free_type_entry(RBinWasmTypeEntry *ptr) { 	if (ptr) { 		free_type_vec (ptr->args); 		free_type_vec (ptr->rets); 		free (ptr->to_str); 		free (ptr); 	} }"
"246481_not_vulnerable.c","not_vulnerable","static size_t consume_u1_r(RBuffer *b, ut64 bound, ut8 *out) { 	size_t n = 0; 	ut32 tmp = consume_r (b, bound, &n, read_u32_leb128); 	if (out) { 		*out = (ut8) (tmp & 0x1); 	} 	return n; }"
"246643_not_vulnerable.c","not_vulnerable","static GF_Err naludmx_initialize(GF_Filter *filter) { 	GF_NALUDmxCtx *ctx = gf_filter_get_udta(filter); 	ctx->sps = gf_list_new(); 	ctx->pps = gf_list_new(); 	switch (ctx->nal_length) { 	case 1: 		ctx->max_nalu_size_allowed = 0xFF; 		break; 	case 2: 		ctx->max_nalu_size_allowed = 0xFFFF; 		break; 	case 4: 		ctx->max_nalu_size_allowed = 0xFFFFFFFF; 		break; 	case 0: 		ctx->max_nalu_size_allowed = 0xFFFFFFFF; 		ctx->nal_length = 4; 		ctx->nal_adjusted = GF_TRUE; 		break; 	default: 		GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[%s] NAL size length %d is not allowed, defaulting to 4 bytes\n"", ctx->log_name)); 		ctx->max_nalu_size_allowed = 0xFFFFFFFF; 		ctx->nal_length = 4; 		break; 	} 	return GF_OK; }"
"246665_not_vulnerable.c","not_vulnerable","static void naludmx_log_stats(GF_NALUDmxCtx *ctx) { 	u32 i, count; 	const char *msg_import; 	u32 nb_frames = 0; 	if (ctx->cur_fps.den) 		nb_frames = (u32) (ctx->dts / ctx->cur_fps.den);  	if (ctx->dur.den && ctx->dur.num) { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s duration specified at import time, may have parsed more frames than imported\n"", ctx->log_name)); 		msg_import = ""parsed""; 	} else { 		msg_import = ""Import results:""; 	}  	if (ctx->nb_si || ctx->nb_sp) { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s %s %d frames (%d NALUs) - Slices: %d I %d P %d B %d SP %d SI - %d SEI - %d IDR\n"", ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sp, ctx->nb_si, ctx->nb_sei, ctx->nb_idr )); 	} else if (ctx->vvc_no_stats) { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s %s %d samples (%d NALUs) - %d SEI - %d IDR - %d CRA\n"", 			                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra)); 	} else { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s %s %d samples (%d NALUs) - Slices: %d I %d P %d B - %d SEI - %d IDR - %d CRA\n"", 			                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra)); 	}  	if (ctx->codecid==GF_CODECID_AVC) { 		count = gf_list_count(ctx->sps); 		for (i=0; i<count; i++) { 			AVC_SPS *sps; 			GF_NALUFFParam *svcc = (GF_NALUFFParam*)gf_list_get(ctx->sps, i); 			sps = & ctx->avc_state->sps[svcc->id]; 			if (sps->nb_ei || sps->nb_ep) { 				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s SVC (SSPS ID %d, %dx%d) %s Slices: %d I %d P %d B\n"", ctx->log_name, svcc->id - GF_SVC_SSPS_ID_SHIFT, sps->width, sps->height, msg_import, sps->nb_ei, sps->nb_ep, sps->nb_eb )); 			} 		} 	} else if (ctx->nb_e_i || ctx->nb_e_p || ctx->nb_e_b) { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s L-HEVC %s Slices: %d I %d P %d B\n"", ctx->log_name, msg_import, ctx->nb_e_i, ctx->nb_e_p, ctx->nb_e_b )); 	}  	if (ctx->max_total_delay>1) { 		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s Stream uses forward prediction - stream CTS offset: %d frames\n"", ctx->log_name, ctx->max_total_delay)); 	}  	if (!ctx->nal_adjusted) { 		if ((ctx->max_nalu_size < 0xFF) && (ctx->nal_length>1) ){ 			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s Max NALU size is %d - stream could be optimized by setting nal_length=1\n"", ctx->log_name, ctx->max_nalu_size)); 		} else if ((ctx->max_nalu_size < 0xFFFF) && (ctx->nal_length>2) ){ 			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""%s Max NALU size is %d - stream could be optimized by setting nal_length=2\n"", ctx->log_name, ctx->max_nalu_size)); 		} 	} }"
"246670_not_vulnerable.c","not_vulnerable","static Bool create_new_track_action(char *arg_val, u32 act_type, u32 dump_type) { 	TrackAction *tka; 	char *param = arg_val; 	tracks = (TrackAction *)gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act+1)); 	if (!tracks) return GF_FALSE;  	tka = & tracks[nb_track_act]; 	nb_track_act++;  	memset(tka, 0, sizeof(TrackAction) ); 	tka->act_type = act_type; 	tka->dump_type = dump_type; 	if (act_type != TRAC_ACTION_RAW_EXTRACT) { 		open_edit = GF_TRUE; 		do_save = GF_TRUE; 	}  	if ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) { 		if (sscanf(param, ""%d:%u"", &tka->trackID, &tka->newTrackID) != 2) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for -set-track-id - expecting \""id1:id2\"" got \""%s\""\n"", param)); 			return GF_FALSE; 		} 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_PAR) { 		char *ext; 		ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '=';  		if (!stricmp(ext+1, ""none"")) 			tka->par_num = tka->par_den = 0; 		else if (!stricmp(ext+1, ""auto"")) { 			tka->par_num = tka->par_den = -1; 			tka->force_par = 1; 		} 		else if (!stricmp(ext+1, ""force"")) { 			tka->par_num = tka->par_den = 1; 			tka->force_par = 1; 		} 		else { 			if (ext[1]=='w') { 				tka->rewrite_bs = 1; 				ext++; 			} 			if (sscanf(ext+1, ""%d:%d"", &tka->par_num, &tka->par_den) != 2) { 				M4_LOG(GF_LOG_ERROR, (""Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\n"", param)); 				return GF_FALSE; 			} 		} 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_CLAP) { 		char *ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '='; 		if (stricmp(ext + 1, ""none"")) { 			if (sscanf(ext + 1, ""%d,%d,%d,%d,%d,%d,%d,%d"", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {  				M4_LOG(GF_LOG_ERROR, (""Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\n"", param)); 				return GF_FALSE; 			} 		} 		return GF_TRUE; 	}  	if (act_type==TRAC_ACTION_SET_MX) { 		char *ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '='; 		if (!stricmp(ext + 1, ""none"")) { 			memset(tka->mx, 0, sizeof(s32)*9); 			tka->mx[0] = tka->mx[4] = tka->mx[8] = 1; 		} else { 			s32 res; 			if (strstr(ext+1, ""0x"")) { 				res = sscanf(ext + 1, ""0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d"", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]); 			} else { 				res = sscanf(ext + 1, ""%d:%d:%d:%d:%d:%d:%d:%d:%d"", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]); 			} 			if (res != 9) { 				M4_LOG(GF_LOG_ERROR, (""Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\n"", param)); 				return GF_FALSE; 			} 		} 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_EDITS) { 		char *ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track edits - expecting ID=EDITS got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '='; 		tka->string = gf_strdup(ext+1); 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_LANGUAGE) { 		char *ext = strchr(param, '='); 		if (!strnicmp(param, ""all="", 4)) { 			strncpy(tka->lang, param + 4, 10-1); 		} 		else if (!ext) { 			strncpy(tka->lang, param, 10-1); 		} else { 			strncpy(tka->lang, ext + 1, 10-1); 			ext[0] = 0; 			tka->trackID = atoi(param); 			ext[0] = '='; 		} 		return GF_TRUE; 	} 	if ((act_type==TRAC_ACTION_SET_KIND) || (act_type==TRAC_ACTION_REM_KIND)) { 		char *ext; 		char *scheme_start = NULL;  		//extract trackID 		if (!strnicmp(param, ""all="", 4)) { 			scheme_start = param + 4; 		} else { 			ext = strchr(param, '='); 			if (ext) { 				ext[0] = 0; 				if (sscanf(param, ""%d"", &tka->trackID) == 1) { 					scheme_start = ext + 1; 				} else { 					scheme_start = param; 				} 				ext[0] = '='; 			} else { 				scheme_start = param; 			} 		}  		//extract scheme and value - if not, remove kind 		if (!scheme_start || !scheme_start[0]) { 			M4_LOG(GF_LOG_ERROR, (""Missing kind scheme - expecting ID=schemeURI=value got %s\n"", param)); 			return GF_FALSE; 		} else { 			ext = strchr(scheme_start, '='); 			if (!ext) { 				tka->kind_scheme = gf_strdup(scheme_start); 			} else { 				ext[0] = 0; 				tka->kind_scheme = gf_strdup(scheme_start); 				ext[0] = '='; 				tka->kind_value = gf_strdup(ext + 1); 			} 		} 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_DELAY) { 		char *ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track delay - expecting tkID=DLAY got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '='; 		if (sscanf(ext+1, ""%d/%u"", &tka->delay.num, &tka->delay.den) != 2) { 			tka->delay.num = atoi(ext + 1); 			tka->delay.den = 1000; 		} 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_REFERENCE) { 		char *ext = strchr(param, '='); 		if (!ext) ext = strchr(param, ':'); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track reference - expecting tkID:XXXX:refID got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '=';  		char *ext2 = strchr(ext, ':'); 		if (!ext2) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track reference - expecting tkID:XXXX:refID got %s\n"", param)); 			return GF_FALSE; 		} 		ext2[0] = 0; 		strncpy(tka->lang, ext+1, 9); 		ext2[0] = ':'; 		tka->newTrackID = (s32) atoi(ext2 + 1); 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_HANDLER_NAME) { 		char *ext = strchr(param, '='); 		if (!ext) { 			M4_LOG(GF_LOG_ERROR, (""Bad format for track name - expecting tkID=name got %s\n"", param)); 			return GF_FALSE; 		} 		ext[0] = 0; 		tka->trackID = atoi(param); 		ext[0] = '='; 		tka->hdl_name = ext + 1; 		return GF_TRUE; 	} 	if (act_type==TRAC_ACTION_SET_KMS_URI) { 		char *ext = strchr(param, '=');  		if (!strnicmp(param, ""all="", 4)) { 			tka->kms = param + 4; 		} else if (!ext) { 			tka->kms = param; 		} else { 			tka->kms = ext + 1; 			ext[0] = 0; 			tka->trackID = atoi(param); 			ext[0] = '='; 		} 		return GF_TRUE; 	} 	if ((act_type==TRAC_ACTION_SET_TIME) || (act_type==TRAC_ACTION_SET_MEDIA_TIME)) { 		struct tm time; 		char *ext = strchr(arg_val, '='); 		if (ext) { 			ext[0] = 0; 			tka->trackID = atoi(arg_val); 			ext[0] = '='; 			arg_val = ext+1; 		} 		memset(&time, 0, sizeof(struct tm)); 		sscanf(arg_val, ""%d/%d/%d-%d:%d:%d"", &time.tm_mday, &time.tm_mon, &time.tm_year, &time.tm_hour, &time.tm_min, &time.tm_sec); 		time.tm_isdst = 0; 		time.tm_year -= 1900; 		time.tm_mon -= 1; 		tka->time = 2082758400; 		tka->time += mktime(&time); 		return GF_TRUE; 	}  	while (param) { 		param = gf_url_colon_suffix(param); 		if (param) { 			*param = 0; 			param++; #ifndef GPAC_DISABLE_MEDIA_EXPORT 			if (!strncmp(""vttnomerge"", param, 10)) { 				tka->dump_type |= GF_EXPORT_WEBVTT_NOMERGE; 			} else if (!strncmp(""layer"", param, 5)) { 				tka->dump_type |= GF_EXPORT_SVC_LAYER; 			} else if (!strncmp(""full"", param, 4)) { 				tka->dump_type |= GF_EXPORT_NHML_FULL; 			} else if (!strncmp(""embedded"", param, 8)) { 				tka->dump_type |= GF_EXPORT_WEBVTT_META_EMBEDDED; 			} else if (!strncmp(""output="", param, 7)) { 				tka->out_name = gf_strdup(param+7); 			} else if (!strncmp(""src="", param, 4)) { 				tka->src_name = gf_strdup(param+4); 			} else if (!strncmp(""str="", param, 4)) { 				tka->string = gf_strdup(param+4); 			} else if (!strncmp(""box="", param, 4)) { 				tka->src_name = gf_strdup(param+4); 				tka->sample_num = 1; 			} else if (!strncmp(""type="", param, 4)) { 				tka->udta_type = GF_4CC(param[5], param[6], param[7], param[8]); 			} else if (tka->dump_type == GF_EXPORT_RAW_SAMPLES) { 				tka->sample_num = atoi(param); 			} #endif 		} 	} 	if (arg_val) { 		if (!strcmp(arg_val, ""*"")) { 			tka->trackID = (u32) -1; 		} else { 			if (act_type==TRAC_ACTION_RAW_EXTRACT) { 				if (!strncmp(arg_val, ""video"", 5)) { 					arg_val += 5; 					tka->dump_track_type = 1; 				} 				else if (!strncmp(arg_val, ""audio"", 5)) { 					arg_val += 5; 					tka->dump_track_type = 2; 				} 			} 			if (arg_val[0]) 				tka->trackID = atoi(arg_val); 		} 	} 	return GF_TRUE; }"
"247105_not_vulnerable.c","not_vulnerable","static void filter_abort(GF_FSTask *task) { 	GF_FilterEvent evt; 	GF_FEVT_INIT(evt, GF_FEVT_STOP, task->pid);  	task->pid->filter->freg->process_event(task->pid->filter, &evt); 	gf_filter_pid_set_eos(task->pid); 	task->pid->filter->disabled = GF_TRUE; 	safe_int_dec(&task->pid->filter->abort_pending);  }"
"247117_not_vulnerable.c","not_vulnerable","GF_Err gf_fs_post_user_task(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name) { 	GF_UserTask *utask; 	char *_log_name; 	if (!fsess || !task_execute) return GF_BAD_PARAM; 	GF_SAFEALLOC(utask, GF_UserTask); 	if (!utask) return GF_OUT_OF_MEM; 	utask->fsess = fsess; 	utask->callback = udta_callback; 	utask->task_execute = task_execute; 	//dup mem for user task 	_log_name = gf_strdup(log_name ? log_name : ""user_task""); 	gf_fs_post_task(fsess, gf_fs_user_task, NULL, NULL, _log_name, utask); 	return GF_OK; }"
"247530_not_vulnerable.cc","not_vulnerable","TEST_P(SslSocketTest, FailedClientCertificateHashVerificationWrongCA) {   const std::string client_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"" )EOF"";    const std::string server_ctx_yaml = absl::StrCat(R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""     validation_context:       trusted_ca:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem""       verify_certificate_hash: "")EOF"",                                                    TEST_SAN_URI_CERT_256_HASH, ""\"""");    TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());   testUtil(test_options.setExpectedServerStats(""ssl.fail_verify_error"")                .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)); }"
"247587_not_vulnerable.cc","not_vulnerable","TEST_P(SslSocketTest, MultiCertPreferEcdsa) {   const std::string client_ctx_yaml = absl::StrCat(R""EOF(     common_tls_context:       tls_params:         tls_minimum_protocol_version: TLSv1_2         tls_maximum_protocol_version: TLSv1_2         cipher_suites:         - ECDHE-ECDSA-AES128-GCM-SHA256         - ECDHE-RSA-AES128-GCM-SHA256       validation_context:         verify_certificate_hash: )EOF"",                                                    TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);    const std::string server_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:     - certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_key.pem""     - certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem"" )EOF"";    TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());   testUtil(test_options); }"
"247631_not_vulnerable.cc","not_vulnerable","TEST_P(SslSocketTest, GetCertDigestServerCertWithoutCommonName) {   const std::string client_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem"" )EOF"";    const std::string server_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_key.pem""     validation_context:       trusted_ca:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"" )EOF"";    TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());   testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)                .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)                .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)); }"
"247677_not_vulnerable.cc","not_vulnerable","TEST_P(SslSocketTest, GetUriWithLocalUriSan) {   const std::string client_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem"" )EOF"";    const std::string server_ctx_yaml = R""EOF(   common_tls_context:     tls_certificates:       certificate_chain:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""       private_key:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem""     validation_context:       trusted_ca:         filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"" )EOF"";    TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());   testUtil(test_options.setExpectedLocalUri(""spiffe://lyft.com/test-team"")                .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)); }"
"247710_not_vulnerable.cc","not_vulnerable","  const std::vector<std::string>& expectedLocalUri() const { return expected_local_uri_; }"
"248241_not_vulnerable.c","not_vulnerable","DLLIMPORT cfg_t *cfg_getnsec(cfg_t *cfg, const char *name, unsigned int index) { 	return cfg_opt_getnsec(cfg_getopt(cfg, name), index); }"
"248258_not_vulnerable.c","not_vulnerable","static cfg_opt_t *cfg_getopt_array(cfg_opt_t *rootopts, int cfg_flags, const char *name) { 	unsigned int i; 	cfg_opt_t *opts = rootopts;  	if (!rootopts || !name) { 		errno = EINVAL; 		return NULL; 	}  	while (name && *name) { 		cfg_t *seccfg; 		char *secname; 		size_t len = strcspn(name, ""|"");  		if (name[len] == 0 /*len == strlen(name) */ ) 			/* no more subsections */ 			break;  		if (len) { 			cfg_opt_t *secopt;  			secname = strndup(name, len); 			if (!secname) 				return NULL;  			secopt = cfg_getopt_array(opts, cfg_flags, secname); 			free(secname); 			if (!secopt) { 				/*fprintf(stderr, ""section not found\n""); */ 				return NULL; 			} 			if (secopt->type != CFGT_SEC) { 				/*fprintf(stderr, ""not a section!\n""); */ 				return NULL; 			}  			if (!is_set(CFGF_MULTI, secopt->flags) && (seccfg = cfg_opt_getnsec(secopt, 0)) != NULL) 				opts = seccfg->opts; 			else 				opts = secopt->subopts;  			if (!opts) { 				/*fprintf(stderr, ""section have no subopts!?\n""); */ 				return NULL; 			} 		} 		name += len; 		name += strspn(name, ""|""); 	}  	for (i = 0; opts[i].name; i++) { 		if (is_set(CFGF_NOCASE, cfg_flags)) { 			if (strcasecmp(opts[i].name, name) == 0) 				return &opts[i]; 		} else { 			if (strcmp(opts[i].name, name) == 0) 				return &opts[i]; 		} 	}  	return NULL; }"
"248267_not_vulnerable.c","not_vulnerable","DLLIMPORT cfg_t *cfg_addtsec(cfg_t *cfg, const char *name, const char *title) { 	cfg_opt_t *opt; 	cfg_value_t *val;  	if (cfg_gettsec(cfg, name, title)) 		return NULL;  	opt = cfg_getopt(cfg, name); 	if (!opt) { 		cfg_error(cfg, _(""no such option '%s'""), name); 		return NULL; 	} 	val = cfg_setopt(cfg, opt, title); 	if (!val) 		return NULL;  	val->section->path = cfg->path; /* Remember global search path. */ 	val->section->line = 1; 	val->section->errfunc = cfg->errfunc;  	return val->section; }"
"248274_not_vulnerable.c","not_vulnerable","DLLIMPORT signed long cfg_getint(cfg_t *cfg, const char *name) { 	return cfg_getnint(cfg, name, 0); }"
"248297_not_vulnerable.c","not_vulnerable","static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts) { 	int i; 	cfg_opt_t *dupopts; 	int n = cfg_numopts(opts);  	dupopts = calloc(n + 1, sizeof(cfg_opt_t)); 	if (!dupopts) 		return NULL;  	memcpy(dupopts, opts, n * sizeof(cfg_opt_t));  	for (i = 0; i < n; i++) { 		/* Clear dynamic ptrs, protecting the original on failure */ 		dupopts[i].name = NULL; 		dupopts[i].subopts = NULL; 		dupopts[i].def.parsed = NULL; 		dupopts[i].def.string = NULL; 		dupopts[i].comment = NULL; 	}  	for (i = 0; i < n; i++) { 		dupopts[i].name = strdup(opts[i].name); 		if (!dupopts[i].name) 			goto err;  		if (opts[i].subopts) { 			dupopts[i].subopts = cfg_dupopt_array(opts[i].subopts); 			if (!dupopts[i].subopts) 				goto err; 		}  		if (opts[i].def.parsed) { 			dupopts[i].def.parsed = strdup(opts[i].def.parsed); 			if (!dupopts[i].def.parsed) 				goto err; 		}  		if (opts[i].def.string) { 			dupopts[i].def.string = strdup(opts[i].def.string); 			if (!dupopts[i].def.string) 				goto err; 		}  		if (opts[i].comment) { 			dupopts[i].comment = strdup(opts[i].comment); 			if (!dupopts[i].comment) 				goto err; 		} 	}  	return dupopts; err: 	cfg_free_opt_array(dupopts); 	return NULL; }"
"248304_not_vulnerable.c","not_vulnerable","DLLIMPORT void cfg_error(cfg_t *cfg, const char *fmt, ...) { 	va_list ap;  	va_start(ap, fmt);  	if (cfg && cfg->errfunc) 		(*cfg->errfunc) (cfg, fmt, ap); 	else { 		if (cfg && cfg->filename && cfg->line) 			fprintf(stderr, ""%s:%d: "", cfg->filename, cfg->line); 		else if (cfg && cfg->filename) 			fprintf(stderr, ""%s: "", cfg->filename); 		vfprintf(stderr, fmt, ap); 		fprintf(stderr, ""\n""); 	}  	va_end(ap); }"
"248746_not_vulnerable.c","not_vulnerable","struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,                                     const char *file,                                     struct CookieInfo *inc,                                     bool newsession) {   struct CookieInfo *c;   FILE *fp = NULL;   bool fromfile = TRUE;   char *line = NULL;    if(!inc) {     /* we didn't get a struct, create one */     c = calloc(1, sizeof(struct CookieInfo));     if(!c)       return NULL; /* failed to get memory */     c->filename = strdup(file?file:""none""); /* copy the name just in case */     if(!c->filename)       goto fail; /* failed to get memory */     /*      * Initialize the next_expiration time to signal that we don't have enough      * information yet.      */     c->next_expiration = CURL_OFF_T_MAX;   }   else {     /* we got an already existing one, use that */     c = inc;   }   c->running = FALSE; /* this is not running, this is init */    if(file && !strcmp(file, ""-"")) {     fp = stdin;     fromfile = FALSE;   }   else if(!file || !*file) {     /* points to an empty string or NULL */     fp = NULL;   }   else {     fp = fopen(file, FOPEN_READTEXT);     if(!fp)       infof(data, ""WARNING: failed to open cookie file \""%s\"""", file);   }    c->newsession = newsession; /* new session? */    if(fp) {     char *lineptr;     bool headerline;      line = malloc(MAX_COOKIE_LINE);     if(!line)       goto fail;     while(Curl_get_line(line, MAX_COOKIE_LINE, fp)) {       if(checkprefix(""Set-Cookie:"", line)) {         /* This is a cookie line, get it! */         lineptr = &line[11];         headerline = TRUE;       }       else {         lineptr = line;         headerline = FALSE;       }       while(*lineptr && ISBLANK(*lineptr))         lineptr++;        Curl_cookie_add(data, c, headerline, TRUE, lineptr, NULL, NULL, TRUE);     }     free(line); /* free the line buffer */      /*      * Remove expired cookies from the hash. We must make sure to run this      * after reading the file, and not on every cookie.      */     remove_expired(c);      if(fromfile && fp)       fclose(fp);   }    c->running = TRUE;          /* now, we're running */   if(data)     data->state.cookie_engine = TRUE;    return c;  fail:   free(line);   /*    * Only clean up if we allocated it here, as the original could still be in    * use by a share handle.    */   if(!inc)     Curl_cookie_cleanup(c);   if(fromfile && fp)     fclose(fp);   return NULL; /* out of memory */ }"
"248766_not_vulnerable.c","not_vulnerable","static char *sanitize_cookie_path(const char *cookie_path) {   size_t len;   char *new_path = strdup(cookie_path);   if(!new_path)     return NULL;    /* some stupid site sends path attribute with '""'. */   len = strlen(new_path);   if(new_path[0] == '\""') {     memmove((void *)new_path, (const void *)(new_path + 1), len);     len--;   }   if(len && (new_path[len - 1] == '\""')) {     new_path[len - 1] = 0x0;     len--;   }    /* RFC6265 5.2.4 The Path Attribute */   if(new_path[0] != '/') {     /* Let cookie-path be the default-path. */     strstore(&new_path, ""/"");     return new_path;   }    /* convert /hoge/ to /hoge */   if(len && new_path[len - 1] == '/') {     new_path[len - 1] = 0x0;   }    return new_path; }"
"252317_not_vulnerable.h","not_vulnerable","static bool DecompressPiz(unsigned char *outPtr, const unsigned char *inPtr,                           size_t tmpBufSize, size_t inLen, int num_channels,                           const EXRChannelInfo *channels, int data_width,                           int num_lines) {   if (inLen == tmpBufSize) {     // Data is not compressed(Issue 40).     memcpy(outPtr, inPtr, inLen);     return true;   }    std::vector<unsigned char> bitmap(BITMAP_SIZE);   unsigned short minNonZero;   unsigned short maxNonZero;  #if !MINIZ_LITTLE_ENDIAN   // @todo { PIZ compression on BigEndian architecture. }   assert(0);   return false; #endif    memset(bitmap.data(), 0, BITMAP_SIZE);    const unsigned char *ptr = inPtr;   // minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));   tinyexr::cpy2(&minNonZero, reinterpret_cast<const unsigned short *>(ptr));   // maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));   tinyexr::cpy2(&maxNonZero, reinterpret_cast<const unsigned short *>(ptr + 2));   ptr += 4;    if (maxNonZero >= BITMAP_SIZE) {     return false;   }    if (minNonZero <= maxNonZero) {     memcpy(reinterpret_cast<char *>(&bitmap[0] + minNonZero), ptr,            maxNonZero - minNonZero + 1);     ptr += maxNonZero - minNonZero + 1;   }    std::vector<unsigned short> lut(USHORT_RANGE);   memset(lut.data(), 0, sizeof(unsigned short) * USHORT_RANGE);   unsigned short maxValue = reverseLutFromBitmap(bitmap.data(), lut.data());    //   // Huffman decoding   //    int length;    // length = *(reinterpret_cast<const int *>(ptr));   tinyexr::cpy4(&length, reinterpret_cast<const int *>(ptr));   ptr += sizeof(int);    if (size_t((ptr - inPtr) + length) > inLen) {     return false;   }    std::vector<unsigned short> tmpBuffer(tmpBufSize);   hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer);    //   // Wavelet decoding   //    std::vector<PIZChannelData> channelData(static_cast<size_t>(num_channels));    unsigned short *tmpBufferEnd = &tmpBuffer.at(0);    for (size_t i = 0; i < static_cast<size_t>(num_channels); ++i) {     const EXRChannelInfo &chan = channels[i];      size_t pixelSize = sizeof(int);  // UINT and FLOAT     if (chan.pixel_type == TINYEXR_PIXELTYPE_HALF) {       pixelSize = sizeof(short);     }      channelData[i].start = tmpBufferEnd;     channelData[i].end = channelData[i].start;     channelData[i].nx = data_width;     channelData[i].ny = num_lines;     // channelData[i].ys = 1;     channelData[i].size = static_cast<int>(pixelSize / sizeof(short));      tmpBufferEnd += channelData[i].nx * channelData[i].ny * channelData[i].size;   }    for (size_t i = 0; i < channelData.size(); ++i) {     PIZChannelData &cd = channelData[i];      for (int j = 0; j < cd.size; ++j) {       wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,                  maxValue);     }   }    //   // Expand the pixel data to their original range   //    applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBufSize));    for (int y = 0; y < num_lines; y++) {     for (size_t i = 0; i < channelData.size(); ++i) {       PIZChannelData &cd = channelData[i];        // if (modp (y, cd.ys) != 0)       //    continue;        size_t n = static_cast<size_t>(cd.nx * cd.size);       memcpy(outPtr, cd.end, static_cast<size_t>(n * sizeof(unsigned short)));       outPtr += n * sizeof(unsigned short);       cd.end += n;     }   }    return true; }"
"252345_not_vulnerable.h","not_vulnerable","static unsigned int readUInt(const char buf[4]) {   const unsigned char *b = (const unsigned char *)buf;    return (b[0] & 0x000000ff) | ((b[1] << 8) & 0x0000ff00) |          ((b[2] << 16) & 0x00ff0000) | ((b[3] << 24) & 0xff000000); }"
"252359_not_vulnerable.h","not_vulnerable","mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,                                      tdefl_put_buf_func_ptr pPut_buf_func,                                      void *pPut_buf_user, int flags) {   tdefl_compressor *pComp;   mz_bool succeeded;   if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;   pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));   if (!pComp) return MZ_FALSE;   succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==                TDEFL_STATUS_OKAY);   succeeded =       succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==                     TDEFL_STATUS_DONE);   MZ_FREE(pComp);   return succeeded; }"
"252371_not_vulnerable.h","not_vulnerable","static FILE *mz_fopen(const char *pFilename, const char *pMode) {   FILE *pFile = NULL;   fopen_s(&pFile, pFilename, pMode);   return pFile; }"
"252423_not_vulnerable.h","not_vulnerable","static MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(     mz_zip_archive *pZip, mz_uint file_index) {   if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) ||       (pZip->m_zip_mode != MZ_ZIP_MODE_READING))     return NULL;   return &MZ_ZIP_ARRAY_ELEMENT(       &pZip->m_pState->m_central_dir, mz_uint8,       MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,                            file_index)); }"
"252453_not_vulnerable.h","not_vulnerable","mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,                                    char *pFilename, mz_uint filename_buf_size) {   mz_uint n;   const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);   if (!p) {     if (filename_buf_size) pFilename[0] = '\0';     return 0;   }   n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);   if (filename_buf_size) {     n = MZ_MIN(n, filename_buf_size - 1);     memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);     pFilename[n] = '\0';   }   return n + 1; }"
"252455_not_vulnerable.h","not_vulnerable","static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip,                                               mz_zip_array *pArray) {   pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);   memset(pArray, 0, sizeof(mz_zip_array)); }"
"253528_not_vulnerable.c","not_vulnerable","static long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon, 			    loff_t offset, loff_t len) { 	struct inode *inode; 	struct cifsFileInfo *cfile = file->private_data; 	struct file_zero_data_information fsctl_buf; 	long rc; 	unsigned int xid; 	__u8 set_sparse = 1;  	xid = get_xid();  	inode = d_inode(cfile->dentry);  	/* Need to make file sparse, if not already, before freeing range. */ 	/* Consider adding equivalent for compressed since it could also work */ 	if (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse)) { 		rc = -EOPNOTSUPP; 		free_xid(xid); 		return rc; 	}  	filemap_invalidate_lock(inode->i_mapping); 	/* 	 * We implement the punch hole through ioctl, so we need remove the page 	 * caches first, otherwise the data may be inconsistent with the server. 	 */ 	truncate_pagecache_range(inode, offset, offset + len - 1);  	cifs_dbg(FYI, ""Offset %lld len %lld\n"", offset, len);  	fsctl_buf.FileOffset = cpu_to_le64(offset); 	fsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);  	rc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid, 			cfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA, 			true /* is_fctl */, (char *)&fsctl_buf, 			sizeof(struct file_zero_data_information), 			CIFSMaxBufSize, NULL, NULL); 	free_xid(xid); 	filemap_invalidate_unlock(inode->i_mapping); 	return rc; }"
"253554_not_vulnerable.c","not_vulnerable","static int smb3_simple_fallocate_range(unsigned int xid, 				       struct cifs_tcon *tcon, 				       struct cifsFileInfo *cfile, 				       loff_t off, loff_t len) { 	struct file_allocated_range_buffer in_data, *out_data = NULL, *tmp_data; 	u32 out_data_len; 	char *buf = NULL; 	loff_t l; 	int rc;  	in_data.file_offset = cpu_to_le64(off); 	in_data.length = cpu_to_le64(len); 	rc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid, 			cfile->fid.volatile_fid, 			FSCTL_QUERY_ALLOCATED_RANGES, true, 			(char *)&in_data, sizeof(in_data), 			1024 * sizeof(struct file_allocated_range_buffer), 			(char **)&out_data, &out_data_len); 	if (rc) 		goto out;  	buf = kzalloc(1024 * 1024, GFP_KERNEL); 	if (buf == NULL) { 		rc = -ENOMEM; 		goto out; 	}  	tmp_data = out_data; 	while (len) { 		/* 		 * The rest of the region is unmapped so write it all. 		 */ 		if (out_data_len == 0) { 			rc = smb3_simple_fallocate_write_range(xid, tcon, 					       cfile, off, len, buf); 			goto out; 		}  		if (out_data_len < sizeof(struct file_allocated_range_buffer)) { 			rc = -EINVAL; 			goto out; 		}  		if (off < le64_to_cpu(tmp_data->file_offset)) { 			/* 			 * We are at a hole. Write until the end of the region 			 * or until the next allocated data, 			 * whichever comes next. 			 */ 			l = le64_to_cpu(tmp_data->file_offset) - off; 			if (len < l) 				l = len; 			rc = smb3_simple_fallocate_write_range(xid, tcon, 					       cfile, off, l, buf); 			if (rc) 				goto out; 			off = off + l; 			len = len - l; 			if (len == 0) 				goto out; 		} 		/* 		 * We are at a section of allocated data, just skip forward 		 * until the end of the data or the end of the region 		 * we are supposed to fallocate, whichever comes first. 		 */ 		l = le64_to_cpu(tmp_data->length); 		if (len < l) 			l = len; 		off += l; 		len -= l;  		tmp_data = &tmp_data[1]; 		out_data_len -= sizeof(struct file_allocated_range_buffer); 	}   out: 	kfree(out_data); 	kfree(buf); 	return rc; }"
"253564_not_vulnerable.c","not_vulnerable","smb2_sync_read(const unsigned int xid, struct cifs_fid *pfid, 	       struct cifs_io_parms *parms, unsigned int *bytes_read, 	       char **buf, int *buf_type) { 	parms->persistent_fid = pfid->persistent_fid; 	parms->volatile_fid = pfid->volatile_fid; 	return SMB2_read(xid, parms, bytes_read, buf, buf_type); }"
"253577_not_vulnerable.c","not_vulnerable","smb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon, 		   struct cifsFileInfo *cfile) { 	struct fsctl_set_integrity_information_req integr_info; 	unsigned int ret_data_len;  	integr_info.ChecksumAlgorithm = cpu_to_le16(CHECKSUM_TYPE_UNCHANGED); 	integr_info.Flags = 0; 	integr_info.Reserved = 0;  	return SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid, 			cfile->fid.volatile_fid, 			FSCTL_SET_INTEGRITY_INFORMATION, 			true /* is_fsctl */, 			(char *)&integr_info, 			sizeof(struct fsctl_set_integrity_information_req), 			CIFSMaxBufSize, NULL, 			&ret_data_len);  }"
"253584_not_vulnerable.c","not_vulnerable","smb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon, 	     struct cifs_sb_info *cifs_sb, struct kstatfs *buf) { 	struct smb2_query_info_rsp *rsp; 	struct smb2_fs_full_size_info *info = NULL; 	struct kvec rsp_iov = {NULL, 0}; 	int buftype = CIFS_NO_BUFFER; 	int rc;   	rc = smb2_query_info_compound(xid, tcon, """", 				      FILE_READ_ATTRIBUTES, 				      FS_FULL_SIZE_INFORMATION, 				      SMB2_O_INFO_FILESYSTEM, 				      sizeof(struct smb2_fs_full_size_info), 				      &rsp_iov, &buftype, cifs_sb); 	if (rc) 		goto qfs_exit;  	rsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base; 	buf->f_type = SMB2_SUPER_MAGIC; 	info = (struct smb2_fs_full_size_info *)( 		le16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp); 	rc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset), 			       le32_to_cpu(rsp->OutputBufferLength), 			       &rsp_iov, 			       sizeof(struct smb2_fs_full_size_info)); 	if (!rc) 		smb2_copy_fs_info_to_kstatfs(info, buf);  qfs_exit: 	free_rsp_buf(buftype, rsp_iov.iov_base); 	return rc; }"
"253610_not_vulnerable.c","not_vulnerable","fill_transform_hdr(struct smb2_transform_hdr *tr_hdr, unsigned int orig_len, 		   struct smb_rqst *old_rq, __le16 cipher_type) { 	struct smb2_hdr *shdr = 			(struct smb2_hdr *)old_rq->rq_iov[0].iov_base;  	memset(tr_hdr, 0, sizeof(struct smb2_transform_hdr)); 	tr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM; 	tr_hdr->OriginalMessageSize = cpu_to_le32(orig_len); 	tr_hdr->Flags = cpu_to_le16(0x01); 	if ((cipher_type == SMB2_ENCRYPTION_AES128_GCM) || 	    (cipher_type == SMB2_ENCRYPTION_AES256_GCM)) 		get_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE); 	else 		get_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE); 	memcpy(&tr_hdr->SessionId, &shdr->SessionId, 8); }"
"253619_not_vulnerable.c","not_vulnerable","smb2_copychunk_range(const unsigned int xid, 			struct cifsFileInfo *srcfile, 			struct cifsFileInfo *trgtfile, u64 src_off, 			u64 len, u64 dest_off) { 	int rc; 	unsigned int ret_data_len; 	struct copychunk_ioctl *pcchunk; 	struct copychunk_ioctl_rsp *retbuf = NULL; 	struct cifs_tcon *tcon; 	int chunks_copied = 0; 	bool chunk_sizes_updated = false; 	ssize_t bytes_written, total_bytes_written = 0;  	pcchunk = kmalloc(sizeof(struct copychunk_ioctl), GFP_KERNEL);  	if (pcchunk == NULL) 		return -ENOMEM;  	cifs_dbg(FYI, ""%s: about to call request res key\n"", __func__); 	/* Request a key from the server to identify the source of the copy */ 	rc = SMB2_request_res_key(xid, tlink_tcon(srcfile->tlink), 				srcfile->fid.persistent_fid, 				srcfile->fid.volatile_fid, pcchunk);  	/* Note: request_res_key sets res_key null only if rc !=0 */ 	if (rc) 		goto cchunk_out;  	/* For now array only one chunk long, will make more flexible later */ 	pcchunk->ChunkCount = cpu_to_le32(1); 	pcchunk->Reserved = 0; 	pcchunk->Reserved2 = 0;  	tcon = tlink_tcon(trgtfile->tlink);  	while (len > 0) { 		pcchunk->SourceOffset = cpu_to_le64(src_off); 		pcchunk->TargetOffset = cpu_to_le64(dest_off); 		pcchunk->Length = 			cpu_to_le32(min_t(u32, len, tcon->max_bytes_chunk));  		/* Request server copy to target from src identified by key */ 		kfree(retbuf); 		retbuf = NULL; 		rc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid, 			trgtfile->fid.volatile_fid, FSCTL_SRV_COPYCHUNK_WRITE, 			true /* is_fsctl */, (char *)pcchunk, 			sizeof(struct copychunk_ioctl),	CIFSMaxBufSize, 			(char **)&retbuf, &ret_data_len); 		if (rc == 0) { 			if (ret_data_len != 					sizeof(struct copychunk_ioctl_rsp)) { 				cifs_tcon_dbg(VFS, ""Invalid cchunk response size\n""); 				rc = -EIO; 				goto cchunk_out; 			} 			if (retbuf->TotalBytesWritten == 0) { 				cifs_dbg(FYI, ""no bytes copied\n""); 				rc = -EIO; 				goto cchunk_out; 			} 			/* 			 * Check if server claimed to write more than we asked 			 */ 			if (le32_to_cpu(retbuf->TotalBytesWritten) > 			    le32_to_cpu(pcchunk->Length)) { 				cifs_tcon_dbg(VFS, ""Invalid copy chunk response\n""); 				rc = -EIO; 				goto cchunk_out; 			} 			if (le32_to_cpu(retbuf->ChunksWritten) != 1) { 				cifs_tcon_dbg(VFS, ""Invalid num chunks written\n""); 				rc = -EIO; 				goto cchunk_out; 			} 			chunks_copied++;  			bytes_written = le32_to_cpu(retbuf->TotalBytesWritten); 			src_off += bytes_written; 			dest_off += bytes_written; 			len -= bytes_written; 			total_bytes_written += bytes_written;  			cifs_dbg(FYI, ""Chunks %d PartialChunk %d Total %zu\n"", 				le32_to_cpu(retbuf->ChunksWritten), 				le32_to_cpu(retbuf->ChunkBytesWritten), 				bytes_written); 		} else if (rc == -EINVAL) { 			if (ret_data_len != sizeof(struct copychunk_ioctl_rsp)) 				goto cchunk_out;  			cifs_dbg(FYI, ""MaxChunks %d BytesChunk %d MaxCopy %d\n"", 				le32_to_cpu(retbuf->ChunksWritten), 				le32_to_cpu(retbuf->ChunkBytesWritten), 				le32_to_cpu(retbuf->TotalBytesWritten));  			/* 			 * Check if this is the first request using these sizes, 			 * (ie check if copy succeed once with original sizes 			 * and check if the server gave us different sizes after 			 * we already updated max sizes on previous request). 			 * if not then why is the server returning an error now 			 */ 			if ((chunks_copied != 0) || chunk_sizes_updated) 				goto cchunk_out;  			/* Check that server is not asking us to grow size */ 			if (le32_to_cpu(retbuf->ChunkBytesWritten) < 					tcon->max_bytes_chunk) 				tcon->max_bytes_chunk = 					le32_to_cpu(retbuf->ChunkBytesWritten); 			else 				goto cchunk_out; /* server gave us bogus size */  			/* No need to change MaxChunks since already set to 1 */ 			chunk_sizes_updated = true; 		} else 			goto cchunk_out; 	}  cchunk_out: 	kfree(pcchunk); 	kfree(retbuf); 	if (rc) 		return rc; 	else 		return total_bytes_written; }"
"253705_not_vulnerable.c","not_vulnerable","static int ccp_run_ecc_mm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd) { 	struct ccp_ecc_engine *ecc = &cmd->u.ecc; 	struct ccp_dm_workarea src, dst; 	struct ccp_op op; 	int ret; 	u8 *save;  	if (!ecc->u.mm.operand_1 || 	    (ecc->u.mm.operand_1_len > CCP_ECC_MODULUS_BYTES)) 		return -EINVAL;  	if (ecc->function != CCP_ECC_FUNCTION_MINV_384BIT) 		if (!ecc->u.mm.operand_2 || 		    (ecc->u.mm.operand_2_len > CCP_ECC_MODULUS_BYTES)) 			return -EINVAL;  	if (!ecc->u.mm.result || 	    (ecc->u.mm.result_len < CCP_ECC_MODULUS_BYTES)) 		return -EINVAL;  	memset(&op, 0, sizeof(op)); 	op.cmd_q = cmd_q; 	op.jobid = CCP_NEW_JOBID(cmd_q->ccp);  	/* Concatenate the modulus and the operands. Both the modulus and 	 * the operands must be in little endian format.  Since the input 	 * is in big endian format it must be converted and placed in a 	 * fixed length buffer. 	 */ 	ret = ccp_init_dm_workarea(&src, cmd_q, CCP_ECC_SRC_BUF_SIZE, 				   DMA_TO_DEVICE); 	if (ret) 		return ret;  	/* Save the workarea address since it is updated in order to perform 	 * the concatenation 	 */ 	save = src.address;  	/* Copy the ECC modulus */ 	ret = ccp_reverse_set_dm_area(&src, 0, ecc->mod, 0, ecc->mod_len); 	if (ret) 		goto e_src; 	src.address += CCP_ECC_OPERAND_SIZE;  	/* Copy the first operand */ 	ret = ccp_reverse_set_dm_area(&src, 0, ecc->u.mm.operand_1, 0, 				      ecc->u.mm.operand_1_len); 	if (ret) 		goto e_src; 	src.address += CCP_ECC_OPERAND_SIZE;  	if (ecc->function != CCP_ECC_FUNCTION_MINV_384BIT) { 		/* Copy the second operand */ 		ret = ccp_reverse_set_dm_area(&src, 0, ecc->u.mm.operand_2, 0, 					      ecc->u.mm.operand_2_len); 		if (ret) 			goto e_src; 		src.address += CCP_ECC_OPERAND_SIZE; 	}  	/* Restore the workarea address */ 	src.address = save;  	/* Prepare the output area for the operation */ 	ret = ccp_init_dm_workarea(&dst, cmd_q, CCP_ECC_DST_BUF_SIZE, 				   DMA_FROM_DEVICE); 	if (ret) 		goto e_src;  	op.soc = 1; 	op.src.u.dma.address = src.dma.address; 	op.src.u.dma.offset = 0; 	op.src.u.dma.length = src.length; 	op.dst.u.dma.address = dst.dma.address; 	op.dst.u.dma.offset = 0; 	op.dst.u.dma.length = dst.length;  	op.u.ecc.function = cmd->u.ecc.function;  	ret = cmd_q->ccp->vdata->perform->ecc(&op); 	if (ret) { 		cmd->engine_error = cmd_q->cmd_error; 		goto e_dst; 	}  	ecc->ecc_result = le16_to_cpup( 		(const __le16 *)(dst.address + CCP_ECC_RESULT_OFFSET)); 	if (!(ecc->ecc_result & CCP_ECC_RESULT_SUCCESS)) { 		ret = -EIO; 		goto e_dst; 	}  	/* Save the ECC result */ 	ccp_reverse_get_dm_area(&dst, 0, ecc->u.mm.result, 0, 				CCP_ECC_MODULUS_BYTES);  e_dst: 	ccp_dm_free(&dst);  e_src: 	ccp_dm_free(&src);  	return ret; }"
"253709_not_vulnerable.c","not_vulnerable","static int ccp_init_sg_workarea(struct ccp_sg_workarea *wa, struct device *dev, 				struct scatterlist *sg, u64 len, 				enum dma_data_direction dma_dir) { 	memset(wa, 0, sizeof(*wa));  	wa->sg = sg; 	if (!sg) 		return 0;  	wa->nents = sg_nents_for_len(sg, len); 	if (wa->nents < 0) 		return wa->nents;  	wa->bytes_left = len; 	wa->sg_used = 0;  	if (len == 0) 		return 0;  	if (dma_dir == DMA_NONE) 		return 0;  	wa->dma_sg = sg; 	wa->dma_sg_head = sg; 	wa->dma_dev = dev; 	wa->dma_dir = dma_dir; 	wa->dma_count = dma_map_sg(dev, sg, wa->nents, dma_dir); 	if (!wa->dma_count) 		return -ENOMEM;  	return 0; }"
"253982_not_vulnerable.c","not_vulnerable","static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b) { 	enum v4l2_buf_type type; 	int index; 	struct v4l2_loopback_device *dev; 	struct v4l2_loopback_opener *opener;  	MARK();  	type = b->type; 	index = b->index; 	dev = v4l2loopback_getdevice(file); 	opener = file->private_data;  	if ((b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) && 			(b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)) { 		return -EINVAL; 	} 	if (b->index > max_buffers) 		return -EINVAL;  	if (opener->timeout_image_io) 		*b = dev->timeout_image_buffer.buffer; 	else 		*b = dev->buffers[b->index % dev->used_buffers].buffer;  	b->type = type; 	b->index = index; 	dprintkrw(""buffer type: %d (of %d with size=%ld)\n"", b->memory, dev->buffers_number, dev->buffer_size);  	/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture' 		https://github.com/umlaeute/v4l2loopback/issues/60 */ 	b->flags &= ~V4L2_BUF_FLAG_DONE; 	b->flags |= V4L2_BUF_FLAG_QUEUED;  	return 0; }"
"255930_not_vulnerable.cpp","not_vulnerable","Status ShapeRefiner::PartialStridedSliceShape(     Node* slice_node, InferenceContext* ctx, ShapeHandle* result,     shape_inference::InferenceContext* outer_context) {   // Only attempt to evaluate if begin/end/strides all are scalars.   for (int i = 1; i <= 3; ++i) {     ShapeHandle input_shape = ctx->input(i);     if (ctx->Value(ctx->Dim(input_shape, 0)) != 1) {       *result = ctx->UnknownShape();       return Status::OK();     }   }    int begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask;   TF_RETURN_IF_ERROR(       GetNodeAttr(slice_node->attrs(), ""begin_mask"", &begin_mask));   TF_RETURN_IF_ERROR(GetNodeAttr(slice_node->attrs(), ""end_mask"", &end_mask));   TF_RETURN_IF_ERROR(       GetNodeAttr(slice_node->attrs(), ""ellipsis_mask"", &ellipsis_mask));   TF_RETURN_IF_ERROR(       GetNodeAttr(slice_node->attrs(), ""new_axis_mask"", &new_axis_mask));   TF_RETURN_IF_ERROR(       GetNodeAttr(slice_node->attrs(), ""shrink_axis_mask"", &shrink_axis_mask));    // Only attempt to evaluate if there are no special masks set (note that we   // can handle begin/end_mask == 1).   if (!(begin_mask == 0 || begin_mask == 1) ||       !(end_mask == 0 || end_mask == 1) || ellipsis_mask != 0 ||       new_axis_mask != 0 || shrink_axis_mask != 0) {     *result = ctx->UnknownShape();     return Status::OK();   }    bool evaluated;   int64 begin;   if (begin_mask == 1) {     begin = 0;   } else {     TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 1, &evaluated,                                                      &begin, outer_context));     if (!evaluated) {       *result = ctx->UnknownShape();       return Status::OK();     }   }    int64 end;   if (end_mask == 1) {     end = std::numeric_limits<int64>::max();   } else {     TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 2, &evaluated,                                                      &end, outer_context));     if (!evaluated) {       *result = ctx->UnknownShape();       return Status::OK();     }   }    int64 stride;   TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 3, &evaluated,                                                    &stride, outer_context));   if (!evaluated) {     *result = ctx->UnknownShape();     return Status::OK();   }    // Apply stride to input interpreted as a partial shape.   ShapeHandle input;   TF_RETURN_IF_ERROR(       ConstantPartialShape(ctx, slice_node, 0, &input, outer_context));   TF_RETURN_IF_ERROR(ctx->Subshape(input, begin, end, stride, result));   return Status::OK(); }"
"256122_not_vulnerable.cc","not_vulnerable","ALWAYS_INLINE void ScalarMulAdd3Way(const float a1, const float a2,                                     const float a3, const float** inp1,                                     const float** inp2, const float** inp3,                                     float** out) {   **out += a1 * **inp1 + a2 * **inp2 + a3 * **inp3;   ++*out;   ++*inp1;   ++*inp2;   ++*inp3; }"
"256141_not_vulnerable.cc","not_vulnerable","ALWAYS_INLINE void MulAdd(const Packet a, const float** inp, float** out) {   const auto b = LOAD(*inp);   *inp += kNumOperands;   auto c = LOAD(*out);   FMA(a, b, c, c);   STORE(*out, c);   *out += kNumOperands; }"
"256995_not_vulnerable.c","not_vulnerable","static int route4_set_parms(struct net *net, struct tcf_proto *tp, 			    unsigned long base, struct route4_filter *f, 			    u32 handle, struct route4_head *head, 			    struct nlattr **tb, struct nlattr *est, int new, 			    u32 flags, struct netlink_ext_ack *extack) { 	u32 id = 0, to = 0, nhandle = 0x8000; 	struct route4_filter *fp; 	unsigned int h1; 	struct route4_bucket *b; 	int err;  	err = tcf_exts_validate(net, tp, tb, est, &f->exts, flags, extack); 	if (err < 0) 		return err;  	if (tb[TCA_ROUTE4_TO]) { 		if (new && handle & 0x8000) 			return -EINVAL; 		to = nla_get_u32(tb[TCA_ROUTE4_TO]); 		if (to > 0xFF) 			return -EINVAL; 		nhandle = to; 	}  	if (tb[TCA_ROUTE4_FROM]) { 		if (tb[TCA_ROUTE4_IIF]) 			return -EINVAL; 		id = nla_get_u32(tb[TCA_ROUTE4_FROM]); 		if (id > 0xFF) 			return -EINVAL; 		nhandle |= id << 16; 	} else if (tb[TCA_ROUTE4_IIF]) { 		id = nla_get_u32(tb[TCA_ROUTE4_IIF]); 		if (id > 0x7FFF) 			return -EINVAL; 		nhandle |= (id | 0x8000) << 16; 	} else 		nhandle |= 0xFFFF << 16;  	if (handle && new) { 		nhandle |= handle & 0x7F00; 		if (nhandle != handle) 			return -EINVAL; 	}  	h1 = to_hash(nhandle); 	b = rtnl_dereference(head->table[h1]); 	if (!b) { 		b = kzalloc(sizeof(struct route4_bucket), GFP_KERNEL); 		if (b == NULL) 			return -ENOBUFS;  		rcu_assign_pointer(head->table[h1], b); 	} else { 		unsigned int h2 = from_hash(nhandle >> 16);  		for (fp = rtnl_dereference(b->ht[h2]); 		     fp; 		     fp = rtnl_dereference(fp->next)) 			if (fp->handle == f->handle) 				return -EEXIST; 	}  	if (tb[TCA_ROUTE4_TO]) 		f->id = to;  	if (tb[TCA_ROUTE4_FROM]) 		f->id = to | id<<16; 	else if (tb[TCA_ROUTE4_IIF]) 		f->iif = id;  	f->handle = nhandle; 	f->bkt = b; 	f->tp = tp;  	if (tb[TCA_ROUTE4_CLASSID]) { 		f->res.classid = nla_get_u32(tb[TCA_ROUTE4_CLASSID]); 		tcf_bind_filter(tp, &f->res, base); 	}  	return 0; }"
"256999_not_vulnerable.c","not_vulnerable","static void route4_bind_class(void *fh, u32 classid, unsigned long cl, void *q, 			      unsigned long base) { 	struct route4_filter *f = fh;  	if (f && f->res.classid == classid) { 		if (cl) 			__tcf_bind_filter(q, &f->res, base); 		else 			__tcf_unbind_filter(q, &f->res); 	} }"
"259282_not_vulnerable.c","not_vulnerable","static int cbc1_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size) {     int i, ret;     int num_of_encrypted_blocks;     uint8_t iv[16];      if (!sc->cenc.aes_ctx) {         /* initialize the cipher */         sc->cenc.aes_ctx = av_aes_alloc();         if (!sc->cenc.aes_ctx) {             return AVERROR(ENOMEM);         }          ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);         if (ret < 0) {             return ret;         }     }      memcpy(iv, sample->iv, 16);      /* whole-block full sample encryption */     if (!sample->subsample_count) {         /* decrypt the whole packet */         av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);         return 0;     }      for (i = 0; i < sample->subsample_count; i++) {         if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {             av_log(c->fc, AV_LOG_ERROR, ""subsample size exceeds the packet size left\n"");             return AVERROR_INVALIDDATA;         }          if (sample->subsamples[i].bytes_of_protected_data % 16) {             av_log(c->fc, AV_LOG_ERROR, ""subsample BytesOfProtectedData is not a multiple of 16\n"");             return AVERROR_INVALIDDATA;         }          /* skip the clear bytes */         input += sample->subsamples[i].bytes_of_clear_data;         size -= sample->subsamples[i].bytes_of_clear_data;          /* decrypt the encrypted bytes */         num_of_encrypted_blocks = sample->subsamples[i].bytes_of_protected_data/16;         if (num_of_encrypted_blocks > 0) {             av_aes_crypt(sc->cenc.aes_ctx, input, input, num_of_encrypted_blocks, iv, 1);         }         input += sample->subsamples[i].bytes_of_protected_data;         size -= sample->subsamples[i].bytes_of_protected_data;     }      if (size > 0) {         av_log(c->fc, AV_LOG_ERROR, ""leftover packet bytes after subsample processing\n"");         return AVERROR_INVALIDDATA;     }      return 0; }"
"259610_not_vulnerable.cpp","not_vulnerable","void HierarchicalBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr) { #if ACCUSOFT_CODE   class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);   UBYTE i;      if (m_bSubsampling && rr->rr_bUpsampling) {      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {       class Component *comp = m_pFrame->ComponentOf(i);       UBYTE subx            = comp->SubXOf();       UBYTE suby            = comp->SubYOf();       class UpsamplerBase *up;  // upsampler       LONG bx,by;       RectAngle<LONG> blocks;       //       // Compute the region of blocks       assert(subx > 0 && suby > 0);       if ((up = m_ppUpsampler[i])) {         LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;         LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;         LONG rx               = (subx > 1)?(1):(0);         LONG ry               = (suby > 1)?(1):(0);         // The +/-1 include additional lines required for subsampling expansion         blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);         blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);         blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);         blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);         // Clip.         if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;         if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;         if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;         if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;         up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.         //         for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {           Pull8Lines(i);           for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {             LONG dst[64];             FetchRegion(bx,m_ppDecodingMCU + (i << 3),dst);             up->DefineRegion(bx,by,dst);           }           Release8Lines(i);         }       } else {         // Load into the decoding MCU         Pull8Lines(i);       }     }     // Now push blocks into the color transformer from the upsampler.     {       RectAngle<LONG> r;       ULONG minx   = orgregion.ra_MinX >> 3;       ULONG maxx   = orgregion.ra_MaxX >> 3;       ULONG miny   = orgregion.ra_MinY >> 3;       ULONG maxy   = orgregion.ra_MaxY >> 3;       ULONG x,y;              if (maxy > m_ulMaxMCU)         maxy = m_ulMaxMCU;        for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {         r.ra_MaxY = (r.ra_MinY & -8) + 7;         if (r.ra_MaxY > orgregion.ra_MaxY)           r.ra_MaxY = orgregion.ra_MaxY;                  for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {           r.ra_MaxX = (r.ra_MinX & -8) + 7;           if (r.ra_MaxX > orgregion.ra_MaxX)             r.ra_MaxX = orgregion.ra_MaxX;                      for(i = 0;i < m_ucCount;i++) {             if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {               ExtractBitmap(m_ppTempIBM[i],r,i);               if (m_ppUpsampler[i]) {                 // Upsampled case, take from the upsampler, transform                 // into the color buffer.                 m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);               } else {                 FetchRegion(x,m_ppDecodingMCU + (i << 3),m_ppCTemp[i]);               }             } else {               // Not requested, zero the buffer.               memset(m_ppCTemp[i],0,sizeof(LONG) * 64);             }           }           ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);         }         //         // Advance the quantized rows for the non-subsampled components,         // upsampled components have been advanced above.         for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {           if (m_ppUpsampler[i] == NULL)             Release8Lines(i);         }       }     }   } else {      // direct case, no upsampling required, residual coding possible, but not applied here.     RectAngle<LONG> r;     RectAngle<LONG> region = orgregion;     SubsampledRegion(region,rr);     ULONG minx   = region.ra_MinX >> 3;     ULONG maxx   = region.ra_MaxX >> 3;     ULONG miny   = region.ra_MinY >> 3;     ULONG maxy   = region.ra_MaxY >> 3;     ULONG x,y;            if (maxy > m_ulMaxMCU)       maxy = m_ulMaxMCU;      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {       Pull8Lines(i);     }          for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {       r.ra_MaxY = (r.ra_MinY & -8) + 7;       if (r.ra_MaxY > region.ra_MaxY)         r.ra_MaxY = region.ra_MaxY;                for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {         r.ra_MaxX = (r.ra_MinX & -8) + 7;         if (r.ra_MaxX > region.ra_MaxX)           r.ra_MaxX = region.ra_MaxX;          for(i = 0;i < m_ucCount;i++) {                 LONG *dst = m_ppCTemp[i];           if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {             ExtractBitmap(m_ppTempIBM[i],r,i);             FetchRegion(x,m_ppDecodingMCU + (i << 3),dst);           } else {             memset(dst,0,sizeof(LONG) * 64);           }         }         //         // Perform the color transformation now.         ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);       } // of loop over x       //       // Advance the rows.       for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {         Release8Lines(i);       }     }   } #else   NOREF(orgregion);   NOREF(rr); #endif }"
"261393_not_vulnerable.cc","not_vulnerable","static enum InterPredIdc  decode_inter_pred_idc(thread_context* tctx,                                                int x0, int y0,                                                int nPbW, int nPbH,                                                int ctDepth) {   logtrace(LogSlice,""# inter_pred_idc\n"");    int value;    context_model* model = &tctx->ctx_model[CONTEXT_MODEL_INTER_PRED_IDC];    if (nPbW+nPbH==12) {     value = decode_CABAC_bit(&tctx->cabac_decoder,                              &model[4]);   }   else {     int bit0 = decode_CABAC_bit(&tctx->cabac_decoder,                                 &model[ctDepth]);     if (bit0==0) {       value = decode_CABAC_bit(&tctx->cabac_decoder,                                &model[4]);     }     else {       value = 2;     }   }    logtrace(LogSlice,""> inter_pred_idc = %d (%s)\n"",value,            value==0 ? ""L0"" : (value==1 ? ""L1"" : ""BI""));    logtrace(LogSymbols,""$1 decode_inter_pred_idx=%d\n"",value+1);    return (enum InterPredIdc) (value+1); }"
"261426_not_vulnerable.cc","not_vulnerable","static int decode_sao_class(thread_context* tctx) {   logtrace(LogSlice,""# sao_class\n"");   int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 2);   logtrace(LogSymbols,""$1 sao_class=%d\n"",value);   return value; }"
"261442_not_vulnerable.cc","not_vulnerable","static inline int decode_coeff_abs_level_greater1(thread_context* tctx,                                                   int cIdx, int i,                                                   bool firstCoeffInSubblock,                                                   bool firstSubblock,                                                   int  lastSubblock_greater1Ctx,                                                   int* lastInvocation_greater1Ctx,                                                   int* lastInvocation_coeff_abs_level_greater1_flag,                                                   int* lastInvocation_ctxSet, int c1) {   logtrace(LogSlice,""# coeff_abs_level_greater1\n"");    logtrace(LogSlice,""  cIdx:%d i:%d firstCoeffInSB:%d firstSB:%d lastSB>1:%d last>1Ctx:%d lastLev>1:%d lastCtxSet:%d\n"", cIdx,i,firstCoeffInSubblock,firstSubblock,lastSubblock_greater1Ctx, 	   *lastInvocation_greater1Ctx, 	   *lastInvocation_coeff_abs_level_greater1_flag, 	   *lastInvocation_ctxSet);    int lastGreater1Ctx;   int greater1Ctx;   int ctxSet;    logtrace(LogSlice,""c1: %d\n"",c1);    if (firstCoeffInSubblock) {     // block with real DC -> ctx 0     if (i==0 || cIdx>0) { ctxSet=0; }     else { ctxSet=2; }      if (firstSubblock) { lastGreater1Ctx=1; }     else { lastGreater1Ctx = lastSubblock_greater1Ctx; }      if (lastGreater1Ctx==0) { ctxSet++; }      logtrace(LogSlice,""ctxSet: %d\n"",ctxSet);      greater1Ctx=1;   }   else { // !firstCoeffInSubblock     ctxSet = *lastInvocation_ctxSet;     logtrace(LogSlice,""ctxSet (old): %d\n"",ctxSet);      greater1Ctx = *lastInvocation_greater1Ctx;     if (greater1Ctx>0) {       int lastGreater1Flag=*lastInvocation_coeff_abs_level_greater1_flag;       if (lastGreater1Flag==1) greater1Ctx=0;       else { /*if (greater1Ctx>0)*/ greater1Ctx++; }     }   }    ctxSet = c1; // use HM algo    int ctxIdxInc = (ctxSet*4) + (greater1Ctx>=3 ? 3 : greater1Ctx);    if (cIdx>0) { ctxIdxInc+=16; }    int bit = decode_CABAC_bit(&tctx->cabac_decoder,                              &tctx->ctx_model[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER1_FLAG + ctxIdxInc]);    *lastInvocation_greater1Ctx = greater1Ctx;   *lastInvocation_coeff_abs_level_greater1_flag = bit;   *lastInvocation_ctxSet = ctxSet;    //logtrace(LogSymbols,""$1 coeff_abs_level_greater1=%d\n"",bit);    return bit; }"
"261968_not_vulnerable.c","not_vulnerable","njs_string_base64url(njs_vm_t *vm, njs_value_t *value, const njs_str_t *src) {     size_t     padding;     njs_str_t  dst;      if (njs_slow_path(src->length == 0)) {         vm->retval = njs_string_empty;         return NJS_OK;     }      padding = src->length % 3;      /*      * Calculating the padding length: 0 -> 0, 1 -> 2, 2 -> 1.      */     padding = (4 >> padding) & 0x03;      dst.length = njs_base64_encoded_length(src->length) - padding;      dst.start = njs_string_alloc(vm, value, dst.length, dst.length);     if (njs_slow_path(dst.start == NULL)) {         return NJS_ERROR;     }      njs_encode_base64url(&dst, src);      return NJS_OK; }"
"262022_not_vulnerable.c","not_vulnerable","Proto_RequestNameToType(const gchar *name) {    int i;     for (i = 0; i < G_N_ELEMENTS(reqNameList); i++) {       if (g_strcmp0(name, reqNameList[i].reqName) == 0) {          return reqNameList[i].type;       }    }     return PROTO_REQUEST_UNKNOWN; }"
"262722_not_vulnerable.c","not_vulnerable","njs_array_iterator_next(njs_vm_t *vm, njs_value_t *iterator,     njs_value_t *retval) {     int64_t               length;     njs_int_t             ret;     njs_array_t           *array, *entry;     njs_typed_array_t     *tarray;     const njs_value_t     *value;     njs_array_iterator_t  *it;      if (njs_slow_path(!njs_is_valid(njs_object_value(iterator)))) {         return NJS_DECLINED;     }      it = njs_object_data(iterator);     value = &njs_value_undefined;      if (njs_is_fast_array(&it->target)) {         array = njs_array(&it->target);         length = array->length;          if (it->next >= length) {             goto release;         }          if (it->kind > NJS_ENUM_KEYS && njs_is_valid(&array->start[it->next])) {             value = &array->start[it->next];         }      } else if (njs_is_typed_array(&it->target)) {         tarray = njs_typed_array(&it->target);          if (njs_slow_path(njs_is_detached_buffer(tarray->buffer))) {             njs_type_error(vm, ""detached buffer"");             return NJS_ERROR;         }          length = njs_typed_array_length(tarray);          if (it->next >= length) {             goto release;         }          if (it->kind > NJS_ENUM_KEYS) {             njs_set_number(retval, njs_typed_array_prop(tarray, it->next));             value = retval;         }      } else {         ret = njs_object_length(vm, &it->target, &length);         if (njs_slow_path(ret == NJS_ERROR)) {             return ret;         }          if (it->next >= length) {             goto release;         }          if (it->kind > NJS_ENUM_KEYS) {             ret = njs_value_property_i64(vm, &it->target, it->next, retval);             if (njs_slow_path(ret == NJS_ERROR)) {                 return ret;             }              value = njs_is_valid(retval) ? retval                                          : &njs_value_undefined;         }     }      switch (it->kind) {     case NJS_ENUM_KEYS:         njs_set_number(retval, it->next++);         break;      case NJS_ENUM_VALUES:         it->next++;         *retval = *value;         break;      case NJS_ENUM_BOTH:         entry = njs_array_alloc(vm, 0, 2, 0);         if (njs_slow_path(entry == NULL)) {             return NJS_ERROR;         }          njs_set_number(&entry->start[0], it->next++);         entry->start[1] = *value;          njs_set_array(retval, entry);         break;      default:         njs_internal_error(vm, ""invalid enum kind"");         return NJS_ERROR;     }      return NJS_OK;  release:      /* GC release it->target */     njs_mp_free(vm->mem_pool, it);     njs_set_invalid(njs_object_value(iterator));      return NJS_DECLINED; }"
"263298_not_vulnerable.c","not_vulnerable","char *_q_strcpy(char *dst, size_t size, const char *src) {     if (dst == NULL || size == 0 || src == NULL) return dst;      size_t copylen = strlen(src);     if (copylen >= size) copylen = size - 1;     memmove((void *)dst, (void *)src, copylen);     dst[copylen] = '\0';      return dst; }"
"263507_not_vulnerable.c","not_vulnerable","static int sco_sock_setsockopt(struct socket *sock, int level, int optname, 			       sockptr_t optval, unsigned int optlen) { 	struct sock *sk = sock->sk; 	int len, err = 0; 	struct bt_voice voice; 	u32 opt;  	BT_DBG(""sk %p"", sk);  	lock_sock(sk);  	switch (optname) {  	case BT_DEFER_SETUP: 		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) { 			err = -EINVAL; 			break; 		}  		if (copy_from_sockptr(&opt, optval, sizeof(u32))) { 			err = -EFAULT; 			break; 		}  		if (opt) 			set_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags); 		else 			clear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags); 		break;  	case BT_VOICE: 		if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND && 		    sk->sk_state != BT_CONNECT2) { 			err = -EINVAL; 			break; 		}  		voice.setting = sco_pi(sk)->setting;  		len = min_t(unsigned int, sizeof(voice), optlen); 		if (copy_from_sockptr(&voice, optval, len)) { 			err = -EFAULT; 			break; 		}  		/* Explicitly check for these values */ 		if (voice.setting != BT_VOICE_TRANSPARENT && 		    voice.setting != BT_VOICE_CVSD_16BIT) { 			err = -EINVAL; 			break; 		}  		sco_pi(sk)->setting = voice.setting; 		break;  	case BT_PKT_STATUS: 		if (copy_from_sockptr(&opt, optval, sizeof(u32))) { 			err = -EFAULT; 			break; 		}  		if (opt) 			sco_pi(sk)->cmsg_mask |= SCO_CMSG_PKT_STATUS; 		else 			sco_pi(sk)->cmsg_mask &= SCO_CMSG_PKT_STATUS; 		break;  	default: 		err = -ENOPROTOOPT; 		break; 	}  	release_sock(sk); 	return err; }"
"264365_not_vulnerable.h","not_vulnerable","inline int TensorProtoDataSize<Eigen::half>(const TensorProto& t) {   return t.half_val_size(); }"
"264370_not_vulnerable.h","not_vulnerable","inline const int32* TensorProtoData<qint32>(const TensorProto& t) {   static_assert(SaveTypeTraits<qint32>::supported,                 ""Specified type qint32 not supported for Restore"");   return reinterpret_cast<const int32*>(t.int_val().data()); }"
"264658_not_vulnerable.c","not_vulnerable","static GF_Err BM_ParseMultipleReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list) { 	u32 i, numFields, index, flag, nbBits, field_ref, fieldind; 	GF_Err e; 	GF_FieldInfo field; 	u32 NodeID; 	GF_Node *node; 	GF_Command *com; 	GF_CommandField *inf;  	NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); 	node = gf_sg_find_node(codec->current_graph, NodeID); 	if (!node) return GF_NON_COMPLIANT_BITSTREAM;  	e = GF_OK; 	com = gf_sg_command_new(codec->current_graph, GF_SG_MULTIPLE_REPLACE); 	BM_SetCommandNode(com, node); 	flag = gf_bs_read_int(bs, 1); 	if (flag) { 		numFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF); 		for (i=0; i<numFields; i++) { 			flag = gf_bs_read_int(bs, 1); 			if (!flag) continue; 			gf_bifs_get_field_index(node, i, GF_SG_FIELD_CODING_DEF, &index); 			e = gf_node_get_field(node, index, &field); 			if (e) goto exit; 			inf = gf_sg_command_field_new(com); 			inf->fieldType = field.fieldType; 			inf->fieldIndex = field.fieldIndex; 			if (inf->fieldType==GF_SG_VRML_SFNODE) { 				field.far_ptr = inf->field_ptr = &inf->new_node; 			} else if (inf->fieldType==GF_SG_VRML_MFNODE) { 				field.far_ptr = inf->field_ptr = &inf->node_list; 			} else { 				field.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType); 			} 			e = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE); 			if (e) goto exit; 		} 	} else { 		flag = gf_bs_read_int(bs, 1); 		nbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF)-1); 		while (!flag && (codec->LastError>=0)) { 			field_ref = gf_bs_read_int(bs, nbBits); 			e = gf_bifs_get_field_index(node, field_ref, GF_SG_FIELD_CODING_DEF, &fieldind); 			if (e) goto exit; 			e = gf_node_get_field(node, fieldind, &field); 			if (e) goto exit; 			inf = gf_sg_command_field_new(com); 			inf->fieldType = field.fieldType; 			inf->fieldIndex = field.fieldIndex; 			if (inf->fieldType==GF_SG_VRML_SFNODE) { 				field.far_ptr = inf->field_ptr = &inf->new_node; 			} else if (inf->fieldType==GF_SG_VRML_MFNODE) { 				field.far_ptr = inf->field_ptr = &inf->node_list; 			} else { 				field.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType); 			} 			e = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE); 			if (e) goto exit; 			flag = gf_bs_read_int(bs, 1); 		} 	}   exit: 	if (e) gf_sg_command_del(com); 	else gf_list_add(com_list, com); 	return e; }"
"264695_not_vulnerable.c","not_vulnerable","lexer_convert_ident_to_cesu8 (uint8_t *destination_p, /**< destination string */                               const uint8_t *source_p, /**< source string */                               prop_length_t length) /**< length of destination string */ {   const uint8_t *destination_end_p = destination_p + length;    JERRY_ASSERT (length <= PARSER_MAXIMUM_IDENT_LENGTH);    do   {     if (*source_p == LIT_CHAR_BACKSLASH)     {       source_p += 2;       destination_p += lit_code_point_to_cesu8_bytes (destination_p, lexer_unchecked_hex_to_character (&source_p));       continue;     }  #if JERRY_ESNEXT     if (*source_p >= LIT_UTF8_4_BYTE_MARKER)     {       lit_four_byte_utf8_char_to_cesu8 (destination_p, source_p);        destination_p += 6;       source_p += 4;       continue;     } #endif /* JERRY_ESNEXT */      *destination_p++ = *source_p++;   } while (destination_p < destination_end_p); } /* lexer_convert_ident_to_cesu8 */"
"264707_not_vulnerable.cc","not_vulnerable","void AddShapeNodeToConstantGraph(     Node* n,     const std::unordered_map<const Node*, std::vector<Tensor>>&         shape_replacement_map,     std::unordered_map<Node*, std::vector<Node*>>* node_map,     const ConstantFoldNameGenerator& generate_new_name, Graph* constant_graph) {   std::vector<Node*>& added = (*node_map)[n];   const string& node_name = n->name();   for (const Tensor& t : shape_replacement_map.at(n)) {     auto builder =         NodeDefBuilder(generate_new_name(constant_graph, node_name), ""Const"")             .Attr(""dtype"", t.dtype())             .Attr(""value"", t);     NodeDef def;     CHECK(builder.Finalize(&def).ok());     Node* constant_node;     CHECK(NodeBuilder(builder).Finalize(constant_graph, &constant_node).ok());     added.push_back(constant_node);   }   // Don't copy incoming edges to shape nodes that are being replaced. }"
"265043_not_vulnerable.c","not_vulnerable","allocate_colour_buffer(void) {     char **atrs;     int lenfg, lenbg, len;      if (colseq_buf_allocs++) 	return;      atrs = getaparam(""zle_highlight"");     if (atrs) { 	for (; *atrs; atrs++) { 	    if (strpfx(""fg_start_code:"", *atrs)) { 		set_colour_code(*atrs + 14, &fg_bg_sequences[COL_SEQ_FG].start); 	    } else if (strpfx(""fg_default_code:"", *atrs)) { 		set_colour_code(*atrs + 16, &fg_bg_sequences[COL_SEQ_FG].def); 	    } else if (strpfx(""fg_end_code:"", *atrs)) { 		set_colour_code(*atrs + 12, &fg_bg_sequences[COL_SEQ_FG].end); 	    } else if (strpfx(""bg_start_code:"", *atrs)) { 		set_colour_code(*atrs + 14, &fg_bg_sequences[COL_SEQ_BG].start); 	    } else if (strpfx(""bg_default_code:"", *atrs)) { 		set_colour_code(*atrs + 16, &fg_bg_sequences[COL_SEQ_BG].def); 	    } else if (strpfx(""bg_end_code:"", *atrs)) { 		set_colour_code(*atrs + 12, &fg_bg_sequences[COL_SEQ_BG].end); 	    } 	}     }      lenfg = strlen(fg_bg_sequences[COL_SEQ_FG].def);     /* always need 1 character for non-default code */     if (lenfg < 1) 	lenfg = 1;     lenfg += strlen(fg_bg_sequences[COL_SEQ_FG].start) + 	strlen(fg_bg_sequences[COL_SEQ_FG].end);      lenbg = strlen(fg_bg_sequences[COL_SEQ_BG].def);     /* always need 1 character for non-default code */     if (lenbg < 1) 	lenbg = 1;     lenbg += strlen(fg_bg_sequences[COL_SEQ_BG].start) + 	strlen(fg_bg_sequences[COL_SEQ_BG].end);      len = lenfg > lenbg ? lenfg : lenbg;     /* add 1 for the null and 14 for truecolor */     colseq_buf = (char *)zalloc(len+15); }"
"270391_not_vulnerable.c","not_vulnerable","bool ok_inflater_needs_input(const ok_inflater *inflater) {     return inflater &&         inflater->state != OK_INFLATER_STATE_ERROR &&         ok_inflater_can_flush_total(inflater) == 0 &&         inflater->input == inflater->input_end; }"
"270772_not_vulnerable.c","not_vulnerable","static unsigned char to_hexa(unsigned char c) { 	if (c < 10) 		c += '0'; 	else 		c += 'a' - 10;  	return c; }"
"272338_not_vulnerable.c","not_vulnerable","void cms_set_pw_callback(cms_context *cms, PK11PasswordFunc func) { 	cms->func = func; }"
"272376_not_vulnerable.c","not_vulnerable","digest_get_digest_size(cms_context *cms) { 	int i = cms->selected_digest; 	return digest_params[i].size; }"
"273059_not_vulnerable.c","not_vulnerable","net_evhttp_bind(struct evhttp *evhttp, short unsigned port, const char *log_service_name) {   const char *bind_address;   bool v6_enabled;   int ret;    bind_address = cfg_getstr(cfg_getsec(cfg, ""general""), ""bind_address"");   if (bind_address)     evhttp_bind_socket(evhttp, bind_address, port);    // For Linux, we could just do evhttp_bind_socket() for ""::"", and both the   // ipv4 and v6 port would be bound. However, for bsd it seems it is necessary   // to do like below.   v6_enabled = cfg_getbool(cfg_getsec(cfg, ""general""), ""ipv6"");   if (v6_enabled)     {       ret = evhttp_bind_socket(evhttp, ""::"", port);       if (ret < 0) 	{ 	  DPRINTF(E_LOG, L_MISC, ""Could not bind service '%s' to port %d with IPv6, falling back to IPv4\n"", log_service_name, port); 	  v6_enabled = 0; 	}     }    ret = evhttp_bind_socket(evhttp, ""0.0.0.0"", port);   if (ret < 0)     {       if (!v6_enabled) 	return -1;  #ifndef __linux__       DPRINTF(E_LOG, L_MISC, ""Could not bind service '%s' to port %d with IPv4, listening on IPv6 only\n"", log_service_name, port); #endif     }    return 0; }"
"273407_not_vulnerable.cc","not_vulnerable","  void Compute(OpKernelContext* ctx) override {     const Tensor* x_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""x"", &x_tensor));      const Tensor* cs_prev_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""cs_prev"", &cs_prev_tensor));      const Tensor* h_prev_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""h_prev"", &h_prev_tensor));      const Tensor* w_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""w"", &w_tensor));      const Tensor* wci_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wci"", &wci_tensor));      const Tensor* wcf_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wcf"", &wcf_tensor));      const Tensor* wco_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""wco"", &wco_tensor));      const Tensor* b_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->input(""b"", &b_tensor));      const int64_t batch_size = x_tensor->dim_size(0);     const int64_t input_size = x_tensor->dim_size(1);     const int64_t cell_size = cs_prev_tensor->dim_size(1);      // Sanity checks for our input shapes.     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,                 errors::InvalidArgument(""cs_prev.dims(0) != batch_size: "",                                         cs_prev_tensor->dim_size(0), "" vs. "",                                         batch_size));     OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,                 errors::InvalidArgument(""cs_prev.dims(1) != cell_size: "",                                         cs_prev_tensor->dim_size(1), "" vs. "",                                         cell_size));      OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,                 errors::InvalidArgument(""h_prev.dims(0) != batch_size: "",                                         h_prev_tensor->dim_size(0), "" vs. "",                                         batch_size));     OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,                 errors::InvalidArgument(                     ""h_prev.dims(1) != cell_size: "", h_prev_tensor->dim_size(1),                     "" vs. "", cell_size));      OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,                 errors::InvalidArgument(                     ""w.dim_size(0) != input_size + cell_size: "",                     w_tensor->dim_size(0), "" vs. "", input_size + cell_size));     OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,                 errors::InvalidArgument(                     ""w.dim_size(1) != cell_size * 4: "", w_tensor->dim_size(1),                     "" vs. "", cell_size * 4));      OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,                 errors::InvalidArgument(                     ""b.dim_size(0) != cell_size * 4: "", b_tensor->dim_size(0),                     "" vs. "", cell_size * 4));      // Allocate our output tensors.     Tensor* i_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(                             {""h_prev""}, ""i"",                             TensorShape({batch_size, cell_size}), &i_tensor));      Tensor* cs_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""cs"", TensorShape({batch_size, cell_size}),                                   &cs_tensor));      Tensor* f_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""f"", TensorShape({batch_size, cell_size}),                                   &f_tensor));      Tensor* o_tensor = nullptr;     OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(                             {""cs_prev""}, ""o"",                             TensorShape({batch_size, cell_size}), &o_tensor));      Tensor* ci_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""ci"", TensorShape({batch_size, cell_size}),                                   &ci_tensor));      Tensor* co_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""co"", TensorShape({batch_size, cell_size}),                                   &co_tensor));      Tensor* h_tensor = nullptr;     OP_REQUIRES_OK(         ctx, ctx->allocate_output(""h"", TensorShape({batch_size, cell_size}),                                   &h_tensor));      // Allocate our temp tensors.     Tensor xh_tensor;     OP_REQUIRES_OK(ctx, ctx->allocate_temp(                             DataTypeToEnum<T>::v(),                             TensorShape({batch_size, input_size + cell_size}),                             &xh_tensor));      Tensor gates_tensor;     OP_REQUIRES_OK(ctx,                    ctx->allocate_temp(DataTypeToEnum<T>::v(),                                       TensorShape({batch_size, cell_size * 4}),                                       &gates_tensor));      const Device& device = ctx->eigen_device<Device>();      // Sanity check that each of the tensors have the required NDIMS.     OP_REQUIRES(ctx, x_tensor->dims() == 2,                 errors::InvalidArgument(""x_tensor must be rank 2 but is rank "",                                         x_tensor->dims(), "".""));     OP_REQUIRES(         ctx, cs_prev_tensor->dims() == 2,         errors::InvalidArgument(""cs_prev_tensor must be rank 2 but is rank "",                                 cs_prev_tensor->dims(), "".""));     OP_REQUIRES(         ctx, h_prev_tensor->dims() == 2,         errors::InvalidArgument(""h_prev_tensor must be rank 2 but is rank "",                                 h_prev_tensor->dims(), "".""));     OP_REQUIRES(ctx, w_tensor->dims() == 2,                 errors::InvalidArgument(""w_tensor must be rank 2 but is rank "",                                         w_tensor->dims(), "".""));     OP_REQUIRES(         ctx, wci_tensor->dims() == 1,         errors::InvalidArgument(""wci_tensor must be rank 1 but is rank "",                                 wci_tensor->dims(), "".""));     OP_REQUIRES(         ctx, wcf_tensor->dims() == 1,         errors::InvalidArgument(""wcf_tensor must be rank 1 but is rank "",                                 wci_tensor->dims(), "".""));     OP_REQUIRES(         ctx, wco_tensor->dims() == 1,         errors::InvalidArgument(""wco_tensor must be rank 1 but is rank "",                                 wco_tensor->dims(), "".""));     OP_REQUIRES(ctx, b_tensor->dims() == 1,                 errors::InvalidArgument(""b_tensor must be rank 1 but is rank "",                                         b_tensor->dims(), "".""));     OP_REQUIRES(ctx, xh_tensor.dims() == 2,                 errors::InvalidArgument(""xh_tensor must be rank 2 but is rank "",                                         xh_tensor.dims(), "".""));     OP_REQUIRES(ctx, i_tensor->dims() == 2,                 errors::InvalidArgument(""i_tensor must be rank 2 but is rank "",                                         i_tensor->dims(), "".""));     OP_REQUIRES(ctx, cs_tensor->dims() == 2,                 errors::InvalidArgument(""cs_tensor must be rank 2 but is rank "",                                         cs_tensor->dims(), "".""));     OP_REQUIRES(ctx, f_tensor->dims() == 2,                 errors::InvalidArgument(""f_tensor must be rank 2 but is rank "",                                         f_tensor->dims(), "".""));     OP_REQUIRES(ctx, o_tensor->dims() == 2,                 errors::InvalidArgument(""o_tensor must be rank 2 but is rank "",                                         o_tensor->dims(), "".""));     OP_REQUIRES(ctx, ci_tensor->dims() == 2,                 errors::InvalidArgument(""ci_tensor must be rank 2 but is rank "",                                         ci_tensor->dims(), "".""));     OP_REQUIRES(ctx, co_tensor->dims() == 2,                 errors::InvalidArgument(""co_tensor must be rank 2 but is rank "",                                         co_tensor->dims(), "".""));     OP_REQUIRES(         ctx, gates_tensor.dims() == 2,         errors::InvalidArgument(""gates_tensor must be rank 2 but is rank "",                                 gates_tensor.dims(), "".""));     OP_REQUIRES(ctx, h_tensor->dims() == 2,                 errors::InvalidArgument(""h_tensor must be rank 2 but is rank "",                                         h_tensor->dims(), "".""));      functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(         batch_size, input_size, cell_size)(         ctx, device, forget_bias_, cell_clip_, use_peephole_,         x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),         h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),         wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),         xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),         f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),         co_tensor->matrix<T>(), gates_tensor.matrix<T>(),         h_tensor->matrix<T>());   }"
"273879_not_vulnerable.c","not_vulnerable","static int close_data_connection(ctrl_t *ctrl) { 	int ret = 0;  	DBG(""Closing data connection ..."");  	/* PASV server listening socket */ 	if (ctrl->data_listen_sd > 0) { 		shutdown(ctrl->data_listen_sd, SHUT_RDWR); 		close(ctrl->data_listen_sd); 		ctrl->data_listen_sd = -1; 		ret++; 	}  	/* PASV client socket */ 	if (ctrl->data_sd > 0) { 		shutdown(ctrl->data_sd, SHUT_RDWR); 		close(ctrl->data_sd); 		ctrl->data_sd = -1; 		ret++; 	}  	/* PORT */ 	if (ctrl->data_address[0]) { 		ctrl->data_address[0] = 0; 		ctrl->data_port = 0; 	}  	return ret; }"
"273883_not_vulnerable.c","not_vulnerable","static void handle_QUIT(ctrl_t *ctrl, char *arg) { 	send_msg(ctrl->sd, ""221 Goodbye.\r\n""); 	uev_exit(ctrl->ctx); }"
"273900_not_vulnerable.c","not_vulnerable","static void handle_STOR(ctrl_t *ctrl, char *file) { 	FILE *fp = NULL; 	char *path; 	int rc = 0;  	path = compose_abspath(ctrl, file); 	if (!path) { 		INFO(""Invalid path for %s: %m"", file); 		goto fail; 	}  	DBG(""Trying to write to %s ..."", path); 	fp = fopen(path, ""wb""); 	if (!fp) { 		/* If EACCESS client is trying to do something disallowed */ 		ERR(errno, ""Failed writing %s"", path); 	fail: 		send_msg(ctrl->sd, ""451 Trouble storing file.\r\n""); 		do_abort(ctrl); 		return; 	}  	ctrl->fp = fp; 	ctrl->file = strdup(file);  	if (ctrl->data_sd > -1) { 		if (ctrl->offset) 			rc = fseek(fp, ctrl->offset, SEEK_SET); 		if (rc) { 			do_abort(ctrl); 			send_msg(ctrl->sd, ""551 Failed seeking to that position in file.\r\n""); 			return; 		}  		send_msg(ctrl->sd, ""125 Data connection already open; transfer starting.\r\n""); 		uev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ); 		return; 	}  	do_PORT(ctrl, 3); }"
"273903_not_vulnerable.c","not_vulnerable","static void handle_EPRT(ctrl_t *ctrl, char *str) { 	send_msg(ctrl->sd, ""502 Command not implemented.\r\n""); }"
"273906_not_vulnerable.c","not_vulnerable","static void handle_PASV(ctrl_t *ctrl, char *arg) { 	struct sockaddr_in data; 	socklen_t len = sizeof(data); 	char *msg, *p, buf[200]; 	int port;  	if (do_PASV(ctrl, arg, (struct sockaddr *)&data, &len)) 		return;  	/* Convert server IP address and port to comma separated list */ 	msg = strdup(ctrl->serveraddr); 	if (!msg) { 		send_msg(ctrl->sd, ""426 Internal server error.\r\n""); 		exit(1); 	} 	p = msg; 	while ((p = strchr(p, '.'))) 		*p++ = ',';  	port = ntohs(data.sin_port); 	snprintf(buf, sizeof(buf), ""227 Entering Passive Mode (%s,%d,%d)\r\n"", 		 msg, port / 256, port % 256); 	send_msg(ctrl->sd, buf);  	free(msg); }"
"273922_not_vulnerable.c","not_vulnerable","static void handle_ABOR(ctrl_t *ctrl, char *arg) { 	DBG(""Aborting any current transfer ...""); 	if (do_abort(ctrl)) 		send_msg(ctrl->sd, ""426 Connection closed; transfer aborted.\r\n"");  	send_msg(ctrl->sd, ""226 Closing data connection.\r\n""); }"
"274681_not_vulnerable.c","not_vulnerable","void callbacks_update_ruler_pointers (void) { 	double xPosition, yPosition; 	xPosition = screenRenderInfo.lowerLeftX + (screen.last_x / screenRenderInfo.scaleFactorX); 	yPosition = screenRenderInfo.lowerLeftY + ((screenRenderInfo.displayHeight - screen.last_y) / screenRenderInfo.scaleFactorY);  	if (!((screen.unit == GERBV_MILS) && ((screenRenderInfo.scaleFactorX < 80)||(screenRenderInfo.scaleFactorY < 80)))) { 		xPosition = callbacks_calculate_actual_distance (xPosition); 		yPosition = callbacks_calculate_actual_distance (yPosition); 	} 	g_object_set (G_OBJECT (screen.win.hRuler), ""position"", xPosition, NULL); 	g_object_set (G_OBJECT (screen.win.vRuler), ""position"", yPosition, NULL); }"
"274754_not_vulnerable.c","not_vulnerable","static int ntfs_attr_map_partial_runlist(ntfs_attr *na, VCN vcn) { 	VCN last_vcn; 	VCN highest_vcn; 	VCN needed; 	runlist_element *rl; 	ATTR_RECORD *a; 	BOOL startseen; 	ntfs_attr_search_ctx *ctx; 	BOOL done; 	BOOL newrunlist;  	if (NAttrFullyMapped(na)) 		return 0;  	ctx = ntfs_attr_get_search_ctx(na->ni, NULL); 	if (!ctx) 		return -1;  	/* Get the last vcn in the attribute. */ 	last_vcn = na->allocated_size >> na->ni->vol->cluster_size_bits;  	needed = vcn; 	highest_vcn = 0; 	startseen = FALSE; 	done = FALSE; 	rl = (runlist_element*)NULL; 	do { 		newrunlist = FALSE; 		/* Find the attribute in the mft record. */ 		if (!ntfs_attr_lookup(na->type, na->name, na->name_len, CASE_SENSITIVE, 				needed, NULL, 0, ctx)) {  			a = ctx->attr; 				/* Decode and merge the runlist. */ 			if (ntfs_rl_vcn_to_lcn(na->rl, needed) 						== LCN_RL_NOT_MAPPED) { 				rl = ntfs_mapping_pairs_decompress(na->ni->vol, 					a, na->rl); 				newrunlist = TRUE; 			} else 				rl = na->rl; 			if (rl) { 				na->rl = rl; 				highest_vcn = sle64_to_cpu(a->highest_vcn); 				if (highest_vcn < needed) { 				/* corruption detection on unchanged runlists */ 					if (newrunlist 					    && ((highest_vcn + 1) < last_vcn)) { 						ntfs_log_error(""Corrupt attribute list\n""); 						rl = (runlist_element*)NULL; 						errno = EIO; 					} 					done = TRUE; 				} 				needed = highest_vcn + 1; 				if (!a->lowest_vcn) 					startseen = TRUE; 			} 		} else { 			done = TRUE; 		} 	} while (rl && !done && (needed < last_vcn)); 	ntfs_attr_put_search_ctx(ctx); 		/* 		 * Make sure we reached the end, unless the last 		 * runlist was modified earlier (using HOLES_DELAY 		 * leads to have a visibility over attributes which 		 * have not yet been fully updated) 		 */ 	if (done && newrunlist && (needed < last_vcn)) { 		ntfs_log_error(""End of runlist not reached\n""); 		rl = (runlist_element*)NULL; 		errno = EIO; 	} 		/* mark fully mapped if we did so */ 	if (rl && startseen) 		NAttrSetFullyMapped(na); 	return (rl ? 0 : -1); }"
"274864_not_vulnerable.cc","not_vulnerable","  void ConfigureBuiltinOp(BuiltinOperator op) {     switch (op) {       case BuiltinOperator_EQUAL: {         SetBuiltinOp(op, BuiltinOptions_EqualOptions,                      CreateEqualOptions(builder_).Union());         break;       }       case BuiltinOperator_NOT_EQUAL: {         SetBuiltinOp(op, BuiltinOptions_NotEqualOptions,                      CreateNotEqualOptions(builder_).Union());         break;       }       case BuiltinOperator_GREATER: {         SetBuiltinOp(op, BuiltinOptions_GreaterOptions,                      CreateGreaterOptions(builder_).Union());         break;       }       case BuiltinOperator_GREATER_EQUAL: {         SetBuiltinOp(op, BuiltinOptions_GreaterEqualOptions,                      CreateGreaterEqualOptions(builder_).Union());         break;       }       case BuiltinOperator_LESS: {         SetBuiltinOp(op, BuiltinOptions_LessOptions,                      CreateLessOptions(builder_).Union());         break;       }       case BuiltinOperator_LESS_EQUAL: {         SetBuiltinOp(op, BuiltinOptions_LessEqualOptions,                      CreateLessEqualOptions(builder_).Union());         break;       }       default: { FAIL() << ""We shouldn't get here.""; }     }   }"
"274872_not_vulnerable.cc","not_vulnerable","TEST(ComparisonsTest, GreaterQuantizedSmallRange) {   ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, 0.0, 1.0},                           {TensorType_UINT8, {1, 2, 2, 1}, 0.0, 2.0},                           TensorType_UINT8, BuiltinOperator_GREATER);   model.QuantizeAndPopulate<uint8_t>(model.input1(), {1.0, 0.5, 0.35, 0.1});   model.QuantizeAndPopulate<uint8_t>(model.input2(), {1.01, 0.25, 0.3, 0.4});   model.Invoke();    EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false)); }"
"274873_not_vulnerable.cc","not_vulnerable","TEST(ComparisonsTest, QuantizedUInt8LessWithBroadcast) {   const float kMin = -1.f;   const float kMax = 128.f;   std::vector<std::vector<int>> test_shapes = {       {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};   for (int i = 0; i < test_shapes.size(); ++i) {     ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},                             {TensorType_UINT8, {}, kMin, kMax},                             TensorType_UINT8, BuiltinOperator_LESS);     model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});     model.QuantizeAndPopulate<uint8_t>(model.input2(), {8});     model.Invoke();     EXPECT_THAT(model.GetOutput(),                 ElementsAre(false, true, true, false, false, false))         << ""With shape number "" << i;   } }"
"275527_not_vulnerable.c","not_vulnerable","njs_vm_bind(njs_vm_t *vm, const njs_str_t *var_name, const njs_value_t *value,     njs_bool_t shared) {     njs_int_t           ret;     njs_object_t        *global;     njs_lvlhsh_t        *hash;     njs_object_prop_t   *prop;     njs_lvlhsh_query_t  lhq;      prop = njs_object_prop_alloc(vm, &njs_value_undefined, value, 1);     if (njs_slow_path(prop == NULL)) {         return NJS_ERROR;     }      ret = njs_string_new(vm, &prop->name, var_name->start, var_name->length, 0);     if (njs_slow_path(ret != NJS_OK)) {         return NJS_ERROR;     }      lhq.value = prop;     lhq.key = *var_name;     lhq.key_hash = njs_djb_hash(lhq.key.start, lhq.key.length);     lhq.replace = 1;     lhq.pool = vm->mem_pool;     lhq.proto = &njs_object_hash_proto;      global = &vm->global_object;     hash = shared ? &global->shared_hash : &global->hash;      ret = njs_lvlhsh_insert(hash, &lhq);     if (njs_slow_path(ret != NJS_OK)) {         njs_internal_error(vm, ""lvlhsh insert failed"");         return ret;     }      return NJS_OK; }"
"275982_not_vulnerable.c","not_vulnerable","uECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,                                    const uECC_word_t *left,                                    const uECC_word_t *right,                                    const uECC_word_t *mod,                                    wordcount_t num_words) {     uECC_word_t product[2 * uECC_MAX_WORDS];     uECC_vli_mult(product, left, right, num_words);     uECC_vli_mmod(result, product, mod, num_words); }"
"276972_not_vulnerable.cpp","not_vulnerable","SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {     encrypter = NULL;     AP4_BlockCipher* block_cipher = NULL;     AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,                                                                              AP4_BlockCipher::ENCRYPT,                                                                              AP4_BlockCipher::CBC,                                                                              NULL,                                                                              key,                                                                              16,                                                                              block_cipher);     if (AP4_FAILED(result)) return result;     AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);     encrypter = new SampleEncrypter(stream_cipher, iv);          return AP4_SUCCESS; }"
"277669_not_vulnerable.c","not_vulnerable","get_word_gray_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo) /* This version is for reading raw-word-format PGM files with any maxval */ {   ppm_source_ptr source = (ppm_source_ptr) sinfo;   register JSAMPROW ptr;   register U_CHAR * bufferptr;   register JSAMPLE *rescale = source->rescale;   JDIMENSION col;    if (! ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))     ERREXIT(cinfo, JERR_INPUT_EOF);   ptr = source->pub.buffer[0];   bufferptr = source->iobuffer;   for (col = cinfo->image_width; col > 0; col--) {     register int temp;     temp  = UCH(*bufferptr++) << 8;     temp |= UCH(*bufferptr++);     *ptr++ = rescale[temp];   }   return 1; }"
"278262_not_vulnerable.c","not_vulnerable","get_indent_str_vtab(char_u *ptr, int ts, int *vts, int list) {     int		count = 0;      for ( ; *ptr; ++ptr)     { 	if (*ptr == TAB)    // count a tab for what it is worth 	{ 	    if (!list || curwin->w_lcs_chars.tab1) 		count += tabstop_padding(count, ts, vts); 	    else 		// In list mode, when tab is not set, count screen char width 		// for Tab, displays: ^I 		count += ptr2cells(ptr); 	} 	else if (*ptr == ' ') 	    ++count;		// count a space for one 	else 	    break;     }     return count; }"
"279906_not_vulnerable.c","not_vulnerable","prepare_tagpreview(     int		undo_sync,	    // sync undo when leaving the window     int		use_previewpopup,   // use popup if 'previewpopup' set     use_popup_T	use_popup)	    // use other popup window {     win_T	*wp;  # ifdef FEAT_GUI     need_mouse_correct = TRUE; # endif      /*      * If there is already a preview window open, use that one.      */     if (!curwin->w_p_pvw)     { # ifdef FEAT_PROP_POPUP 	if (use_previewpopup && *p_pvp != NUL) 	{ 	    wp = popup_find_preview_window(); 	    if (wp != NULL) 		popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL); 	} 	else if (use_popup != USEPOPUP_NONE) 	{ 	    wp = popup_find_info_window(); 	    if (wp != NULL) 	    { 		if (use_popup == USEPOPUP_NORMAL) 		    popup_show(wp); 		else 		    popup_hide(wp); 		// When the popup moves or resizes it may reveal part of 		// another window.  TODO: can this be done more efficiently? 		redraw_all_later(NOT_VALID); 	    } 	} 	else # endif 	{ 	    FOR_ALL_WINDOWS(wp) 		if (wp->w_p_pvw) 		    break; 	} 	if (wp != NULL) 	    win_enter(wp, undo_sync); 	else 	{ 	    /* 	     * There is no preview window open yet.  Create one. 	     */ # ifdef FEAT_PROP_POPUP 	    if ((use_previewpopup && *p_pvp != NUL) 						 || use_popup != USEPOPUP_NONE) 		return popup_create_preview_window(use_popup != USEPOPUP_NONE); # endif 	    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL) 		return FALSE; 	    curwin->w_p_pvw = TRUE; 	    curwin->w_p_wfh = TRUE; 	    RESET_BINDING(curwin);	    // don't take over 'scrollbind' 	    // and 'cursorbind' # ifdef FEAT_DIFF 	    curwin->w_p_diff = FALSE;	    // no 'diff' # endif # ifdef FEAT_FOLDING 	    curwin->w_p_fdc = 0;	    // no 'foldcolumn' # endif 	    return TRUE; 	}     }     return FALSE; }"
"279945_not_vulnerable.c","not_vulnerable","linelen(int *has_tab) {     char_u  *line;     char_u  *first;     char_u  *last;     int	    save;     int	    len;      // Get the line.  If it's empty bail out early (could be the empty string     // for an unloaded buffer).     line = ml_get_curline();     if (*line == NUL) 	return 0;      // find the first non-blank character     first = skipwhite(line);      // find the character after the last non-blank character     for (last = first + STRLEN(first); 				last > first && VIM_ISWHITE(last[-1]); --last) 	;     save = *last;     *last = NUL;     len = linetabsize(line);		// get line length     if (has_tab != NULL)		// check for embedded TAB 	*has_tab = (vim_strchr(first, TAB) != NULL);     *last = save;      return len; }"
"281094_not_vulnerable.c","not_vulnerable","xfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols, 			       const struct flowi *fl, u16 family, 			       struct dst_entry *dst_orig) { 	struct net *net = xp_net(pols[0]); 	struct xfrm_state *xfrm[XFRM_MAX_DEPTH]; 	struct dst_entry *dst; 	struct xfrm_dst *xdst; 	int err;  	/* Try to instantiate a bundle */ 	err = xfrm_tmpl_resolve(pols, num_pols, fl, xfrm, family); 	if (err <= 0) { 		if (err != 0 && err != -EAGAIN) 			XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR); 		return ERR_PTR(err); 	}  	dst = xfrm_bundle_create(pols[0], xfrm, err, fl, dst_orig); 	if (IS_ERR(dst)) { 		XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLEGENERROR); 		return ERR_CAST(dst); 	}  	xdst = (struct xfrm_dst *)dst; 	xdst->num_xfrms = err; 	xdst->num_pols = num_pols; 	memcpy(xdst->pols, pols, sizeof(struct xfrm_policy *) * num_pols); 	xdst->policy_genid = atomic_read(&pols[0]->genid);  	return xdst; }"
"285158_not_vulnerable.c","not_vulnerable","RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) { 	RBinSymbol *sym; 	ut16 off = bin->ne_header->ResidNamTable + bin->header_offset; 	RList *symbols = r_list_newf (free); 	if (!symbols) { 		return NULL; 	} 	RList *entries = r_bin_ne_get_entrypoints (bin); 	bool resident = true, first = true; 	while (entries) { 		ut8 sz = r_buf_read8_at (bin->buf, off); 		if (!sz) { 			first = true; 			if (resident) { 				resident = false; 				off = bin->ne_header->OffStartNonResTab; 				sz = r_buf_read8_at (bin->buf, off); 				if (!sz) { 					break; 				} 			} else { 				break; 			} 		} 		char *name = malloc ((ut64)sz + 1); 		if (!name) { 			break; 		} 		off++; 		r_buf_read_at (bin->buf, off, (ut8 *)name, sz); 		name[sz] = '\0'; 		off += sz; 		sym = R_NEW0 (RBinSymbol); 		if (!sym) { 			break; 		} 		sym->name = name; 		if (!first) { 			sym->bind = R_BIN_BIND_GLOBAL_STR; 		} 		ut16 entry_off = r_buf_read_le16_at (bin->buf, off); 		off += 2; 		RBinAddr *entry = r_list_get_n (entries, entry_off); 		if (entry) { 			sym->paddr = entry->paddr; 		} else { 			sym->paddr = -1; 		} 		sym->ordinal = entry_off; 		r_list_append (symbols, sym); 		first = false; 	} 	RListIter *it; 	RBinAddr *en; 	int i = 1; 	r_list_foreach (entries, it, en) { 		if (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) { 			sym = R_NEW0 (RBinSymbol); 			if (!sym) { 				break; 			} 			sym->name = r_str_newf (""entry%d"", i - 1); 			sym->paddr = en->paddr; 			sym->bind = R_BIN_BIND_GLOBAL_STR; 			sym->ordinal = i; 			r_list_append (symbols, sym); 		} 		i++; 	} 	bin->symbols = symbols; 	return symbols; }"
"286724_not_vulnerable.c","not_vulnerable","TPM_RESULT SWTPM_NVRAM_Init(void) {     const char  *backend_uri;     TPM_RESULT  rc = 0;     TPM_DEBUG("" SWTPM_NVRAM_Init:\n"");      backend_uri = tpmstate_get_backend_uri();     if (!backend_uri) {         logprintf(STDERR_FILENO,                   ""SWTPM_NVRAM_Init: Missing backend URI.\n"");         rc = TPM_FAIL;     } else if (strncmp(backend_uri, ""dir://"", 6) == 0) {         g_nvram_backend_ops = &nvram_dir_ops;     } else if (strncmp(backend_uri, ""file://"", 7) == 0) {         g_nvram_backend_ops = &nvram_linear_ops;     } else {         logprintf(STDERR_FILENO,                   ""SWTPM_NVRAM_Init: Unsupported backend.\n"");         rc = TPM_FAIL;     }      if (rc == 0)         rc = g_nvram_backend_ops->prepare(backend_uri);      return rc; }"
"289249_not_vulnerable.c","not_vulnerable","static int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream) { 	struct snd_pcm_runtime *runtime; 	int err;  	runtime = substream->runtime; 	if (runtime->oss.params) { 		err = snd_pcm_oss_change_params_locked(substream); 		if (err < 0) 			return err; 	} 	if (runtime->oss.prepare) { 		err = snd_pcm_oss_prepare(substream); 		if (err < 0) 			return err; 	} 	return 0; }"
"291804_not_vulnerable.c","not_vulnerable","static void query_fast_reg_mode(struct rtrs_clt_path *clt_path) { 	struct ib_device *ib_dev; 	u64 max_pages_per_mr; 	int mr_page_shift;  	ib_dev = clt_path->s.dev->ib_dev;  	/* 	 * Use the smallest page size supported by the HCA, down to a 	 * minimum of 4096 bytes. We're unlikely to build large sglists 	 * out of smaller entries. 	 */ 	mr_page_shift      = max(12, ffs(ib_dev->attrs.page_size_cap) - 1); 	max_pages_per_mr   = ib_dev->attrs.max_mr_size; 	do_div(max_pages_per_mr, (1ull << mr_page_shift)); 	clt_path->max_pages_per_mr = 		min3(clt_path->max_pages_per_mr, (u32)max_pages_per_mr, 		     ib_dev->attrs.max_fast_reg_page_list_len); 	clt_path->clt->max_segments = 		min(clt_path->max_pages_per_mr, clt_path->clt->max_segments); }"
"291816_not_vulnerable.c","not_vulnerable","static void rtrs_clt_rkey_rsp_done(struct rtrs_clt_con *con, struct ib_wc *wc) { 	struct rtrs_clt_path *clt_path = to_clt_path(con->c.path); 	struct rtrs_msg_rkey_rsp *msg; 	u32 imm_type, imm_payload; 	bool w_inval = false; 	struct rtrs_iu *iu; 	u32 buf_id; 	int err;  	WARN_ON((clt_path->flags & RTRS_MSG_NEW_RKEY_F) == 0);  	iu = container_of(wc->wr_cqe, struct rtrs_iu, cqe);  	if (wc->byte_len < sizeof(*msg)) { 		rtrs_err(con->c.path, ""rkey response is malformed: size %d\n"", 			  wc->byte_len); 		goto out; 	} 	ib_dma_sync_single_for_cpu(clt_path->s.dev->ib_dev, iu->dma_addr, 				   iu->size, DMA_FROM_DEVICE); 	msg = iu->buf; 	if (le16_to_cpu(msg->type) != RTRS_MSG_RKEY_RSP) { 		rtrs_err(clt_path->clt, 			  ""rkey response is malformed: type %d\n"", 			  le16_to_cpu(msg->type)); 		goto out; 	} 	buf_id = le16_to_cpu(msg->buf_id); 	if (WARN_ON(buf_id >= clt_path->queue_depth)) 		goto out;  	rtrs_from_imm(be32_to_cpu(wc->ex.imm_data), &imm_type, &imm_payload); 	if (imm_type == RTRS_IO_RSP_IMM || 	    imm_type == RTRS_IO_RSP_W_INV_IMM) { 		u32 msg_id;  		w_inval = (imm_type == RTRS_IO_RSP_W_INV_IMM); 		rtrs_from_io_rsp_imm(imm_payload, &msg_id, &err);  		if (WARN_ON(buf_id != msg_id)) 			goto out; 		clt_path->rbufs[buf_id].rkey = le32_to_cpu(msg->rkey); 		process_io_rsp(clt_path, msg_id, err, w_inval); 	} 	ib_dma_sync_single_for_device(clt_path->s.dev->ib_dev, iu->dma_addr, 				      iu->size, DMA_FROM_DEVICE); 	return rtrs_clt_recv_done(con, wc); out: 	rtrs_rdma_error_recovery(con); }"
"291832_not_vulnerable.c","not_vulnerable","static void free_path_reqs(struct rtrs_clt_path *clt_path) { 	struct rtrs_clt_io_req *req; 	int i;  	if (!clt_path->reqs) 		return; 	for (i = 0; i < clt_path->queue_depth; ++i) { 		req = &clt_path->reqs[i]; 		if (req->mr) 			ib_dereg_mr(req->mr); 		kfree(req->sge); 		rtrs_iu_free(req->iu, clt_path->s.dev->ib_dev, 1); 	} 	kfree(clt_path->reqs); 	clt_path->reqs = NULL; }"
"291835_not_vulnerable.c","not_vulnerable","static int process_info_rsp(struct rtrs_clt_path *clt_path, 			    const struct rtrs_msg_info_rsp *msg) { 	unsigned int sg_cnt, total_len; 	int i, sgi;  	sg_cnt = le16_to_cpu(msg->sg_cnt); 	if (!sg_cnt || (clt_path->queue_depth % sg_cnt)) { 		rtrs_err(clt_path->clt, 			  ""Incorrect sg_cnt %d, is not multiple\n"", 			  sg_cnt); 		return -EINVAL; 	}  	/* 	 * Check if IB immediate data size is enough to hold the mem_id and 	 * the offset inside the memory chunk. 	 */ 	if ((ilog2(sg_cnt - 1) + 1) + (ilog2(clt_path->chunk_size - 1) + 1) > 	    MAX_IMM_PAYL_BITS) { 		rtrs_err(clt_path->clt, 			  ""RDMA immediate size (%db) not enough to encode %d buffers of size %dB\n"", 			  MAX_IMM_PAYL_BITS, sg_cnt, clt_path->chunk_size); 		return -EINVAL; 	} 	total_len = 0; 	for (sgi = 0, i = 0; sgi < sg_cnt && i < clt_path->queue_depth; sgi++) { 		const struct rtrs_sg_desc *desc = &msg->desc[sgi]; 		u32 len, rkey; 		u64 addr;  		addr = le64_to_cpu(desc->addr); 		rkey = le32_to_cpu(desc->key); 		len  = le32_to_cpu(desc->len);  		total_len += len;  		if (!len || (len % clt_path->chunk_size)) { 			rtrs_err(clt_path->clt, ""Incorrect [%d].len %d\n"", 				  sgi, 				  len); 			return -EINVAL; 		} 		for ( ; len && i < clt_path->queue_depth; i++) { 			clt_path->rbufs[i].addr = addr; 			clt_path->rbufs[i].rkey = rkey;  			len  -= clt_path->chunk_size; 			addr += clt_path->chunk_size; 		} 	} 	/* Sanity check */ 	if (sgi != sg_cnt || i != clt_path->queue_depth) { 		rtrs_err(clt_path->clt, 			 ""Incorrect sg vector, not fully mapped\n""); 		return -EINVAL; 	} 	if (total_len != clt_path->chunk_size * clt_path->queue_depth) { 		rtrs_err(clt_path->clt, ""Incorrect total_len %d\n"", total_len); 		return -EINVAL; 	}  	return 0; }"
"291848_not_vulnerable.c","not_vulnerable","static int rtrs_rdma_route_resolved(struct rtrs_clt_con *con) { 	struct rtrs_clt_path *clt_path = to_clt_path(con->c.path); 	struct rtrs_clt_sess *clt = clt_path->clt; 	struct rtrs_msg_conn_req msg; 	struct rdma_conn_param param;  	int err;  	param = (struct rdma_conn_param) { 		.retry_count = 7, 		.rnr_retry_count = 7, 		.private_data = &msg, 		.private_data_len = sizeof(msg), 	};  	msg = (struct rtrs_msg_conn_req) { 		.magic = cpu_to_le16(RTRS_MAGIC), 		.version = cpu_to_le16(RTRS_PROTO_VER), 		.cid = cpu_to_le16(con->c.cid), 		.cid_num = cpu_to_le16(clt_path->s.con_num), 		.recon_cnt = cpu_to_le16(clt_path->s.recon_cnt), 	}; 	msg.first_conn = clt_path->for_new_clt ? FIRST_CONN : 0; 	uuid_copy(&msg.sess_uuid, &clt_path->s.uuid); 	uuid_copy(&msg.paths_uuid, &clt->paths_uuid);  	err = rdma_connect_locked(con->c.cm_id, &param); 	if (err) 		rtrs_err(clt, ""rdma_connect_locked(): %d\n"", err);  	return err; }"
"292147_not_vulnerable.cpp","not_vulnerable","void LinkResolver::check_field_accessability(Klass* ref_klass,                                              Klass* resolved_klass,                                              Klass* sel_klass,                                              const fieldDescriptor& fd,                                              TRAPS) {   bool can_access = Reflection::verify_member_access(ref_klass,                                                      resolved_klass,                                                      sel_klass,                                                      fd.access_flags(),                                                      true, false, CHECK);   // Any existing exceptions that may have been thrown, for example LinkageErrors   // from nest-host resolution, have been allowed to propagate.   if (!can_access) {     bool same_module = (sel_klass->module() == ref_klass->module());     ResourceMark rm(THREAD);     Exceptions::fthrow(       THREAD_AND_LOCATION,       vmSymbols::java_lang_IllegalAccessError(),       ""class %s tried to access %s%sfield %s.%s (%s%s%s)"",       ref_klass->external_name(),       fd.is_protected() ? ""protected "" : """",       fd.is_private()   ? ""private ""   : """",       sel_klass->external_name(),       fd.name()->as_C_string(),       (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),       (same_module) ? """" : ""; "",       (same_module) ? """" : sel_klass->class_in_module_of_loader()     );     return;   } }"
"292152_not_vulnerable.cpp","not_vulnerable","LinkInfo::LinkInfo(const constantPoolHandle& pool, int index, const methodHandle& current_method, TRAPS) {    // resolve klass   _resolved_klass = pool->klass_ref_at(index, CHECK);    // Get name, signature, and static klass   _name          = pool->name_ref_at(index);   _signature     = pool->signature_ref_at(index);   _tag           = pool->tag_ref_at(index);   _current_klass = pool->pool_holder();   _current_method = current_method;    // Coming from the constant pool always checks access   _check_access  = true; }"
"292220_not_vulnerable.c","not_vulnerable","inbound_part (server *serv, char *chan, char *user, char *ip, char *reason, 				  const message_tags_data *tags_data) { 	session *sess = find_channel (serv, chan); 	if (sess) 	{ 		if (*reason) 			EMIT_SIGNAL_TIMESTAMP (XP_TE_PARTREASON, sess, user, ip, chan, reason, 										  0, tags_data->timestamp); 		else 			EMIT_SIGNAL_TIMESTAMP (XP_TE_PART, sess, user, ip, chan, NULL, 0, 										  tags_data->timestamp); 		userlist_remove (sess, user); 	} }"
"293499_not_vulnerable.c","not_vulnerable","static unsigned int gif_interlaced_line(int height, int y) {         if ((y << 3) < height) {                 return (y << 3);         }         y -= ((height + 7) >> 3);         if ((y << 3) < (height - 4)) {                 return (y << 3) + 4;         }         y -= ((height + 3) >> 3);         if ((y << 2) < (height - 2)) {                 return (y << 2) + 2;         }         y -= ((height + 1) >> 2);         return (y << 1) + 1; }"
"293743_not_vulnerable.c","not_vulnerable","static void r_rebase_info_populate(RRebaseInfo *info, RKernelCacheObj *obj) { 	struct section_t *sections = NULL; 	int i = 0;  	if (obj->rebase_info_populated) { 		return; 	} 	obj->rebase_info_populated = true;  	for (; i < info->n_ranges; i++) { 		if (info->ranges[i].size != UT64_MAX) { 			goto cleanup; 		} else if (sections == NULL) { 			if (!(sections = MACH0_(get_sections) (obj->mach0))) { 				return; 			} 		} 		info->ranges[i].offset = r_rebase_offset_to_paddr (obj, sections, info->ranges[i].offset); 		ut64 end = iterate_rebase_list (obj->cache_buf, info->multiplier, info->ranges[i].offset, NULL, NULL); 		if (end != UT64_MAX) { 			info->ranges[i].size = end - info->ranges[i].offset + 8; 		} else { 			info->ranges[i].size = 0; 		} 	}  cleanup: 	R_FREE (sections); }"
"293756_not_vulnerable.c","not_vulnerable","static void rebase_buffer(RKernelCacheObj *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) { 	if (obj->rebasing_buffer || !buf) { 		return; 	} 	obj->rebasing_buffer = true;  	ut64 eob = off + count; 	int i = 0; 	RRebaseCtx ctx;  	ctx.off = off; 	ctx.eob = eob; 	ctx.buf = buf; 	ctx.count = count; 	ctx.obj = obj;  	for (; i < obj->rebase_info->n_ranges; i++) { 		ut64 start = obj->rebase_info->ranges[i].offset; 		ut64 end = start + obj->rebase_info->ranges[i].size; 		if (end >= off && start <= eob) { 			iterate_rebase_list (obj->cache_buf, obj->rebase_info->multiplier, start, 				(ROnRebaseFunc) on_rebase_pointer, &ctx); 		} 	}  	obj->rebasing_buffer = false; }"
"294360_not_vulnerable.c","not_vulnerable","d_lite_step(int argc, VALUE *argv, VALUE self) {     VALUE limit, step, date;     int c;      rb_scan_args(argc, argv, ""11"", &limit, &step);      if (argc < 2) 	step = INT2FIX(1);  #if 0     if (f_zero_p(step)) 	rb_raise(rb_eArgError, ""step can't be 0""); #endif      RETURN_ENUMERATOR(self, argc, argv);      date = self;     c = f_cmp(step, INT2FIX(0));     if (c < 0) { 	while (FIX2INT(d_lite_cmp(date, limit)) >= 0) { 	    rb_yield(date); 	    date = d_lite_plus(date, step); 	}     }     else if (c == 0) { 	while (1) 	    rb_yield(date);     }     else /* if (c > 0) */ { 	while (FIX2INT(d_lite_cmp(date, limit)) <= 0) { 	    rb_yield(date); 	    date = d_lite_plus(date, step); 	}     }     return self; }"
"294362_not_vulnerable.c","not_vulnerable","c_valid_civil_p(int y, int m, int d, double sg, 		int *rm, int *rd, int *rjd, int *ns) {     int ry;      if (m < 0) 	m += 13;     if (d < 0) { 	if (!c_find_ldom(y, m, sg, rjd, ns)) 	    return 0; 	c_jd_to_civil(*rjd + d + 1, sg, &ry, rm, rd); 	if (ry != y || *rm != m) 	    return 0; 	d = *rd;     }     c_civil_to_jd(y, m, d, sg, rjd, ns);     c_jd_to_civil(*rjd, sg, &ry, rm, rd);     if (ry != y || *rm != m || *rd != d) 	return 0;     return 1; }"
"294366_not_vulnerable.c","not_vulnerable","tmx_m_secs(union DateData *x) {     VALUE s;     int df;      s = day_to_sec(f_sub(m_real_jd(x), 			 UNIX_EPOCH_IN_CJD));     if (simple_dat_p(x)) 	return s;     df = m_df(x);     if (df) 	s = f_add(s, INT2FIX(df));     return s; }"
"294517_not_vulnerable.c","not_vulnerable","div_df(VALUE d, VALUE *f) {     VALUE s = day_to_sec(d);      if (f) 	*f = f_mod(s, INT2FIX(1));     return f_floor(s); }"
"294543_not_vulnerable.c","not_vulnerable","m_real_local_jd(union DateData *x) {     VALUE nth, rjd;     int jd;      nth = m_nth(x);     jd = m_local_jd(x);      encode_jd(nth, jd, &rjd);     return rjd; }"
"294584_not_vulnerable.c","not_vulnerable","rt__valid_weeknum_p(VALUE y, VALUE w, VALUE d, VALUE f, VALUE sg) {     VALUE nth, rjd2;     int ry, rw, rd, rjd, ns;      if (!valid_weeknum_p(y, NUM2INT(w), NUM2INT(d), NUM2INT(f), NUM2DBL(sg), 			 &nth, &ry, 			 &rw, &rd, &rjd, 			 &ns)) 	return Qnil;     encode_jd(nth, rjd, &rjd2);     return rjd2; }"
"294598_not_vulnerable.c","not_vulnerable","m_mday(union DateData *x) {     if (simple_dat_p(x)) { 	get_s_civil(x); #ifndef USE_PACK 	return x->s.mday; #else 	return EX_MDAY(x->s.pc); #endif     }     else { 	get_c_civil(x); #ifndef USE_PACK 	return x->c.mday; #else 	return EX_MDAY(x->c.pc); #endif     } }"
"294628_not_vulnerable.c","not_vulnerable","c_valid_gregorian_p(int y, int m, int d, int *rm, int *rd) {     int last;      if (m < 0) 	m += 13;     if (m < 1 || m > 12) 	return 0;     last = c_gregorian_last_day_of_month(y, m);     if (d < 0) 	d = last + d + 1;     if (d < 1 || d > last) 	return 0;     *rm = m;     *rd = d;     return 1; }"
"299916_not_vulnerable.c","not_vulnerable","read_macro_assignment(uschar *s) { uschar name[64]; int namelen = 0; BOOL redef = FALSE; macro_item *m; macro_item *mlast = NULL;  while (isalnum(*s) || *s == '_')   {   if (namelen >= sizeof(name) - 1)     log_write(0, LOG_PANIC_DIE|LOG_CONFIG_IN,       ""macro name too long (maximum is %d characters)"", sizeof(name) - 1);   name[namelen++] = *s++;   } name[namelen] = 0;  while (isspace(*s)) s++; if (*s++ != '=')   log_write(0, LOG_PANIC_DIE|LOG_CONFIG_IN, ""malformed macro definition"");  if (*s == '=')   {   redef = TRUE;   s++;   } while (isspace(*s)) s++;  /* If an existing macro of the same name was defined on the command line, we just skip this definition. It's an error to attempt to redefine a macro without redef set to TRUE, or to redefine a macro when it hasn't been defined earlier. It is also an error to define a macro whose name begins with the name of a previously defined macro. Note: it is documented that the other way round works. */  for (m = macros; m != NULL; m = m->next)   {   int len = Ustrlen(m->name);    if (Ustrcmp(m->name, name) == 0)     {     if (!m->command_line && !redef)       log_write(0, LOG_CONFIG|LOG_PANIC_DIE, ""macro \""%s\"" is already ""        ""defined (use \""==\"" if you want to redefine it"", name);     break;     }    if (len < namelen && Ustrstr(name, m->name) != NULL)     log_write(0, LOG_CONFIG|LOG_PANIC_DIE, ""\""%s\"" cannot be defined as ""       ""a macro because previously defined macro \""%s\"" is a substring"",       name, m->name);    /* We cannot have this test, because it is documented that a substring   macro is permitted (there is even an example).   *   * if (len > namelen && Ustrstr(m->name, name) != NULL)   *   log_write(0, LOG_CONFIG|LOG_PANIC_DIE, ""\""%s\"" cannot be defined as ""   *     ""a macro because it is a substring of previously defined macro \""%s\"""",   *     name, m->name);   */    mlast = m;   }  /* Check for an overriding command-line definition. */  if (m != NULL && m->command_line) return;  /* Redefinition must refer to an existing macro. */  if (redef)   {   if (m == NULL)     log_write(0, LOG_CONFIG|LOG_PANIC_DIE, ""can't redefine an undefined macro ""       ""\""%s\"""", name);   }  /* We have a new definition. The macro_item structure includes a final vector called ""name"" which is one byte long. Thus, adding ""namelen"" gives us enough room to store the ""name"" string. */  else   {   m = store_get(sizeof(macro_item) + namelen);   if (macros == NULL) macros = m; else mlast->next = m;   Ustrncpy(m->name, name, namelen);   m->name[namelen] = 0;   m->next = NULL;   m->command_line = FALSE;   }  /* Set the value of the new or redefined macro */  m->replacement = string_copy(s); }"
"299978_not_vulnerable.c","not_vulnerable","static int elo_raw_event(struct hid_device *hdev, struct hid_report *report, 	 u8 *data, int size) { 	struct hid_input *hidinput;  	if (!(hdev->claimed & HID_CLAIMED_INPUT) || list_empty(&hdev->inputs)) 		return 0;  	hidinput = list_first_entry(&hdev->inputs, struct hid_input, list);  	switch (report->id) { 	case 0: 		if (data[0] == 'T') {	/* Mandatory ELO packet marker */ 			elo_process_data(hidinput->input, data, size); 			return 1; 		} 		break; 	default:	/* unknown report */ 		/* Unknown report type; pass upstream */ 		hid_info(hdev, ""unknown report type %d\n"", report->id); 		break; 	}  	return 0; }"
"301014_not_vulnerable.c","not_vulnerable","pcx256_print_page(gx_device_printer * pdev, gp_file * file) {     pcx_header header;     int code;      header = pcx_header_prototype;     header.version = version_3_0;     header.bpp = 8;     header.nplanes = 1;     assign_ushort(header.palinfo,                   (pdev->color_info.num_components > 1 ?                    palinfo_color : palinfo_gray));     code = pcx_write_page(pdev, file, &header, false);     if (code >= 0) {		/* Write out the palette. */         gp_fputc(0x0c, file);         code = pc_write_palette((gx_device *) pdev, 256, file);     }     return code; }"
"301343_not_vulnerable.c","not_vulnerable","static int vfswrap_kernel_flock(vfs_handle_struct *handle, files_struct *fsp, 				uint32 share_mode, uint32 access_mask) { 	START_PROFILE(syscall_kernel_flock); 	kernel_flock(fsp->fh->fd, share_mode, access_mask); 	END_PROFILE(syscall_kernel_flock); 	return 0; }"
"301395_not_vulnerable.c","not_vulnerable","static struct dirent *vfswrap_readdir(vfs_handle_struct *handle, 				          DIR *dirp, 					  SMB_STRUCT_STAT *sbuf) { 	struct dirent *result;  	START_PROFILE(syscall_readdir); 	result = readdir(dirp); 	END_PROFILE(syscall_readdir); 	if (sbuf) { 		/* Default Posix readdir() does not give us stat info. 		 * Set to invalid to indicate we didn't return this info. */ 		SET_STAT_INVALID(*sbuf); #if defined(HAVE_DIRFD) && defined(HAVE_FSTATAT) 		if (result != NULL) { 			/* See if we can efficiently return this. */ 			struct stat st; 			int flags = (lp_posix_pathnames() ? 				AT_SYMLINK_NOFOLLOW : 0); 			int ret = fstatat(dirfd(dirp), 					result->d_name, 					&st, 					flags); 			if (ret == 0) { 				init_stat_ex_from_stat(sbuf, 					&st, 					lp_fake_dir_create_times( 						SNUM(handle->conn))); 			} 		} #endif 	} 	return result; }"
"301492_not_vulnerable.c","not_vulnerable","can_be_compound(     trystate_T	*sp,     slang_T	*slang,     char_u	*compflags,     int		flag) {     // If the flag doesn't appear in sl_compstartflags or sl_compallflags     // then it can't possibly compound.     if (!byte_in_str(sp->ts_complen == sp->ts_compsplit 		? slang->sl_compstartflags : slang->sl_compallflags, flag)) 	return FALSE;      // If there are no wildcards, we can check if the flags collected so far     // possibly can form a match with COMPOUNDRULE patterns.  This only     // makes sense when we have two or more words.     if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)     { 	int v;  	compflags[sp->ts_complen] = flag; 	compflags[sp->ts_complen + 1] = NUL; 	v = match_compoundrule(slang, compflags + sp->ts_compsplit); 	compflags[sp->ts_complen] = NUL; 	return v;     }      return TRUE; }"
"307846_not_vulnerable.cpp","not_vulnerable","ciKlass* ciEnv::get_klass_by_index(constantPoolHandle cpool,                                    int index,                                    bool& is_accessible,                                    ciInstanceKlass* accessor) {   GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);) }"
"308203_not_vulnerable.c","not_vulnerable","static int fastrpc_init(void) { 	int ret;  	ret = platform_driver_register(&fastrpc_cb_driver); 	if (ret < 0) { 		pr_err(""fastrpc: failed to register cb driver\n""); 		return ret; 	}  	ret = register_rpmsg_driver(&fastrpc_driver); 	if (ret < 0) { 		pr_err(""fastrpc: failed to register rpmsg driver\n""); 		platform_driver_unregister(&fastrpc_cb_driver); 		return ret; 	}  	return 0; }"
"309838_not_vulnerable.c","not_vulnerable","cleanup(void) {     endwin();      fflush(stdout);     fprintf(stderr, ""\n\n%ld total cells, rate %.2f/sec\n"", 	    total_chars, 	    ((double) (total_chars) / (double) (time((time_t *) 0) - started))); }"
"309870_not_vulnerable.c","not_vulnerable","reset_color_pair(NCURSES_SP_DCL0) { #ifdef USE_TERM_DRIVER     return CallDriver(SP_PARM, td_rescol); #else     bool result = FALSE;      (void) SP_PARM;     if (orig_pair != 0) { 	(void) NCURSES_PUTP2(""orig_pair"", orig_pair); 	result = TRUE;     }     return result; #endif }"
"309898_not_vulnerable.c","not_vulnerable","check_sgr_param(TERMTYPE2 *tp, int code, const char *name, char *value) {     if (VALID_STRING(value)) { 	int ncv = ((code != 0) ? (1 << (code - 1)) : 0); 	char *test = tgoto(value, 0, 0); 	if (is_sgr_string(test)) { 	    int param = 0; 	    int count = 0; 	    int skips = 0; 	    int color = (value == set_a_foreground || 			 value == set_a_background || 			 value == set_foreground || 			 value == set_background); 	    while (*test != 0) { 		if (isdigit(UChar(*test))) { 		    param = 10 * param + (*test - '0'); 		    ++count; 		} else { 		    if (count) { 			/* 			 * Avoid unnecessary warning for xterm 256color codes. 			 */ 			if (color && (param == 38 || param == 48)) 			    skips = 3; 			if ((skips-- <= 0) && (param == code)) 			    break; 		    } 		    count = 0; 		    param = 0; 		} 		++test; 	    } 	    if (count != 0 && param == code) { 		if (code == 0 || 		    no_color_video < 0 || 		    !(no_color_video & ncv)) { 		    _nc_warning(""\""%s\"" SGR-attribute used in %s"", 				sgr_names[code], 				name); 		} 	    } 	}     } }"
"309950_not_vulnerable.c","not_vulnerable","NCURSES_SP_NAME(init_color) (NCURSES_SP_DCLx 			     NCURSES_COLOR_T color, 			     NCURSES_COLOR_T r, 			     NCURSES_COLOR_T g, 			     NCURSES_COLOR_T b) {     return _nc_init_color(SP_PARM, color, r, g, b); }"
"310000_not_vulnerable.c","not_vulnerable","npop(void) {     int result = 0;     if (TPS(stack_ptr) > 0) { 	TPS(stack_ptr)--; 	if (TPS(stack)[TPS(stack_ptr)].num_type) 	    result = TPS(stack)[TPS(stack_ptr)].data.num;     } else { 	DEBUG(2, (""npop: stack underflow: %s"", _nc_visbuf(TPS(tparam_base)))); 	_nc_tparm_err++;     }     return result; }"
"310336_not_vulnerable.c","not_vulnerable","dirserv_get_networkstatus_v2_fingerprints(smartlist_t *result,                                           const char *key) {   tor_assert(result);    if (!cached_v2_networkstatus)     cached_v2_networkstatus = digestmap_new();    if (should_generate_v2_networkstatus())     generate_v2_networkstatus_opinion();    if (!strcmp(key,""authority"")) {     if (authdir_mode_v2(get_options())) {       routerinfo_t *me = router_get_my_routerinfo();       if (me)         smartlist_add(result,                       tor_memdup(me->cache_info.identity_digest, DIGEST_LEN));     }   } else if (!strcmp(key, ""all"")) {     if (digestmap_size(cached_v2_networkstatus)) {       digestmap_iter_t *iter;       iter = digestmap_iter_init(cached_v2_networkstatus);       while (!digestmap_iter_done(iter)) {         const char *ident;         void *val;         digestmap_iter_get(iter, &ident, &val);         smartlist_add(result, tor_memdup(ident, DIGEST_LEN));         iter = digestmap_iter_next(cached_v2_networkstatus, iter);       }     } else {       SMARTLIST_FOREACH(router_get_trusted_dir_servers(),                   trusted_dir_server_t *, ds,                   if (ds->type & V2_AUTHORITY)                     smartlist_add(result, tor_memdup(ds->digest, DIGEST_LEN)));     }     smartlist_sort_digests(result);     if (smartlist_len(result) == 0)       log_info(LD_DIRSERV,                ""Client requested 'all' network status objects; we have none."");   } else if (!strcmpstart(key, ""fp/"")) {     dir_split_resource_into_fingerprints(key+3, result, NULL,                                          DSR_HEX|DSR_SORT_UNIQ);   } }"
"312511_not_vulnerable.c","not_vulnerable","qf_open_new_file_win(qf_info_T *ll_ref) {     int		flags;      flags = WSP_ABOVE;     if (ll_ref != NULL) 	flags |= WSP_NEWLOC;     if (win_split(0, flags) == FAIL) 	return FAIL;		// not enough room for window     p_swb = empty_option;	// don't split again     swb_flags = 0;     RESET_BINDING(curwin);     if (ll_ref != NULL) 	// The new window should use the location list from the 	// location list window 	win_set_loclist(curwin, ll_ref);     return OK; }"
"312523_not_vulnerable.c","not_vulnerable","get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv) {     if (what_arg->v_type == VAR_UNKNOWN)     { 	if (rettv_list_alloc(rettv) == OK) 	    if (is_qf || wp != NULL) 		(void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);     }     else     { 	if (rettv_dict_alloc(rettv) == OK) 	    if (is_qf || (wp != NULL)) 	    { 		if (what_arg->v_type == VAR_DICT) 		{ 		    dict_T	*d = what_arg->vval.v_dict;  		    if (d != NULL) 			qf_get_properties(wp, d, rettv->vval.v_dict); 		} 		else 		    emsg(_(e_dictionary_required)); 	    }     } }"
"312531_not_vulnerable.c","not_vulnerable","qf_update_win_titlevar(qf_info_T *qi) {     qf_list_T	*qfl = qf_get_curlist(qi);     tabpage_T	*tp;     win_T	*win;     win_T	*save_curwin = curwin;      FOR_ALL_TAB_WINDOWS(tp, win)     { 	if (is_qf_win(win, qi)) 	{ 	    curwin = win; 	    qf_set_title_var(qfl); 	}     }     curwin = save_curwin; }"
"313139_not_vulnerable.c","not_vulnerable","testStorageChain(const void *args) {     const struct testChainData *data = args;     virStorageSourcePtr elt;     size_t i = 0;     g_autoptr(virStorageSource) meta = NULL;     g_autofree char *broken = NULL;      meta = testStorageFileGetMetadata(data->start, data->format, -1, -1);     if (!meta) {         if (data->flags & EXP_FAIL) {             virResetLastError();             return 0;         }         return -1;     } else if (data->flags & EXP_FAIL) {         fprintf(stderr, ""call should have failed\n"");         return -1;     }      if (virGetLastErrorCode()) {         fprintf(stderr, ""call should not have reported error\n"");         return -1;     }      if (virStorageFileChainGetBroken(meta, &broken) || broken) {         fprintf(stderr, ""chain should not be identified as broken\n"");         return -1;     }      elt = meta;     while (virStorageSourceIsBacking(elt)) {         g_autofree char *expect = NULL;         g_autofree char *actual = NULL;          if (i == data->nfiles) {             fprintf(stderr, ""probed chain was too long\n"");             return -1;         }          expect = g_strdup_printf(testStorageChainFormat, i,                                  NULLSTR(data->files[i]->path),                                  NULLSTR(data->files[i]->expBackingStoreRaw),                                  data->files[i]->expCapacity,                                  data->files[i]->expEncrypted,                                  NULLSTR(data->files[i]->pathRel),                                  data->files[i]->type,                                  data->files[i]->format,                                  virStorageNetProtocolTypeToString(data->files[i]->protocol),                                  NULLSTR(data->files[i]->hostname));         actual = g_strdup_printf(testStorageChainFormat, i,                                  NULLSTR(elt->path),                                  NULLSTR(elt->backingStoreRaw),                                  elt->capacity,                                  !!elt->encryption,                                  NULLSTR(elt->relPath),                                  elt->type,                                  elt->format,                                  virStorageNetProtocolTypeToString(elt->protocol),                                  NULLSTR(elt->nhosts ? elt->hosts[0].name : NULL));         if (STRNEQ(expect, actual)) {             virTestDifference(stderr, expect, actual);             return -1;         }         elt = elt->backingStore;         i++;     }     if (i != data->nfiles) {         fprintf(stderr, ""probed chain was too short\n"");         return -1;     }      return 0; }"
"313541_not_vulnerable.c","not_vulnerable","static void rose_remove_node(struct rose_node *rose_node) { 	struct rose_node *s;  	if ((s = rose_node_list) == rose_node) { 		rose_node_list = rose_node->next; 		kfree(rose_node); 		return; 	}  	while (s != NULL && s->next != NULL) { 		if (s->next == rose_node) { 			s->next = rose_node->next; 			kfree(rose_node); 			return; 		}  		s = s->next; 	} }"
"313819_not_vulnerable.c","not_vulnerable","do_nv_ident(int c1, int c2) {     oparg_T	oa;     cmdarg_T	ca;      clear_oparg(&oa);     CLEAR_FIELD(ca);     ca.oap = &oa;     ca.cmdchar = c1;     ca.nchar = c2;     nv_ident(&ca); }"
"313835_not_vulnerable.c","not_vulnerable","call_yank_do_autocmd(int regname) {     oparg_T	oa;     yankreg_T	*reg;      clear_oparg(&oa);     oa.regname = regname;     oa.op_type = OP_YANK;     oa.is_VIsual = TRUE;     reg = get_register(regname, TRUE);     yank_do_autocmd(&oa, reg);     free_register(reg); }"
"314475_not_vulnerable.h","not_vulnerable","static bool FNAME(is_bad_mt_xwr)(struct rsvd_bits_validate *rsvd_check, u64 gpte) { #if PTTYPE != PTTYPE_EPT 	return false; #else 	return __is_bad_mt_xwr(rsvd_check, gpte); #endif }"
"314531_not_vulnerable.c","not_vulnerable","PJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr2( 				const pjmedia_sdp_media *m, 				const char *name, const pj_str_t *fmt) {     PJ_ASSERT_RETURN(m && name, NULL);     return pjmedia_sdp_attr_find2(m->attr_count, m->attr, name, fmt); }"
"314749_not_vulnerable.c","not_vulnerable","cdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat) { 	size_t i, j, k; 	size_t ss = CDF_SEC_SIZE(h); 	cdf_secid_t *msa, mid, sec; 	size_t nsatpersec = (ss / sizeof(mid)) - 1;  	for (i = 0; i < __arraycount(h->h_master_sat); i++) 		if (h->h_master_sat[i] == CDF_SECID_FREE) 			break;  #define CDF_SEC_LIMIT (UINT32_MAX / (4 * ss)) 	if ((nsatpersec > 0 && 	    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) || 	    i > CDF_SEC_LIMIT) { 		DPRINTF((""Number of sectors in master SAT too big %u %"" 		    SIZE_T_FORMAT ""u\n"", h->h_num_sectors_in_master_sat, i)); 		errno = EFTYPE; 		return -1; 	}  	sat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i; 	DPRINTF((""sat_len = %"" SIZE_T_FORMAT ""u ss = %"" SIZE_T_FORMAT ""u\n"", 	    sat->sat_len, ss)); 	if ((sat->sat_tab = CAST(cdf_secid_t *, calloc(sat->sat_len, ss))) 	    == NULL) 		return -1;  	for (i = 0; i < __arraycount(h->h_master_sat); i++) { 		if (h->h_master_sat[i] < 0) 			break; 		if (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h, 		    h->h_master_sat[i]) != (ssize_t)ss) { 			DPRINTF((""Reading sector %d"", h->h_master_sat[i])); 			goto out1; 		} 	}  	if ((msa = CAST(cdf_secid_t *, calloc(1, ss))) == NULL) 		goto out1;  	mid = h->h_secid_first_sector_in_master_sat; 	for (j = 0; j < h->h_num_sectors_in_master_sat; j++) { 		if (mid < 0) 			goto out; 		if (j >= CDF_LOOP_LIMIT) { 			DPRINTF((""Reading master sector loop limit"")); 			errno = EFTYPE; 			goto out2; 		} 		if (cdf_read_sector(info, msa, 0, ss, h, mid) != (ssize_t)ss) { 			DPRINTF((""Reading master sector %d"", mid)); 			goto out2; 		} 		for (k = 0; k < nsatpersec; k++, i++) { 			sec = CDF_TOLE4((uint32_t)msa[k]); 			if (sec < 0) 				goto out; 			if (i >= sat->sat_len) { 			    DPRINTF((""Out of bounds reading MSA %"" SIZE_T_FORMAT 				""u >= %"" SIZE_T_FORMAT ""u"", i, sat->sat_len)); 			    errno = EFTYPE; 			    goto out2; 			} 			if (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h, 			    sec) != (ssize_t)ss) { 				DPRINTF((""Reading sector %d"", 				    CDF_TOLE4(msa[k]))); 				goto out2; 			} 		} 		mid = CDF_TOLE4((uint32_t)msa[nsatpersec]); 	} out: 	sat->sat_len = i; 	free(msa); 	return 0; out2: 	free(msa); out1: 	free(sat->sat_tab); 	return -1; }"
"314776_not_vulnerable.c","not_vulnerable","cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,     const cdf_header_t *h, cdf_secid_t id) { 	size_t ss = CDF_SEC_SIZE(h); 	size_t pos = CDF_SEC_POS(h, id); 	assert(ss == len); 	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len); }"
"316978_not_vulnerable.c","not_vulnerable","static int smack_inode_getattr(const struct path *path) { 	struct smk_audit_info ad; 	struct inode *inode = d_backing_inode(path->dentry); 	int rc;  	smk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH); 	smk_ad_setfield_u_fs_path(&ad, *path); 	rc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad); 	rc = smk_bu_inode(inode, MAY_READ, rc); 	return rc; }"
"317038_not_vulnerable.c","not_vulnerable","static int smack_inode_setsecurity(struct inode *inode, const char *name, 				   const void *value, size_t size, int flags) { 	struct smack_known *skp; 	struct inode_smack *nsp = smack_inode(inode); 	struct socket_smack *ssp; 	struct socket *sock; 	int rc = 0;  	if (value == NULL || size > SMK_LONGLABEL || size == 0) 		return -EINVAL;  	skp = smk_import_entry(value, size); 	if (IS_ERR(skp)) 		return PTR_ERR(skp);  	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0) { 		nsp->smk_inode = skp; 		nsp->smk_flags |= SMK_INODE_INSTANT; 		return 0; 	} 	/* 	 * The rest of the Smack xattrs are only on sockets. 	 */ 	if (inode->i_sb->s_magic != SOCKFS_MAGIC) 		return -EOPNOTSUPP;  	sock = SOCKET_I(inode); 	if (sock == NULL || sock->sk == NULL) 		return -EOPNOTSUPP;  	ssp = sock->sk->sk_security;  	if (strcmp(name, XATTR_SMACK_IPIN) == 0) 		ssp->smk_in = skp; 	else if (strcmp(name, XATTR_SMACK_IPOUT) == 0) { 		ssp->smk_out = skp; 		if (sock->sk->sk_family == PF_INET) { 			rc = smack_netlbl_add(sock->sk); 			if (rc != 0) 				printk(KERN_WARNING 					""Smack: \""%s\"" netlbl error %d.\n"", 					__func__, -rc); 		} 	} else 		return -EOPNOTSUPP;  #ifdef SMACK_IPV6_PORT_LABELING 	if (sock->sk->sk_family == PF_INET6) 		smk_ipv6_port_label(sock, NULL); #endif  	return 0; }"
"317089_not_vulnerable.c","not_vulnerable","static int selinux_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid) { 	return security_context_to_sid(&selinux_state, secdata, seclen, 				       secid, GFP_KERNEL); }"
"317162_not_vulnerable.c","not_vulnerable","static int smack_file_lock(struct file *file, unsigned int cmd) { 	struct smk_audit_info ad; 	int rc; 	struct inode *inode = file_inode(file);  	if (unlikely(IS_PRIVATE(inode))) 		return 0;  	smk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH); 	smk_ad_setfield_u_fs_path(&ad, file->f_path); 	rc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad); 	rc = smk_bu_file(file, MAY_LOCK, rc); 	return rc; }"
"317217_not_vulnerable.c","not_vulnerable","static void smack_ipc_getsecid(struct kern_ipc_perm *ipp, u32 *secid) { 	struct smack_known **blob = smack_ipc(ipp); 	struct smack_known *iskp = *blob;  	*secid = iskp->smk_secid; }"
"317311_not_vulnerable.c","not_vulnerable","static inline u32 open_file_to_av(struct file *file) { 	u32 av = file_to_av(file); 	struct inode *inode = file_inode(file);  	if (selinux_policycap_openperm() && 	    inode->i_sb->s_magic != SOCKFS_MAGIC) 		av |= FILE__OPEN;  	return av; }"
"317355_not_vulnerable.c","not_vulnerable","static int selinux_socket_getpeersec_stream(struct socket *sock, char __user *optval, 					    int __user *optlen, unsigned len) { 	int err = 0; 	char *scontext; 	u32 scontext_len; 	struct sk_security_struct *sksec = sock->sk->sk_security; 	u32 peer_sid = SECSID_NULL;  	if (sksec->sclass == SECCLASS_UNIX_STREAM_SOCKET || 	    sksec->sclass == SECCLASS_TCP_SOCKET || 	    sksec->sclass == SECCLASS_SCTP_SOCKET) 		peer_sid = sksec->peer_sid; 	if (peer_sid == SECSID_NULL) 		return -ENOPROTOOPT;  	err = security_sid_to_context(&selinux_state, peer_sid, &scontext, 				      &scontext_len); 	if (err) 		return err;  	if (scontext_len > len) { 		err = -ERANGE; 		goto out_len; 	}  	if (copy_to_user(optval, scontext, scontext_len)) 		err = -EFAULT;  out_len: 	if (put_user(scontext_len, optlen)) 		err = -EFAULT; 	kfree(scontext); 	return err; }"
"318104_not_vulnerable.c","not_vulnerable","static int rsi_usb_read_register_multiple(struct rsi_hw *adapter, u32 addr, 					  u8 *data, u16 count) { 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev; 	u8 *buf; 	u16 transfer; 	int status;  	if (!addr) 		return -EINVAL;  	buf = kzalloc(RSI_USB_BUF_SIZE, GFP_KERNEL); 	if (!buf) 		return -ENOMEM;  	while (count) { 		transfer = min_t(u16, count, RSI_USB_BUF_SIZE); 		status = usb_control_msg(dev->usbdev, 					 usb_rcvctrlpipe(dev->usbdev, 0), 					 USB_VENDOR_REGISTER_READ, 					 RSI_USB_REQ_IN, 					 ((addr & 0xffff0000) >> 16), 					 (addr & 0xffff), (void *)buf, 					 transfer, USB_CTRL_GET_TIMEOUT); 		if (status < 0) { 			rsi_dbg(ERR_ZONE, 				""Reg read failed with error code :%d\n"", 				 status); 			kfree(buf); 			return status; 		} 		memcpy(data, buf, transfer); 		count -= transfer; 		data += transfer; 		addr += transfer; 	} 	kfree(buf); 	return 0; }"
"318977_not_vulnerable.c","not_vulnerable","f_test_null_list(typval_T *argvars UNUSED, typval_T *rettv) {     rettv_list_set(rettv, NULL); }"
"326105_not_vulnerable.c","not_vulnerable","reg(     int		paren,	// REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN     int		*flagp) {     char_u	*ret;     char_u	*br;     char_u	*ender;     int		parno = 0;     int		flags;      *flagp = HASWIDTH;		// Tentatively.  #ifdef FEAT_SYN_HL     if (paren == REG_ZPAREN)     { 	// Make a ZOPEN node. 	if (regnzpar >= NSUBEXP) 	    EMSG_RET_NULL(_(e_too_many_z)); 	parno = regnzpar; 	regnzpar++; 	ret = regnode(ZOPEN + parno);     }     else #endif 	if (paren == REG_PAREN)     { 	// Make a MOPEN node. 	if (regnpar >= NSUBEXP) 	    EMSG2_RET_NULL(_(e_too_many_str_open), reg_magic == MAGIC_ALL); 	parno = regnpar; 	++regnpar; 	ret = regnode(MOPEN + parno);     }     else if (paren == REG_NPAREN)     { 	// Make a NOPEN node. 	ret = regnode(NOPEN);     }     else 	ret = NULL;      // Pick up the branches, linking them together.     br = regbranch(&flags);     if (br == NULL) 	return NULL;     if (ret != NULL) 	regtail(ret, br);	// [MZ]OPEN -> first.     else 	ret = br;     // If one of the branches can be zero-width, the whole thing can.     // If one of the branches has * at start or matches a line-break, the     // whole thing can.     if (!(flags & HASWIDTH)) 	*flagp &= ~HASWIDTH;     *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);     while (peekchr() == Magic('|'))     { 	skipchr(); 	br = regbranch(&flags); 	if (br == NULL || reg_toolong) 	    return NULL; 	regtail(ret, br);	// BRANCH -> BRANCH. 	if (!(flags & HASWIDTH)) 	    *flagp &= ~HASWIDTH; 	*flagp |= flags & (SPSTART | HASNL | HASLOOKBH);     }      // Make a closing node, and hook it on the end.     ender = regnode( #ifdef FEAT_SYN_HL 	    paren == REG_ZPAREN ? ZCLOSE + parno : #endif 	    paren == REG_PAREN ? MCLOSE + parno : 	    paren == REG_NPAREN ? NCLOSE : END);     regtail(ret, ender);      // Hook the tails of the branches to the closing node.     for (br = ret; br != NULL; br = regnext(br)) 	regoptail(br, ender);      // Check for proper termination.     if (paren != REG_NOPAREN && getchr() != Magic(')'))     { #ifdef FEAT_SYN_HL 	if (paren == REG_ZPAREN) 	    EMSG_RET_NULL(_(e_unmatched_z)); 	else #endif 	    if (paren == REG_NPAREN) 	    EMSG2_RET_NULL(_(e_unmatched_str_percent_open), reg_magic == MAGIC_ALL); 	else 	    EMSG2_RET_NULL(_(e_unmatched_str_open), reg_magic == MAGIC_ALL);     }     else if (paren == REG_NOPAREN && peekchr() != NUL)     { 	if (curchr == Magic(')')) 	    EMSG2_RET_NULL(_(e_unmatched_str_close), reg_magic == MAGIC_ALL); 	else 	    EMSG_RET_NULL(_(e_trailing_characters));	// ""Can't happen"". 	// NOTREACHED     }     // Here we set the flag allowing back references to this set of     // parentheses.     if (paren == REG_PAREN) 	had_endbrace[parno] = TRUE;	// have seen the close paren     return ret; }"
"326590_not_vulnerable.c","not_vulnerable","archive_write_disk_set_user_lookup(struct archive *_a,     void *private_data,     int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),     void (*cleanup_uid)(void *private)) { 	struct archive_write_disk *a = (struct archive_write_disk *)_a; 	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC, 	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_user_lookup"");  	if (a->cleanup_uid != NULL && a->lookup_uid_data != NULL) 		(a->cleanup_uid)(a->lookup_uid_data);  	a->lookup_uid = lookup_uid; 	a->cleanup_uid = cleanup_uid; 	a->lookup_uid_data = private_data; 	return (ARCHIVE_OK); }"
"328819_not_vulnerable.c","not_vulnerable","R_API void r_bin_java_print_line_number_attr_summary(RBinJavaLineNumberAttribute *lnattr) { 	if (!lnattr) { 		eprintf (""Attempting to print an invalid RBinJavaLineNumberAttribute *.\n""); 		return; 	} 	printf (""  Line Number Attribute Offset: 0x%08""PFMT64x ""\n"", lnattr->file_offset); 	printf (""  Line Number Attribute StartPC: %d\n"", lnattr->start_pc); 	printf (""  Line Number Attribute LineNumber: %d\n"", lnattr->line_number); }"
"328827_not_vulnerable.c","not_vulnerable","R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) { 	ut32 i = 0; 	ut64 offset = 0; 	if (sz < 8) { 		return NULL; 	} 	RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue); 	if (!element_value) { 		return NULL; 	} 	RBinJavaElementValuePair *evps = NULL; 	element_value->metas = R_NEW0 (RBinJavaMetaInfo); 	if (!element_value->metas) { 		R_FREE (element_value); 		return NULL; 	} 	element_value->file_offset = buf_offset; 	element_value->tag = buffer[offset]; 	element_value->size += 1; 	offset += 1; 	element_value->metas->type_info = (void *) r_bin_java_get_ev_meta_from_tag (element_value->tag); 	switch (element_value->tag) { 	case R_BIN_JAVA_EV_TAG_BYTE: 	case R_BIN_JAVA_EV_TAG_CHAR: 	case R_BIN_JAVA_EV_TAG_DOUBLE: 	case R_BIN_JAVA_EV_TAG_FLOAT: 	case R_BIN_JAVA_EV_TAG_INT: 	case R_BIN_JAVA_EV_TAG_LONG: 	case R_BIN_JAVA_EV_TAG_SHORT: 	case R_BIN_JAVA_EV_TAG_BOOLEAN: 	case R_BIN_JAVA_EV_TAG_STRING: 		// look up value in bin->cp_list 		// (ut16) read and set const_value.const_value_idx 		element_value->value.const_value.const_value_idx = R_BIN_JAVA_USHORT (buffer, offset); 		element_value->size += 2; 		// look-up, deep copy, and set const_value.const_value_cp_obj 		element_value->value.const_value.const_value_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.const_value.const_value_idx); 		break; 	case R_BIN_JAVA_EV_TAG_ENUM: 		// (ut16) read and set enum_const_value.type_name_idx 		element_value->value.enum_const_value.type_name_idx = R_BIN_JAVA_USHORT (buffer, offset); 		element_value->size += 2; 		offset += 2; 		// (ut16) read and set enum_const_value.const_name_idx 		element_value->value.enum_const_value.const_name_idx = R_BIN_JAVA_USHORT (buffer, offset); 		element_value->size += 2; 		offset += 2; 		// look up type_name_index in bin->cp_list 		// look-up, deep copy, and set enum_const_value.const_name_cp_obj 		element_value->value.enum_const_value.const_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.const_name_idx); 		// look-up, deep copy, and set enum_const_value.type_name_cp_obj 		element_value->value.enum_const_value.type_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.type_name_idx); 		break; 	case R_BIN_JAVA_EV_TAG_CLASS: 		// (ut16) read and set class_value.class_info_idx 		element_value->value.class_value.class_info_idx = R_BIN_JAVA_USHORT (buffer, offset); 		element_value->size += 2; 		offset += 2; 		// look up type_name_index in bin->cp_list 		// look-up, deep copy, and set class_value.class_info_cp_obj 		element_value->value.class_value.class_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.class_value.class_info_idx); 		break; 	case R_BIN_JAVA_EV_TAG_ARRAY: 		// (ut16) read and set array_value.num_values 		element_value->value.array_value.num_values = R_BIN_JAVA_USHORT (buffer, offset); 		element_value->size += 2; 		offset += 2; 		element_value->value.array_value.values = r_list_new (); 		for (i = 0; i < element_value->value.array_value.num_values; i++) { 			if (offset >= sz) { 				break; 			} 			RBinJavaElementValue *ev_element = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset); 			if (ev_element) { 				element_value->size += ev_element->size; 				offset += ev_element->size; 				// read array_value.num_values, and append to array_value.values 				r_list_append (element_value->value.array_value.values, (void *) ev_element); 			} 		} 		break; 	case R_BIN_JAVA_EV_TAG_ANNOTATION: 		// annotation new is not used here. 		// (ut16) read and set annotation_value.type_idx; 		if (offset + 8 < sz) { 			element_value->value.annotation_value.type_idx = R_BIN_JAVA_USHORT (buffer, offset); 			element_value->size += 2; 			offset += 2; 			// (ut16) read and set annotation_value.num_element_value_pairs; 			element_value->value.annotation_value.num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset); 			element_value->size += 2; 			offset += 2; 		} 		element_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free); 		// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs 		for (i = 0; i < element_value->value.annotation_value.num_element_value_pairs; i++) { 			if (offset > sz) { 				break; 			} 			evps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset); 			if (evps) { 				element_value->size += evps->size; 				offset += evps->size; 			} 			if (evps == NULL) { 				// TODO: eprintf error when reading element pair 			} 			r_list_append (element_value->value.annotation_value.element_value_pairs, (void *) evps); 		} 		break; 	default: 		// eprintf unable to handle tag 		break; 	} 	return element_value; }"
"328849_not_vulnerable.c","not_vulnerable","R_API void r_bin_java_print_method_summary(RBinJavaField *field) { 	RBinJavaAttrInfo *attr; 	RListIter *iter, *iter_tmp; 	if (field == NULL) { 		eprintf (""Attempting to print an invalid RBinJavaField* Method.\n""); 		return; 	} 	printf (""Method Summary Information:\n""); 	printf (""  File Offset: 0x%08""PFMT64x ""\n"", field->file_offset); 	printf (""  Name Index: %d (%s)\n"", field->name_idx, field->name); 	printf (""  Descriptor Index: %d (%s)\n"", field->descriptor_idx, field->descriptor); 	printf (""  Access Flags: 0x%02x (%s)\n"", field->flags, field->flags_str); 	printf (""  Method Attributes Count: %d\n"", field->attr_count); 	printf (""  Method Attributes:\n""); 	r_list_foreach_safe (field->attributes, iter, iter_tmp, attr) { 		r_bin_java_print_attr_summary (attr); 	} }"
"328914_not_vulnerable.c","not_vulnerable","R_API RList *retrieve_all_class_access_string_and_value(void) { 	return retrieve_all_access_string_and_value (CLASS_ACCESS_FLAGS); }"
"328941_not_vulnerable.c","not_vulnerable","R_API RBinJavaAttrInfo *r_bin_java_rtvp_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { 	ut32 i = 0; 	RBinJavaAttrInfo *attr = NULL; 	ut64 offset = 0; 	attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); 	offset += 6; 	RBinJavaAnnotationsArray *annotation_array; 	if (attr) { 		attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR; 		attr->info.rtvp_annotations_attr.num_parameters = buffer[offset]; 		offset += 1; 		attr->info.rtvp_annotations_attr.parameter_annotations = r_list_newf (r_bin_java_annotation_array_free); 		for (i = 0; i < attr->info.rtvp_annotations_attr.num_parameters; i++) { 			if (offset > sz) { 				break; 			} 			annotation_array = r_bin_java_annotation_array_new (buffer + offset, sz - offset, buf_offset + offset); 			if (annotation_array) { 				offset += annotation_array->size; 			} 			r_list_append (attr->info.rtvp_annotations_attr.parameter_annotations, (void *) annotation_array); 		} 		attr->size = offset; 	} 	return attr; }"
"329876_not_vulnerable.c","not_vulnerable","_blit_xrgb32_lerp_spans (void *abstract_renderer, int y, int h, 			 const cairo_half_open_span_t *spans, unsigned num_spans) {     cairo_image_span_renderer_t *r = abstract_renderer;      if (num_spans == 0) 	return CAIRO_STATUS_SUCCESS;      if (likely(h == 1)) { 	uint8_t *src = r->u.blit.src_data + y*r->u.blit.src_stride; 	uint8_t *dst = r->u.blit.data + y*r->u.blit.stride; 	do { 	    uint8_t a = mul8_8 (spans[0].coverage, r->bpp); 	    if (a) { 		uint32_t *s = (uint32_t*)src + spans[0].x; 		uint32_t *d = (uint32_t*)dst + spans[0].x; 		int len = spans[1].x - spans[0].x; 		if (a == 0xff) { 		    if (len == 1) 			*d = *s; 		    else 			memcpy(d, s, len*4); 		} else { 		    while (len-- > 0) { 			*d = lerp8x4 (*s, a, *d); 			s++, d++; 		    } 		} 	    } 	    spans++; 	} while (--num_spans > 1);     } else { 	do { 	    uint8_t a = mul8_8 (spans[0].coverage, r->bpp); 	    if (a) { 		int yy = y, hh = h; 		do { 		    uint32_t *s = (uint32_t *)(r->u.blit.src_data + yy*r->u.blit.src_stride + spans[0].x * 4); 		    uint32_t *d = (uint32_t *)(r->u.blit.data + yy*r->u.blit.stride + spans[0].x * 4); 		    int len = spans[1].x - spans[0].x; 		    if (a == 0xff) { 			if (len == 1) 			    *d = *s; 			else 			    memcpy(d, s, len * 4); 		    } else { 			while (len-- > 0) { 			    *d = lerp8x4 (*s, a, *d); 			    s++, d++; 			} 		    } 		    yy++; 		} while (--hh); 	    } 	    spans++; 	} while (--num_spans > 1);     }      return CAIRO_STATUS_SUCCESS; }"
"329922_not_vulnerable.c","not_vulnerable","composite_glyphs_via_mask (void				*_dst, 			   cairo_operator_t		 op, 			   cairo_surface_t		*_src, 			   int				 src_x, 			   int				 src_y, 			   int				 dst_x, 			   int				 dst_y, 			   cairo_composite_glyphs_info_t *info) {     cairo_scaled_glyph_t *glyph_cache[64];     pixman_image_t *white = _pixman_image_for_color (CAIRO_COLOR_WHITE);     cairo_scaled_glyph_t *scaled_glyph;     uint8_t buf[2048];     pixman_image_t *mask;     pixman_format_code_t format;     cairo_status_t status;     int i;      TRACE ((stderr, ""%s\n"", __FUNCTION__));      if (unlikely (white == NULL)) 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);      /* XXX convert the glyphs to common formats a8/a8r8g8b8 to hit      * optimised paths through pixman. Should we increase the bit      * depth of the target surface, we should reconsider the appropriate      * mask formats.      */      status = _cairo_scaled_glyph_lookup (info->font, 					 info->glyphs[0].index, 					 CAIRO_SCALED_GLYPH_INFO_SURFACE, 					 &scaled_glyph);     if (unlikely (status)) { 	pixman_image_unref (white); 	return status;     }      memset (glyph_cache, 0, sizeof (glyph_cache));     glyph_cache[info->glyphs[0].index % ARRAY_LENGTH (glyph_cache)] = scaled_glyph;      format = PIXMAN_a8;     i = (info->extents.width + 3) & ~3;     if (scaled_glyph->surface->base.content & CAIRO_CONTENT_COLOR) { 	format = PIXMAN_a8r8g8b8; 	i = info->extents.width * 4;     }      if (i * info->extents.height > (int) sizeof (buf)) { 	mask = pixman_image_create_bits (format, 					info->extents.width, 					info->extents.height, 					NULL, 0);     } else { 	memset (buf, 0, i * info->extents.height); 	mask = pixman_image_create_bits (format, 					info->extents.width, 					info->extents.height, 					(uint32_t *)buf, i);     }     if (unlikely (mask == NULL)) { 	pixman_image_unref (white); 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);     }      status = CAIRO_STATUS_SUCCESS;     for (i = 0; i < info->num_glyphs; i++) { 	unsigned long glyph_index = info->glyphs[i].index; 	int cache_index = glyph_index % ARRAY_LENGTH (glyph_cache); 	cairo_image_surface_t *glyph_surface; 	int x, y;  	scaled_glyph = glyph_cache[cache_index]; 	if (scaled_glyph == NULL || 	    _cairo_scaled_glyph_index (scaled_glyph) != glyph_index) 	{ 	    status = _cairo_scaled_glyph_lookup (info->font, glyph_index, 						 CAIRO_SCALED_GLYPH_INFO_SURFACE, 						 &scaled_glyph);  	    if (unlikely (status)) { 		pixman_image_unref (mask); 		pixman_image_unref (white); 		return status; 	    }  	    glyph_cache[cache_index] = scaled_glyph; 	}  	glyph_surface = scaled_glyph->surface; 	if (glyph_surface->width && glyph_surface->height) { 	    if (glyph_surface->base.content & CAIRO_CONTENT_COLOR && 		format == PIXMAN_a8) { 		pixman_image_t *ca_mask;  		format = PIXMAN_a8r8g8b8; 		ca_mask = pixman_image_create_bits (format, 						    info->extents.width, 						    info->extents.height, 						    NULL, 0); 		if (unlikely (ca_mask == NULL)) { 		    pixman_image_unref (mask); 		    pixman_image_unref (white); 		    return _cairo_error (CAIRO_STATUS_NO_MEMORY); 		}  		pixman_image_composite32 (PIXMAN_OP_SRC, 					  white, mask, ca_mask, 					  0, 0, 					  0, 0, 					  0, 0, 					  info->extents.width, 					  info->extents.height); 		pixman_image_unref (mask); 		mask = ca_mask; 	    }  	    /* round glyph locations to the nearest pixel */ 	    /* XXX: FRAGILE: We're ignoring device_transform scaling here. A bug? */ 	    x = _cairo_lround (info->glyphs[i].x - 			       glyph_surface->base.device_transform.x0); 	    y = _cairo_lround (info->glyphs[i].y - 			       glyph_surface->base.device_transform.y0);  	    if (glyph_surface->pixman_format == format) { 		pixman_image_composite32 (PIXMAN_OP_ADD, 					  glyph_surface->pixman_image, NULL, mask, 					  0, 0, 					  0, 0, 					  x - info->extents.x, y - info->extents.y, 					  glyph_surface->width, 					  glyph_surface->height); 	    } else { 		pixman_image_composite32 (PIXMAN_OP_ADD, 					  white, glyph_surface->pixman_image, mask, 					  0, 0, 					  0, 0, 					  x - info->extents.x, y - info->extents.y, 					  glyph_surface->width, 					  glyph_surface->height); 	    } 	}     }      if (format == PIXMAN_a8r8g8b8) 	pixman_image_set_component_alpha (mask, TRUE);      pixman_image_composite32 (_pixman_operator (op), 			      ((cairo_image_source_t *)_src)->pixman_image, 			      mask, 			      to_pixman_image (_dst), 			      info->extents.x + src_x, info->extents.y + src_y, 			      0, 0, 			      info->extents.x - dst_x, info->extents.y - dst_y, 			      info->extents.width, info->extents.height);     pixman_image_unref (mask);     pixman_image_unref (white);      return CAIRO_STATUS_SUCCESS; }"
"331777_not_vulnerable.cpp","not_vulnerable","bool QPaintEngineEx::shouldDrawCachedGlyphs(QFontEngine *fontEngine, const QTransform &m) const {     if (fontEngine->glyphFormat == QFontEngine::Format_ARGB)         return true;      static const int maxCachedGlyphSizeSquared = std::pow([]{         if (int env = qEnvironmentVariableIntValue(""QT_MAX_CACHED_GLYPH_SIZE""))             return env;         return QT_MAX_CACHED_GLYPH_SIZE;     }(), 2);      qreal pixelSize = fontEngine->fontDef.pixelSize;     return (pixelSize * pixelSize * qAbs(m.determinant())) <= maxCachedGlyphSizeSquared; }"
"333514_not_vulnerable.c","not_vulnerable","gdImagePtr gdImageRotateBilinear(gdImagePtr src, const float degrees, const int bgColor) { 	float _angle = (float)((- degrees / 180.0f) * M_PI); 	const unsigned int src_w = gdImageSX(src); 	const unsigned int src_h = gdImageSY(src); 	unsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f)); 	unsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f)); 	const gdFixed f_0_5 = gd_ftofx(0.5f); 	const gdFixed f_H = gd_itofx(src_h/2); 	const gdFixed f_W = gd_itofx(src_w/2); 	const gdFixed f_cos = gd_ftofx(cos(-_angle)); 	const gdFixed f_sin = gd_ftofx(sin(-_angle)); 	const gdFixed f_1 = gd_itofx(1); 	unsigned int i; 	unsigned int dst_offset_x; 	unsigned int dst_offset_y = 0; 	unsigned int src_offset_x, src_offset_y; 	gdImagePtr dst;  	dst = gdImageCreateTrueColor(new_width, new_height); 	if (dst == NULL) { 		return NULL; 	} 	dst->saveAlphaFlag = 1;  	for (i = 0; i < new_height; i++) { 		unsigned int j; 		dst_offset_x = 0;  		for (j=0; j < new_width; j++) { 			const gdFixed f_i = gd_itofx((int)i - (int)new_height/2); 			const gdFixed f_j = gd_itofx((int)j - (int)new_width/2); 			const gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H; 			const gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W; 			const unsigned int m = gd_fxtoi(f_m); 			const unsigned int n = gd_fxtoi(f_n);  			if ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w - 1)) { 				const gdFixed f_f = f_m - gd_itofx(m); 				const gdFixed f_g = f_n - gd_itofx(n); 				const gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g); 				const gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g); 				const gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g); 				const gdFixed f_w4 = gd_mulfx(f_f, f_g);  				if (n < src_w - 1) { 					src_offset_x = n + 1; 					src_offset_y = m; 				}  				if (m < src_h-1) { 					src_offset_x = n; 					src_offset_y = m + 1; 				}  				if (!((n >= src_w-1) || (m >= src_h-1))) { 					src_offset_x = n + 1; 					src_offset_y = m + 1; 				} 				{ 					const int pixel1 = src->tpixels[src_offset_y][src_offset_x]; 					register int pixel2, pixel3, pixel4;  					if (src_offset_y + 1 >= src_h) { 						pixel2 = bgColor; 						pixel3 = bgColor; 						pixel4 = bgColor; 					} else if (src_offset_x + 1 >= src_w) { 						pixel2 = bgColor; 						pixel3 = bgColor; 						pixel4 = bgColor; 					} else { 					    pixel2 = src->tpixels[src_offset_y][src_offset_x + 1]; 						pixel3 = src->tpixels[src_offset_y + 1][src_offset_x]; 						pixel4 = src->tpixels[src_offset_y + 1][src_offset_x + 1]; 					} 					{ 						const gdFixed f_r1 = gd_itofx(gdTrueColorGetRed(pixel1)); 						const gdFixed f_r2 = gd_itofx(gdTrueColorGetRed(pixel2)); 						const gdFixed f_r3 = gd_itofx(gdTrueColorGetRed(pixel3)); 						const gdFixed f_r4 = gd_itofx(gdTrueColorGetRed(pixel4)); 						const gdFixed f_g1 = gd_itofx(gdTrueColorGetGreen(pixel1)); 						const gdFixed f_g2 = gd_itofx(gdTrueColorGetGreen(pixel2)); 						const gdFixed f_g3 = gd_itofx(gdTrueColorGetGreen(pixel3)); 						const gdFixed f_g4 = gd_itofx(gdTrueColorGetGreen(pixel4)); 						const gdFixed f_b1 = gd_itofx(gdTrueColorGetBlue(pixel1)); 						const gdFixed f_b2 = gd_itofx(gdTrueColorGetBlue(pixel2)); 						const gdFixed f_b3 = gd_itofx(gdTrueColorGetBlue(pixel3)); 						const gdFixed f_b4 = gd_itofx(gdTrueColorGetBlue(pixel4)); 						const gdFixed f_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1)); 						const gdFixed f_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2)); 						const gdFixed f_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3)); 						const gdFixed f_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4)); 						const gdFixed f_red = gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4); 						const gdFixed f_green = gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4); 						const gdFixed f_blue = gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4); 						const gdFixed f_alpha = gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4);  						const unsigned char red   = (unsigned char) CLAMP(gd_fxtoi(f_red),   0, 255); 						const unsigned char green = (unsigned char) CLAMP(gd_fxtoi(f_green), 0, 255); 						const unsigned char blue  = (unsigned char) CLAMP(gd_fxtoi(f_blue),  0, 255); 						const unsigned char alpha = (unsigned char) CLAMP(gd_fxtoi(f_alpha), 0, 127);  						dst->tpixels[dst_offset_y][dst_offset_x++] = gdTrueColorAlpha(red, green, blue, alpha); 					} 				} 			} else { 				dst->tpixels[dst_offset_y][dst_offset_x++] = bgColor; 			} 		} 		dst_offset_y++; 	} 	return dst; }"
"333549_not_vulnerable.c","not_vulnerable","int gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox) { 	gdPointF extent[4], min, max, point; 	int i;  	extent[0].x=0.0; 	extent[0].y=0.0; 	extent[1].x=(double) src->width; 	extent[1].y=0.0; 	extent[2].x=(double) src->width; 	extent[2].y=(double) src->height; 	extent[3].x=0.0; 	extent[3].y=(double) src->height;  	for (i=0; i < 4; i++) { 		point=extent[i]; 		if (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) { 			return GD_FALSE; 		} 	} 	min=extent[0]; 	max=extent[0];  	for (i=1; i < 4; i++) { 		if (min.x > extent[i].x) 			min.x=extent[i].x; 		if (min.y > extent[i].y) 			min.y=extent[i].y; 		if (max.x < extent[i].x) 			max.x=extent[i].x; 		if (max.y < extent[i].y) 			max.y=extent[i].y; 	} 	bbox->x = (int) min.x; 	bbox->y = (int) min.y; 	bbox->width  = (int) floor(max.x - min.x) - 1; 	bbox->height = (int) floor(max.y - min.y); 	return GD_TRUE; }"
"335411_not_vulnerable.c","not_vulnerable","ex_setfiletype(exarg_T *eap) {     if (!did_filetype)     { 	char_u *arg = eap->arg;  	if (STRNCMP(arg, ""FALLBACK "", 9) == 0) 	    arg += 9;  	set_option_value_give_err((char_u *)""filetype"", 0L, arg, OPT_LOCAL); 	if (arg != eap->arg) 	    did_filetype = FALSE;     } }"
"336113_not_vulnerable.c","not_vulnerable","static netdev_tx_t ip6gre_tunnel_xmit(struct sk_buff *skb, 	struct net_device *dev) { 	struct ip6_tnl *t = netdev_priv(dev); 	struct net_device_stats *stats = &t->dev->stats; 	int ret;  	if (!ip6_tnl_xmit_ctl(t, &t->parms.laddr, &t->parms.raddr)) 		goto tx_err;  	switch (skb->protocol) { 	case htons(ETH_P_IP): 		ret = ip6gre_xmit_ipv4(skb, dev); 		break; 	case htons(ETH_P_IPV6): 		ret = ip6gre_xmit_ipv6(skb, dev); 		break; 	default: 		ret = ip6gre_xmit_other(skb, dev); 		break; 	}  	if (ret < 0) 		goto tx_err;  	return NETDEV_TX_OK;  tx_err: 	stats->tx_errors++; 	stats->tx_dropped++; 	kfree_skb(skb); 	return NETDEV_TX_OK; }"
"336498_not_vulnerable.cpp","not_vulnerable","static void reds_handle_auth_mechanism(void *opaque) {     RedLinkInfo *link = (RedLinkInfo *)opaque;     RedsState *reds = link->reds;      spice_debug(""Auth method: %d"", link->auth_mechanism.auth_mechanism);      link->auth_mechanism.auth_mechanism = GUINT32_FROM_LE(link->auth_mechanism.auth_mechanism);     if (link->auth_mechanism.auth_mechanism == SPICE_COMMON_CAP_AUTH_SPICE         && !reds->config->sasl_enabled         ) {         reds_get_spice_ticket(link); #if HAVE_SASL     } else if (link->auth_mechanism.auth_mechanism == SPICE_COMMON_CAP_AUTH_SASL) {         spice_debug(""Starting SASL"");         reds_start_auth_sasl(link); #endif     } else {         spice_warning(""Unknown auth method, disconnecting"");         if (reds->config->sasl_enabled) {             spice_warning(""Your client doesn't handle SASL?"");         }         reds_send_link_error(link, SPICE_LINK_ERR_INVALID_DATA);         reds_link_free(link);     } }"
"336592_not_vulnerable.cpp","not_vulnerable","static void reds_handle_read_link_done(void *opaque) {     RedLinkInfo *link = (RedLinkInfo *)opaque;     RedsState *reds = link->reds;     SpiceLinkMess *link_mess = link->link_mess;     uint32_t num_caps;     uint32_t *caps;     int auth_selection;     unsigned int i;      link_mess->caps_offset = GUINT32_FROM_LE(link_mess->caps_offset);     link_mess->connection_id = GUINT32_FROM_LE(link_mess->connection_id);     link_mess->num_channel_caps = GUINT32_FROM_LE(link_mess->num_channel_caps);     link_mess->num_common_caps = GUINT32_FROM_LE(link_mess->num_common_caps);      /* Prevent DoS. Currently we defined only 13 capabilities,      * I expect 1024 to be valid for quite a lot time */     if (link_mess->num_channel_caps > 1024 || link_mess->num_common_caps > 1024) {         reds_send_link_error(link, SPICE_LINK_ERR_INVALID_DATA);         reds_link_free(link);         return;     }      num_caps = link_mess->num_common_caps + link_mess->num_channel_caps;     caps = (uint32_t *)((uint8_t *)link_mess + link_mess->caps_offset);      if (num_caps && (num_caps * sizeof(uint32_t) + link_mess->caps_offset >                      link->link_header.size ||                      link_mess->caps_offset < sizeof(*link_mess))) {         reds_send_link_error(link, SPICE_LINK_ERR_INVALID_DATA);         reds_link_free(link);         return;     }      for(i = 0; i < num_caps;i++)         caps[i] = GUINT32_FROM_LE(caps[i]);      auth_selection = red_link_info_test_capability(link,                                                    SPICE_COMMON_CAP_PROTOCOL_AUTH_SELECTION);      if (!reds_security_check(link)) {         if (red_stream_is_ssl(link->stream)) {             spice_warning(""spice channels %d should not be encrypted"", link_mess->channel_type);             reds_send_link_error(link, SPICE_LINK_ERR_NEED_UNSECURED);         } else {             spice_warning(""spice channels %d should be encrypted"", link_mess->channel_type);             reds_send_link_error(link, SPICE_LINK_ERR_NEED_SECURED);         }         reds_link_free(link);         return;     }      if (!reds_send_link_ack(reds, link)) {         reds_link_free(link);         return;     }      if (!auth_selection) {         if (reds->config->sasl_enabled && !link->skip_auth) {             spice_warning(""SASL enabled, but peer supports only spice authentication"");             reds_send_link_error(link, SPICE_LINK_ERR_VERSION_MISMATCH);             return;         }         spice_warning(""Peer doesn't support AUTH selection"");         reds_get_spice_ticket(link);     } else {         red_stream_async_read(link->stream,                               (uint8_t *)&link->auth_mechanism,                               sizeof(SpiceLinkAuthMechanism),                               reds_handle_auth_mechanism,                               link);     } }"
"336595_not_vulnerable.cpp","not_vulnerable","void reds_register_channel(RedsState *reds, RedChannel *channel) {     spice_assert(reds);      uint32_t this_type = channel->type();     uint32_t this_id = channel->id();     if (spice_extra_checks) {         g_assert(reds_find_channel(reds, this_type, this_id) == NULL);     } else {         g_warn_if_fail(reds_find_channel(reds, this_type, this_id) == NULL);     }     reds->channels.push_front(red::shared_ptr<RedChannel>(channel));     // create new channel in the client if possible     reds->main_channel->registered_new_channel(channel); }"
"336628_not_vulnerable.cpp","not_vulnerable","SPICE_GNUC_VISIBLE int spice_server_set_agent_file_xfer(SpiceServer *reds, int enable) {     reds->config->agent_file_xfer = enable;     reds_update_agent_properties(reds);     return 0; }"
"336653_not_vulnerable.cpp","not_vulnerable","red_channel_capabilities_init_from_link_message(RedChannelCapabilities *caps,                                                 const SpiceLinkMess *link_mess) {     const uint8_t *raw_caps = (const uint8_t *)link_mess + link_mess->caps_offset;      caps->num_common_caps = link_mess->num_common_caps;     caps->common_caps = NULL;     if (caps->num_common_caps) {         caps->common_caps = (uint32_t*) g_memdup(raw_caps,                                      link_mess->num_common_caps * sizeof(uint32_t));     }     caps->num_caps = link_mess->num_channel_caps;     caps->caps = NULL;     if (link_mess->num_channel_caps) {         caps->caps = (uint32_t*) g_memdup(raw_caps + link_mess->num_common_caps * sizeof(uint32_t),                               link_mess->num_channel_caps * sizeof(uint32_t));     } }"
"336807_not_vulnerable.c","not_vulnerable","lprn_is_black(gx_device_printer * pdev, int r, int h, int bx) {     gx_device_lprn *const lprn = (gx_device_lprn *) pdev;      int bh = lprn->nBh;     int bpl = gdev_mem_bytes_per_scan_line(pdev);     int x, y, y0;     byte *p;     int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;      y0 = (r + h - bh) % maxY;     for (y = 0; y < bh; y++) {         p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];         for (x = 0; x < lprn->nBw; x++) {             /* bpl isn't necessarily a multiple of lprn->nBw, so             we need to explicitly stop after the last byte in this             line to avoid accessing either the next line's data or             going off the end of our buffer completely. This avoids             https://bugs.ghostscript.com/show_bug.cgi?id=701785. */             if (bx * lprn->nBw + x >= bpl)  break;             if (p[x] != 0)                 return 1;         }     }     return 0; }"
"337379_not_vulnerable.c","not_vulnerable","buflist_list(exarg_T *eap) {     buf_T	*buf = firstbuf;     int		len;     int		i;     int		ro_char;     int		changed_char; #ifdef FEAT_TERMINAL     int		job_running;     int		job_none_open; #endif  #ifdef FEAT_VIMINFO     garray_T	buflist;     buf_T	**buflist_data = NULL, **p;      if (vim_strchr(eap->arg, 't'))     { 	ga_init2(&buflist, sizeof(buf_T *), 50); 	FOR_ALL_BUFFERS(buf) 	{ 	    if (ga_grow(&buflist, 1) == OK) 		((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf; 	}  	qsort(buflist.ga_data, (size_t)buflist.ga_len, 		sizeof(buf_T *), buf_compare);  	buflist_data = (buf_T **)buflist.ga_data; 	buf = *buflist_data;     }     p = buflist_data;      for (; buf != NULL && !got_int; buf = buflist_data != NULL 	    ? (++p < buflist_data + buflist.ga_len ? *p : NULL) 	    : buf->b_next) #else     for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next) #endif     { #ifdef FEAT_TERMINAL 	job_running = term_job_running(buf->b_term); 	job_none_open = job_running && term_none_open(buf->b_term); #endif 	// skip unlisted buffers, unless ! was used 	if ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u')) 		|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl) 		|| (vim_strchr(eap->arg, '+') 			&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf))) 		|| (vim_strchr(eap->arg, 'a') 			&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0)) 		|| (vim_strchr(eap->arg, 'h') 			&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0)) #ifdef FEAT_TERMINAL 		|| (vim_strchr(eap->arg, 'R') 			&& (!job_running || (job_running && job_none_open))) 		|| (vim_strchr(eap->arg, '?') 			&& (!job_running || (job_running && !job_none_open))) 		|| (vim_strchr(eap->arg, 'F') 			&& (job_running || buf->b_term == NULL)) #endif 		|| (vim_strchr(eap->arg, '-') && buf->b_p_ma) 		|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro) 		|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR)) 		|| (vim_strchr(eap->arg, '%') && buf != curbuf) 		|| (vim_strchr(eap->arg, '#') 		      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum))) 	    continue; 	if (buf_spname(buf) != NULL) 	    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1); 	else 	    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE); 	if (message_filtered(NameBuff)) 	    continue;  	changed_char = (buf->b_flags & BF_READERR) ? 'x' 					     : (bufIsChanged(buf) ? '+' : ' '); #ifdef FEAT_TERMINAL 	if (term_job_running(buf->b_term)) 	{ 	    if (term_none_open(buf->b_term)) 		ro_char = '?'; 	    else 		ro_char = 'R'; 	    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid 				 // closing, but it's not actually changed. 	} 	else if (buf->b_term != NULL) 	    ro_char = 'F'; 	else #endif 	    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');  	msg_putchar('\n'); 	len = vim_snprintf((char *)IObuff, IOSIZE - 20, ""%3d%c%c%c%c%c \""%s\"""", 		buf->b_fnum, 		buf->b_p_bl ? ' ' : 'u', 		buf == curbuf ? '%' : 			(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '), 		buf->b_ml.ml_mfp == NULL ? ' ' : 			(buf->b_nwindows == 0 ? 'h' : 'a'), 		ro_char, 		changed_char, 		NameBuff); 	if (len > IOSIZE - 20) 	    len = IOSIZE - 20;  	// put ""line 999"" in column 40 or after the file name 	i = 40 - vim_strsize(IObuff); 	do 	    IObuff[len++] = ' '; 	while (--i > 0 && len < IOSIZE - 18); #ifdef FEAT_VIMINFO 	if (vim_strchr(eap->arg, 't') && buf->b_last_used) 	    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used); 	else #endif 	    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len), 		    _(""line %ld""), buf == curbuf ? curwin->w_cursor.lnum 					       : (long)buflist_findlnum(buf)); 	msg_outtrans(IObuff); 	out_flush();	    // output one line at a time 	ui_breakcheck();     }  #ifdef FEAT_VIMINFO     if (buflist_data) 	ga_clear(&buflist); #endif }"
"337784_not_vulnerable.c","not_vulnerable","struct sctp_chunk *sctp_make_new_encap_port(const struct sctp_association *asoc, 					    const struct sctp_chunk *chunk) { 	struct sctp_new_encap_port_hdr nep; 	struct sctp_chunk *retval;  	retval = sctp_make_abort(asoc, chunk, 				 sizeof(struct sctp_errhdr) + sizeof(nep)); 	if (!retval) 		goto nodata;  	sctp_init_cause(retval, SCTP_ERROR_NEW_ENCAP_PORT, sizeof(nep)); 	nep.cur_port = SCTP_INPUT_CB(chunk->skb)->encap_port; 	nep.new_port = chunk->transport->encap_port; 	sctp_addto_chunk(retval, sizeof(nep), &nep);  nodata: 	return retval; }"
"337832_not_vulnerable.c","not_vulnerable","struct sctp_chunk *sctp_make_datafrag_empty(const struct sctp_association *asoc, 					    const struct sctp_sndrcvinfo *sinfo, 					    int len, __u8 flags, gfp_t gfp) { 	struct sctp_chunk *retval; 	struct sctp_datahdr dp;  	/* We assign the TSN as LATE as possible, not here when 	 * creating the chunk. 	 */ 	memset(&dp, 0, sizeof(dp)); 	dp.ppid = sinfo->sinfo_ppid; 	dp.stream = htons(sinfo->sinfo_stream);  	/* Set the flags for an unordered send.  */ 	if (sinfo->sinfo_flags & SCTP_UNORDERED) 		flags |= SCTP_DATA_UNORDERED;  	retval = sctp_make_data(asoc, flags, sizeof(dp) + len, gfp); 	if (!retval) 		return NULL;  	retval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp); 	memcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));  	return retval; }"
"338041_not_vulnerable.cpp","not_vulnerable","void WasmBinaryBuilder::visitMemorySize(MemorySize* curr) {   BYN_TRACE(""zz node: MemorySize\n"");   auto reserved = getU32LEB();   if (reserved != 0) {     throwError(""Invalid reserved field on memory.size"");   }   curr->finalize(); }"
"338048_not_vulnerable.cpp","not_vulnerable","HeapType WasmBinaryBuilder::getTypeByFunctionIndex(Index index) {   if (index >= functionTypes.size()) {     throwError(""invalid function index"");   }   return functionTypes[index]; }"
"338086_not_vulnerable.cpp","not_vulnerable","bool WasmBinaryBuilder::maybeVisitConst(Expression*& out, uint8_t code) {   Const* curr;   BYN_TRACE(""zz node: Const, code "" << code << std::endl);   switch (code) {     case BinaryConsts::I32Const:       curr = allocator.alloc<Const>();       curr->value = Literal(getS32LEB());       break;     case BinaryConsts::I64Const:       curr = allocator.alloc<Const>();       curr->value = Literal(getS64LEB());       break;     case BinaryConsts::F32Const:       curr = allocator.alloc<Const>();       curr->value = getFloat32Literal();       break;     case BinaryConsts::F64Const:       curr = allocator.alloc<Const>();       curr->value = getFloat64Literal();       break;     default:       return false;   }   curr->type = curr->value.type;   out = curr;    return true; }"
"338102_not_vulnerable.cpp","not_vulnerable","void WasmBinaryBuilder::visitThrow(Throw* curr) {   BYN_TRACE(""zz node: Throw\n"");   auto index = getU32LEB();   if (index >= wasm.tags.size()) {     throwError(""bad tag index"");   }   auto* tag = wasm.tags[index].get();   curr->tag = tag->name;   size_t num = tag->sig.params.size();   curr->operands.resize(num);   for (size_t i = 0; i < num; i++) {     curr->operands[num - i - 1] = popNonVoidExpression();   }   curr->finalize(); }"
"338114_not_vulnerable.cpp","not_vulnerable","bool WasmBinaryBuilder::maybeVisitSIMDUnary(Expression*& out, uint32_t code) {   Unary* curr;   switch (code) {     case BinaryConsts::I8x16Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecI8x16;       break;     case BinaryConsts::I16x8Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecI16x8;       break;     case BinaryConsts::I32x4Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecI32x4;       break;     case BinaryConsts::I64x2Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecI64x2;       break;     case BinaryConsts::F32x4Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecF32x4;       break;     case BinaryConsts::F64x2Splat:       curr = allocator.alloc<Unary>();       curr->op = SplatVecF64x2;       break;     case BinaryConsts::V128Not:       curr = allocator.alloc<Unary>();       curr->op = NotVec128;       break;     case BinaryConsts::V128AnyTrue:       curr = allocator.alloc<Unary>();       curr->op = AnyTrueVec128;       break;     case BinaryConsts::I8x16Popcnt:       curr = allocator.alloc<Unary>();       curr->op = PopcntVecI8x16;       break;     case BinaryConsts::I8x16Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecI8x16;       break;     case BinaryConsts::I8x16Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecI8x16;       break;     case BinaryConsts::I8x16AllTrue:       curr = allocator.alloc<Unary>();       curr->op = AllTrueVecI8x16;       break;     case BinaryConsts::I8x16Bitmask:       curr = allocator.alloc<Unary>();       curr->op = BitmaskVecI8x16;       break;     case BinaryConsts::I16x8Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecI16x8;       break;     case BinaryConsts::I16x8Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecI16x8;       break;     case BinaryConsts::I16x8AllTrue:       curr = allocator.alloc<Unary>();       curr->op = AllTrueVecI16x8;       break;     case BinaryConsts::I16x8Bitmask:       curr = allocator.alloc<Unary>();       curr->op = BitmaskVecI16x8;       break;     case BinaryConsts::I32x4Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecI32x4;       break;     case BinaryConsts::I32x4Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecI32x4;       break;     case BinaryConsts::I32x4AllTrue:       curr = allocator.alloc<Unary>();       curr->op = AllTrueVecI32x4;       break;     case BinaryConsts::I32x4Bitmask:       curr = allocator.alloc<Unary>();       curr->op = BitmaskVecI32x4;       break;     case BinaryConsts::I64x2Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecI64x2;       break;     case BinaryConsts::I64x2Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecI64x2;       break;     case BinaryConsts::I64x2AllTrue:       curr = allocator.alloc<Unary>();       curr->op = AllTrueVecI64x2;       break;     case BinaryConsts::I64x2Bitmask:       curr = allocator.alloc<Unary>();       curr->op = BitmaskVecI64x2;       break;     case BinaryConsts::F32x4Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecF32x4;       break;     case BinaryConsts::F32x4Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecF32x4;       break;     case BinaryConsts::F32x4Sqrt:       curr = allocator.alloc<Unary>();       curr->op = SqrtVecF32x4;       break;     case BinaryConsts::F32x4Ceil:       curr = allocator.alloc<Unary>();       curr->op = CeilVecF32x4;       break;     case BinaryConsts::F32x4Floor:       curr = allocator.alloc<Unary>();       curr->op = FloorVecF32x4;       break;     case BinaryConsts::F32x4Trunc:       curr = allocator.alloc<Unary>();       curr->op = TruncVecF32x4;       break;     case BinaryConsts::F32x4Nearest:       curr = allocator.alloc<Unary>();       curr->op = NearestVecF32x4;       break;     case BinaryConsts::F64x2Abs:       curr = allocator.alloc<Unary>();       curr->op = AbsVecF64x2;       break;     case BinaryConsts::F64x2Neg:       curr = allocator.alloc<Unary>();       curr->op = NegVecF64x2;       break;     case BinaryConsts::F64x2Sqrt:       curr = allocator.alloc<Unary>();       curr->op = SqrtVecF64x2;       break;     case BinaryConsts::F64x2Ceil:       curr = allocator.alloc<Unary>();       curr->op = CeilVecF64x2;       break;     case BinaryConsts::F64x2Floor:       curr = allocator.alloc<Unary>();       curr->op = FloorVecF64x2;       break;     case BinaryConsts::F64x2Trunc:       curr = allocator.alloc<Unary>();       curr->op = TruncVecF64x2;       break;     case BinaryConsts::F64x2Nearest:       curr = allocator.alloc<Unary>();       curr->op = NearestVecF64x2;       break;     case BinaryConsts::I16x8ExtaddPairwiseI8x16S:       curr = allocator.alloc<Unary>();       curr->op = ExtAddPairwiseSVecI8x16ToI16x8;       break;     case BinaryConsts::I16x8ExtaddPairwiseI8x16U:       curr = allocator.alloc<Unary>();       curr->op = ExtAddPairwiseUVecI8x16ToI16x8;       break;     case BinaryConsts::I32x4ExtaddPairwiseI16x8S:       curr = allocator.alloc<Unary>();       curr->op = ExtAddPairwiseSVecI16x8ToI32x4;       break;     case BinaryConsts::I32x4ExtaddPairwiseI16x8U:       curr = allocator.alloc<Unary>();       curr->op = ExtAddPairwiseUVecI16x8ToI32x4;       break;     case BinaryConsts::I32x4TruncSatF32x4S:       curr = allocator.alloc<Unary>();       curr->op = TruncSatSVecF32x4ToVecI32x4;       break;     case BinaryConsts::I32x4TruncSatF32x4U:       curr = allocator.alloc<Unary>();       curr->op = TruncSatUVecF32x4ToVecI32x4;       break;     case BinaryConsts::F32x4ConvertI32x4S:       curr = allocator.alloc<Unary>();       curr->op = ConvertSVecI32x4ToVecF32x4;       break;     case BinaryConsts::F32x4ConvertI32x4U:       curr = allocator.alloc<Unary>();       curr->op = ConvertUVecI32x4ToVecF32x4;       break;     case BinaryConsts::I16x8ExtendLowI8x16S:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowSVecI8x16ToVecI16x8;       break;     case BinaryConsts::I16x8ExtendHighI8x16S:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighSVecI8x16ToVecI16x8;       break;     case BinaryConsts::I16x8ExtendLowI8x16U:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowUVecI8x16ToVecI16x8;       break;     case BinaryConsts::I16x8ExtendHighI8x16U:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighUVecI8x16ToVecI16x8;       break;     case BinaryConsts::I32x4ExtendLowI16x8S:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowSVecI16x8ToVecI32x4;       break;     case BinaryConsts::I32x4ExtendHighI16x8S:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighSVecI16x8ToVecI32x4;       break;     case BinaryConsts::I32x4ExtendLowI16x8U:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowUVecI16x8ToVecI32x4;       break;     case BinaryConsts::I32x4ExtendHighI16x8U:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighUVecI16x8ToVecI32x4;       break;     case BinaryConsts::I64x2ExtendLowI32x4S:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowSVecI32x4ToVecI64x2;       break;     case BinaryConsts::I64x2ExtendHighI32x4S:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighSVecI32x4ToVecI64x2;       break;     case BinaryConsts::I64x2ExtendLowI32x4U:       curr = allocator.alloc<Unary>();       curr->op = ExtendLowUVecI32x4ToVecI64x2;       break;     case BinaryConsts::I64x2ExtendHighI32x4U:       curr = allocator.alloc<Unary>();       curr->op = ExtendHighUVecI32x4ToVecI64x2;       break;     case BinaryConsts::F64x2ConvertLowI32x4S:       curr = allocator.alloc<Unary>();       curr->op = ConvertLowSVecI32x4ToVecF64x2;       break;     case BinaryConsts::F64x2ConvertLowI32x4U:       curr = allocator.alloc<Unary>();       curr->op = ConvertLowUVecI32x4ToVecF64x2;       break;     case BinaryConsts::I32x4TruncSatF64x2SZero:       curr = allocator.alloc<Unary>();       curr->op = TruncSatZeroSVecF64x2ToVecI32x4;       break;     case BinaryConsts::I32x4TruncSatF64x2UZero:       curr = allocator.alloc<Unary>();       curr->op = TruncSatZeroUVecF64x2ToVecI32x4;       break;     case BinaryConsts::F32x4DemoteF64x2Zero:       curr = allocator.alloc<Unary>();       curr->op = DemoteZeroVecF64x2ToVecF32x4;       break;     case BinaryConsts::F64x2PromoteLowF32x4:       curr = allocator.alloc<Unary>();       curr->op = PromoteLowVecF32x4ToVecF64x2;       break;     case BinaryConsts::I32x4RelaxedTruncF32x4S:       curr = allocator.alloc<Unary>();       curr->op = RelaxedTruncSVecF32x4ToVecI32x4;       break;     case BinaryConsts::I32x4RelaxedTruncF32x4U:       curr = allocator.alloc<Unary>();       curr->op = RelaxedTruncUVecF32x4ToVecI32x4;       break;     case BinaryConsts::I32x4RelaxedTruncF64x2SZero:       curr = allocator.alloc<Unary>();       curr->op = RelaxedTruncZeroSVecF64x2ToVecI32x4;       break;     case BinaryConsts::I32x4RelaxedTruncF64x2UZero:       curr = allocator.alloc<Unary>();       curr->op = RelaxedTruncZeroUVecF64x2ToVecI32x4;       break;     default:       return false;   }   curr->value = popNonVoidExpression();   curr->finalize();   out = curr;   return true; }"
"338124_not_vulnerable.cpp","not_vulnerable","void WasmBinaryBuilder::throwError(std::string text) {   throw ParseException(text, 0, pos); }"
"338203_not_vulnerable.cpp","not_vulnerable","Name WasmBinaryBuilder::getTableName(Index index) {   if (index >= wasm.tables.size()) {     throwError(""invalid table index"");   }   return wasm.tables[index]->name; }"
"338213_not_vulnerable.cpp","not_vulnerable","void WasmBinaryBuilder::visitSelect(Select* curr, uint8_t code) {   BYN_TRACE(""zz node: Select, code "" << int32_t(code) << std::endl);   if (code == BinaryConsts::SelectWithType) {     size_t numTypes = getU32LEB();     std::vector<Type> types;     for (size_t i = 0; i < numTypes; i++) {       types.push_back(getType());     }     curr->type = Type(types);   }   curr->condition = popNonVoidExpression();   curr->ifFalse = popNonVoidExpression();   curr->ifTrue = popNonVoidExpression();   if (code == BinaryConsts::SelectWithType) {     curr->finalize(curr->type);   } else {     curr->finalize();   } }"
"339724_not_vulnerable.c","not_vulnerable","static char * rv_alloc(int i) { 	int j, k, *r;  	j = sizeof(ULong); 	for(k = 0; 			sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= i; 			j <<= 1) { 		k++; 	} 	r = (int*)Balloc(k); 	*r = k; 	return (char *)(r+1); }"
"343124_not_vulnerable.c","not_vulnerable","static inline u8 *esp_tmp_iv(struct crypto_aead *aead, void *tmp, int seqhilen) { 	return crypto_aead_ivsize(aead) ? 	       PTR_ALIGN((u8 *)tmp + seqhilen, 			 crypto_aead_alignmask(aead) + 1) : tmp + seqhilen; }"
"343143_not_vulnerable.c","not_vulnerable","static void esp_input_done(struct crypto_async_request *base, int err) { 	struct sk_buff *skb = base->data;  	xfrm_input_resume(skb, esp6_input_done2(skb, err)); }"
"343161_not_vulnerable.c","not_vulnerable","static void __exit esp6_fini(void) { 	if (xfrm6_protocol_deregister(&esp6_protocol, IPPROTO_ESP) < 0) 		pr_info(""%s: can't remove protocol\n"", __func__); 	xfrm_unregister_type(&esp6_type, AF_INET6); }"
"343214_not_vulnerable.c","not_vulnerable","void dositetime(void) {     char tmp[64];     const struct tm *tm;     time_t now;      if ((now = time(NULL)) == (time_t) -1 || (tm = localtime(&now)) == NULL) {         addreply_noformat(451, ""time()"");         return;     }     strftime(tmp, sizeof tmp, ""%Y-%m-%d %H:%M:%S"", tm);     addreply_noformat(211, tmp); }"
"343229_not_vulnerable.c","not_vulnerable","static void overlapcpy(char *d, const char *s) {     while (*s != 0) {         *d++ = *s++;     }     *d = 0; }"
"343270_not_vulnerable.c","not_vulnerable","static void enablesignals(void) {     if (sigprocmask(SIG_SETMASK, &old_sigmask, NULL) < 0) {         _EXIT(EXIT_FAILURE);     } }"
"343275_not_vulnerable.c","not_vulnerable","void doretr(char *name) {     DLHandler dlhandler;     int f;     struct stat st;     double started = 0.0;     int ret;      dlhandler.total_downloaded = 0;     if (!candownload) {         addreply(550, MSG_LOAD_TOO_HIGH, load);         goto end;     }     if (type < 1 || (type == 1 && restartat > (off_t) 1)) {         addreply_noformat(503, MSG_NO_ASCII_RESUME);         goto end;     }     if (checknamesanity(name, dot_read_ok) != 0) {         addreply(553, MSG_SANITY_FILE_FAILURE, name);         goto end;     }     if ((f = open(name, O_RDONLY)) == -1) {         displayopenfailure(name);         goto end;     }     if (fstat(f, &st) < 0) {         stat_failure:         (void) close(f);         error(451, MSG_STAT_FAILURE);         goto end;     }     if (S_ISLNK(st.st_mode)) {         if (stat(name, &st) < 0) {             goto stat_failure;         }     }     if (restartat > st.st_size) {         (void) close(f);         addreply(554, MSG_REST_TOO_LARGE_FOR_FILE ""\n"" MSG_REST_RESET,                  (long long) restartat, (long long) st.st_size);         goto end;     }     if (!S_ISREG(st.st_mode) || ((off_t) st.st_size != st.st_size)) {         (void) close(f);         addreply_noformat(550, MSG_NOT_REGULAR_FILE);         goto end;     }     if (warez != 0 && st.st_uid == warez && guest != 0) {         (void) close(f);         addreply(550, MSG_NOT_MODERATED);         goto end;     } #ifdef RATIOS     if (ratio_upload > 0U && ratio_download > 0U) {         if ((downloaded + st.st_size - restartat) / ratio_download >             (uploaded / ratio_upload)) {             (void) close(f);             addreply(550, MSG_RATIO_DENIAL, ratio_upload, ratio_download,                      (unsigned long long) uploaded / 1024ULL,                      (unsigned long long) downloaded / 1024ULL);             goto end;         }     } #endif     opendata();     if (xferfd == -1) {         (void) close(f);         goto end;     } #ifndef DISABLE_HUMOR     if ((time(NULL) % 100) == 0) {         addreply_noformat(0, MSG_WINNER);     } #endif     if (st.st_size - restartat > 4096) {         addreply(0, MSG_KBYTES_LEFT, (double) ((st.st_size - restartat) / 1024.0));     }     doreply(); # ifdef WITH_TLS     if (data_protection_level == CPL_PRIVATE) {         tls_init_data_session(xferfd, passive);     } # endif     state_needs_update = 1;     setprocessname(""pure-ftpd (DOWNLOAD)"");  #ifdef FTPWHO     if (shm_data_cur != NULL) {         const size_t sl = strlen(name);          ftpwho_lock();         shm_data_cur->state = FTPWHO_STATE_DOWNLOAD;         shm_data_cur->download_total_size = st.st_size;         shm_data_cur->download_current_size = restartat;         shm_data_cur->restartat = restartat;         (void) time(&shm_data_cur->xfer_date);         if (sl < sizeof shm_data_cur->filename) {             memcpy(shm_data_cur->filename, name, sl);             shm_data_cur->filename[sl] = 0;         } else {             memcpy(shm_data_cur->filename,                    &name[sl - sizeof shm_data_cur->filename - 1U],                    sizeof shm_data_cur->filename);         }         ftpwho_unlock();     } #endif #ifdef HAVE_POSIX_FADVISE     (void) posix_fadvise(f, (off_t) 0, st.st_size, POSIX_FADV_SEQUENTIAL); #endif      started = get_usec_time();      if (dlmap_init(&dlhandler, clientfd, tls_cnx, xferfd, name, f,                    tls_data_cnx, restartat, type == 1,                    throttling_bandwidth_dl) == 0) {         ret = dlmap_send(&dlhandler);         dlmap_exit(&dlhandler);     } else {         ret = -1;     }      (void) close(f);     closedata();     if (ret == 0) {         addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL);     }     downloaded += dlhandler.total_downloaded;     displayrate(MSG_DOWNLOADED, dlhandler.total_downloaded, started, name, 0);      end:     restartat = (off_t) 0; }"
"344254_not_vulnerable.c","not_vulnerable","static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {   /* calling function is a known function? */   if (ci != NULL && !(ci->callstatus & CIST_TAIL))     return funcnamefromcall(L, ci->previous, name);   else return NULL;  /* no way to find a name */ }"
"344769_not_vulnerable.c","not_vulnerable","put_u32_le(void *vp, u_int32_t v) { 	u_char *p = (u_char *)vp;  	p[0] = (u_char)v & 0xff; 	p[1] = (u_char)(v >> 8) & 0xff; 	p[2] = (u_char)(v >> 16) & 0xff; 	p[3] = (u_char)(v >> 24) & 0xff; }"
"346419_not_vulnerable.c","not_vulnerable","get_sourced_lnum( 	char_u *(*fgetline)(int, void *, int, getline_opt_T), 	void *cookie) {     return fgetline == getsourceline 			? ((source_cookie_T *)cookie)->sourcing_lnum 			: SOURCING_LNUM; }"
"348424_not_vulnerable.c","not_vulnerable","static void ax_encaps(struct net_device *dev, unsigned char *icp, int len) { 	struct mkiss *ax = netdev_priv(dev); 	unsigned char *p; 	int actual, count;  	if (ax->mtu != ax->dev->mtu + 73)	/* Someone has been ifconfigging */ 		ax_changedmtu(ax);  	if (len > ax->mtu) {		/* Sigh, shouldn't occur BUT ... */ 		printk(KERN_ERR ""mkiss: %s: truncating oversized transmit packet!\n"", ax->dev->name); 		dev->stats.tx_dropped++; 		netif_start_queue(dev); 		return; 	}  	p = icp;  	spin_lock_bh(&ax->buflock); 	if ((*p & 0x0f) != 0) { 		/* Configuration Command (kissparms(1). 		 * Protocol spec says: never append CRC. 		 * This fixes a very old bug in the linux 		 * kiss driver. -- dl9sau */ 		switch (*p & 0xff) { 		case 0x85: 			/* command from userspace especially for us, 			 * not for delivery to the tnc */ 			if (len > 1) { 				int cmd = (p[1] & 0xff); 				switch(cmd) { 				case 3: 				  ax->crcmode = CRC_MODE_SMACK; 				  break; 				case 2: 				  ax->crcmode = CRC_MODE_FLEX; 				  break; 				case 1: 				  ax->crcmode = CRC_MODE_NONE; 				  break; 				case 0: 				default: 				  ax->crcmode = CRC_MODE_SMACK_TEST; 				  cmd = 0; 				} 				ax->crcauto = (cmd ? 0 : 1); 				printk(KERN_INFO ""mkiss: %s: crc mode set to %d\n"", 				       ax->dev->name, cmd); 			} 			spin_unlock_bh(&ax->buflock); 			netif_start_queue(dev);  			return; 		default: 			count = kiss_esc(p, ax->xbuff, len); 		} 	} else { 		unsigned short crc; 		switch (ax->crcmode) { 		case CRC_MODE_SMACK_TEST: 			ax->crcmode  = CRC_MODE_FLEX_TEST; 			printk(KERN_INFO ""mkiss: %s: Trying crc-smack\n"", ax->dev->name); 			fallthrough; 		case CRC_MODE_SMACK: 			*p |= 0x80; 			crc = swab16(crc16(0, p, len)); 			count = kiss_esc_crc(p, ax->xbuff, crc, len+2); 			break; 		case CRC_MODE_FLEX_TEST: 			ax->crcmode = CRC_MODE_NONE; 			printk(KERN_INFO ""mkiss: %s: Trying crc-flexnet\n"", ax->dev->name); 			fallthrough; 		case CRC_MODE_FLEX: 			*p |= 0x20; 			crc = calc_crc_flex(p, len); 			count = kiss_esc_crc(p, ax->xbuff, crc, len+2); 			break;  		default: 			count = kiss_esc(p, ax->xbuff, len); 		} 	} 	spin_unlock_bh(&ax->buflock);  	set_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags); 	actual = ax->tty->ops->write(ax->tty, ax->xbuff, count); 	dev->stats.tx_packets++; 	dev->stats.tx_bytes += actual;  	netif_trans_update(ax->dev); 	ax->xleft = count - actual; 	ax->xhead = ax->xbuff + actual; }"
"352980_not_vulnerable.c","not_vulnerable","booleanMatch( 	int *matchp, 	slap_mask_t flags, 	Syntax *syntax, 	MatchingRule *mr, 	struct berval *value, 	void *assertedValue ) { 	/* simplistic matching allowed by rigid validation */ 	struct berval *asserted = (struct berval *) assertedValue; 	*matchp = (int) asserted->bv_len - (int) value->bv_len; 	return LDAP_SUCCESS; }"
"352990_not_vulnerable.c","not_vulnerable","sidValidate ( 	Syntax *syntax, 	struct berval *in ) { 	assert( in != NULL ); 	assert( !BER_BVISNULL( in ) );  	if ( in->bv_len != 3 ) { 		return LDAP_INVALID_SYNTAX; 	}  	return hexValidate( NULL, in ); }"
"353127_not_vulnerable.c","not_vulnerable","  bool matches(const Ref *idA, double m11A, double m12A, 		double m21A, double m22A)     { return fontID == *idA && 	     m11 == m11A && m12 == m12A && m21 == m21A && m22 == m22A; }"
"355642_not_vulnerable.c","not_vulnerable","item_copy(     typval_T	*from,     typval_T	*to,     int		deep,     int		copyID) {     static int	recurse = 0;     int		ret = OK;      if (recurse >= DICT_MAXNEST)     { 	emsg(_(e_variable_nested_too_deep_for_making_copy)); 	return FAIL;     }     ++recurse;      switch (from->v_type)     { 	case VAR_NUMBER: 	case VAR_FLOAT: 	case VAR_STRING: 	case VAR_FUNC: 	case VAR_PARTIAL: 	case VAR_BOOL: 	case VAR_SPECIAL: 	case VAR_JOB: 	case VAR_CHANNEL: 	case VAR_INSTR: 	    copy_tv(from, to); 	    break; 	case VAR_LIST: 	    to->v_type = VAR_LIST; 	    to->v_lock = 0; 	    if (from->vval.v_list == NULL) 		to->vval.v_list = NULL; 	    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID) 	    { 		// use the copy made earlier 		to->vval.v_list = from->vval.v_list->lv_copylist; 		++to->vval.v_list->lv_refcount; 	    } 	    else 		to->vval.v_list = list_copy(from->vval.v_list, deep, copyID); 	    if (to->vval.v_list == NULL) 		ret = FAIL; 	    break; 	case VAR_BLOB: 	    ret = blob_copy(from->vval.v_blob, to); 	    break; 	case VAR_DICT: 	    to->v_type = VAR_DICT; 	    to->v_lock = 0; 	    if (from->vval.v_dict == NULL) 		to->vval.v_dict = NULL; 	    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID) 	    { 		// use the copy made earlier 		to->vval.v_dict = from->vval.v_dict->dv_copydict; 		++to->vval.v_dict->dv_refcount; 	    } 	    else 		to->vval.v_dict = dict_copy(from->vval.v_dict, deep, copyID); 	    if (to->vval.v_dict == NULL) 		ret = FAIL; 	    break; 	case VAR_UNKNOWN: 	case VAR_ANY: 	case VAR_VOID: 	    internal_error_no_abort(""item_copy(UNKNOWN)""); 	    ret = FAIL;     }     --recurse;     return ret; }"
"356683_not_vulnerable.cc","not_vulnerable","void Statement::GetRow(Row* row, sqlite3_stmt* stmt) {     int rows = sqlite3_column_count(stmt);      for (int i = 0; i < rows; i++) {         int type = sqlite3_column_type(stmt, i);         const char* name = sqlite3_column_name(stmt, i);         switch (type) {             case SQLITE_INTEGER: {                 row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));             }   break;             case SQLITE_FLOAT: {                 row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));             }   break;             case SQLITE_TEXT: {                 const char* text = (const char*)sqlite3_column_text(stmt, i);                 int length = sqlite3_column_bytes(stmt, i);                 row->push_back(new Values::Text(name, length, text));             } break;             case SQLITE_BLOB: {                 const void* blob = sqlite3_column_blob(stmt, i);                 int length = sqlite3_column_bytes(stmt, i);                 row->push_back(new Values::Blob(name, length, blob));             }   break;             case SQLITE_NULL: {                 row->push_back(new Values::Null(name));             }   break;             default:                 assert(false);         }     } }"
"356709_not_vulnerable.cc","not_vulnerable","void Statement::Work_Reset(napi_env e, void* data) {     STATEMENT_INIT(Baton);      sqlite3_reset(stmt->_handle);     stmt->status = SQLITE_OK; }"
"359208_not_vulnerable.c","not_vulnerable","BPF_CALL_2(bpf_ringbuf_discard, void *, sample, u64, flags) { 	bpf_ringbuf_commit(sample, flags, true /* discard */); 	return 0; }"
"359215_not_vulnerable.c","not_vulnerable","static void bpf_ringbuf_commit(void *sample, u64 flags, bool discard) { 	unsigned long rec_pos, cons_pos; 	struct bpf_ringbuf_hdr *hdr; 	struct bpf_ringbuf *rb; 	u32 new_len;  	hdr = sample - BPF_RINGBUF_HDR_SZ; 	rb = bpf_ringbuf_restore_from_rec(hdr); 	new_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT; 	if (discard) 		new_len |= BPF_RINGBUF_DISCARD_BIT;  	/* update record header with correct final size prefix */ 	xchg(&hdr->len, new_len);  	/* if consumer caught up and is waiting for our record, notify about 	 * new data availability 	 */ 	rec_pos = (void *)hdr - (void *)rb->data; 	cons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;  	if (flags & BPF_RB_FORCE_WAKEUP) 		irq_work_queue(&rb->work); 	else if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP)) 		irq_work_queue(&rb->work); }"
"359245_not_vulnerable.c","not_vulnerable","DEFUN (clear_ip_bgp_all_vpnv4_soft_out,        clear_ip_bgp_all_vpnv4_soft_out_cmd,        ""clear ip bgp * vpnv4 unicast soft out"",        CLEAR_STR        IP_STR        BGP_STR        ""Clear all peers\n""        ""Address family\n""        ""Address Family Modifier\n""        ""Soft reconfig\n""        ""Soft reconfig outbound update\n"") {   return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all, 			BGP_CLEAR_SOFT_OUT, NULL); }"
"359281_not_vulnerable.c","not_vulnerable","zroute_lookup(u_int zroute) {   u_int i;    if (zroute >= sizeof(route_types)/sizeof(route_types[0]))     {       zlog_err(""unknown zebra route type: %u"", zroute);       return &unknown;     }   if (zroute == route_types[zroute].type)     return &route_types[zroute];   for (i = 0; i < sizeof(route_types)/sizeof(route_types[0]); i++)     {       if (zroute == route_types[i].type)         { 	  zlog_warn(""internal error: route type table out of order "" 		    ""while searching for %u, please notify developers"", zroute); 	  return &route_types[i];         }     }   zlog_err(""internal error: cannot find route type %u in table!"", zroute);   return &unknown; }"
"359299_not_vulnerable.c","not_vulnerable","DEFUN (no_synchronization,        no_synchronization_cmd,        ""no synchronization"",        NO_STR        ""Perform IGP synchronization\n"") {   return CMD_SUCCESS; }"
"359317_not_vulnerable.c","not_vulnerable","DEFUN (bgp_graceful_restart_stalepath_time,        bgp_graceful_restart_stalepath_time_cmd,        ""bgp graceful-restart stalepath-time <1-3600>"",        ""BGP specific commands\n""        ""Graceful restart capability parameters\n""        ""Set the max time to hold onto restarting peer's stale paths\n""        ""Delay value (seconds)\n"") {   struct bgp *bgp;   u_int32_t stalepath;    bgp = vty->index;   if (! bgp)     return CMD_WARNING;    VTY_GET_INTEGER_RANGE (""stalepath-time"", stalepath, argv[0], 1, 3600);   bgp->stalepath_time = stalepath;   return CMD_SUCCESS; }"
"359335_not_vulnerable.c","not_vulnerable","peer_timers_connect_unset_vty (struct vty *vty, const char *ip_str) {   int ret;   struct peer *peer;    peer = peer_and_group_lookup_vty (vty, ip_str);   if (! peer)     return CMD_WARNING;    ret = peer_timers_connect_unset (peer);    return CMD_SUCCESS; }"
"359337_not_vulnerable.c","not_vulnerable","DEFUN (clear_bgp_peer_group_soft,        clear_bgp_peer_group_soft_cmd,        ""clear bgp peer-group WORD soft"",        CLEAR_STR        BGP_STR        ""Clear all members of peer-group\n""        ""BGP peer-group name\n""        ""Soft reconfig\n"") {   return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group, 			BGP_CLEAR_SOFT_BOTH, argv[0]); }"
"359355_not_vulnerable.c","not_vulnerable","DEFUN (router_bgp,         router_bgp_cmd,         ""router bgp <1-65535>"",        ROUTER_STR        BGP_STR        AS_STR) {   int ret;   as_t as;   struct bgp *bgp;   const char *name = NULL;    VTY_GET_INTEGER_RANGE (""AS"", as, argv[0], 1, 65535);    if (argc == 2)     name = argv[1];    ret = bgp_get (&bgp, &as, name);   switch (ret)     {     case BGP_ERR_MULTIPLE_INSTANCE_NOT_SET:       vty_out (vty, ""Please specify 'bgp multiple-instance' first%s"",  	       VTY_NEWLINE);       return CMD_WARNING;     case BGP_ERR_AS_MISMATCH:       vty_out (vty, ""BGP is already running; AS is %d%s"", as, VTY_NEWLINE);       return CMD_WARNING;     case BGP_ERR_INSTANCE_MISMATCH:       vty_out (vty, ""BGP view name and AS number mismatch%s"", VTY_NEWLINE);       vty_out (vty, ""BGP instance is already running; AS is %d%s"", 	       as, VTY_NEWLINE);       return CMD_WARNING;     }    vty->node = BGP_NODE;   vty->index = bgp;    return CMD_SUCCESS; }"
"359377_not_vulnerable.c","not_vulnerable","bgp_config_write_redistribute (struct vty *vty, struct bgp *bgp, afi_t afi, 			       safi_t safi, int *write) {   int i;    /* Unicast redistribution only.  */   if (safi != SAFI_UNICAST)     return 0;    for (i = 0; i < ZEBRA_ROUTE_MAX; i++)     {       /* Redistribute BGP does not make sense.  */       if (bgp->redist[afi][i] && i != ZEBRA_ROUTE_BGP) 	{ 	  /* Display ""address-family"" when it is not yet diplayed.  */ 	  bgp_config_write_family_header (vty, afi, safi, write);  	  /* ""redistribute"" configuration.  */ 	  vty_out (vty, "" redistribute %s"", zebra_route_string(i));  	  if (bgp->redist_metric_flag[afi][i]) 	    vty_out (vty, "" metric %d"", bgp->redist_metric[afi][i]);  	  if (bgp->rmap[afi][i].name) 	    vty_out (vty, "" route-map %s"", bgp->rmap[afi][i].name);  	  vty_out (vty, ""%s"", VTY_NEWLINE); 	}     }   return *write; }"
"359386_not_vulnerable.c","not_vulnerable","DEFUN (clear_bgp_all_in_prefix_filter,        clear_bgp_all_in_prefix_filter_cmd,        ""clear bgp * in prefix-filter"",        CLEAR_STR        BGP_STR        ""Clear all peers\n""        ""Soft reconfig inbound update\n""        ""Push out prefix-list ORF and do inbound soft reconfig\n"") {   return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all, 			BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL); }"
"359415_not_vulnerable.c","not_vulnerable","DEFUN (clear_ip_bgp_peer_vpnv4_soft_in,        clear_ip_bgp_peer_vpnv4_soft_in_cmd,        ""clear ip bgp A.B.C.D vpnv4 unicast soft in"",        CLEAR_STR        IP_STR        BGP_STR        ""BGP neighbor address to clear\n""        ""Address family\n""        ""Address Family Modifier\n""        ""Soft reconfig\n""        ""Soft reconfig inbound update\n"") {   return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer, 			BGP_CLEAR_SOFT_IN, argv[0]); }"
"359488_not_vulnerable.c","not_vulnerable","DEFUN (show_bgp_instance_summary,        show_bgp_instance_summary_cmd,        ""show bgp view WORD summary"",        SHOW_STR        BGP_STR        ""BGP view\n""        ""View name\n""        ""Summary of BGP neighbor status\n"") {   return bgp_show_summary_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST); }"
"359491_not_vulnerable.c","not_vulnerable","DEFUN (clear_ip_bgp_as_in_prefix_filter,        clear_ip_bgp_as_in_prefix_filter_cmd,        ""clear ip bgp <1-65535> in prefix-filter"",        CLEAR_STR        IP_STR        BGP_STR        ""Clear peers with the AS number\n""        ""Soft reconfig inbound update\n""        ""Push out prefix-list ORF and do inbound soft reconfig\n"") {   return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as, 			BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]); }"
"359525_not_vulnerable.c","not_vulnerable","peer_advertise_interval_vty (struct vty *vty, const char *ip_str,                               const char *time_str, int set)   {   int ret;   struct peer *peer;   u_int32_t routeadv = 0;    peer = peer_lookup_vty (vty, ip_str);   if (! peer)     return CMD_WARNING;    if (time_str)     VTY_GET_INTEGER_RANGE (""advertise interval"", routeadv, time_str, 0, 600);    if (set)     ret = peer_advertise_interval_set (peer, routeadv);   else     ret = peer_advertise_interval_unset (peer);    return CMD_SUCCESS; }"
"359527_not_vulnerable.c","not_vulnerable","DEFUN (no_neighbor_shutdown,        no_neighbor_shutdown_cmd,        NO_NEIGHBOR_CMD2 ""shutdown"",        NO_STR        NEIGHBOR_STR        NEIGHBOR_ADDR_STR2        ""Administratively shut down this neighbor\n"") {   return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_SHUTDOWN); }"
"359614_not_vulnerable.c","not_vulnerable","num_append(char *s, int len, u_long x) {   char buf[30];   char *t;    if (!x)     return str_append(s,len,""0"");   *(t = &buf[sizeof(buf)-1]) = '\0';   while (x && (t > buf))     {       *--t = '0'+(x % 10);       x /= 10;     }   return str_append(s,len,t); }"
"359646_not_vulnerable.c","not_vulnerable","bgp_clear (struct vty *vty, struct bgp *bgp,  afi_t afi, safi_t safi,            enum clear_sort sort,enum bgp_clear_type stype, const char *arg) {   int ret;   struct peer *peer;   struct listnode *node, *nnode;    /* Clear all neighbors. */   if (sort == clear_all)     {       for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer)) 	{ 	  if (stype == BGP_CLEAR_SOFT_NONE) 	    ret = peer_clear (peer); 	  else 	    ret = peer_clear_soft (peer, afi, safi, stype);  	  if (ret < 0) 	    bgp_clear_vty_error (vty, peer, afi, safi, ret); 	}       return 0;     }    /* Clear specified neighbors. */   if (sort == clear_peer)     {       union sockunion su;       int ret;        /* Make sockunion for lookup. */       ret = str2sockunion (arg, &su);       if (ret < 0) 	{ 	  vty_out (vty, ""Malformed address: %s%s"", arg, VTY_NEWLINE); 	  return -1; 	}       peer = peer_lookup (bgp, &su);       if (! peer) 	{ 	  vty_out (vty, ""%%BGP: Unknown neighbor - \""%s\""%s"", arg, VTY_NEWLINE); 	  return -1; 	}        if (stype == BGP_CLEAR_SOFT_NONE) 	ret = peer_clear (peer);       else 	ret = peer_clear_soft (peer, afi, safi, stype);        if (ret < 0) 	bgp_clear_vty_error (vty, peer, afi, safi, ret);        return 0;     }    /* Clear all peer-group members. */   if (sort == clear_group)     {       struct peer_group *group;        group = peer_group_lookup (bgp, arg);       if (! group) 	{ 	  vty_out (vty, ""%%BGP: No such peer-group %s%s"", arg, VTY_NEWLINE); 	  return -1;  	}        for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer)) 	{ 	  if (stype == BGP_CLEAR_SOFT_NONE) 	    { 	      ret = peer_clear (peer); 	      continue; 	    }  	  if (! peer->af_group[afi][safi]) 	    continue;  	  ret = peer_clear_soft (peer, afi, safi, stype);  	  if (ret < 0) 	    bgp_clear_vty_error (vty, peer, afi, safi, ret); 	}       return 0;     }    if (sort == clear_external)     {       for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer)) 	{ 	  if (peer_sort (peer) == BGP_PEER_IBGP)  	    continue;  	  if (stype == BGP_CLEAR_SOFT_NONE) 	    ret = peer_clear (peer); 	  else 	    ret = peer_clear_soft (peer, afi, safi, stype);  	  if (ret < 0) 	    bgp_clear_vty_error (vty, peer, afi, safi, ret); 	}       return 0;     }    if (sort == clear_as)     {       as_t as;       unsigned long as_ul;       char *endptr = NULL;       int find = 0;        as_ul = strtoul(arg, &endptr, 10);        if ((as_ul == ULONG_MAX) || (*endptr != '\0') || (as_ul > USHRT_MAX)) 	{ 	  vty_out (vty, ""Invalid AS number%s"", VTY_NEWLINE);  	  return -1; 	}       as = (as_t) as_ul;        for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer)) 	{ 	  if (peer->as != as)  	    continue;  	  find = 1; 	  if (stype == BGP_CLEAR_SOFT_NONE) 	    ret = peer_clear (peer); 	  else 	    ret = peer_clear_soft (peer, afi, safi, stype);  	  if (ret < 0) 	    bgp_clear_vty_error (vty, peer, afi, safi, ret); 	}       if (! find) 	vty_out (vty, ""%%BGP: No peer is configured with AS %s%s"", arg, 		 VTY_NEWLINE);       return 0;     }    return 0; }"
"359657_not_vulnerable.c","not_vulnerable","community_list_config_write (struct vty *vty) {   struct community_list *list;   struct community_entry *entry;   struct community_list_master *cm;   int write = 0;    /* Community-list.  */   cm = community_list_master_lookup (bgp_clist, COMMUNITY_LIST_MASTER);    for (list = cm->num.head; list; list = list->next)     for (entry = list->head; entry; entry = entry->next)       { 	vty_out (vty, ""ip community-list %s %s %s%s"", 		 list->name, community_direct_str (entry->direct), 		 community_list_config_str (entry), 		 VTY_NEWLINE); 	write++;       }   for (list = cm->str.head; list; list = list->next)     for (entry = list->head; entry; entry = entry->next)       { 	vty_out (vty, ""ip community-list %s %s %s %s%s"", 		 entry->style == COMMUNITY_LIST_STANDARD 		 ? ""standard"" : ""expanded"", 		 list->name, community_direct_str (entry->direct), 		 community_list_config_str (entry), 		 VTY_NEWLINE); 	write++;       }    /* Extcommunity-list.  */   cm = community_list_master_lookup (bgp_clist, EXTCOMMUNITY_LIST_MASTER);    for (list = cm->num.head; list; list = list->next)     for (entry = list->head; entry; entry = entry->next)       { 	vty_out (vty, ""ip extcommunity-list %s %s %s%s"", 		 list->name, community_direct_str (entry->direct), 		 community_list_config_str (entry), VTY_NEWLINE); 	write++;       }   for (list = cm->str.head; list; list = list->next)     for (entry = list->head; entry; entry = entry->next)       { 	vty_out (vty, ""ip extcommunity-list %s %s %s %s%s"", 		 entry->style == EXTCOMMUNITY_LIST_STANDARD 		 ? ""standard"" : ""expanded"", 		 list->name, community_direct_str (entry->direct), 		 community_list_config_str (entry), VTY_NEWLINE); 	write++;       }   return write; }"
"360827_not_vulnerable.c","not_vulnerable","int io_async_cancel(struct io_kiocb *req, unsigned int issue_flags) { 	struct io_cancel *cancel = io_kiocb_to_cmd(req, struct io_cancel); 	struct io_cancel_data cd = { 		.ctx	= req->ctx, 		.data	= cancel->addr, 		.flags	= cancel->flags, 		.seq	= atomic_inc_return(&req->ctx->cancel_seq), 	}; 	struct io_uring_task *tctx = req->task->io_uring; 	int ret;  	if (cd.flags & IORING_ASYNC_CANCEL_FD) { 		if (req->flags & REQ_F_FIXED_FILE || 		    cd.flags & IORING_ASYNC_CANCEL_FD_FIXED) { 			req->flags |= REQ_F_FIXED_FILE; 			req->file = io_file_get_fixed(req, cancel->fd, 							issue_flags); 		} else { 			req->file = io_file_get_normal(req, cancel->fd); 		} 		if (!req->file) { 			ret = -EBADF; 			goto done; 		} 		cd.file = req->file; 	}  	ret = __io_async_cancel(&cd, tctx, issue_flags); done: 	if (ret < 0) 		req_set_fail(req); 	io_req_set_res(req, ret, 0); 	return IOU_OK; }"
"361748_not_vulnerable.c","not_vulnerable","static int em28xx_duplicate_dev(struct em28xx *dev) { 	int nr; 	struct em28xx *sec_dev = kmemdup(dev, sizeof(*sec_dev), GFP_KERNEL);  	if (!sec_dev) { 		dev->dev_next = NULL; 		return -ENOMEM; 	} 	/* Check to see next free device and mark as used */ 	do { 		nr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS); 		if (nr >= EM28XX_MAXBOARDS) { 			/* No free device slots */ 			dev_warn(&dev->intf->dev, "": Supports only %i em28xx boards.\n"", 				 EM28XX_MAXBOARDS); 			kfree(sec_dev); 			dev->dev_next = NULL; 			return -ENOMEM; 		} 	} while (test_and_set_bit(nr, em28xx_devused)); 	sec_dev->devno = nr; 	snprintf(sec_dev->name, 28, ""em28xx #%d"", nr); 	sec_dev->dev_next = NULL; 	dev->dev_next = sec_dev; 	return 0; }"
"364750_not_vulnerable.c","not_vulnerable","findtags_parse_line(     findtags_state_T		*st,     tagptrs_T			*tagpp,     findtags_match_args_T	*margs,     tagsearch_info_T		*sinfo_p) {     int		status;     int		i;     int		cmplen;     int		tagcmp;      // Figure out where the different strings are in this line.     // For ""normal"" tags: Do a quick check if the tag matches.     // This speeds up tag searching a lot!     if (st->orgpat->headlen #ifdef FEAT_EMACS_TAGS 	    && !st->is_etag #endif        )     { 	CLEAR_FIELD(*tagpp); 	tagpp->tagname = st->lbuf; 	tagpp->tagname_end = vim_strchr(st->lbuf, TAB); 	if (tagpp->tagname_end == NULL) 	    // Corrupted tag line. 	    return TAG_MATCH_FAIL;  	// Skip this line if the length of the tag is different and 	// there is no regexp, or the tag is too short. 	cmplen = (int)(tagpp->tagname_end - tagpp->tagname); 	if (p_tl != 0 && cmplen > p_tl)	    // adjust for 'taglength' 	    cmplen = p_tl; 	if ((st->flags & TAG_REGEXP) && st->orgpat->headlen < cmplen) 	    cmplen = st->orgpat->headlen; 	else if (st->state == TS_LINEAR && st->orgpat->headlen != cmplen) 	    return TAG_MATCH_NEXT;  	if (st->state == TS_BINARY) 	{ 	    // Simplistic check for unsorted tags file. 	    i = (int)tagpp->tagname[0]; 	    if (margs->sortic) 		i = (int)TOUPPER_ASC(tagpp->tagname[0]); 	    if (i < sinfo_p->low_char || i > sinfo_p->high_char) 		margs->sort_error = TRUE;  	    // Compare the current tag with the searched tag. 	    if (margs->sortic) 		tagcmp = tag_strnicmp(tagpp->tagname, st->orgpat->head, 							(size_t)cmplen); 	    else 		tagcmp = STRNCMP(tagpp->tagname, st->orgpat->head, cmplen);  	    // A match with a shorter tag means to search forward. 	    // A match with a longer tag means to search backward. 	    if (tagcmp == 0) 	    { 		if (cmplen < st->orgpat->headlen) 		    tagcmp = -1; 		else if (cmplen > st->orgpat->headlen) 		    tagcmp = 1; 	    }  	    if (tagcmp == 0) 	    { 		// We've located the tag, now skip back and search 		// forward until the first matching tag is found. 		st->state = TS_SKIP_BACK; 		sinfo_p->match_offset = sinfo_p->curr_offset; 		return TAG_MATCH_NEXT; 	    } 	    if (tagcmp < 0) 	    { 		sinfo_p->curr_offset = vim_ftell(st->fp); 		if (sinfo_p->curr_offset < sinfo_p->high_offset) 		{ 		    sinfo_p->low_offset = sinfo_p->curr_offset; 		    if (margs->sortic) 			sinfo_p->low_char = TOUPPER_ASC(tagpp->tagname[0]); 		    else 			sinfo_p->low_char = tagpp->tagname[0]; 		    return TAG_MATCH_NEXT; 		} 	    } 	    if (tagcmp > 0 && sinfo_p->curr_offset != sinfo_p->high_offset) 	    { 		sinfo_p->high_offset = sinfo_p->curr_offset; 		if (margs->sortic) 		    sinfo_p->high_char = TOUPPER_ASC(tagpp->tagname[0]); 		else 		    sinfo_p->high_char = tagpp->tagname[0]; 		return TAG_MATCH_NEXT; 	    }  	    // No match yet and are at the end of the binary search. 	    return TAG_MATCH_STOP; 	} 	else if (st->state == TS_SKIP_BACK) 	{ 	    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0) 		st->state = TS_STEP_FORWARD; 	    else 		// Have to skip back more.  Restore the curr_offset 		// used, otherwise we get stuck at a long line. 		sinfo_p->curr_offset = sinfo_p->curr_offset_used; 	    return TAG_MATCH_NEXT; 	} 	else if (st->state == TS_STEP_FORWARD) 	{ 	    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0) 	    { 		if ((off_T)vim_ftell(st->fp) > sinfo_p->match_offset) 		    return TAG_MATCH_STOP;	// past last match 		else 		    return TAG_MATCH_NEXT;	// before first match 	    } 	} 	else 	    // skip this match if it can't match 	    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0) 		return TAG_MATCH_NEXT;  	// Can be a matching tag, isolate the file name and command. 	tagpp->fname = tagpp->tagname_end + 1; 	tagpp->fname_end = vim_strchr(tagpp->fname, TAB); 	if (tagpp->fname_end == NULL) 	    status = FAIL; 	else 	{ 	    tagpp->command = tagpp->fname_end + 1; 	    status = OK; 	}     }     else 	status = parse_tag_line(st->lbuf, #ifdef FEAT_EMACS_TAGS 		st->is_etag, #endif 		tagpp);      if (status == FAIL) 	return TAG_MATCH_FAIL;  #ifdef FEAT_EMACS_TAGS     if (st->is_etag) 	tagpp->fname = st->ebuf; #endif      return TAG_MATCH_SUCCESS; }"
"364768_not_vulnerable.c","not_vulnerable","findtags_state_init(     findtags_state_T	*st,     char_u		*pat,     int			flags,     int			mincount) {     int		mtt;      st->tag_fname = alloc(MAXPATHL + 1);     st->fp = NULL;     st->orgpat = ALLOC_ONE(pat_T);     st->orgpat->pat = pat;     st->orgpat->len = (int)STRLEN(pat);     st->orgpat->regmatch.regprog = NULL;     st->flags = flags;     st->tag_file_sorted = NUL;     st->help_only = (flags & TAG_HELP);     st->get_searchpat = FALSE; #ifdef FEAT_MULTI_LANG     st->help_lang[0] = NUL;     st->help_pri = 0;     st->help_lang_find = NULL;     st->is_txt = FALSE; #endif     st->did_open = FALSE;     st->mincount = mincount;     st->lbuf_size = LSIZE;     st->lbuf = alloc(st->lbuf_size); #ifdef FEAT_EMACS_TAGS     st->ebuf = alloc(LSIZE); #endif     st->match_count = 0;     st->stop_searching = FALSE;      for (mtt = 0; mtt < MT_COUNT; ++mtt)     { 	ga_init2(&st->ga_match[mtt], sizeof(char_u *), 100); 	hash_init(&st->ht_match[mtt]);     }      // check for out of memory situation     if (st->tag_fname == NULL 	    || st->lbuf == NULL #ifdef FEAT_EMACS_TAGS 	    || st->ebuf == NULL #endif        ) 	return FAIL;      return OK; }"
"364770_not_vulnerable.c","not_vulnerable","findtags_string_convert(findtags_state_T *st) {     char_u	*conv_line;     int		len;      conv_line = string_convert(&st->vimconv, st->lbuf, NULL);     if (conv_line == NULL) 	return;      // Copy or swap lbuf and conv_line.     len = (int)STRLEN(conv_line) + 1;     if (len > st->lbuf_size)     { 	vim_free(st->lbuf); 	st->lbuf = conv_line; 	st->lbuf_size = len;     }     else     { 	STRCPY(st->lbuf, conv_line); 	vim_free(conv_line);     } }"
"366324_not_vulnerable.c","not_vulnerable","void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt) { 	struct mountpoint *old_mp = mnt->mnt_mp; 	struct mount *old_parent = mnt->mnt_parent;  	list_del_init(&mnt->mnt_child); 	hlist_del_init(&mnt->mnt_mp_list); 	hlist_del_init_rcu(&mnt->mnt_hash);  	attach_mnt(mnt, parent, mp);  	put_mountpoint(old_mp); 	mnt_add_count(old_parent, -1); }"
"366333_not_vulnerable.c","not_vulnerable","static bool has_locked_children(struct mount *mnt, struct dentry *dentry) { 	struct mount *child;  	list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) { 		if (!is_subdir(child->mnt_mountpoint, dentry)) 			continue;  		if (child->mnt.mnt_flags & MNT_LOCKED) 			return true; 	} 	return false; }"
"369138_not_vulnerable.c","not_vulnerable"," static inline void io_ring_clear_wakeup_flag(struct io_ring_ctx *ctx) { 	spin_lock(&ctx->completion_lock); 	WRITE_ONCE(ctx->rings->sq_flags, 		   ctx->rings->sq_flags & ~IORING_SQ_NEED_WAKEUP); 	spin_unlock(&ctx->completion_lock);"
"369163_not_vulnerable.c","not_vulnerable","static void io_req_task_cancel(struct io_kiocb *req, bool *locked) { 	struct io_ring_ctx *ctx = req->ctx;  	/* not needed for normal modes, but SQPOLL depends on it */ 	io_tw_lock(ctx, locked); 	io_req_complete_failed(req, req->result); }"
"369174_not_vulnerable.c","not_vulnerable"," static int io_close_fixed(struct io_kiocb *req, unsigned int issue_flags) { 	unsigned int offset = req->close.file_slot - 1; 	struct io_ring_ctx *ctx = req->ctx; 	bool needs_lock = issue_flags & IO_URING_F_UNLOCKED; 	struct io_fixed_file *file_slot; 	struct file *file; 	int ret;  	io_ring_submit_lock(ctx, needs_lock); 	ret = -ENXIO; 	if (unlikely(!ctx->file_data)) 		goto out; 	ret = -EINVAL; 	if (offset >= ctx->nr_user_files) 		goto out; 	ret = io_rsrc_node_switch_start(ctx); 	if (ret) 		goto out;  	offset = array_index_nospec(offset, ctx->nr_user_files); 	file_slot = io_fixed_file_slot(&ctx->file_table, offset); 	ret = -EBADF; 	if (!file_slot->file_ptr) 		goto out;  	file = (struct file *)(file_slot->file_ptr & FFS_MASK); 	ret = io_queue_rsrc_removal(ctx->file_data, offset, ctx->rsrc_node, file); 	if (ret) 		goto out;  	file_slot->file_ptr = 0; 	io_rsrc_node_switch(ctx, ctx->file_data); 	ret = 0; out: 	io_ring_submit_unlock(ctx, needs_lock); 	return ret;"
"369185_not_vulnerable.c","not_vulnerable","static int io_fallocate_prep(struct io_kiocb *req, 			     const struct io_uring_sqe *sqe) { 	if (sqe->ioprio || sqe->buf_index || sqe->rw_flags || 	    sqe->splice_fd_in) 		return -EINVAL; 	if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL)) 		return -EINVAL;  	req->sync.off = READ_ONCE(sqe->off); 	req->sync.len = READ_ONCE(sqe->addr); 	req->sync.mode = READ_ONCE(sqe->len); 	return 0; }"
"369191_not_vulnerable.c","not_vulnerable"," */ static const struct io_uring_sqe *io_get_sqe(struct io_ring_ctx *ctx) { 	unsigned head, mask = ctx->sq_entries - 1; 	unsigned sq_idx = ctx->cached_sq_head++ & mask;  	/* 	 * The cached sq head (or cq tail) serves two purposes: 	 * 	 * 1) allows us to batch the cost of updating the user visible 	 *    head updates. 	 * 2) allows the kernel side to track the head on its own, even 	 *    though the application is the one updating it. 	 */ 	head = READ_ONCE(ctx->sq_array[sq_idx]); 	if (likely(head < ctx->sq_entries)) 		return &ctx->sq_sqes[head];  	/* drop invalid entries */ 	ctx->cq_extra--; 	WRITE_ONCE(ctx->rings->sq_dropped, 		   READ_ONCE(ctx->rings->sq_dropped) + 1); 	return NULL;"
"369248_not_vulnerable.c","not_vulnerable"," static int io_req_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe) { 	switch (req->opcode) { 	case IORING_OP_NOP: 		return 0; 	case IORING_OP_READV: 	case IORING_OP_READ_FIXED: 	case IORING_OP_READ: 	case IORING_OP_WRITEV: 	case IORING_OP_WRITE_FIXED: 	case IORING_OP_WRITE: 		return io_prep_rw(req, sqe); 	case IORING_OP_POLL_ADD: 		return io_poll_add_prep(req, sqe); 	case IORING_OP_POLL_REMOVE: 		return io_poll_update_prep(req, sqe); 	case IORING_OP_FSYNC: 		return io_fsync_prep(req, sqe); 	case IORING_OP_SYNC_FILE_RANGE: 		return io_sfr_prep(req, sqe); 	case IORING_OP_SENDMSG: 	case IORING_OP_SEND: 		return io_sendmsg_prep(req, sqe); 	case IORING_OP_RECVMSG: 	case IORING_OP_RECV: 		return io_recvmsg_prep(req, sqe); 	case IORING_OP_CONNECT: 		return io_connect_prep(req, sqe); 	case IORING_OP_TIMEOUT: 		return io_timeout_prep(req, sqe, false); 	case IORING_OP_TIMEOUT_REMOVE: 		return io_timeout_remove_prep(req, sqe); 	case IORING_OP_ASYNC_CANCEL: 		return io_async_cancel_prep(req, sqe); 	case IORING_OP_LINK_TIMEOUT: 		return io_timeout_prep(req, sqe, true); 	case IORING_OP_ACCEPT: 		return io_accept_prep(req, sqe); 	case IORING_OP_FALLOCATE: 		return io_fallocate_prep(req, sqe); 	case IORING_OP_OPENAT: 		return io_openat_prep(req, sqe); 	case IORING_OP_CLOSE: 		return io_close_prep(req, sqe); 	case IORING_OP_FILES_UPDATE: 		return io_rsrc_update_prep(req, sqe); 	case IORING_OP_STATX: 		return io_statx_prep(req, sqe); 	case IORING_OP_FADVISE: 		return io_fadvise_prep(req, sqe); 	case IORING_OP_MADVISE: 		return io_madvise_prep(req, sqe); 	case IORING_OP_OPENAT2: 		return io_openat2_prep(req, sqe); 	case IORING_OP_EPOLL_CTL: 		return io_epoll_ctl_prep(req, sqe); 	case IORING_OP_SPLICE: 		return io_splice_prep(req, sqe); 	case IORING_OP_PROVIDE_BUFFERS: 		return io_provide_buffers_prep(req, sqe); 	case IORING_OP_REMOVE_BUFFERS: 		return io_remove_buffers_prep(req, sqe); 	case IORING_OP_TEE: 		return io_tee_prep(req, sqe); 	case IORING_OP_SHUTDOWN: 		return io_shutdown_prep(req, sqe); 	case IORING_OP_RENAMEAT: 		return io_renameat_prep(req, sqe); 	case IORING_OP_UNLINKAT: 		return io_unlinkat_prep(req, sqe); 	case IORING_OP_MKDIRAT: 		return io_mkdirat_prep(req, sqe); 	case IORING_OP_SYMLINKAT: 		return io_symlinkat_prep(req, sqe); 	case IORING_OP_LINKAT: 		return io_linkat_prep(req, sqe); 	case IORING_OP_MSG_RING: 		return io_msg_ring_prep(req, sqe); 	}  	printk_once(KERN_WARNING ""io_uring: unhandled opcode %d\n"", 			req->opcode); 	return -EINVAL;"
"369384_not_vulnerable.c","not_vulnerable"," static int io_eventfd_unregister(struct io_ring_ctx *ctx) { 	struct io_ev_fd *ev_fd;  	ev_fd = rcu_dereference_protected(ctx->io_ev_fd, 					lockdep_is_held(&ctx->uring_lock)); 	if (ev_fd) { 		ctx->has_evfd = false; 		rcu_assign_pointer(ctx->io_ev_fd, NULL); 		call_rcu(&ev_fd->rcu, io_eventfd_put); 		return 0; 	}  	return -ENXIO;"
"372879_not_vulnerable.c","not_vulnerable","static int irda_open_tsap(struct irda_sock *self, __u8 tsap_sel, char *name) { 	notify_t notify;  	if (self->tsap) { 		IRDA_WARNING(""%s: busy!\n"", __func__); 		return -EBUSY; 	}  	/* Initialize callbacks to be used by the IrDA stack */ 	irda_notify_init(&notify); 	notify.connect_confirm       = irda_connect_confirm; 	notify.connect_indication    = irda_connect_indication; 	notify.disconnect_indication = irda_disconnect_indication; 	notify.data_indication       = irda_data_indication; 	notify.udata_indication	     = irda_data_indication; 	notify.flow_indication       = irda_flow_indication; 	notify.instance = self; 	strncpy(notify.name, name, NOTIFY_MAX_NAME);  	self->tsap = irttp_open_tsap(tsap_sel, DEFAULT_INITIAL_CREDIT, 				     &notify); 	if (self->tsap == NULL) { 		IRDA_DEBUG(0, ""%s(), Unable to allocate TSAP!\n"", 			   __func__); 		return -ENOMEM; 	} 	/* Remember which TSAP selector we actually got */ 	self->stsap_sel = self->tsap->stsap_sel;  	return 0; }"
"376354_not_vulnerable.c","not_vulnerable","gpg_hash_str (CamelCipherHash hash) { 	switch (hash) { 	case CAMEL_CIPHER_HASH_MD2: 		return ""--digest-algo=MD2""; 	case CAMEL_CIPHER_HASH_MD5: 		return ""--digest-algo=MD5""; 	case CAMEL_CIPHER_HASH_SHA1: 		return ""--digest-algo=SHA1""; 	case CAMEL_CIPHER_HASH_SHA256: 		return ""--digest-algo=SHA256""; 	case CAMEL_CIPHER_HASH_SHA384: 		return ""--digest-algo=SHA384""; 	case CAMEL_CIPHER_HASH_SHA512: 		return ""--digest-algo=SHA512""; 	case CAMEL_CIPHER_HASH_RIPEMD160: 		return ""--digest-algo=RIPEMD160""; 	default: 		return NULL; 	} }"
"379666_not_vulnerable.c","not_vulnerable","R_API bool r_anal_var_check_name(const char *name) { 	return !isdigit ((unsigned char)*name) && strcspn (name, ""., =/""); }"
"379677_not_vulnerable.c","not_vulnerable","R_API char *r_anal_function_format_sig(R_NONNULL RAnal *anal, R_NONNULL RAnalFunction *fcn, R_NULLABLE char *fcn_name, 		R_NULLABLE RAnalFcnVarsCache *reuse_cache, R_NULLABLE const char *fcn_name_pre, R_NULLABLE const char *fcn_name_post) { 	RAnalFcnVarsCache *cache = NULL;  	if (!fcn_name) { 		fcn_name = fcn->name; 		if (!fcn_name) { 			return NULL; 		} 	}  	RStrBuf *buf = r_strbuf_new (NULL); 	if (!buf) { 		return NULL; 	}  	Sdb *TDB = anal->sdb_types; 	char *type_fcn_name = r_type_func_guess (TDB, fcn_name); 	if (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) { 		const char *fcn_type = r_type_func_ret (anal->sdb_types, type_fcn_name); 		if (R_STR_ISNOTEMPTY (fcn_type)) { 			const char *sp = "" ""; 			if (*fcn_type && (fcn_type[strlen (fcn_type) - 1] == '*')) { 				sp = """"; 			} 			r_strbuf_appendf (buf, ""%s%s"", fcn_type, sp); 		} 	}  	if (fcn_name_pre) { 		r_strbuf_append (buf, fcn_name_pre); 	} 	r_strbuf_append (buf, fcn_name); 	if (fcn_name_post) { 		r_strbuf_append (buf, fcn_name_post); 	} 	r_strbuf_append (buf, "" ("");  	if (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) { 		int i, argc = r_type_func_args_count (TDB, type_fcn_name); 		bool comma = true; 		// This avoids false positives present in argument recovery 		// and straight away print arguments fetched from types db 		for (i = 0; i < argc; i++) { 			char *type = r_type_func_args_type (TDB, type_fcn_name, i); 			const char *name = r_type_func_args_name (TDB, type_fcn_name, i); 			if (!type || !*type || !name) { 				eprintf (""Missing type for %s\n"", type_fcn_name); 				goto beach; 			} 			if (i == argc - 1) { 				comma = false; 			} 			size_t len = strlen (type); 			const char *tc = len > 0 && type[len - 1] == '*'? """": "" ""; 			r_strbuf_appendf (buf, ""%s%s%s%s"", type, tc, name, comma? "", "": """"); 			free (type); 		} 		goto beach; 	} 	R_FREE (type_fcn_name);   	cache = reuse_cache; 	if (!cache) { 		cache = R_NEW0 (RAnalFcnVarsCache); 		if (!cache) { 			type_fcn_name = NULL; 			goto beach; 		} 		r_anal_function_vars_cache_init (anal, cache, fcn); 	}  	bool comma = true; 	bool arg_bp = false; 	size_t tmp_len; 	RAnalVar *var; 	RListIter *iter;  	r_list_foreach (cache->rvars, iter, var) { 		// assume self, error are always the last 		if (!strcmp (var->name, ""self"") || !strcmp (var->name, ""error"")) { 			r_strbuf_slice (buf, 0, r_strbuf_length (buf) - 2); 			break; 		} 		tmp_len = strlen (var->type); 		if (tmp_len > 0) { 			r_strbuf_appendf (buf, ""%s%s%s%s"", var->type, 				tmp_len && var->type[tmp_len - 1] == '*' ? """" : "" "", 				var->name, iter->n ? "", "" : """"); 		} 	}  	r_list_foreach (cache->bvars, iter, var) { 		if (var->isarg) { 			if (!r_list_empty (cache->rvars) && comma) { 				r_strbuf_append (buf, "", ""); 				comma = false; 			} 			arg_bp = true; 			tmp_len = strlen (var->type); 			if (tmp_len > 0) { 				r_strbuf_appendf (buf, ""%s%s%s%s"", var->type, 						tmp_len && var->type[tmp_len - 1] =='*' ? """" : "" "", 						var->name, iter->n ? "", "" : """"); 			} 		} 	}  	comma = true; 	const char *maybe_comma = "", ""; 	r_list_foreach (cache->svars, iter, var) { 		if (var->isarg) { 			if (!*maybe_comma || ((arg_bp || !r_list_empty (cache->rvars)) && comma)) { 				comma = false; 				r_strbuf_append (buf, "", ""); 			} 			tmp_len = strlen (var->type); 			if (iter->n && ((RAnalVar *)iter->n->data)->isarg) { 				maybe_comma = "", ""; 			} else { 				maybe_comma = """"; 			} 			if (tmp_len > 0) { 				r_strbuf_appendf (buf, ""%s%s%s%s"", var->type, 					tmp_len && var->type[tmp_len - 1] == '*'? """": "" "", 					var->name, maybe_comma); 			} 		} 	}  beach: 	r_strbuf_append (buf, "");""); 	R_FREE (type_fcn_name); 	if (!reuse_cache) { 		// !reuse_cache => we created our own cache 		r_anal_function_vars_cache_fini (cache); 		free (cache); 	} 	return r_strbuf_drain (buf); }"
"379690_not_vulnerable.cpp","not_vulnerable","static inline bool serialize_single_var(RAnalVarProt *vp, RStrBuf *sb) { 	r_return_val_if_fail (vp && sb, false); 	// shouldn't have special chars in them anyways, so replace in place 	sanitize_var_serial (vp->name, false); 	sanitize_var_serial (vp->type, true); 	const char b = vp->isarg? 't': 'f'; 	if (!valid_var_kind (vp->kind)) { 		return false; 	} 	return r_strbuf_appendf (sb, ""%c%c%d:%s:%s"", b, vp->kind, vp->delta, vp->name, vp->type); }"
"379702_not_vulnerable.c","not_vulnerable","R_API ut64 r_anal_var_addr(RAnalVar *var) { 	r_return_val_if_fail (var, UT64_MAX); 	RAnal *anal = var->fcn->anal; 	const char *regname = NULL; 	if (var->kind == R_ANAL_VAR_KIND_BPV) { 		regname = r_reg_get_name (anal->reg, R_REG_NAME_BP); 		return r_reg_getv (anal->reg, regname) + var->delta + var->fcn->bp_off; 	} else if (var->kind == R_ANAL_VAR_KIND_SPV) { 		regname = r_reg_get_name (anal->reg, R_REG_NAME_SP); 		return r_reg_getv (anal->reg, regname) + var->delta; 	} 	return 0; }"
"381855_not_vulnerable.c","not_vulnerable","static int udf_read_inode(struct inode *inode, bool hidden_inode) { 	struct buffer_head *bh = NULL; 	struct fileEntry *fe; 	struct extendedFileEntry *efe; 	uint16_t ident; 	struct udf_inode_info *iinfo = UDF_I(inode); 	struct udf_sb_info *sbi = UDF_SB(inode->i_sb); 	struct kernel_lb_addr *iloc = &iinfo->i_location; 	unsigned int link_count; 	unsigned int indirections = 0; 	int bs = inode->i_sb->s_blocksize; 	int ret = -EIO; 	uint32_t uid, gid;  reread: 	if (iloc->partitionReferenceNum >= sbi->s_partitions) { 		udf_debug(""partition reference: %u > logical volume partitions: %u\n"", 			  iloc->partitionReferenceNum, sbi->s_partitions); 		return -EIO; 	}  	if (iloc->logicalBlockNum >= 	    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) { 		udf_debug(""block=%u, partition=%u out of range\n"", 			  iloc->logicalBlockNum, iloc->partitionReferenceNum); 		return -EIO; 	}  	/* 	 * Set defaults, but the inode is still incomplete! 	 * Note: get_new_inode() sets the following on a new inode: 	 *      i_sb = sb 	 *      i_no = ino 	 *      i_flags = sb->s_flags 	 *      i_state = 0 	 * clean_inode(): zero fills and sets 	 *      i_count = 1 	 *      i_nlink = 1 	 *      i_op = NULL; 	 */ 	bh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident); 	if (!bh) { 		udf_err(inode->i_sb, ""(ino %lu) failed !bh\n"", inode->i_ino); 		return -EIO; 	}  	if (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && 	    ident != TAG_IDENT_USE) { 		udf_err(inode->i_sb, ""(ino %lu) failed ident=%u\n"", 			inode->i_ino, ident); 		goto out; 	}  	fe = (struct fileEntry *)bh->b_data; 	efe = (struct extendedFileEntry *)bh->b_data;  	if (fe->icbTag.strategyType == cpu_to_le16(4096)) { 		struct buffer_head *ibh;  		ibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident); 		if (ident == TAG_IDENT_IE && ibh) { 			struct kernel_lb_addr loc; 			struct indirectEntry *ie;  			ie = (struct indirectEntry *)ibh->b_data; 			loc = lelb_to_cpu(ie->indirectICB.extLocation);  			if (ie->indirectICB.extLength) { 				brelse(ibh); 				memcpy(&iinfo->i_location, &loc, 				       sizeof(struct kernel_lb_addr)); 				if (++indirections > UDF_MAX_ICB_NESTING) { 					udf_err(inode->i_sb, 						""too many ICBs in ICB hierarchy"" 						"" (max %d supported)\n"", 						UDF_MAX_ICB_NESTING); 					goto out; 				} 				brelse(bh); 				goto reread; 			} 		} 		brelse(ibh); 	} else if (fe->icbTag.strategyType != cpu_to_le16(4)) { 		udf_err(inode->i_sb, ""unsupported strategy type: %u\n"", 			le16_to_cpu(fe->icbTag.strategyType)); 		goto out; 	} 	if (fe->icbTag.strategyType == cpu_to_le16(4)) 		iinfo->i_strat4096 = 0; 	else /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */ 		iinfo->i_strat4096 = 1;  	iinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) & 							ICBTAG_FLAG_AD_MASK; 	if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_SHORT && 	    iinfo->i_alloc_type != ICBTAG_FLAG_AD_LONG && 	    iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) { 		ret = -EIO; 		goto out; 	} 	iinfo->i_unique = 0; 	iinfo->i_lenEAttr = 0; 	iinfo->i_lenExtents = 0; 	iinfo->i_lenAlloc = 0; 	iinfo->i_next_alloc_block = 0; 	iinfo->i_next_alloc_goal = 0; 	if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) { 		iinfo->i_efe = 1; 		iinfo->i_use = 0; 		ret = udf_alloc_i_data(inode, bs - 					sizeof(struct extendedFileEntry)); 		if (ret) 			goto out; 		memcpy(iinfo->i_data, 		       bh->b_data + sizeof(struct extendedFileEntry), 		       bs - sizeof(struct extendedFileEntry)); 	} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) { 		iinfo->i_efe = 0; 		iinfo->i_use = 0; 		ret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry)); 		if (ret) 			goto out; 		memcpy(iinfo->i_data, 		       bh->b_data + sizeof(struct fileEntry), 		       bs - sizeof(struct fileEntry)); 	} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) { 		iinfo->i_efe = 0; 		iinfo->i_use = 1; 		iinfo->i_lenAlloc = le32_to_cpu( 				((struct unallocSpaceEntry *)bh->b_data)-> 				 lengthAllocDescs); 		ret = udf_alloc_i_data(inode, bs - 					sizeof(struct unallocSpaceEntry)); 		if (ret) 			goto out; 		memcpy(iinfo->i_data, 		       bh->b_data + sizeof(struct unallocSpaceEntry), 		       bs - sizeof(struct unallocSpaceEntry)); 		return 0; 	}  	ret = -EIO; 	read_lock(&sbi->s_cred_lock); 	uid = le32_to_cpu(fe->uid); 	if (uid == UDF_INVALID_ID || 	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET)) 		inode->i_uid = sbi->s_uid; 	else 		i_uid_write(inode, uid);  	gid = le32_to_cpu(fe->gid); 	if (gid == UDF_INVALID_ID || 	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET)) 		inode->i_gid = sbi->s_gid; 	else 		i_gid_write(inode, gid);  	if (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY && 			sbi->s_fmode != UDF_INVALID_MODE) 		inode->i_mode = sbi->s_fmode; 	else if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY && 			sbi->s_dmode != UDF_INVALID_MODE) 		inode->i_mode = sbi->s_dmode; 	else 		inode->i_mode = udf_convert_permissions(fe); 	inode->i_mode &= ~sbi->s_umask; 	iinfo->i_extraPerms = le32_to_cpu(fe->permissions) & ~FE_MAPPED_PERMS;  	read_unlock(&sbi->s_cred_lock);  	link_count = le16_to_cpu(fe->fileLinkCount); 	if (!link_count) { 		if (!hidden_inode) { 			ret = -ESTALE; 			goto out; 		} 		link_count = 1; 	} 	set_nlink(inode, link_count);  	inode->i_size = le64_to_cpu(fe->informationLength); 	iinfo->i_lenExtents = inode->i_size;  	if (iinfo->i_efe == 0) { 		inode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) << 			(inode->i_sb->s_blocksize_bits - 9);  		udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime); 		udf_disk_stamp_to_time(&inode->i_mtime, fe->modificationTime); 		udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime);  		iinfo->i_unique = le64_to_cpu(fe->uniqueID); 		iinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr); 		iinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs); 		iinfo->i_checkpoint = le32_to_cpu(fe->checkpoint); 		iinfo->i_streamdir = 0; 		iinfo->i_lenStreams = 0; 	} else { 		inode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) << 		    (inode->i_sb->s_blocksize_bits - 9);  		udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime); 		udf_disk_stamp_to_time(&inode->i_mtime, efe->modificationTime); 		udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime); 		udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime);  		iinfo->i_unique = le64_to_cpu(efe->uniqueID); 		iinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr); 		iinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs); 		iinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);  		/* Named streams */ 		iinfo->i_streamdir = (efe->streamDirectoryICB.extLength != 0); 		iinfo->i_locStreamdir = 			lelb_to_cpu(efe->streamDirectoryICB.extLocation); 		iinfo->i_lenStreams = le64_to_cpu(efe->objectSize); 		if (iinfo->i_lenStreams >= inode->i_size) 			iinfo->i_lenStreams -= inode->i_size; 		else 			iinfo->i_lenStreams = 0; 	} 	inode->i_generation = iinfo->i_unique;  	/* 	 * Sanity check length of allocation descriptors and extended attrs to 	 * avoid integer overflows 	 */ 	if (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs) 		goto out; 	/* Now do exact checks */ 	if (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs) 		goto out; 	/* Sanity checks for files in ICB so that we don't get confused later */ 	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) { 		/* 		 * For file in ICB data is stored in allocation descriptor 		 * so sizes should match 		 */ 		if (iinfo->i_lenAlloc != inode->i_size) 			goto out; 		/* File in ICB has to fit in there... */ 		if (inode->i_size > bs - udf_file_entry_alloc_offset(inode)) 			goto out; 	}  	switch (fe->icbTag.fileType) { 	case ICBTAG_FILE_TYPE_DIRECTORY: 		inode->i_op = &udf_dir_inode_operations; 		inode->i_fop = &udf_dir_operations; 		inode->i_mode |= S_IFDIR; 		inc_nlink(inode); 		break; 	case ICBTAG_FILE_TYPE_REALTIME: 	case ICBTAG_FILE_TYPE_REGULAR: 	case ICBTAG_FILE_TYPE_UNDEF: 	case ICBTAG_FILE_TYPE_VAT20: 		if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) 			inode->i_data.a_ops = &udf_adinicb_aops; 		else 			inode->i_data.a_ops = &udf_aops; 		inode->i_op = &udf_file_inode_operations; 		inode->i_fop = &udf_file_operations; 		inode->i_mode |= S_IFREG; 		break; 	case ICBTAG_FILE_TYPE_BLOCK: 		inode->i_mode |= S_IFBLK; 		break; 	case ICBTAG_FILE_TYPE_CHAR: 		inode->i_mode |= S_IFCHR; 		break; 	case ICBTAG_FILE_TYPE_FIFO: 		init_special_inode(inode, inode->i_mode | S_IFIFO, 0); 		break; 	case ICBTAG_FILE_TYPE_SOCKET: 		init_special_inode(inode, inode->i_mode | S_IFSOCK, 0); 		break; 	case ICBTAG_FILE_TYPE_SYMLINK: 		inode->i_data.a_ops = &udf_symlink_aops; 		inode->i_op = &udf_symlink_inode_operations; 		inode_nohighmem(inode); 		inode->i_mode = S_IFLNK | 0777; 		break; 	case ICBTAG_FILE_TYPE_MAIN: 		udf_debug(""METADATA FILE-----\n""); 		break; 	case ICBTAG_FILE_TYPE_MIRROR: 		udf_debug(""METADATA MIRROR FILE-----\n""); 		break; 	case ICBTAG_FILE_TYPE_BITMAP: 		udf_debug(""METADATA BITMAP FILE-----\n""); 		break; 	default: 		udf_err(inode->i_sb, ""(ino %lu) failed unknown file type=%u\n"", 			inode->i_ino, fe->icbTag.fileType); 		goto out; 	} 	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) { 		struct deviceSpec *dsea = 			(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1); 		if (dsea) { 			init_special_inode(inode, inode->i_mode, 				MKDEV(le32_to_cpu(dsea->majorDeviceIdent), 				      le32_to_cpu(dsea->minorDeviceIdent))); 			/* Developer ID ??? */ 		} else 			goto out; 	} 	ret = 0; out: 	brelse(bh); 	return ret; }"
"381860_not_vulnerable.c","not_vulnerable","static struct buffer_head *udf_getblk(struct inode *inode, udf_pblk_t block, 				      int create, int *err) { 	struct buffer_head *bh; 	struct buffer_head dummy;  	dummy.b_state = 0; 	dummy.b_blocknr = -1000; 	*err = udf_get_block(inode, block, &dummy, create); 	if (!*err && buffer_mapped(&dummy)) { 		bh = sb_getblk(inode->i_sb, dummy.b_blocknr); 		if (buffer_new(&dummy)) { 			lock_buffer(bh); 			memset(bh->b_data, 0x00, inode->i_sb->s_blocksize); 			set_buffer_uptodate(bh); 			unlock_buffer(bh); 			mark_buffer_dirty_inode(bh, inode); 		} 		return bh; 	}  	return NULL; }"
"382784_not_vulnerable.c","not_vulnerable","gdIOCtx * gdNewDynamicCtxEx (int initialSize, void *data, int freeOKFlag) { 	dpIOCtx *ctx; 	dynamicPtr *dp;  	ctx = (dpIOCtx *) gdMalloc (sizeof (dpIOCtx));  	dp = newDynamic(initialSize, data, freeOKFlag);  	ctx->dp = dp;  	ctx->ctx.getC = dynamicGetchar; 	ctx->ctx.putC = dynamicPutchar;  	ctx->ctx.getBuf = dynamicGetbuf; 	ctx->ctx.putBuf = dynamicPutbuf;  	ctx->ctx.seek = dynamicSeek; 	ctx->ctx.tell = dynamicTell;  	ctx->ctx.gd_free = gdFreeDynamicCtx;  	return (gdIOCtx *) ctx; }"
"382795_not_vulnerable.c","not_vulnerable","static int trimDynamic (dynamicPtr * dp) { 	/* 2.0.21: we don't reallocate memory we don't own */ 	if (!dp->freeOK) { 		return FALSE; 	} 	return gdReallocDynamic(dp, dp->logicalSize); }"
"383303_not_vulnerable.c","not_vulnerable","int gdImageBrightness(gdImagePtr src, int brightness) { 	int x, y; 	int r,g,b,a; 	int new_pxl, pxl; 	typedef int (*FuncPtr)(gdImagePtr, int, int); 	FuncPtr f; 	f = GET_PIXEL_FUNCTION(src);  	if (src==NULL || (brightness < -255 || brightness>255)) { 		return 0; 	}    	if (brightness==0) { 		return 1; 	}  	for (y=0; y<src->sy; ++y) { 		for (x=0; x<src->sx; ++x) { 			pxl = f (src, x, y); 			 			r = gdImageRed(src, pxl); 			g = gdImageGreen(src, pxl); 			b = gdImageBlue(src, pxl); 			a = gdImageAlpha(src, pxl); 			 			r = r + brightness; 			g = g + brightness; 			b = b + brightness; 			 			r = (r > 255)? 255 : ((r < 0)? 0:r); 			g = (g > 255)? 255 : ((g < 0)? 0:g); 			b = (b > 255)? 255 : ((b < 0)? 0:b);  			new_pxl = gdImageColorAllocateAlpha(src, (int)r, (int)g, (int)b, a); 			if (new_pxl == -1) { 				new_pxl = gdImageColorClosestAlpha(src, (int)r, (int)g, (int)b, a); 			} 			if ((y >= 0) && (y < src->sy)) { 				gdImageSetPixel (src, x, y, new_pxl); 			} 		} 	} 	return 1; }"
"383315_not_vulnerable.c","not_vulnerable","void gdImageSkewY (gdImagePtr dst, gdImagePtr src, int uCol, int iOffset, double dWeight, int clrBack) { 	typedef int (*FuncPtr)(gdImagePtr, int, int); 	int i, iYPos=0, r, g, b, a; 	FuncPtr f; 	int pxlOldLeft, pxlLeft=0, pxlSrc;  	if (src->trueColor) { 		f = gdImageGetTrueColorPixel; 	} else { 		f = gdImageGetPixel; 	}  	for (i = 0; i<iOffset; i++) { 		gdImageSetPixel (dst, uCol, i, clrBack); 	}  	pxlOldLeft = clrBack;  	for (i = 0; i < src->sy; i++) { 		pxlSrc = f (src, uCol, i); 		iYPos = i + iOffset;  		r = (int)(gdImageRed(src,pxlSrc) * dWeight); 		g = (int)(gdImageGreen(src,pxlSrc) * dWeight); 		b = (int)(gdImageBlue(src,pxlSrc) * dWeight); 		a = (int)(gdImageAlpha(src,pxlSrc) * dWeight); 		 		pxlLeft = gdImageColorAllocateAlpha(src, r, g, b, a); 		 		if (pxlLeft == -1) { 			pxlLeft = gdImageColorClosestAlpha(src, r, g, b, a); 		}  	        r = gdImageRed(src,pxlSrc) - (gdImageRed(src,pxlLeft) - gdImageRed(src,pxlOldLeft)); 		g = gdImageGreen(src,pxlSrc) - (gdImageGreen(src,pxlLeft) - gdImageGreen(src,pxlOldLeft)); 		b = gdImageBlue(src,pxlSrc) - (gdImageBlue(src,pxlLeft) - gdImageBlue(src,pxlOldLeft)); 		a = gdImageAlpha(src,pxlSrc) - (gdImageAlpha(src,pxlLeft) - gdImageAlpha(src,pxlOldLeft)); 		 		if (r>255) {         		r = 255;         	}         	 		if (g>255) { 			g = 255; 		}	 	 	        if(b>255) { 	        	b = 255; 	        } 	         		if (a>127) { 			b = 127; 		}  		pxlSrc = gdImageColorAllocateAlpha(dst, r, g, b, a);  		if (pxlSrc == -1) { 			pxlSrc = gdImageColorClosestAlpha(dst, r, g, b, a); 		}  		if ((iYPos >= 0) && (iYPos < dst->sy)) { 			gdImageSetPixel (dst, uCol, iYPos, pxlSrc); 		} 		 		pxlOldLeft = pxlLeft; 	}  	i = iYPos; 	if (i < dst->sy) { 		gdImageSetPixel (dst, uCol, i, pxlLeft); 	}  	i--; 	while (++i < dst->sy) { 		gdImageSetPixel (dst, uCol, i, clrBack); 	} }"
"383316_not_vulnerable.c","not_vulnerable","void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color) { 	int lastBorder; 	/* Seek left */ 	int leftLimit = -1, rightLimit; 	int i;  	if (border < 0) { 		/* Refuse to fill to a non-solid border */ 		return; 	}  	if (x >= im->sx) { 		x = im->sx - 1; 	} 	if (y >= im->sy) { 		y = im->sy - 1; 	}  	for (i = x; i >= 0; i--) { 		if (gdImageGetPixel(im, i, y) == border) { 			break; 		} 		gdImageSetPixel(im, i, y, color); 		leftLimit = i; 	} 	if (leftLimit == -1) { 		return; 	} 	/* Seek right */ 	rightLimit = x; 	for (i = (x + 1); i < im->sx; i++) { 		if (gdImageGetPixel(im, i, y) == border) { 			break; 		} 		gdImageSetPixel(im, i, y, color); 		rightLimit = i; 	} 	/* Look at lines above and below and start paints */ 	/* Above */ 	if (y > 0) { 		lastBorder = 1; 		for (i = leftLimit; i <= rightLimit; i++) { 			int c = gdImageGetPixel(im, i, y - 1); 			if (lastBorder) { 				if ((c != border) && (c != color)) { 					gdImageFillToBorder(im, i, y - 1, border, color); 					lastBorder = 0; 				} 			} else if ((c == border) || (c == color)) { 				lastBorder = 1; 			} 		} 	} 	/* Below */ 	if (y < ((im->sy) - 1)) { 		lastBorder = 1; 		for (i = leftLimit; i <= rightLimit; i++) { 			int c = gdImageGetPixel(im, i, y + 1);  			if (lastBorder) { 				if ((c != border) && (c != color)) { 					gdImageFillToBorder(im, i, y + 1, border, color); 					lastBorder = 0; 				} 			} else if ((c == border) || (c == color)) { 				lastBorder = 1; 			} 		} 	} }"
"383328_not_vulnerable.c","not_vulnerable","gdImagePtr gdImageRotate (gdImagePtr src, double dAngle, int clrBack) { 	gdImagePtr pMidImg; 	gdImagePtr rotatedImg;  	if (src == NULL) { 		return NULL; 	}  	while (dAngle >= 360.0) { 		dAngle -= 360.0; 	}  	while (dAngle < 0) { 		dAngle += 360.0; 	}      	if (dAngle == 90.00) { 		return gdImageRotate90(src); 	} 	if (dAngle == 180.00) { 		return gdImageRotate180(src); 	} 	if(dAngle == 270.00) { 		return gdImageRotate270 ( src); 	}  	if ((dAngle > 45.0) && (dAngle <= 135.0)) { 		pMidImg = gdImageRotate90 (src); 		dAngle -= 90.0; 	} else if ((dAngle > 135.0) && (dAngle <= 225.0)) { 		pMidImg = gdImageRotate180 (src); 		dAngle -= 180.0; 	} else if ((dAngle > 225.0) && (dAngle <= 315.0)) { 		pMidImg = gdImageRotate270 (src); 		dAngle -= 270.0; 	} else { 		return gdImageRotate45 (src, dAngle, clrBack); 	}      	if (pMidImg == NULL) { 		return NULL; 	} 	 	rotatedImg = gdImageRotate45 (pMidImg, dAngle, clrBack); 	gdImageDestroy(pMidImg); 	 	return rotatedImg; }"
"383336_not_vulnerable.c","not_vulnerable","gdImagePtr gdImageRotate180 (gdImagePtr src) { 	int uY, uX; 	int c; 	gdImagePtr dst; 	typedef int (*FuncPtr)(gdImagePtr, int, int); 	FuncPtr f;  	if (src->trueColor) { 		dst = gdImageCreateTrueColor ( src->sx,src->sy); 		f = gdImageGetTrueColorPixel; 	} else { 		dst = gdImageCreate (src->sx, src->sy); 		f = gdImageGetPixel; 	}  	if (dst != NULL) { 		gdImagePaletteCopy (dst, src); 		 		for (uY = 0; uY<src->sy; uY++) { 			for (uX = 0; uX<src->sx; uX++) { 				c = f (src, uX, uY); 				gdImageSetPixel(dst, (dst->sx - uX - 1), (dst->sy - uY - 1), c); 			} 		} 	}  	return dst; }"
"384212_not_vulnerable.c","not_vulnerable","static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info, 			     const struct nlattr * const nla[]) { 	struct netlink_ext_ack *extack = info->extack; 	u8 genmask = nft_genmask_next(info->net); 	u8 family = info->nfmsg->nfgen_family; 	struct nft_chain *chain = NULL; 	struct net *net = info->net; 	struct nft_table *table; 	struct nft_rule *rule; 	struct nft_ctx ctx; 	int err = 0;  	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, 				 NETLINK_CB(skb).portid); 	if (IS_ERR(table)) { 		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]); 		return PTR_ERR(table); 	}  	if (nla[NFTA_RULE_CHAIN]) { 		chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], 					 genmask); 		if (IS_ERR(chain)) { 			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]); 			return PTR_ERR(chain); 		} 		if (nft_chain_is_bound(chain)) 			return -EOPNOTSUPP; 	}  	nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);  	if (chain) { 		if (nla[NFTA_RULE_HANDLE]) { 			rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]); 			if (IS_ERR(rule)) { 				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]); 				return PTR_ERR(rule); 			}  			err = nft_delrule(&ctx, rule); 		} else if (nla[NFTA_RULE_ID]) { 			rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]); 			if (IS_ERR(rule)) { 				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]); 				return PTR_ERR(rule); 			}  			err = nft_delrule(&ctx, rule); 		} else { 			err = nft_delrule_by_chain(&ctx); 		} 	} else { 		list_for_each_entry(chain, &table->chains, list) { 			if (!nft_is_active_next(net, chain)) 				continue;  			ctx.chain = chain; 			err = nft_delrule_by_chain(&ctx); 			if (err < 0) 				break; 		} 	}  	return err; }"
"384757_not_vulnerable.c","not_vulnerable","redraw_for_cursorline(win_T *wp) {     if ((wp->w_p_rnu #ifdef FEAT_SYN_HL 		|| wp->w_p_cul #endif 		) 	    && (wp->w_valid & VALID_CROW) == 0 	    && !pum_visible())     { 	if (wp->w_p_rnu) 	    // win_line() will redraw the number column only. 	    redraw_win_later(wp, VALID); #ifdef FEAT_SYN_HL 	if (wp->w_p_cul) 	{ 	    if (wp->w_redr_type <= VALID && wp->w_last_cursorline != 0) 	    { 		// ""w_last_cursorline"" may be outdated, worst case we redraw 		// too much.  This is optimized for moving the cursor around in 		// the current window. 		redrawWinline(wp, wp->w_last_cursorline); 		redrawWinline(wp, wp->w_cursor.lnum); 	    } 	    else 		redraw_win_later(wp, SOME_VALID); 	} #endif     } }"
"384801_not_vulnerable.c","not_vulnerable","vim_iswordc_buf(int c, buf_T *buf) {     if (c >= 0x100)     { 	if (enc_dbcs != 0) 	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2; 	if (enc_utf8) 	    return utf_class_buf(c, buf) >= 2; 	return FALSE;     }     return (c > 0 && GET_CHARTAB(buf, c) != 0); }"
"384803_not_vulnerable.c","not_vulnerable","unix_expandpath(     garray_T	*gap,     char_u	*path,     int		wildoff,     int		flags,		// EW_* flags     int		didstar)	// expanded ""**"" once already {     char_u	*buf;     char_u	*path_end;     char_u	*p, *s, *e;     int		start_len = gap->ga_len;     char_u	*pat;     regmatch_T	regmatch;     int		starts_with_dot;     int		matches;     int		len;     int		starstar = FALSE;     static int	stardepth = 0;	    // depth for ""**"" expansion      DIR		*dirp;     struct dirent *dp;      // Expanding ""**"" may take a long time, check for CTRL-C.     if (stardepth > 0)     { 	ui_breakcheck(); 	if (got_int) 	    return 0;     }      // make room for file name     buf = alloc(STRLEN(path) + BASENAMELEN + 5);     if (buf == NULL) 	return 0;      /*      * Find the first part in the path name that contains a wildcard.      * When EW_ICASE is set every letter is considered to be a wildcard.      * Copy it into ""buf"", including the preceding characters.      */     p = buf;     s = buf;     e = NULL;     path_end = path;     while (*path_end != NUL)     { 	// May ignore a wildcard that has a backslash before it; it will 	// be removed by rem_backslash() or file_pat_to_reg_pat() below. 	if (path_end >= path + wildoff && rem_backslash(path_end)) 	    *p++ = *path_end++; 	else if (*path_end == '/') 	{ 	    if (e != NULL) 		break; 	    s = p + 1; 	} 	else if (path_end >= path + wildoff 			 && (vim_strchr((char_u *)""*?[{~$"", *path_end) != NULL 			     || (!p_fic && (flags & EW_ICASE) 					  && vim_isalpha(PTR2CHAR(path_end))))) 	    e = p; 	if (has_mbyte) 	{ 	    len = (*mb_ptr2len)(path_end); 	    STRNCPY(p, path_end, len); 	    p += len; 	    path_end += len; 	} 	else 	    *p++ = *path_end++;     }     e = p;     *e = NUL;      // Now we have one wildcard component between ""s"" and ""e"".     // Remove backslashes between ""wildoff"" and the start of the wildcard     // component.     for (p = buf + wildoff; p < s; ++p) 	if (rem_backslash(p)) 	{ 	    STRMOVE(p, p + 1); 	    --e; 	    --s; 	}      // Check for ""**"" between ""s"" and ""e"".     for (p = s; p < e; ++p) 	if (p[0] == '*' && p[1] == '*') 	    starstar = TRUE;      // convert the file pattern to a regexp pattern     starts_with_dot = *s == '.';     pat = file_pat_to_reg_pat(s, e, NULL, FALSE);     if (pat == NULL)     { 	vim_free(buf); 	return 0;     }      // compile the regexp into a program     if (flags & EW_ICASE) 	regmatch.rm_ic = TRUE;		// 'wildignorecase' set     else 	regmatch.rm_ic = p_fic;	// ignore case when 'fileignorecase' is set     if (flags & (EW_NOERROR | EW_NOTWILD)) 	++emsg_silent;     regmatch.regprog = vim_regcomp(pat, RE_MAGIC);     if (flags & (EW_NOERROR | EW_NOTWILD)) 	--emsg_silent;     vim_free(pat);      if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)     { 	vim_free(buf); 	return 0;     }      // If ""**"" is by itself, this is the first time we encounter it and more     // is following then find matches without any directory.     if (!didstar && stardepth < 100 && starstar && e - s == 2 							  && *path_end == '/')     { 	STRCPY(s, path_end + 1); 	++stardepth; 	(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE); 	--stardepth;     }      // open the directory for scanning     *s = NUL;     dirp = opendir(*buf == NUL ? ""."" : (char *)buf);      // Find all matching entries     if (dirp != NULL)     { 	for (;;) 	{ 	    dp = readdir(dirp); 	    if (dp == NULL) 		break; 	    if ((dp->d_name[0] != '.' || starts_with_dot 			|| ((flags & EW_DODOT) 			    && dp->d_name[1] != NUL 			    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL))) 		 && ((regmatch.regprog != NULL && vim_regexec(&regmatch, 					     (char_u *)dp->d_name, (colnr_T)0)) 		   || ((flags & EW_NOTWILD) 		     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0))) 	    { 		STRCPY(s, dp->d_name); 		len = STRLEN(buf);  		if (starstar && stardepth < 100) 		{ 		    // For ""**"" in the pattern first go deeper in the tree to 		    // find matches. 		    STRCPY(buf + len, ""/**""); 		    STRCPY(buf + len + 3, path_end); 		    ++stardepth; 		    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE); 		    --stardepth; 		}  		STRCPY(buf + len, path_end); 		if (mch_has_exp_wildcard(path_end)) // handle more wildcards 		{ 		    // need to expand another component of the path 		    // remove backslashes for the remaining components only 		    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE); 		} 		else 		{ 		    stat_T  sb;  		    // no more wildcards, check if there is a match 		    // remove backslashes for the remaining components only 		    if (*path_end != NUL) 			backslash_halve(buf + len + 1); 		    // add existing file or symbolic link 		    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0 						      : mch_getperm(buf) >= 0) 		    { #ifdef MACOS_CONVERT 			size_t precomp_len = STRLEN(buf)+1; 			char_u *precomp_buf = 			    mac_precompose_path(buf, precomp_len, &precomp_len);  			if (precomp_buf) 			{ 			    mch_memmove(buf, precomp_buf, precomp_len); 			    vim_free(precomp_buf); 			} #endif 			addfile(gap, buf, flags); 		    } 		} 	    } 	}  	closedir(dirp);     }      vim_free(buf);     vim_regfree(regmatch.regprog);      matches = gap->ga_len - start_len;     if (matches > 0) 	qsort(((char_u **)gap->ga_data) + start_len, matches, 						   sizeof(char_u *), pstrcmp);     return matches; }"
"384822_not_vulnerable.c","not_vulnerable","hexhex2nr(char_u *p) {     if (!vim_isxdigit(p[0]) || !vim_isxdigit(p[1])) 	return -1;     return (hex2nr(p[0]) << 4) + hex2nr(p[1]); }"
"384840_not_vulnerable.c","not_vulnerable","str_foldcase(     char_u	*str,     int		orglen,     char_u	*buf,     int		buflen) {     garray_T	ga;     int		i;     int		len = orglen;  #define GA_CHAR(i)  ((char_u *)ga.ga_data)[i] #define GA_PTR(i)   ((char_u *)ga.ga_data + (i)) #define STR_CHAR(i)  (buf == NULL ? GA_CHAR(i) : buf[i]) #define STR_PTR(i)   (buf == NULL ? GA_PTR(i) : buf + (i))      // Copy ""str"" into ""buf"" or allocated memory, unmodified.     if (buf == NULL)     { 	ga_init2(&ga, 1, 10); 	if (ga_grow(&ga, len + 1) == FAIL) 	    return NULL; 	mch_memmove(ga.ga_data, str, (size_t)len); 	ga.ga_len = len;     }     else     { 	if (len >= buflen)	    // Ugly! 	    len = buflen - 1; 	mch_memmove(buf, str, (size_t)len);     }     if (buf == NULL) 	GA_CHAR(len) = NUL;     else 	buf[len] = NUL;      // Make each character lower case.     i = 0;     while (STR_CHAR(i) != NUL)     { 	if (enc_utf8 || (has_mbyte && MB_BYTE2LEN(STR_CHAR(i)) > 1)) 	{ 	    if (enc_utf8) 	    { 		int	c = utf_ptr2char(STR_PTR(i)); 		int	olen = utf_ptr2len(STR_PTR(i)); 		int	lc = utf_tolower(c);  		// Only replace the character when it is not an invalid 		// sequence (ASCII character or more than one byte) and 		// utf_tolower() doesn't return the original character. 		if ((c < 0x80 || olen > 1) && c != lc) 		{ 		    int	    nlen = utf_char2len(lc);  		    // If the byte length changes need to shift the following 		    // characters forward or backward. 		    if (olen != nlen) 		    { 			if (nlen > olen) 			{ 			    if (buf == NULL 				    ? ga_grow(&ga, nlen - olen + 1) == FAIL 				    : len + nlen - olen >= buflen) 			    { 				// out of memory, keep old char 				lc = c; 				nlen = olen; 			    } 			} 			if (olen != nlen) 			{ 			    if (buf == NULL) 			    { 				STRMOVE(GA_PTR(i) + nlen, GA_PTR(i) + olen); 				ga.ga_len += nlen - olen; 			    } 			    else 			    { 				STRMOVE(buf + i + nlen, buf + i + olen); 				len += nlen - olen; 			    } 			} 		    } 		    (void)utf_char2bytes(lc, STR_PTR(i)); 		} 	    } 	    // skip to next multi-byte char 	    i += (*mb_ptr2len)(STR_PTR(i)); 	} 	else 	{ 	    if (buf == NULL) 		GA_CHAR(i) = TOLOWER_LOC(GA_CHAR(i)); 	    else 		buf[i] = TOLOWER_LOC(buf[i]); 	    ++i; 	}     }      if (buf == NULL) 	return (char_u *)ga.ga_data;     return buf; }"
"384908_not_vulnerable.c","not_vulnerable","vim_FullName(     char_u	*fname,     char_u	*buf,     int		len,     int		force)	    // force expansion even when already absolute {     int		retval = OK;     int		url;      *buf = NUL;     if (fname == NULL) 	return FAIL;      url = path_with_url(fname);     if (!url) 	retval = mch_FullName(fname, buf, len, force);     if (url || retval == FAIL)     { 	// something failed; use the file name (truncate when too long) 	vim_strncpy(buf, fname, len - 1);     } #if defined(MSWIN)     slash_adjust(buf); #endif     return retval; }"
"386489_not_vulnerable.cpp","not_vulnerable","void DL_Dxf::writeView(DL_WriterA& dw) {     dw.dxfString(  0, ""TABLE"");     dw.dxfString(  2, ""VIEW"");     if (version==DL_VERSION_2000) {         dw.dxfHex(5, 6);     }     //dw.dxfHex(330, 0);     if (version==DL_VERSION_2000) {         dw.dxfString(100, ""AcDbSymbolTable"");     }     dw.dxfInt( 70, 0);     dw.dxfString(  0, ""ENDTAB""); }"
"386533_not_vulnerable.cpp","not_vulnerable","DL_WriterA* DL_Dxf::out(const char* file, DL_Codes::version version) {     char* f = new char[strlen(file)+1];     strcpy(f, file);     this->version = version;      DL_WriterA* dw = new DL_WriterA(f, version);     if (dw->openFailed()) {         delete dw;         delete[] f;         return NULL;     } else {         delete[] f;         return dw;     } }"
"386553_not_vulnerable.cpp","not_vulnerable","void DL_Dxf::writeAppid(DL_WriterA& dw, const std::string& name) {     if (name.empty()) {         std::cerr << ""DL_Dxf::writeAppid: ""         << ""Application  name must not be empty\n"";         return;     }      std::string n = name;     std::transform(n.begin(), n.end(), n.begin(), ::toupper);      if (n==""ACAD"") {         dw.tableAppidEntry(0x12);     } else {         dw.tableAppidEntry();     }     dw.dxfString(2, name);     dw.dxfInt(70, 0); }"
"386570_not_vulnerable.cpp","not_vulnerable","void DL_Dxf::writeAppDictionary(DL_WriterA& dw) {     dw.dxfString(  0, ""DICTIONARY"");     //dw.handle();     dw.dxfHex(5, appDictionaryHandle);     dw.dxfString(100, ""AcDbDictionary"");     dw.dxfInt(281, 1); }"
"386597_not_vulnerable.cpp","not_vulnerable","void DL_Dxf::writeControlPoint(DL_WriterA& dw,                                const DL_ControlPointData& data) {      dw.dxfReal(10, data.x);     dw.dxfReal(20, data.y);     dw.dxfReal(30, data.z); }"
"386605_not_vulnerable.cpp","not_vulnerable","bool DL_Dxf::handleXRecordData(DL_CreationInterface* creationInterface) {     if (groupCode==105) {         return false;     }      if (groupCode==5) {         creationInterface->addXRecord(groupValue);         return true;     }      if (groupCode==280) {         xRecordValues = true;         return true;     }      if (!xRecordValues) {         return false;     }      // string:     if (groupCode<=9 ||         groupCode==100 || groupCode==102 || groupCode==105 ||         (groupCode>=300 && groupCode<=369) ||         (groupCode>=1000 && groupCode<=1009)) {          creationInterface->addXRecordString(groupCode, groupValue);         return true;     }      // int:     else if ((groupCode>=60 && groupCode<=99) || (groupCode>=160 && groupCode<=179) || (groupCode>=270 && groupCode<=289)) {         creationInterface->addXRecordInt(groupCode, toInt(groupValue));         return true;     }      // bool:     else if (groupCode>=290 && groupCode<=299) {         creationInterface->addXRecordBool(groupCode, toBool(groupValue));         return true;     }      // double:     else if ((groupCode>=10 && groupCode<=59) || (groupCode>=110 && groupCode<=149) || (groupCode>=210 && groupCode<=239)) {         creationInterface->addXRecordReal(groupCode, toReal(groupValue));         return true;     }      return false; }"
"387568_not_vulnerable.c","not_vulnerable","static int call_tlv_handler(struct snd_ctl_file *file, int op_flag, 			    struct snd_kcontrol *kctl, 			    struct snd_ctl_elem_id *id, 			    unsigned int __user *buf, unsigned int size) { 	static const struct { 		int op; 		int perm; 	} pairs[] = { 		{SNDRV_CTL_TLV_OP_READ,  SNDRV_CTL_ELEM_ACCESS_TLV_READ}, 		{SNDRV_CTL_TLV_OP_WRITE, SNDRV_CTL_ELEM_ACCESS_TLV_WRITE}, 		{SNDRV_CTL_TLV_OP_CMD,   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND}, 	}; 	struct snd_kcontrol_volatile *vd = &kctl->vd[snd_ctl_get_ioff(kctl, id)]; 	int i, ret;  	/* Check support of the request for this element. */ 	for (i = 0; i < ARRAY_SIZE(pairs); ++i) { 		if (op_flag == pairs[i].op && (vd->access & pairs[i].perm)) 			break; 	} 	if (i == ARRAY_SIZE(pairs)) 		return -ENXIO;  	if (kctl->tlv.c == NULL) 		return -ENXIO;  	/* Write and command operations are not allowed for locked element. */ 	if (op_flag != SNDRV_CTL_TLV_OP_READ && 	    vd->owner != NULL && vd->owner != file) 		return -EPERM;  	ret = snd_power_ref_and_wait(file->card); 	if (!ret) 		ret = kctl->tlv.c(kctl, op_flag, size, buf); 	snd_power_unref(file->card); 	return ret; }"
"387592_not_vulnerable.c","not_vulnerable","static int snd_ctl_dev_disconnect(struct snd_device *device) { 	struct snd_card *card = device->device_data; 	struct snd_ctl_file *ctl; 	struct snd_ctl_layer_ops *lops; 	unsigned long flags;  	read_lock_irqsave(&card->ctl_files_rwlock, flags); 	list_for_each_entry(ctl, &card->ctl_files, list) { 		wake_up(&ctl->change_sleep); 		snd_kill_fasync(ctl->fasync, SIGIO, POLL_ERR); 	} 	read_unlock_irqrestore(&card->ctl_files_rwlock, flags);  	down_read(&card->controls_rwsem); 	down_read(&snd_ctl_layer_rwsem); 	for (lops = snd_ctl_layer; lops; lops = lops->next) 		lops->ldisconnect(card); 	up_read(&snd_ctl_layer_rwsem); 	up_read(&card->controls_rwsem);  	return snd_unregister_device(&card->ctl_dev); }"
"387840_not_vulnerable.cpp","not_vulnerable","oop InstanceKlass::init_lock() const {   // return the init lock from the mirror   oop lock = java_lang_Class::init_lock(java_mirror());   // Prevent reordering with any access of initialization state   OrderAccess::loadload();   assert((oop)lock != NULL || !is_not_initialized(), // initialized or in_error state          ""only fully initialized state can have a null lock"");   return lock; }"
"387857_not_vulnerable.cpp","not_vulnerable","void InstanceKlass::remove_dependent_nmethod(nmethod* nm, bool delete_immediately) {   dependencies().remove_dependent_nmethod(nm, delete_immediately); }"
"387874_not_vulnerable.cpp","not_vulnerable","Method* InstanceKlass::uncached_lookup_method(const Symbol* name,                                               const Symbol* signature,                                               OverpassLookupMode overpass_mode,                                               PrivateLookupMode private_mode) const {   OverpassLookupMode overpass_local_mode = overpass_mode;   const Klass* klass = this;   while (klass != NULL) {     Method* const method = InstanceKlass::cast(klass)->find_method_impl(name,                                                                         signature,                                                                         overpass_local_mode,                                                                         find_static,                                                                         private_mode);     if (method != NULL) {       return method;     }     klass = klass->super();     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses   }   return NULL; }"
"389684_not_vulnerable.c","not_vulnerable","tv_get_bool_chk(typval_T *varp, int *denote) {     return tv_get_bool_or_number_chk(varp, denote, TRUE); }"
"389689_not_vulnerable.c","not_vulnerable","check_for_opt_buffer_arg(typval_T *args, int idx) {     return (args[idx].v_type == VAR_UNKNOWN 	    || check_for_buffer_arg(args, idx)); }"
"389739_not_vulnerable.c","not_vulnerable","check_for_chan_or_job_arg(typval_T *args, int idx) {     if (args[idx].v_type != VAR_CHANNEL && args[idx].v_type != VAR_JOB)     { 	semsg(_(e_chan_or_job_required_for_argument_nr), idx + 1); 	return FAIL;     }     return OK; }"
"389748_not_vulnerable.c","not_vulnerable","check_for_opt_chan_or_job_arg(typval_T *args, int idx) {     return (args[idx].v_type == VAR_UNKNOWN 	    || check_for_chan_or_job_arg(args, idx) != FAIL); }"
"393503_not_vulnerable.cpp","not_vulnerable","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror) {     SQArray *aparams=_array(stack_get(v,2));     SQInteger nparams=aparams->Size();     v->Push(stack_get(v,1));     for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);     return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR; }"
"393528_not_vulnerable.cpp","not_vulnerable","static SQInteger thread_call(HSQUIRRELVM v) {     SQObjectPtr o = stack_get(v,1);     if(sq_type(o) == OT_THREAD) {         SQInteger nparams = sq_gettop(v);         sq_reservestack(_thread(o), nparams + 3);         _thread(o)->Push(_thread(o)->_roottable);         for(SQInteger i = 2; i<(nparams+1); i++)             sq_move(_thread(o),v,i);         if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {             sq_move(v,_thread(o),-1);             sq_pop(_thread(o),1);             return 1;         }         v->_lasterror = _thread(o)->_lasterror;         return SQ_ERROR;     }     return sq_throwerror(v,_SC(""wrong parameter"")); }"
"393531_not_vulnerable.cpp","not_vulnerable","static SQInteger array_find(HSQUIRRELVM v) {     SQObject &o = stack_get(v,1);     SQObjectPtr &val = stack_get(v,2);     SQArray *a = _array(o);     SQInteger size = a->Size();     SQObjectPtr temp;     for(SQInteger n = 0; n < size; n++) {         bool res = false;         a->Get(n,temp);         if(SQVM::IsEqual(temp,val,res) && res) {             v->Push(n);             return 1;         }     }     return 0; }"
"395083_not_vulnerable.c","not_vulnerable","updateWindow(win_T *wp) {     // return if already busy updating     if (updating_screen) 	return;      update_prepare();  #ifdef FEAT_CLIPBOARD     // When Visual area changed, may have to update selection.     if (clip_star.available && clip_isautosel_star()) 	clip_update_selection(&clip_star);     if (clip_plus.available && clip_isautosel_plus()) 	clip_update_selection(&clip_plus); #endif      win_update(wp);      // When the screen was cleared redraw the tab pages line.     if (redraw_tabline) 	draw_tabline();      if (wp->w_redr_status # ifdef FEAT_CMDL_INFO 	    || p_ru # endif # ifdef FEAT_STL_OPT 	    || *p_stl != NUL || *wp->w_p_stl != NUL # endif 	    ) 	win_redr_status(wp, FALSE);  #ifdef FEAT_PROP_POPUP     // Display popup windows on top of everything.     update_popups(win_update); #endif      update_finish(); }"
"398532_not_vulnerable.c","not_vulnerable","RZ_API const char *rz_bin_dwarf_get_attr_name(ut64 attr_code) { 	if (attr_code < RZ_ARRAY_SIZE(dwarf_attr_encodings)) { 		return dwarf_attr_encodings[attr_code]; 	} 	// the below codes are much sparser, so putting them in an array would require a lot of 	// unused memory 	switch (attr_code) { 	case DW_AT_lo_user: 		return ""DW_AT_lo_user""; 	case DW_AT_MIPS_linkage_name: 		return ""DW_AT_MIPS_linkage_name""; 	case DW_AT_GNU_call_site_value: 		return ""DW_AT_GNU_call_site_value""; 	case DW_AT_GNU_call_site_data_value: 		return ""DW_AT_GNU_call_site_data_value""; 	case DW_AT_GNU_call_site_target: 		return ""DW_AT_GNU_call_site_target""; 	case DW_AT_GNU_call_site_target_clobbered: 		return ""DW_AT_GNU_call_site_target_clobbered""; 	case DW_AT_GNU_tail_call: 		return ""DW_AT_GNU_tail_call""; 	case DW_AT_GNU_all_tail_call_sites: 		return ""DW_AT_GNU_all_tail_call_sites""; 	case DW_AT_GNU_all_call_sites: 		return ""DW_AT_GNU_all_call_sites""; 	case DW_AT_GNU_all_source_call_sites: 		return ""DW_AT_GNU_all_source_call_sites""; 	case DW_AT_GNU_macros: 		return ""DW_AT_GNU_macros""; 	case DW_AT_GNU_deleted: 		return ""DW_AT_GNU_deleted""; 	case DW_AT_GNU_dwo_name: 		return ""DW_AT_GNU_dwo_name""; 	case DW_AT_GNU_dwo_id: 		return ""DW_AT_GNU_dwo_id""; 	case DW_AT_GNU_ranges_base: 		return ""DW_AT_GNU_ranges_base""; 	case DW_AT_GNU_addr_base: 		return ""DW_AT_GNU_addr_base""; 	case DW_AT_GNU_pubnames: 		return ""DW_AT_GNU_pubnames""; 	case DW_AT_GNU_pubtypes: 		return ""DW_AT_GNU_pubtypes""; 	case DW_AT_hi_user: 		return ""DW_AT_hi_user""; 	default: 		return NULL; 	} }"
"400713_not_vulnerable.c","not_vulnerable","static inline void pipe_truncate(struct iov_iter *i) { 	struct pipe_inode_info *pipe = i->pipe; 	unsigned int p_tail = pipe->tail; 	unsigned int p_head = pipe->head; 	unsigned int p_mask = pipe->ring_size - 1;  	if (!pipe_empty(p_head, p_tail)) { 		struct pipe_buffer *buf; 		unsigned int i_head = i->head; 		size_t off = i->iov_offset;  		if (off) { 			buf = &pipe->bufs[i_head & p_mask]; 			buf->len = off - buf->offset; 			i_head++; 		} 		while (p_head != i_head) { 			p_head--; 			pipe_buf_release(pipe, &pipe->bufs[p_head & p_mask]); 		}  		pipe->head = p_head; 	} }"
"400769_not_vulnerable.c","not_vulnerable","size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes, 			 struct iov_iter *i) { 	if (unlikely(!page_copy_sane(page, offset, bytes))) 		return 0; 	if (likely(iter_is_iovec(i))) 		return copy_page_from_iter_iovec(page, offset, bytes, i); 	if (iov_iter_is_bvec(i) || iov_iter_is_kvec(i) || iov_iter_is_xarray(i)) { 		void *kaddr = kmap_local_page(page); 		size_t wanted = _copy_from_iter(kaddr + offset, bytes, i); 		kunmap_local(kaddr); 		return wanted; 	} 	WARN_ON(1); 	return 0; }"
"400774_not_vulnerable.c","not_vulnerable","static struct page **get_pages_array(size_t n) { 	return kvmalloc_array(n, sizeof(struct page *), GFP_KERNEL); }"
"401530_not_vulnerable.c","not_vulnerable","int timer_reduce(struct timer_list *timer, unsigned long expires) { 	return __mod_timer(timer, expires, MOD_TIMER_REDUCE); }"
"401531_not_vulnerable.c","not_vulnerable","int timers_dead_cpu(unsigned int cpu) { 	struct timer_base *old_base; 	struct timer_base *new_base; 	int b, i;  	BUG_ON(cpu_online(cpu));  	for (b = 0; b < NR_BASES; b++) { 		old_base = per_cpu_ptr(&timer_bases[b], cpu); 		new_base = get_cpu_ptr(&timer_bases[b]); 		/* 		 * The caller is globally serialized and nobody else 		 * takes two locks at once, deadlock is not possible. 		 */ 		raw_spin_lock_irq(&new_base->lock); 		raw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);  		/* 		 * The current CPUs base clock might be stale. Update it 		 * before moving the timers over. 		 */ 		forward_timer_base(new_base);  		BUG_ON(old_base->running_timer);  		for (i = 0; i < WHEEL_SIZE; i++) 			migrate_timer_list(new_base, old_base->vectors + i);  		raw_spin_unlock(&old_base->lock); 		raw_spin_unlock_irq(&new_base->lock); 		put_cpu_ptr(&timer_bases); 	} 	return 0; }"
"401537_not_vulnerable.c","not_vulnerable","static int collect_expired_timers(struct timer_base *base, 				  struct hlist_head *heads) { 	unsigned long now = READ_ONCE(jiffies);  	/* 	 * NOHZ optimization. After a long idle sleep we need to forward the 	 * base to current jiffies. Avoid a loop by searching the bitfield for 	 * the next expiring timer. 	 */ 	if ((long)(now - base->clk) > 2) { 		unsigned long next = __next_timer_interrupt(base);  		/* 		 * If the next timer is ahead of time forward to current 		 * jiffies, otherwise forward to the next expiry time: 		 */ 		if (time_after(next, now)) { 			/* 			 * The call site will increment base->clk and then 			 * terminate the expiry loop immediately. 			 */ 			base->clk = now; 			return 0; 		} 		base->clk = next; 	} 	return __collect_expired_timers(base, heads); }"
"402603_not_vulnerable.c","not_vulnerable","handle_get_cmd_version(context *ctx, struct pollfd *pollfd, socklen_t size) { 	struct msghdr msg; 	struct iovec iov; 	ssize_t n;  	int rc = cms_context_alloc(&ctx->cms); 	if (rc < 0) { 		send_response(ctx, ctx->backup_cms, pollfd, rc); 		return; 	}  	steal_from_cms(ctx->backup_cms, ctx->cms);  	char *buffer = malloc(size); 	if (!buffer) { 		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR, 			""unable to allocate memory: %m""); 		exit(1); 	}  	memset(&msg, '\0', sizeof(msg));  	iov.iov_base = buffer; 	iov.iov_len = size; 	msg.msg_iov = &iov; 	msg.msg_iovlen = 1;  	n = recvmsg(pollfd->fd, &msg, MSG_WAITALL);  	int32_t version = -1; 	uint32_t command;  	if (n < (long long)sizeof(command)) { 		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR, 			""unlock-token: invalid data""); 		ctx->cms->log(ctx->cms, ctx->priority|LOG_ERR, 			""possible exploit attempt. closing.""); 		close(pollfd->fd); 		return; 	}  	memcpy(&command, buffer, sizeof (command)); 	ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE, 			""searching for command %d"", command);  	for (int i = 0; cmd_table[i].cmd != CMD_LIST_END; i++) { 		if (cmd_table[i].cmd == command) { 			ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE, 					""cmd-version: found command \""%s\"" "" 					""version %d"", 					cmd_table[i].name, 					cmd_table[i].version); 			version = cmd_table[i].version; 			break; 		} 	}  	if (version == -1) { 		ctx->cms->log(ctx->cms, ctx->priority|LOG_NOTICE, 				""cmd-version: could not find command %d"", 				command); 	} 	send_response(ctx, ctx->cms, pollfd, version);  	free(buffer);  	hide_stolen_goods_from_cms(ctx->cms, ctx->backup_cms); 	cms_context_fini(ctx->cms); }"
"402635_not_vulnerable.c","not_vulnerable","write_pid_file(int pid) { 	int fd = open(PIDFILE, O_WRONLY|O_CREAT|O_TRUNC, 0644); 	if (fd < 0) { err: 		fprintf(stderr, ""couldn't open pidfile: %m\n""); 		exit(1); 	} 	char *pidstr = NULL; 	int rc = asprintf(&pidstr, ""%d\n"", pid); 	if (rc < 0) 		goto err;  	rc = write(fd, pidstr, strlen(pidstr)+1); 	if (rc < 0) 		goto err;  	free(pidstr); 	close(fd); }"
"404700_not_vulnerable.c","not_vulnerable","int __close_fd_get_file(unsigned int fd, struct file **res) { 	struct files_struct *files = current->files; 	struct file *file; 	struct fdtable *fdt;  	fdt = files_fdtable(files); 	if (fd >= fdt->max_fds) 		goto out_err; 	file = fdt->fd[fd]; 	if (!file) 		goto out_err; 	rcu_assign_pointer(fdt->fd[fd], NULL); 	__put_unused_fd(files, fd); 	get_file(file); 	*res = file; 	return 0; out_err: 	*res = NULL; 	return -ENOENT; }"
"404726_not_vulnerable.c","not_vulnerable","int close_fd(unsigned fd) { 	struct files_struct *files = current->files; 	struct file *file;  	file = pick_file(files, fd); 	if (IS_ERR(file)) 		return -EBADF;  	return filp_close(file, files); }"
"404745_not_vulnerable.cpp","not_vulnerable","static inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt) { 	__set_bit(fd, fdt->close_on_exec); }"
"405333_not_vulnerable.c","not_vulnerable","static int xfrm_expand_policies(const struct flowi *fl, u16 family, 				struct xfrm_policy **pols, 				int *num_pols, int *num_xfrms) { 	int i;  	if (*num_pols == 0 || !pols[0]) { 		*num_pols = 0; 		*num_xfrms = 0; 		return 0; 	} 	if (IS_ERR(pols[0])) { 		*num_pols = 0; 		return PTR_ERR(pols[0]); 	}  	*num_xfrms = pols[0]->xfrm_nr;  #ifdef CONFIG_XFRM_SUB_POLICY 	if (pols[0]->action == XFRM_POLICY_ALLOW && 	    pols[0]->type != XFRM_POLICY_TYPE_MAIN) { 		pols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]), 						    XFRM_POLICY_TYPE_MAIN, 						    fl, family, 						    XFRM_POLICY_OUT, 						    pols[0]->if_id); 		if (pols[1]) { 			if (IS_ERR(pols[1])) { 				xfrm_pols_put(pols, *num_pols); 				*num_pols = 0; 				return PTR_ERR(pols[1]); 			} 			(*num_pols)++; 			(*num_xfrms) += pols[1]->xfrm_nr; 		} 	} #endif 	for (i = 0; i < *num_pols; i++) { 		if (pols[i]->action != XFRM_POLICY_ALLOW) { 			*num_xfrms = -1; 			break; 		} 	}  	return 0;  }"
"405373_not_vulnerable.c","not_vulnerable","static const void *xfrm_get_dst_nexthop(const struct dst_entry *dst, 					const void *daddr) { 	while (dst->xfrm) { 		const struct xfrm_state *xfrm = dst->xfrm;  		dst = xfrm_dst_child(dst);  		if (xfrm->props.mode == XFRM_MODE_TRANSPORT) 			continue; 		if (xfrm->type->flags & XFRM_TYPE_REMOTE_COADDR) 			daddr = xfrm->coaddr; 		else if (!(xfrm->type->flags & XFRM_TYPE_LOCAL_COADDR)) 			daddr = &xfrm->id.daddr; 	} 	return daddr; }"
"405382_not_vulnerable.c","not_vulnerable","static void xfrm_bydst_resize(struct net *net, int dir) { 	unsigned int hmask = net->xfrm.policy_bydst[dir].hmask; 	unsigned int nhashmask = xfrm_new_hash_mask(hmask); 	unsigned int nsize = (nhashmask + 1) * sizeof(struct hlist_head); 	struct hlist_head *ndst = xfrm_hash_alloc(nsize); 	struct hlist_head *odst; 	int i;  	if (!ndst) 		return;  	spin_lock_bh(&net->xfrm.xfrm_policy_lock); 	write_seqcount_begin(&net->xfrm.xfrm_policy_hash_generation);  	odst = rcu_dereference_protected(net->xfrm.policy_bydst[dir].table, 				lockdep_is_held(&net->xfrm.xfrm_policy_lock));  	for (i = hmask; i >= 0; i--) 		xfrm_dst_hash_transfer(net, odst + i, ndst, nhashmask, dir);  	rcu_assign_pointer(net->xfrm.policy_bydst[dir].table, ndst); 	net->xfrm.policy_bydst[dir].hmask = nhashmask;  	write_seqcount_end(&net->xfrm.xfrm_policy_hash_generation); 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);  	synchronize_rcu();  	xfrm_hash_free(odst, (hmask + 1) * sizeof(struct hlist_head)); }"
"409411_not_vulnerable.c","not_vulnerable","term_append_lines(int line_count) {     OUT_STR(tgoto((char *)T_CAL, 0, line_count)); }"
"409422_not_vulnerable.c","not_vulnerable","term_get_bg_color(char_u *r, char_u *g, char_u *b) {     if (rbg_status.tr_progress == STATUS_GOT)     { 	*r = bg_r; 	*g = bg_g; 	*b = bg_b;     } }"
"409466_not_vulnerable.c","not_vulnerable","get_termcode(int i) {     if (i >= tc_len) 	return NULL;     return &termcodes[i].name[0]; }"
"409488_not_vulnerable.c","not_vulnerable","add_termcode(char_u *name, char_u *string, int flags) {     struct termcode *new_tc;     int		    i, j;     char_u	    *s;     int		    len;      if (string == NULL || *string == NUL)     { 	del_termcode(name); 	return;     }  #if defined(MSWIN) && !defined(FEAT_GUI)     s = vim_strnsave(string, STRLEN(string) + 1); #else # ifdef VIMDLL     if (!gui.in_use) 	s = vim_strnsave(string, STRLEN(string) + 1);     else # endif 	s = vim_strsave(string); #endif     if (s == NULL) 	return;      // Change leading <Esc>[ to CSI, change <Esc>O to <M-O>.     if (flags != 0 && flags != ATC_FROM_TERM && term_7to8bit(string) != 0)     { 	STRMOVE(s, s + 1); 	s[0] = term_7to8bit(string);     }  #if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL)) # ifdef VIMDLL     if (!gui.in_use) # endif     { 	if (s[0] == K_NUL) 	{ 	    STRMOVE(s + 1, s); 	    s[1] = 3; 	}     } #endif      len = (int)STRLEN(s);      need_gather = TRUE;		// need to fill termleader[]      /*      * need to make space for more entries      */     if (tc_len == tc_max_len)     { 	tc_max_len += 20; 	new_tc = ALLOC_MULT(struct termcode, tc_max_len); 	if (new_tc == NULL) 	{ 	    tc_max_len -= 20; 	    vim_free(s); 	    return; 	} 	for (i = 0; i < tc_len; ++i) 	    new_tc[i] = termcodes[i]; 	vim_free(termcodes); 	termcodes = new_tc;     }      /*      * Look for existing entry with the same name, it is replaced.      * Look for an existing entry that is alphabetical higher, the new entry      * is inserted in front of it.      */     for (i = 0; i < tc_len; ++i)     { 	if (termcodes[i].name[0] < name[0]) 	    continue; 	if (termcodes[i].name[0] == name[0]) 	{ 	    if (termcodes[i].name[1] < name[1]) 		continue; 	    /* 	     * Exact match: May replace old code. 	     */ 	    if (termcodes[i].name[1] == name[1]) 	    { 		if (flags == ATC_FROM_TERM && (j = termcode_star( 				    termcodes[i].code, termcodes[i].len)) > 0) 		{ 		    // Don't replace ESC[123;*X or ESC O*X with another when 		    // invoked from got_code_from_term(). 		    if (len == termcodes[i].len - j 			    && STRNCMP(s, termcodes[i].code, len - 1) == 0 			    && s[len - 1] 				   == termcodes[i].code[termcodes[i].len - 1]) 		    { 			// They are equal but for the "";*"": don't add it. 			vim_free(s); 			return; 		    } 		} 		else 		{ 		    // Replace old code. 		    vim_free(termcodes[i].code); 		    --tc_len; 		    break; 		} 	    } 	} 	/* 	 * Found alphabetical larger entry, move rest to insert new entry 	 */ 	for (j = tc_len; j > i; --j) 	    termcodes[j] = termcodes[j - 1]; 	break;     }      termcodes[i].name[0] = name[0];     termcodes[i].name[1] = name[1];     termcodes[i].code = s;     termcodes[i].len = len;      // For xterm we recognize special codes like ""ESC[42;*X"" and ""ESC O*X"" that     // accept modifiers.     termcodes[i].modlen = 0;     j = termcode_star(s, len);     if (j > 0)     { 	termcodes[i].modlen = len - 1 - j; 	// For ""CSI[@;X"" the ""@"" is not included in ""modlen"". 	if (termcodes[i].code[termcodes[i].modlen - 1] == '@') 	    --termcodes[i].modlen;     }     ++tc_len; }"
"409523_not_vulnerable.c","not_vulnerable","check_shellsize(void) {     if (Rows < min_rows())	// need room for one window and command line 	Rows = min_rows();     limit_screen_size();      // make sure these values are not invalid     if (cmdline_row >= Rows) 	cmdline_row = Rows - 1;     if (msg_row >= Rows) 	msg_row = Rows - 1; }"
"411892_not_vulnerable.c","not_vulnerable","extrainfo_parse_entry_from_string(const char *s, const char *end,                            int cache_copy, struct digest_ri_map_t *routermap) {   extrainfo_t *extrainfo = NULL;   char digest[128];   smartlist_t *tokens = NULL;   directory_token_t *tok;   crypto_pk_env_t *key = NULL;   routerinfo_t *router = NULL;   memarea_t *area = NULL;   const char *s_dup = s;    if (!end) {     end = s + strlen(s);   }    /* point 'end' to a point immediately after the final newline. */   while (end > s+2 && *(end-1) == '\n' && *(end-2) == '\n')     --end;    if (router_get_extrainfo_hash(s, digest) < 0) {     log_warn(LD_DIR, ""Couldn't compute router hash."");     goto err;   }   tokens = smartlist_create();   area = memarea_new();   if (tokenize_string(area,s,end,tokens,extrainfo_token_table,0)) {     log_warn(LD_DIR, ""Error tokenizing extra-info document."");     goto err;   }    if (smartlist_len(tokens) < 2) {     log_warn(LD_DIR, ""Impossibly short extra-info document."");     goto err;   }    tok = smartlist_get(tokens,0);   if (tok->tp != K_EXTRA_INFO) {     log_warn(LD_DIR,""Entry does not start with \""extra-info\"""");     goto err;   }    extrainfo = tor_malloc_zero(sizeof(extrainfo_t));   extrainfo->cache_info.is_extrainfo = 1;   if (cache_copy)     extrainfo->cache_info.signed_descriptor_body = tor_strndup(s, end-s);   extrainfo->cache_info.signed_descriptor_len = end-s;   memcpy(extrainfo->cache_info.signed_descriptor_digest, digest, DIGEST_LEN);    tor_assert(tok->n_args >= 2);   if (!is_legal_nickname(tok->args[0])) {     log_warn(LD_DIR,""Bad nickname %s on \""extra-info\"""",escaped(tok->args[0]));     goto err;   }   strlcpy(extrainfo->nickname, tok->args[0], sizeof(extrainfo->nickname));   if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||       base16_decode(extrainfo->cache_info.identity_digest, DIGEST_LEN,                     tok->args[1], HEX_DIGEST_LEN)) {     log_warn(LD_DIR,""Invalid fingerprint %s on \""extra-info\"""",              escaped(tok->args[1]));     goto err;   }    tok = find_by_keyword(tokens, K_PUBLISHED);   if (parse_iso_time(tok->args[0], &extrainfo->cache_info.published_on)) {     log_warn(LD_DIR,""Invalid published time %s on \""extra-info\"""",              escaped(tok->args[0]));     goto err;   }    if (routermap &&       (router = digestmap_get((digestmap_t*)routermap,                               extrainfo->cache_info.identity_digest))) {     key = router->identity_pkey;   }    tok = find_by_keyword(tokens, K_ROUTER_SIGNATURE);   if (strcmp(tok->object_type, ""SIGNATURE"") ||       tok->object_size < 128 || tok->object_size > 512) {     log_warn(LD_DIR, ""Bad object type or length on extra-info signature"");     goto err;   }    if (key) {     note_crypto_pk_op(VERIFY_RTR);     if (check_signature_token(digest, DIGEST_LEN, tok, key, 0,                               ""extra-info"") < 0)       goto err;      if (router)       extrainfo->cache_info.send_unencrypted =         router->cache_info.send_unencrypted;   } else {     extrainfo->pending_sig = tor_memdup(tok->object_body,                                         tok->object_size);     extrainfo->pending_sig_len = tok->object_size;   }    goto done;  err:   dump_desc(s_dup, ""extra-info descriptor"");   extrainfo_free(extrainfo);   extrainfo = NULL;  done:   if (tokens) {     SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));     smartlist_free(tokens);   }   if (area) {     DUMP_AREA(area, ""extrainfo"");     memarea_drop_all(area);   }   return extrainfo; }"
"412127_not_vulnerable.c","not_vulnerable","dnsc_shared_secrets_compfunc(void *m1, void *m2) {     return sodium_memcmp(m1, m2, DNSCRYPT_SHARED_SECRET_KEY_LENGTH); }"
"413590_not_vulnerable.c","not_vulnerable","static int cmpfcncc(const void *_a, const void *_b) { 	RAnalFunction *a = (RAnalFunction *)_a; 	RAnalFunction *b = (RAnalFunction *)_b; 	ut64 as = r_anal_function_complexity (a); 	ut64 bs = r_anal_function_complexity (b); 	return (as > bs)? 1: (as < bs)? -1: 0; }"
"413638_not_vulnerable.c","not_vulnerable","static ut64 RAnalRef_val(const void *_ref1) { 	const RAnalRef* ref1 = _ref1; 	return ref1->addr; }"
"413672_not_vulnerable.cpp","not_vulnerable","static bool found_xref(RCore *core, ut64 at, ut64 xref_to, RAnalRefType type, PJ *pj, int rad, bool cfg_debug, bool cfg_anal_strings) { 	// Validate the reference. If virtual addressing is enabled, we 	// allow only references to virtual addresses in order to reduce 	// the number of false positives. In debugger mode, the reference 	// must point to a mapped memory region. 	if (type == R_ANAL_REF_TYPE_NULL) { 		return false; 	} 	if (cfg_debug) { 		if (!r_debug_map_get (core->dbg, xref_to)) { 			return false; 		} 	} else if (core->io->va) { 		if (!r_io_is_valid_offset (core->io, xref_to, 0)) { 			return false; 		} 	} 	if (!rad) { 		if (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) { 			int len = 0; 			char *str_string = is_string_at (core, xref_to, &len); 			if (str_string) { 				r_name_filter (str_string, -1); 				char *str_flagname = r_str_newf (""str.%s"", str_string); 				r_flag_space_push (core->flags, R_FLAGS_FS_STRINGS); 				(void)r_flag_set (core->flags, str_flagname, xref_to, 1); 				r_flag_space_pop (core->flags); 				free (str_flagname); 				if (len > 0) { 					r_meta_set (core->anal, R_META_TYPE_STRING, xref_to, 								len, (const char *) str_string); 				} 				free (str_string); 			} 		} 		// Add to SDB 		if (xref_to) { 			r_anal_xrefs_set (core->anal, at, xref_to, type); 		} 	} else if (rad == 'j') { 		r_strf_var (key, 32, ""0x%""PFMT64x, xref_to); 		r_strf_var (value, 32, ""0x%""PFMT64x, at); 		pj_ks (pj, key, value); 	} else { 		int len = 0; 		// Display in radare commands format 		char *cmd; 		switch (type) { 		case R_ANAL_REF_TYPE_CODE: cmd = ""axc""; break; 		case R_ANAL_REF_TYPE_CALL: cmd = ""axC""; break; 		case R_ANAL_REF_TYPE_DATA: cmd = ""axd""; break; 		default: cmd = ""ax""; break; 		} 		r_cons_printf (""%s 0x%08""PFMT64x"" 0x%08""PFMT64x""\n"", cmd, xref_to, at); 		if (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) { 			char *str_flagname = is_string_at (core, xref_to, &len); 			if (str_flagname) { 				ut64 str_addr = xref_to; 				r_name_filter (str_flagname, -1); 				r_cons_printf (""f str.%s=0x%""PFMT64x""\n"", str_flagname, str_addr); 				r_cons_printf (""Cs %d @ 0x%""PFMT64x""\n"", len, str_addr); 				free (str_flagname); 			} 		} 	} 	return true; }"
"413686_not_vulnerable.c","not_vulnerable","void hint_node_free(RBNode *node, void *user) { 	free (container_of (node, HintNode, rb)); }"
"413698_not_vulnerable.c","not_vulnerable","static bool isValidSymbol(RBinSymbol *symbol) { 	if (symbol && symbol->type) { 		const char *type = symbol->type; 		return (symbol->paddr != UT64_MAX) && (!strcmp (type, R_BIN_TYPE_FUNC_STR) || !strcmp (type, R_BIN_TYPE_HIOS_STR) || !strcmp (type, R_BIN_TYPE_LOOS_STR) || !strcmp (type, R_BIN_TYPE_METH_STR) || !strcmp (type , R_BIN_TYPE_STATIC_STR)); 	} 	return false; }"
"418777_not_vulnerable.c","not_vulnerable","mouse_set_hor_scroll_step(long step) {     mouse_hor_step = step; }"
"424533_not_vulnerable.c","not_vulnerable","static UINT video_VideoData(VideoClientContext* context, TSMM_VIDEO_DATA* data) { 	VideoClientContextPriv* priv = context->priv; 	PresentationContext* presentation; 	int status;  	presentation = priv->currentPresentation; 	if (!presentation) 	{ 		WLog_ERR(TAG, ""no current presentation""); 		return CHANNEL_RC_OK; 	}  	if (presentation->PresentationId != data->PresentationId) 	{ 		WLog_ERR(TAG, ""current presentation id=%d doesn't match data id=%d"", 		         presentation->PresentationId, data->PresentationId); 		return CHANNEL_RC_OK; 	}  	if (!Stream_EnsureRemainingCapacity(presentation->currentSample, data->cbSample)) 	{ 		WLog_ERR(TAG, ""unable to expand the current packet""); 		return CHANNEL_RC_NO_MEMORY; 	}  	Stream_Write(presentation->currentSample, data->pSample, data->cbSample);  	if (data->CurrentPacketIndex == data->PacketsInSample) 	{ 		H264_CONTEXT* h264 = presentation->h264; 		UINT64 startTime = GetTickCount64(), timeAfterH264; 		MAPPED_GEOMETRY* geom = presentation->geometry;  		Stream_SealLength(presentation->currentSample); 		Stream_SetPosition(presentation->currentSample, 0);  		status = h264->subsystem->Decompress(h264, Stream_Pointer(presentation->currentSample), 		                                     Stream_Length(presentation->currentSample)); 		if (status == 0) 			return CHANNEL_RC_OK;  		if (status < 0) 			return CHANNEL_RC_OK;  		timeAfterH264 = GetTickCount64(); 		if (data->SampleNumber == 1) 		{ 			presentation->lastPublishTime = startTime; 		}  		presentation->lastPublishTime += (data->hnsDuration / 10000); 		if (presentation->lastPublishTime <= timeAfterH264 + 10) 		{ 			int dropped = 0;  			/* if the frame is to be published in less than 10 ms, let's consider it's now */ 			yuv_to_rgb(presentation, presentation->surfaceData);  			context->showSurface(context, presentation->surface);  			priv->publishedFrames++;  			/* cleanup previously scheduled frames */ 			EnterCriticalSection(&priv->framesLock); 			while (Queue_Count(priv->frames) > 0) 			{ 				VideoFrame* frame = Queue_Dequeue(priv->frames); 				if (frame) 				{ 					priv->droppedFrames++; 					VideoFrame_free(&frame); 					dropped++; 				} 			} 			LeaveCriticalSection(&priv->framesLock);  			if (dropped) 				WLog_DBG(TAG, ""showing frame (%d dropped)"", dropped); 		} 		else 		{ 			BOOL enqueueResult; 			VideoFrame* frame = calloc(1, sizeof(*frame)); 			if (!frame) 			{ 				WLog_ERR(TAG, ""unable to create frame""); 				return CHANNEL_RC_NO_MEMORY; 			} 			mappedGeometryRef(geom);  			frame->presentation = presentation; 			frame->publishTime = presentation->lastPublishTime; 			frame->geometry = geom; 			frame->w = presentation->SourceWidth; 			frame->h = presentation->SourceHeight;  			frame->surfaceData = BufferPool_Take(priv->surfacePool, frame->w * frame->h * 4); 			if (!frame->surfaceData) 			{ 				WLog_ERR(TAG, ""unable to allocate frame data""); 				mappedGeometryUnref(geom); 				free(frame); 				return CHANNEL_RC_NO_MEMORY; 			}  			if (!yuv_to_rgb(presentation, frame->surfaceData)) 			{ 				WLog_ERR(TAG, ""error during YUV->RGB conversion""); 				BufferPool_Return(priv->surfacePool, frame->surfaceData); 				mappedGeometryUnref(geom); 				free(frame); 				return CHANNEL_RC_NO_MEMORY; 			}  			InterlockedIncrement(&presentation->refCounter);  			EnterCriticalSection(&priv->framesLock); 			enqueueResult = Queue_Enqueue(priv->frames, frame); 			LeaveCriticalSection(&priv->framesLock);  			if (!enqueueResult) 			{ 				WLog_ERR(TAG, ""unable to enqueue frame""); 				VideoFrame_free(&frame); 				return CHANNEL_RC_NO_MEMORY; 			}  			WLog_DBG(TAG, ""scheduling frame in %"" PRIu32 "" ms"", (frame->publishTime - startTime)); 		} 	}  	return CHANNEL_RC_OK; }"
"424892_not_vulnerable.c","not_vulnerable","static int iwl_pcie_apm_init(struct iwl_trans *trans) { 	int ret;  	IWL_DEBUG_INFO(trans, ""Init card's basic functions\n"");  	/* 	 * Use ""set_bit"" below rather than ""write"", to preserve any hardware 	 * bits already set by default after reset. 	 */  	/* Disable L0S exit timer (platform NMI Work/Around) */ 	if (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_8000) 		iwl_set_bit(trans, CSR_GIO_CHICKEN_BITS, 			    CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);  	/* 	 * Disable L0s without affecting L1; 	 *  don't wait for ICH L0s (ICH bug W/A) 	 */ 	iwl_set_bit(trans, CSR_GIO_CHICKEN_BITS, 		    CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);  	/* Set FH wait threshold to maximum (HW error during stress W/A) */ 	iwl_set_bit(trans, CSR_DBG_HPET_MEM_REG, CSR_DBG_HPET_MEM_REG_VAL);  	/* 	 * Enable HAP INTA (interrupt from management bus) to 	 * wake device's PCI Express link L1a -> L0s 	 */ 	iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG, 		    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);  	iwl_pcie_apm_config(trans);  	/* Configure analog phase-lock-loop before activating to D0A */ 	if (trans->trans_cfg->base_params->pll_cfg) 		iwl_set_bit(trans, CSR_ANA_PLL_CFG, CSR50_ANA_PLL_CFG_VAL);  	ret = iwl_finish_nic_init(trans, trans->trans_cfg); 	if (ret) 		return ret;  	if (trans->cfg->host_interrupt_operation_mode) { 		/* 		 * This is a bit of an abuse - This is needed for 7260 / 3160 		 * only check host_interrupt_operation_mode even if this is 		 * not related to host_interrupt_operation_mode. 		 * 		 * Enable the oscillator to count wake up time for L1 exit. This 		 * consumes slightly more power (100uA) - but allows to be sure 		 * that we wake up from L1 on time. 		 * 		 * This looks weird: read twice the same register, discard the 		 * value, set a bit, and yet again, read that same register 		 * just to discard the value. But that's the way the hardware 		 * seems to like it. 		 */ 		iwl_read_prph(trans, OSC_CLK); 		iwl_read_prph(trans, OSC_CLK); 		iwl_set_bits_prph(trans, OSC_CLK, OSC_CLK_FORCE_CONTROL); 		iwl_read_prph(trans, OSC_CLK); 		iwl_read_prph(trans, OSC_CLK); 	}  	/* 	 * Enable DMA clock and wait for it to stabilize. 	 * 	 * Write to ""CLK_EN_REG""; ""1"" bits enable clocks, while ""0"" 	 * bits do not disable clocks.  This preserves any hardware 	 * bits already set by default in ""CLK_CTRL_REG"" after reset. 	 */ 	if (!trans->cfg->apmg_not_supported) { 		iwl_write_prph(trans, APMG_CLK_EN_REG, 			       APMG_CLK_VAL_DMA_CLK_RQT); 		udelay(20);  		/* Disable L1-Active */ 		iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG, 				  APMG_PCIDEV_STT_VAL_L1_ACT_DIS);  		/* Clear the interrupt in APMG if the NIC is in RFKILL */ 		iwl_write_prph(trans, APMG_RTC_INT_STT_REG, 			       APMG_RTC_INT_STT_RFKILL); 	}  	set_bit(STATUS_DEVICE_ENABLED, &trans->status);  	return 0; }"
"424898_not_vulnerable.c","not_vulnerable","static u32 iwl_trans_pcie_get_cmdlen(struct iwl_trans *trans, void *tfd) { 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans); 	u32 cmdlen = 0; 	int i;  	for (i = 0; i < trans_pcie->max_tbs; i++) 		cmdlen += iwl_pcie_tfd_tb_get_len(trans, tfd, i);  	return cmdlen; }"
"424906_not_vulnerable.c","not_vulnerable","static void iwl_pcie_apm_stop(struct iwl_trans *trans, bool op_mode_leave) { 	IWL_DEBUG_INFO(trans, ""Stop card, put in low power state\n"");  	if (op_mode_leave) { 		if (!test_bit(STATUS_DEVICE_ENABLED, &trans->status)) 			iwl_pcie_apm_init(trans);  		/* inform ME that we are leaving */ 		if (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) 			iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG, 					  APMG_PCIDEV_STT_VAL_WAKE_ME); 		else if (trans->trans_cfg->device_family >= 			 IWL_DEVICE_FAMILY_8000) { 			iwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG, 				    CSR_RESET_LINK_PWR_MGMT_DISABLED); 			iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG, 				    CSR_HW_IF_CONFIG_REG_PREPARE | 				    CSR_HW_IF_CONFIG_REG_ENABLE_PME); 			mdelay(1); 			iwl_clear_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG, 				      CSR_RESET_LINK_PWR_MGMT_DISABLED); 		} 		mdelay(5); 	}  	clear_bit(STATUS_DEVICE_ENABLED, &trans->status);  	/* Stop device's DMA activity */ 	iwl_pcie_apm_stop_master(trans);  	if (trans->cfg->lp_xtal_workaround) { 		iwl_pcie_apm_lp_xtal_enable(trans); 		return; 	}  	iwl_trans_pcie_sw_reset(trans);  	/* 	 * Clear ""initialization complete"" bit to move adapter from 	 * D0A* (powered-up Active) --> D0U* (Uninitialized) state. 	 */ 	iwl_clear_bit(trans, CSR_GP_CNTRL, 		      BIT(trans->trans_cfg->csr->flag_init_done)); }"
"424944_not_vulnerable.c","not_vulnerable","static int iwl_trans_pcie_rxq_dma_data(struct iwl_trans *trans, int queue, 				       struct iwl_trans_rxq_dma_data *data) { 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);  	if (queue >= trans->num_rx_queues || !trans_pcie->rxq) 		return -EINVAL;  	data->fr_bd_cb = trans_pcie->rxq[queue].bd_dma; 	data->urbd_stts_wrptr = trans_pcie->rxq[queue].rb_stts_dma; 	data->ur_bd_cb = trans_pcie->rxq[queue].used_bd_dma; 	data->fr_bd_wid = 0;  	return 0; }"
"427162_not_vulnerable.c","not_vulnerable","static void closelistfield (FuncState *fs, ConsControl *cc) {   if (cc->v.k == VVOID) return;  /* there is no list item */   luaK_exp2nextreg(fs, &cc->v);   cc->v.k = VVOID;   if (cc->tostore == LFIELDS_PER_FLUSH) {     luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */     cc->na += cc->tostore;     cc->tostore = 0;  /* no more items pending */   } }"
"427173_not_vulnerable.c","not_vulnerable","static void parlist (LexState *ls) {   /* parlist -> [ {NAME ','} (NAME | '...') ] */   FuncState *fs = ls->fs;   Proto *f = fs->f;   int nparams = 0;   int isvararg = 0;   if (ls->t.token != ')') {  /* is 'parlist' not empty? */     do {       switch (ls->t.token) {         case TK_NAME: {           new_localvar(ls, str_checkname(ls));           nparams++;           break;         }         case TK_DOTS: {           luaX_next(ls);           isvararg = 1;           break;         }         default: luaX_syntaxerror(ls, ""<name> or '...' expected"");       }     } while (!isvararg && testnext(ls, ','));   }   adjustlocalvars(ls, nparams);   f->numparams = cast_byte(fs->nactvar);   if (isvararg)     setvararg(fs, f->numparams);  /* declared vararg */   luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */ }"
"427181_not_vulnerable.c","not_vulnerable","static void exprstat (LexState *ls) {   /* stat -> func | assignment */   FuncState *fs = ls->fs;   struct LHS_assign v;   suffixedexp(ls, &v.v);   if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */     v.prev = NULL;     restassign(ls, &v, 1);   }   else {  /* stat -> func */     Instruction *inst;     check_condition(ls, v.v.k == VCALL, ""syntax error"");     inst = &getinstruction(fs, &v.v);     SETARG_C(*inst, 1);  /* call statement uses no results */   } }"
"430368_not_vulnerable.c","not_vulnerable","int seq_write(struct seq_file *seq, const void *data, size_t len) { 	if (seq->count + len < seq->size) { 		memcpy(seq->buf + seq->count, data, len); 		seq->count += len; 		return 0; 	} 	seq_set_overflow(seq); 	return -1; }"
"430427_not_vulnerable.c","not_vulnerable","static int vxlan_tun_opt_from_nlattr(const struct nlattr *attr, 				     struct sw_flow_match *match, bool is_mask, 				     bool log) { 	struct nlattr *a; 	int rem; 	unsigned long opt_key_offset; 	struct vxlan_metadata opts;  	BUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));  	memset(&opts, 0, sizeof(opts)); 	nla_for_each_nested(a, attr, rem) { 		int type = nla_type(a);  		if (type > OVS_VXLAN_EXT_MAX) { 			OVS_NLERR(log, ""VXLAN extension %d out of range max %d"", 				  type, OVS_VXLAN_EXT_MAX); 			return -EINVAL; 		}  		if (!check_attr_len(nla_len(a), 				    ovs_vxlan_ext_key_lens[type].len)) { 			OVS_NLERR(log, ""VXLAN extension %d has unexpected len %d expected %d"", 				  type, nla_len(a), 				  ovs_vxlan_ext_key_lens[type].len); 			return -EINVAL; 		}  		switch (type) { 		case OVS_VXLAN_EXT_GBP: 			opts.gbp = nla_get_u32(a); 			break; 		default: 			OVS_NLERR(log, ""Unknown VXLAN extension attribute %d"", 				  type); 			return -EINVAL; 		} 	} 	if (rem) { 		OVS_NLERR(log, ""VXLAN extension message has %d unknown bytes."", 			  rem); 		return -EINVAL; 	}  	if (!is_mask) 		SW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false); 	else 		SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);  	opt_key_offset = TUN_METADATA_OFFSET(sizeof(opts)); 	SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts), 				  is_mask); 	return 0; }"
"430460_not_vulnerable.c","not_vulnerable","int ovs_nla_put_key(const struct sw_flow_key *swkey, 		    const struct sw_flow_key *output, int attr, bool is_mask, 		    struct sk_buff *skb) { 	int err; 	struct nlattr *nla;  	nla = nla_nest_start_noflag(skb, attr); 	if (!nla) 		return -EMSGSIZE; 	err = __ovs_nla_put_key(swkey, output, is_mask, skb); 	if (err) 		return err; 	nla_nest_end(skb, nla);  	return 0; }"
"432166_not_vulnerable.c","not_vulnerable","void memory_region_init_ram_ptr(struct uc_struct *uc,                                 MemoryRegion *mr,                                 uint64_t size,                                 void *ptr) {     memory_region_init(uc, mr, size);     mr->ram = true;     mr->terminates = true;     mr->destructor = memory_region_destructor_ram;      /* qemu_ram_alloc_from_ptr cannot fail with ptr != NULL.  */     assert(ptr != NULL);     mr->ram_block = qemu_ram_alloc_from_ptr(uc, size, ptr, mr); }"
"432185_not_vulnerable.c","not_vulnerable","static bool can_merge(FlatRange *r1, FlatRange *r2) {     return int128_eq(addrrange_end(r1->addr), r2->addr.start)         && r1->mr == r2->mr         && int128_eq(int128_add(int128_make64(r1->offset_in_region),                                 r1->addr.size),                      int128_make64(r2->offset_in_region))         && r1->readonly == r2->readonly; }"
"432197_not_vulnerable.c","not_vulnerable","void memory_listener_register(MemoryListener *listener, AddressSpace *as) {     listener->address_space = as;     QTAILQ_INSERT_TAIL(&as->uc->memory_listeners, listener, link);     QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);      listener_add_address_space(listener, as); }"
"432205_not_vulnerable.c","not_vulnerable","static void unassigned_io_write(struct uc_struct *uc, void* opaque, hwaddr addr, uint64_t data, unsigned size) { }"
"432237_not_vulnerable.c","not_vulnerable","static FlatView *generate_memory_topology(struct uc_struct *uc, MemoryRegion *mr) {     int i;     FlatView *view;      view = flatview_new(mr);      if (mr) {         render_memory_region(view, mr, int128_zero(),                              addrrange_make(int128_zero(), int128_2_64()),                              false);     }     flatview_simplify(view);      view->dispatch = address_space_dispatch_new(uc, view);     for (i = 0; i < view->nr; i++) {         MemoryRegionSection mrs =             section_from_flat_range(&view->ranges[i], view);         flatview_add_to_dispatch(uc, view, &mrs);     }     address_space_dispatch_compact(view->dispatch);     g_hash_table_replace(uc->flat_views, mr, view);      return view; }"
"432330_not_vulnerable.c","not_vulnerable","void flatview_unref(FlatView *view) {     view->ref--;     if (view->ref <= 0) {         flatview_destroy(view);     } }"
"436041_not_vulnerable.c","not_vulnerable","static inline int io_iter_do_read(struct io_kiocb *req, struct iov_iter *iter) { 	if (req->file->f_op->read_iter) 		return call_read_iter(req->file, &req->rw.kiocb, iter); 	else if (req->file->f_op->read) 		return loop_rw_iter(READ, req, iter); 	else 		return -EINVAL; }"
"436046_not_vulnerable.c","not_vulnerable"," static void io_free_file_tables(struct io_file_table *table, unsigned nr_files) { 	size_t size = nr_files * sizeof(struct io_fixed_file);  	io_free_page_table((void **)table->files, size); 	table->files = NULL;"
"436058_not_vulnerable.c","not_vulnerable","static int io_write(struct io_kiocb *req, unsigned int issue_flags) { 	struct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs; 	struct kiocb *kiocb = &req->rw.kiocb; 	struct iov_iter __iter, *iter = &__iter; 	struct io_async_rw *rw = req->async_data; 	ssize_t ret, ret2, io_size; 	bool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;  	if (rw) { 		iter = &rw->iter; 		iovec = NULL; 	} else { 		ret = io_import_iovec(WRITE, req, &iovec, iter, !force_nonblock); 		if (ret < 0) 			return ret; 	} 	io_size = iov_iter_count(iter); 	req->result = io_size;  	/* Ensure we clear previously set non-block flag */ 	if (!force_nonblock) 		kiocb->ki_flags &= ~IOCB_NOWAIT; 	else 		kiocb->ki_flags |= IOCB_NOWAIT;  	/* If the file doesn't support async, just async punt */ 	if (force_nonblock && !io_file_supports_async(req, WRITE)) 		goto copy_iov;  	/* file path doesn't support NOWAIT for non-direct_IO */ 	if (force_nonblock && !(kiocb->ki_flags & IOCB_DIRECT) && 	    (req->flags & REQ_F_ISREG)) 		goto copy_iov;  	ret = rw_verify_area(WRITE, req->file, io_kiocb_ppos(kiocb), io_size); 	if (unlikely(ret)) 		goto out_free;  	/* 	 * Open-code file_start_write here to grab freeze protection, 	 * which will be released by another thread in 	 * io_complete_rw().  Fool lockdep by telling it the lock got 	 * released so that it doesn't complain about the held lock when 	 * we return to userspace. 	 */ 	if (req->flags & REQ_F_ISREG) { 		sb_start_write(file_inode(req->file)->i_sb); 		__sb_writers_release(file_inode(req->file)->i_sb, 					SB_FREEZE_WRITE); 	} 	kiocb->ki_flags |= IOCB_WRITE;  	if (req->file->f_op->write_iter) 		ret2 = call_write_iter(req->file, kiocb, iter); 	else if (req->file->f_op->write) 		ret2 = loop_rw_iter(WRITE, req, iter); 	else 		ret2 = -EINVAL;  	if (req->flags & REQ_F_REISSUE) { 		req->flags &= ~REQ_F_REISSUE; 		ret2 = -EAGAIN; 	}  	/* 	 * Raw bdev writes will return -EOPNOTSUPP for IOCB_NOWAIT. Just 	 * retry them without IOCB_NOWAIT. 	 */ 	if (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT)) 		ret2 = -EAGAIN; 	/* no retry on NONBLOCK nor RWF_NOWAIT */ 	if (ret2 == -EAGAIN && (req->flags & REQ_F_NOWAIT)) 		goto done; 	if (!force_nonblock || ret2 != -EAGAIN) { 		/* IOPOLL retry should happen for io-wq threads */ 		if ((req->ctx->flags & IORING_SETUP_IOPOLL) && ret2 == -EAGAIN) 			goto copy_iov; done: 		kiocb_done(kiocb, ret2, issue_flags); 	} else { copy_iov: 		/* some cases will consume bytes even on error returns */ 		iov_iter_reexpand(iter, iter->count + iter->truncated); 		iov_iter_revert(iter, io_size - iov_iter_count(iter)); 		ret = io_setup_async_rw(req, iovec, inline_vecs, iter, false); 		return ret ?: -EAGAIN; 	} out_free: 	/* it's reportedly faster than delegating the null check to kfree() */ 	if (iovec) 		kfree(iovec); 	return ret; }"
"436128_not_vulnerable.c","not_vulnerable"," static int io_sq_thread(void *data) { 	struct io_sq_data *sqd = data; 	struct io_ring_ctx *ctx; 	unsigned long timeout = 0; 	char buf[TASK_COMM_LEN]; 	DEFINE_WAIT(wait);  	snprintf(buf, sizeof(buf), ""iou-sqp-%d"", sqd->task_pid); 	set_task_comm(current, buf);  	if (sqd->sq_cpu != -1) 		set_cpus_allowed_ptr(current, cpumask_of(sqd->sq_cpu)); 	else 		set_cpus_allowed_ptr(current, cpu_online_mask); 	current->flags |= PF_NO_SETAFFINITY;  	mutex_lock(&sqd->lock); 	while (1) { 		bool cap_entries, sqt_spin = false;  		if (io_sqd_events_pending(sqd) || signal_pending(current)) { 			if (io_sqd_handle_event(sqd)) 				break; 			timeout = jiffies + sqd->sq_thread_idle; 		}  		cap_entries = !list_is_singular(&sqd->ctx_list); 		list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) { 			int ret = __io_sq_thread(ctx, cap_entries);  			if (!sqt_spin && (ret > 0 || !list_empty(&ctx->iopoll_list))) 				sqt_spin = true; 		} 		if (io_run_task_work()) 			sqt_spin = true;  		if (sqt_spin || !time_after(jiffies, timeout)) { 			cond_resched(); 			if (sqt_spin) 				timeout = jiffies + sqd->sq_thread_idle; 			continue; 		}  		prepare_to_wait(&sqd->wait, &wait, TASK_INTERRUPTIBLE); 		if (!io_sqd_events_pending(sqd) && !current->task_works) { 			bool needs_sched = true;  			list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) { 				io_ring_set_wakeup_flag(ctx);  				if ((ctx->flags & IORING_SETUP_IOPOLL) && 				    !list_empty_careful(&ctx->iopoll_list)) { 					needs_sched = false; 					break; 				} 				if (io_sqring_entries(ctx)) { 					needs_sched = false; 					break; 				} 			}  			if (needs_sched) { 				mutex_unlock(&sqd->lock); 				schedule(); 				mutex_lock(&sqd->lock); 			} 			list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) 				io_ring_clear_wakeup_flag(ctx); 		}  		finish_wait(&sqd->wait, &wait); 		timeout = jiffies + sqd->sq_thread_idle; 	}  	io_uring_cancel_generic(true, sqd); 	sqd->thread = NULL; 	list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) 		io_ring_set_wakeup_flag(ctx); 	io_run_task_work(); 	mutex_unlock(&sqd->lock);  	complete(&sqd->exited); 	do_exit(0);"
"436154_not_vulnerable.c","not_vulnerable","static bool io_poll_rewait(struct io_kiocb *req, struct io_poll_iocb *poll) 	__acquires(&req->ctx->completion_lock) { 	struct io_ring_ctx *ctx = req->ctx;  	if (unlikely(req->task->flags & PF_EXITING)) 		WRITE_ONCE(poll->canceled, true);  	if (!req->result && !READ_ONCE(poll->canceled)) { 		struct poll_table_struct pt = { ._key = poll->events };  		req->result = vfs_poll(req->file, &pt) & poll->events; 	}  	spin_lock_irq(&ctx->completion_lock); 	if (!req->result && !READ_ONCE(poll->canceled)) { 		add_wait_queue(poll->head, &poll->wait); 		return true; 	}  	return false;"
"438663_not_vulnerable.c","not_vulnerable","static int virtio_rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, 					   u32 dst, void *data, int len) { 	struct rpmsg_device *rpdev = ept->rpdev;  	return rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, false); }"
"438681_not_vulnerable.c","not_vulnerable","static void rpmsg_xmit_done(struct virtqueue *svq) { 	struct virtproc_info *vrp = svq->vdev->priv;  	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);  	/* wake up potential senders that are waiting for a tx buffer */ 	wake_up_interruptible(&vrp->sendq); }"
"439069_not_vulnerable.c","not_vulnerable","static struct heif_error heif_write_func(struct heif_context *ctx,const void* data,   size_t size,void* userdata) {   Image     *image;    struct heif_error     error_ok;    (void) ctx;   image=(Image*) userdata;   (void) WriteBlob(image,size,data);   error_ok.code=heif_error_Ok;   error_ok.subcode=heif_suberror_Unspecified;   error_ok.message=""ok"";   return(error_ok); }"
"439087_not_vulnerable.c","not_vulnerable","static MagickBooleanType WritePALMImage(const ImageInfo *image_info,   Image *image) {   ExceptionInfo     *exception;    MagickBooleanType     status;    MagickOffsetType     currentOffset,     offset,     scene;    MagickSizeType     cc;    PixelPacket     transpix;    QuantizeInfo     *quantize_info;    register IndexPacket     *indexes;    register ssize_t     x;    register PixelPacket     *p;    ssize_t     y;    size_t     count,     bits_per_pixel,     bytes_per_row,     imageListLength,     nextDepthOffset,     one;    unsigned char     bit,     byte,     color,     *last_row,     *one_row,     *ptr,     version;    unsigned int     transparentIndex;    unsigned short     color16,     flags;    /*     Open output image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(image != (Image *) NULL);   assert(image->signature == MagickCoreSignature);   if (image->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);   exception=AcquireExceptionInfo();   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);   if (status == MagickFalse)     return(status);   quantize_info=AcquireQuantizeInfo(image_info);   flags=0;   currentOffset=0;   transparentIndex=0;   transpix.red=0;   transpix.green=0;   transpix.blue=0;   transpix.opacity=0;   one=1;   version=0;   scene=0;   imageListLength=GetImageListLength(image);   do   {     (void) TransformImageColorspace(image,sRGBColorspace);     count=GetNumberColors(image,NULL,exception);     for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;     if (bits_per_pixel > 16)       bits_per_pixel=16;     else       if (bits_per_pixel < 16)         (void) TransformImageColorspace(image,image->colorspace);     if (bits_per_pixel < 8)       {         (void) TransformImageColorspace(image,GRAYColorspace);         (void) SetImageType(image,PaletteType);         (void) SortColormapByIntensity(image);       }     if ((image->storage_class == PseudoClass) && (image->colors > 256))       (void) SetImageStorageClass(image,DirectClass);     if (image->storage_class == PseudoClass)       flags|=PALM_HAS_COLORMAP_FLAG;     else       flags|=PALM_IS_DIRECT_COLOR;     (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */     (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */     bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/       bits_per_pixel))*2;     (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);     if ((image_info->compression == RLECompression) ||         (image_info->compression == FaxCompression))       flags|=PALM_IS_COMPRESSED_FLAG;     (void) WriteBlobMSBShort(image, flags);     (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);     if (bits_per_pixel > 1)       version=1;     if ((image_info->compression == RLECompression) ||         (image_info->compression == FaxCompression))       version=2;     (void) WriteBlobByte(image,version);     (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */     (void) WriteBlobByte(image,(unsigned char) transparentIndex);     if (image_info->compression == RLECompression)       (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);     else       if (image_info->compression == FaxCompression)         (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);       else         (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);     (void) WriteBlobMSBShort(image,0);  /* reserved */     offset=16;     if (bits_per_pixel == 16)       {         (void) WriteBlobByte(image,5);  /* # of bits of red */         (void) WriteBlobByte(image,6);  /* # of bits of green */         (void) WriteBlobByte(image,5);  /* # of bits of blue */         (void) WriteBlobByte(image,0);  /* reserved by Palm */         (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */         offset+=8;       }     if (bits_per_pixel == 8)       {         if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */           {             quantize_info->dither=IsPaletteImage(image,&image->exception);             quantize_info->number_colors=image->colors;             (void) QuantizeImage(quantize_info,image);             (void) WriteBlobMSBShort(image,(unsigned short) image->colors);             for (count = 0; count < image->colors; count++)             {               (void) WriteBlobByte(image,(unsigned char) count);               (void) WriteBlobByte(image,ScaleQuantumToChar(                 image->colormap[count].red));               (void) WriteBlobByte(image,                 ScaleQuantumToChar(image->colormap[count].green));               (void) WriteBlobByte(image,                 ScaleQuantumToChar(image->colormap[count].blue));             }             offset+=2+count*4;           }       else  /* Map colors to Palm standard colormap */         {           Image             *affinity_image;            affinity_image=ConstituteImage(256,1,""RGB"",CharPixel,&PalmPalette,             exception);           (void) TransformImageColorspace(affinity_image,             affinity_image->colorspace);           (void) RemapImage(quantize_info,image,affinity_image);           for (y=0; y < (ssize_t) image->rows; y++)           {             p=GetAuthenticPixels(image,0,y,image->columns,1,exception);             indexes=GetAuthenticIndexQueue(image);             for (x=0; x < (ssize_t) image->columns; x++)               SetPixelIndex(indexes+x,FindColor(&image->colormap[                 (ssize_t) GetPixelIndex(indexes+x)]));           }           affinity_image=DestroyImage(affinity_image);         }       }     if (flags & PALM_IS_COMPRESSED_FLAG)       (void) WriteBlobMSBShort(image,0);  /* fill in size later */     last_row=(unsigned char *) NULL;     if (image_info->compression == FaxCompression)       {         last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,           sizeof(*last_row));         if (last_row == (unsigned char *) NULL)           {             quantize_info=DestroyQuantizeInfo(quantize_info);             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");           }       }     one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,       sizeof(*one_row));     if (one_row == (unsigned char *) NULL)       {         if (last_row != (unsigned char *) NULL)           last_row=(unsigned char *) RelinquishMagickMemory(last_row);         quantize_info=DestroyQuantizeInfo(quantize_info);         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");       }     for (y=0; y < (ssize_t) image->rows; y++)     {       ptr=one_row;       (void) memset(ptr,0,bytes_per_row);       p=GetAuthenticPixels(image,0,y,image->columns,1,exception);       if (p == (PixelPacket *) NULL)         break;       indexes=GetAuthenticIndexQueue(image);       if (bits_per_pixel == 16)         {           for (x=0; x < (ssize_t) image->columns; x++)           {             color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/               (size_t) QuantumRange) << 11) |               (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) |               ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange));             if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)               {                 transpix.red=GetPixelRed(p);                 transpix.green=GetPixelGreen(p);                 transpix.blue=GetPixelBlue(p);                 transpix.opacity=GetPixelOpacity(p);                 flags|=PALM_HAS_TRANSPARENCY_FLAG;               }             *ptr++=(unsigned char) ((color16 >> 8) & 0xff);             *ptr++=(unsigned char) (color16 & 0xff);             p++;           }         }       else         {           byte=0x00;           bit=(unsigned char) (8-bits_per_pixel);           for (x=0; x < (ssize_t) image->columns; x++)           {             if (bits_per_pixel >= 8)               color=(unsigned char) GetPixelIndex(indexes+x);             else               color=(unsigned char) (GetPixelIndex(indexes+x)*                 ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));             byte|=color << bit;             if (bit != 0)               bit-=(unsigned char) bits_per_pixel;             else               {                 *ptr++=byte;                 byte=0x00;                 bit=(unsigned char) (8-bits_per_pixel);               }           }           if ((image->columns % (8/bits_per_pixel)) != 0)             *ptr++=byte;         }       if (image_info->compression == RLECompression)         {           x=0;           while (x < (ssize_t) bytes_per_row)           {             byte=one_row[x];             count=1;             while ((one_row[++x] == byte) && (count < 255) &&                    (x < (ssize_t) bytes_per_row))               count++;             (void) WriteBlobByte(image,(unsigned char) count);             (void) WriteBlobByte(image,(unsigned char) byte);           }         }       else         if (image_info->compression == FaxCompression)           {             char               tmpbuf[8],               *tptr;              for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)             {               tptr = tmpbuf;               for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)               {                 if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))                   {                     byte |= (1 << (7 - bit));                     *tptr++ = (char) one_row[x + bit];                   }               }               (void) WriteBlobByte(image, byte);               (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);             }             (void) memcpy(last_row,one_row,bytes_per_row);           }         else           (void) WriteBlob(image,bytes_per_row,one_row);       }     if (flags & PALM_HAS_TRANSPARENCY_FLAG)       {         offset=SeekBlob(image,currentOffset+6,SEEK_SET);         (void) WriteBlobMSBShort(image,flags);         offset=SeekBlob(image,currentOffset+12,SEEK_SET);         (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */       }     if (bits_per_pixel == 16)       {         offset=SeekBlob(image,currentOffset+20,SEEK_SET);         (void) WriteBlobByte(image,0);  /* reserved by Palm */         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/           QuantumRange));         (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/           QuantumRange));         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/           QuantumRange));       }     if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */       {         offset=SeekBlob(image,currentOffset+offset,SEEK_SET);         (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-           currentOffset-offset));       }     if (one_row != (unsigned char *) NULL)       one_row=(unsigned char *) RelinquishMagickMemory(one_row);     if (last_row != (unsigned char *) NULL)       last_row=(unsigned char *) RelinquishMagickMemory(last_row);     if (GetNextImageInList(image) == (Image *) NULL)       break;     /* padding to 4 byte word */     for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)       (void) WriteBlobByte(image,0);     /* write nextDepthOffset and return to end of image */     (void) SeekBlob(image,currentOffset+10,SEEK_SET);     nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);     (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);     currentOffset=(MagickOffsetType) GetBlobSize(image);     (void) SeekBlob(image,currentOffset,SEEK_SET);     image=SyncNextImageInList(image);     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);     if (status == MagickFalse)       break;   } while (image_info->adjoin != MagickFalse);   quantize_info=DestroyQuantizeInfo(quantize_info);   (void) CloseBlob(image);   (void) DestroyExceptionInfo(exception);   return(MagickTrue); }"
"439144_not_vulnerable.c","not_vulnerable","static MagickBooleanType WriteMTVImage(const ImageInfo *image_info,Image *image) {   char     buffer[MaxTextExtent];    MagickBooleanType     status;    MagickOffsetType     scene;    register const PixelPacket     *p;    register ssize_t     x;    register unsigned char     *q;    size_t     imageListLength;    ssize_t     y;    unsigned char     *pixels;    /*     Open output image file.   */   assert(image_info != (const ImageInfo *) NULL);   assert(image_info->signature == MagickCoreSignature);   assert(image != (Image *) NULL);   assert(image->signature == MagickCoreSignature);   if (image->debug != MagickFalse)     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);   if (status == MagickFalse)     return(status);   scene=0;   imageListLength=GetImageListLength(image);   do   {     /*       Allocate memory for pixels.     */     (void) TransformImageColorspace(image,sRGBColorspace);     pixels=(unsigned char *) AcquireQuantumMemory(image->columns,       3UL*sizeof(*pixels));     if (pixels == (unsigned char *) NULL)       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");     /*       Initialize raster file header.     */     (void) FormatLocaleString(buffer,MaxTextExtent,""%.20g %.20g\n"",(double)       image->columns,(double) image->rows);     (void) WriteBlobString(image,buffer);     for (y=0; y < (ssize_t) image->rows; y++)     {       p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);       if (p == (const PixelPacket *) NULL)         break;       q=pixels;       for (x=0; x < (ssize_t) image->columns; x++)       {         *q++=ScaleQuantumToChar(GetPixelRed(p));         *q++=ScaleQuantumToChar(GetPixelGreen(p));         *q++=ScaleQuantumToChar(GetPixelBlue(p));         p++;       }       (void) WriteBlob(image,(size_t) (q-pixels),pixels);       if (image->previous == (Image *) NULL)         {           status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,                 image->rows);           if (status == MagickFalse)             break;         }     }     pixels=(unsigned char *) RelinquishMagickMemory(pixels);     if (GetNextImageInList(image) == (Image *) NULL)       break;     image=SyncNextImageInList(image);     status=SetImageProgress(image,SaveImagesTag,scene,imageListLength);     if (status == MagickFalse)       break;     scene++;   } while (image_info->adjoin != MagickFalse);   (void) CloseBlob(image);   return(MagickTrue); }"
"441814_not_vulnerable.c","not_vulnerable","SProcXkbBell(ClientPtr client) {     REQUEST(xkbBellReq);      swaps(&stuff->length);     REQUEST_SIZE_MATCH(xkbBellReq);     swaps(&stuff->deviceSpec);     swaps(&stuff->bellClass);     swaps(&stuff->bellID);     swapl(&stuff->name);     swapl(&stuff->window);     swaps(&stuff->pitch);     swaps(&stuff->duration);     return ProcXkbBell(client); }"
"443161_not_vulnerable.c","not_vulnerable","static int jfs_writepage(struct page *page, struct writeback_control *wbc) { 	return block_write_full_page(page, jfs_get_block, wbc); }"
"443693_not_vulnerable.c","not_vulnerable","init(void) { #ifdef USE_CALLOUT      int id;     OnigEncoding enc;     char* name;     unsigned int args[4];     OnigValue    opts[4];      enc = ONIG_ENCODING_UTF16_LE;      name = ""F\000A\000I\000L\000\000\000"";            BC0_P(name, fail);     name = ""M\000I\000S\000M\000A\000T\000C\000H\000\000\000""; BC0_P(name, mismatch);      name = ""M\000A\000X\000\000\000"";     args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;     args[1] = ONIG_TYPE_CHAR;     opts[0].c = 'X';     BC_B_O(name, max, 2, args, 1, opts);      name = ""E\000R\000R\000O\000R\000\000\000"";     args[0] = ONIG_TYPE_LONG; opts[0].l = ONIG_ABORT;     BC_P_O(name, error, 1, args, 1, opts);      name = ""C\000O\000U\000N\000T\000\000\000"";     args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';     BC_B_O(name, count, 1, args, 1, opts);      name = ""T\000O\000T\000A\000L\000_\000C\000O\000U\000N\000T\000\000\000"";     args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';     BC_B_O(name, total_count, 1, args, 1, opts);      name = ""C\000M\000P\000\000\000"";     args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;     args[1] = ONIG_TYPE_STRING;     args[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;     BC_P(name, cmp, 3, args);  #endif /* USE_CALLOUT */    return ONIG_NORMAL; }"
"445887_not_vulnerable.c","not_vulnerable","fr_window_archive_add_with_filter (FrWindow      *window, 				   GList         *file_list, /* GFile list */ 				   GFile         *base_dir, 				   const char    *include_files, 				   const char    *exclude_files, 				   const char    *exclude_folders, 				   const char    *dest_dir, 				   gboolean       update, 				   gboolean       follow_links) { 	_archive_operation_started (window, FR_ACTION_ADDING_FILES);  	fr_archive_add_files_with_filter (window->archive, 					  file_list, 					  base_dir, 					  include_files, 					  exclude_files, 					  exclude_folders, 					  (dest_dir == NULL)? fr_window_get_current_location (window): dest_dir, 					  update, 					  follow_links, 					  window->priv->password, 					  window->priv->encrypt_header, 					  window->priv->compression, 					  window->priv->volume_size, 					  window->priv->cancellable, 					  archive_add_files_ready_cb, 					  window); }"
"445942_not_vulnerable.c","not_vulnerable","notify_action_open_archive_cb (NotifyNotification *notification, 			       char               *action, 			       gpointer            user_data) { 	NotifyData *notify_data = user_data; 	FrWindow   *window = notify_data->window; 	GtkWidget  *new_window;  	new_window = fr_window_new (); 	gtk_widget_show (new_window); 	fr_window_archive_open (FR_WINDOW (new_window), 				window->priv->saving_file, 				GTK_WINDOW (new_window));  	notify_data->window_closed = TRUE; 	_fr_window_close_after_notification (window); }"
"445981_not_vulnerable.cpp","not_vulnerable","fr_window_archive_save_as (FrWindow   *window, 			   GFile      *file, 			   const char *mime_type, 			   const char *password, 			   gboolean    encrypt_header, 			   guint       volume_size) { 	FrArchive   *new_archive; 	ConvertData *cdata;  	g_return_if_fail (window != NULL); 	g_return_if_fail (file != NULL); 	g_return_if_fail (window->archive != NULL);  	/* create the new archive */  	new_archive = fr_archive_create (file, mime_type); 	if (new_archive == NULL) { 		GtkWidget *d; 		char      *utf8_name; 		char      *message;  		utf8_name = _g_file_get_display_basename (file); 		message = g_strdup_printf (_(""Could not save the archive \""%s\""""), utf8_name); 		g_free (utf8_name);  		d = _gtk_error_dialog_new (GTK_WINDOW (window), 					   GTK_DIALOG_DESTROY_WITH_PARENT, 					   NULL, 					   message, 					   ""%s"", 					   _(""Archive type not supported."")); 		gtk_dialog_run (GTK_DIALOG (d)); 		gtk_widget_destroy (d);  		g_free (message);  		return; 	}  	cdata = convert_data_new (file, mime_type, password, encrypt_header, volume_size); 	cdata->window = window; 	cdata->new_archive = new_archive;  	_archive_operation_started (window, FR_ACTION_CREATING_ARCHIVE); 	fr_window_set_current_batch_action (window, 					    FR_BATCH_ACTION_SAVE_AS, 					    cdata, 					    (GFreeFunc) convert_data_free);  	g_signal_connect (cdata->new_archive, 			  ""progress"", 			  G_CALLBACK (fr_archive_progress_cb), 			  window); 	g_signal_connect (cdata->new_archive, 			  ""message"", 			  G_CALLBACK (fr_archive_message_cb), 			  window); 	g_signal_connect (cdata->new_archive, 			  ""start"", 			  G_CALLBACK (fr_archive_start_cb), 			  window); 	g_signal_connect (cdata->new_archive, 			  ""stoppable"", 			  G_CALLBACK (fr_archive_stoppable_cb), 			  window); 	g_signal_connect (cdata->new_archive, 			  ""working-archive"", 			  G_CALLBACK (fr_window_working_archive_cb), 			  window);  	_g_object_unref (window->priv->saving_file); 	window->priv->saving_file = g_object_ref (cdata->file);  	fr_archive_action_started (window->archive, FR_ACTION_EXTRACTING_FILES); 	fr_archive_extract (window->archive, 			    NULL, 			    cdata->temp_extraction_dir, 			    NULL, 			    FALSE, 			    TRUE, 			    FALSE, 			    window->priv->password, 			    window->priv->cancellable, 			    archive_extraction_ready_for_convertion_cb, 			    cdata); }"
"446111_not_vulnerable.c","not_vulnerable","static int atusb_get_and_show_revision(struct atusb *atusb) { 	struct usb_device *usb_dev = atusb->usb_dev; 	char *hw_name; 	unsigned char *buffer; 	int ret;  	buffer = kmalloc(3, GFP_KERNEL); 	if (!buffer) 		return -ENOMEM;  	/* Get a couple of the ATMega Firmware values */ 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0), 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0, 				buffer, 3, 1000); 	if (ret >= 0) { 		atusb->fw_ver_maj = buffer[0]; 		atusb->fw_ver_min = buffer[1]; 		atusb->fw_hw_type = buffer[2];  		switch (atusb->fw_hw_type) { 		case ATUSB_HW_TYPE_100813: 		case ATUSB_HW_TYPE_101216: 		case ATUSB_HW_TYPE_110131: 			hw_name = ""ATUSB""; 			atusb->data = &atusb_chip_data; 			break; 		case ATUSB_HW_TYPE_RZUSB: 			hw_name = ""RZUSB""; 			atusb->data = &atusb_chip_data; 			break; 		case ATUSB_HW_TYPE_HULUSB: 			hw_name = ""HULUSB""; 			atusb->data = &hulusb_chip_data; 			break; 		default: 			hw_name = ""UNKNOWN""; 			atusb->err = -ENOTSUPP; 			ret = -ENOTSUPP; 			break; 		}  		dev_info(&usb_dev->dev, 			 ""Firmware: major: %u, minor: %u, hardware type: %s (%d)\n"", 			 atusb->fw_ver_maj, atusb->fw_ver_min, hw_name, 			 atusb->fw_hw_type); 	} 	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) { 		dev_info(&usb_dev->dev, 			 ""Firmware version (%u.%u) predates our first public release."", 			 atusb->fw_ver_maj, atusb->fw_ver_min); 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer""); 	}  	kfree(buffer); 	return ret; }"
"446401_not_vulnerable.c","not_vulnerable","RZ_API void rz_dyldcache_symbols_from_locsym(RzDyldCache *cache, RzDyldBinImage *bin, RzList *symbols, SetU *hash) { 	RzDyldLocSym *locsym = cache->locsym; 	if (!locsym) { 		return; 	}  	if (bin->nlist_start_index >= locsym->nlists_count || 		bin->nlist_start_index + bin->nlist_count > locsym->nlists_count) { 		RZ_LOG_ERROR(""dyldcache: malformed local symbol entry\n""); 		return; 	}  	ut64 nlists_size = sizeof(struct MACH0_(nlist)) * bin->nlist_count; 	struct MACH0_(nlist) *nlists = RZ_NEWS0(struct MACH0_(nlist), bin->nlist_count); 	if (!nlists) { 		return; 	} 	ut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset + 		bin->nlist_start_index * sizeof(struct MACH0_(nlist)); 	if (rz_buf_fread_at(cache->buf, nlists_offset, (ut8 *)nlists, ""iccsl"", bin->nlist_count) != nlists_size) { 		free(nlists); 		return; 	}  	ut32 j; 	for (j = 0; j != bin->nlist_count; j++) { 		struct MACH0_(nlist) *nlist = &nlists[j]; 		if (set_u_contains(hash, (ut64)nlist->n_value)) { 			continue; 		} 		set_u_add(hash, (ut64)nlist->n_value); 		if (nlist->n_strx >= locsym->strings_size) { 			continue; 		} 		RzBinSymbol *sym = RZ_NEW0(RzBinSymbol); 		if (!sym) { 			break; 		} 		sym->type = ""LOCAL""; 		sym->vaddr = nlist->n_value; 		ut64 slide = rz_dyldcache_get_slide(cache); 		sym->paddr = va2pa(nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);  		char *symstr = rz_buf_get_string(cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx); 		if (symstr) { 			sym->name = symstr; 		} else { 			static ut32 k = 0; 			sym->name = rz_str_newf(""unk_local%d"", k++); 		}  		rz_list_append(symbols, sym); 	}  	free(nlists); }"
"447052_not_vulnerable.cpp","not_vulnerable","    void MemIo::Impl::reserve(long wcount)     {         long need = wcount + idx_;          if (!isMalloced_) {             // Minimum size for 1st block is 32kB             long size  = EXV_MAX(32768 * (1 + need / 32768), size_);             byte* data = (byte*)std::malloc(size);             std::memcpy(data, data_, size_);             data_ = data;             sizeAlloced_ = size;             isMalloced_ = true;         }          if (need > size_) {             if (need > sizeAlloced_) {                 // Allocate in blocks of 32kB                 long want = 32768 * (1 + need / 32768);                 data_ = (byte*)std::realloc(data_, want);                 sizeAlloced_ = want;                 isMalloced_ = true;             }             size_ = need;         }     }"
"447053_not_vulnerable.cpp","not_vulnerable","    void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)     {         depth++;         bool bFirst  = true  ;          // buffer         const size_t dirSize = 32;         DataBuf  dir(dirSize);         bool bPrint = option == kpsBasic || option == kpsRecursive;          do {             // Read top of directory             io.seek(start,BasicIo::beg);             io.read(dir.pData_, 2);             uint16_t   dirLength = byteSwap2(dir,0,bSwap);              bool tooBig = dirLength > 500;             if ( tooBig ) throw Error(55);              if ( bFirst && bPrint ) {                 out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF TIFF FILE (%c%c): "",c,c) << io.path() << std::endl;                 if ( tooBig ) out << Internal::indent(depth) << ""dirLength = "" << dirLength << std::endl;             }              // Read the dictionary             for ( int i = 0 ; i < dirLength ; i ++ ) {                 if ( bFirst && bPrint ) {                     out << Internal::indent(depth)                         << "" address |    tag                              |     ""                         << "" type |    count |    offset | value\n"";                 }                 bFirst = false;                  io.read(dir.pData_, 12);                 uint16_t tag    = byteSwap2(dir,0,bSwap);                 uint16_t type   = byteSwap2(dir,2,bSwap);                 uint32_t count  = byteSwap4(dir,4,bSwap);                 uint32_t offset = byteSwap4(dir,8,bSwap);                  // Break for unknown tag types else we may segfault.                 if ( !typeValid(type) ) {                     std::cerr << ""invalid type value detected in Image::printIFDStructure:  "" << type << std::endl;                     start = 0; // break from do loop                     throw Error(56);                     break; // break from for loop                 }                  std::string sp  = """" ; // output spacer                  //prepare to print the value                 uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data                                 : isPrintICC(tag,option) ? count // ditto                                 : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays                                 : count > 5              ? 5                                 : count                                 ;                 uint32_t pad    = isStringType(type) ? 1 : 0;                 uint32_t size   = isStringType(type) ? 1                                 : is2ByteType(type)  ? 2                                 : is4ByteType(type)  ? 4                                 : is8ByteType(type)  ? 8                                 : 1                                 ;                  // if ( offset > io.size() ) offset = 0; // Denial of service?                  // #55 memory allocation crash test/data/POC8                 long long allocate = (long long) (size*count + pad+20);                 if ( allocate > (long long) io.size() ) {                     throw Error(57);                 }                 DataBuf  buf(allocate);  // allocate a buffer                 std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)                 const bool bOffsetIsPointer = count*size > 4;                  if ( bOffsetIsPointer ) {         // read into buffer                     size_t   restore = io.tell();  // save                     io.seek(offset,BasicIo::beg);  // position                     io.read(buf.pData_,count*size);// read                     io.seek(restore,BasicIo::beg); // restore                 }                  if ( bPrint ) {                     const uint32_t address = start + 2 + i*12 ;                     const std::string offsetString = bOffsetIsPointer?                         Internal::stringFormat(""%10u"", offset):                         """";                      out << Internal::indent(depth)                     << Internal::stringFormat(""%8u | %#06x %-28s |%10s |%9u |%10s | ""                                               ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());                     if ( isShortType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             out << sp << byteSwap2(buf,k*size,bSwap);                             sp = "" "";                         }                     } else if ( isLongType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             out << sp << byteSwap4(buf,k*size,bSwap);                             sp = "" "";                         }                      } else if ( isRationalType(type) ){                         for ( size_t k = 0 ; k < kount ; k++ ) {                             uint32_t a = byteSwap4(buf,k*size+0,bSwap);                             uint32_t b = byteSwap4(buf,k*size+4,bSwap);                             out << sp << a << ""/"" << b;                             sp = "" "";                         }                     } else if ( isStringType(type) ) {                         out << sp << Internal::binaryToString(buf, kount);                     }                      sp = kount == count ? """" : "" ..."";                     out << sp << std::endl;                      if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {                         for ( size_t k = 0 ; k < count ; k++ ) {                             size_t   restore = io.tell();                             uint32_t offset = byteSwap4(buf,k*size,bSwap);                             printIFDStructure(io,out,option,offset,bSwap,c,depth);                             io.seek(restore,BasicIo::beg);                         }                     } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {                         size_t   restore = io.tell();  // save                         io.seek(offset,BasicIo::beg);  // position                         byte* bytes=new byte[count] ;  // allocate memory                         io.read(bytes,count)        ;  // read                         io.seek(restore,BasicIo::beg); // restore                         IptcData::printStructure(out,bytes,count,depth);                         delete[] bytes;                // free                     }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {                         size_t   restore = io.tell();  // save                          uint32_t jump= 10           ;                         byte     bytes[20]          ;                         const char* chars = (const char*) &bytes[0] ;                         io.seek(offset,BasicIo::beg);  // position                         io.read(bytes,jump    )     ;  // read                         bytes[jump]=0               ;                         if ( ::strcmp(""Nikon"",chars) == 0 ) {                             // tag is an embedded tiff                             byte* bytes=new byte[count-jump] ;  // allocate memory                             io.read(bytes,count-jump)        ;  // read                             MemIo memIo(bytes,count-jump)    ;  // create a file                             printTiffStructure(memIo,out,option,depth);                             delete[] bytes                   ;  // free                         } else {                             // tag is an IFD                             io.seek(0,BasicIo::beg);  // position                             printIFDStructure(io,out,option,offset,bSwap,c,depth);                         }                          io.seek(restore,BasicIo::beg); // restore                     }                 }                  if ( isPrintXMP(tag,option) ) {                     buf.pData_[count]=0;                     out << (char*) buf.pData_;                 }                 if ( isPrintICC(tag,option) ) {                     out.write((const char*)buf.pData_,count);                 }             }             if ( start ) {                 io.read(dir.pData_, 4);                 start = tooBig ? 0 : byteSwap4(dir,0,bSwap);             }         } while (start) ;          if ( bPrint ) {             out << Internal::indent(depth) << ""END "" << io.path() << std::endl;         }         out.flush();         depth--;     }"
"448549_not_vulnerable.c","not_vulnerable","static struct stream *bgp_update_packet_eor(struct peer *peer, afi_t afi, 					    safi_t safi) { 	struct stream *s; 	iana_afi_t pkt_afi = IANA_AFI_IPV4; 	iana_safi_t pkt_safi = IANA_SAFI_UNICAST;  	if (DISABLE_BGP_ANNOUNCE) 		return NULL;  	if (bgp_debug_neighbor_events(peer)) 		zlog_debug(""send End-of-RIB for %s to %s"", 			   get_afi_safi_str(afi, safi, false), peer->host);  	s = stream_new(peer->max_packet_size);  	/* Make BGP update packet. */ 	bgp_packet_set_marker(s, BGP_MSG_UPDATE);  	/* Unfeasible Routes Length */ 	stream_putw(s, 0);  	if (afi == AFI_IP && safi == SAFI_UNICAST) { 		/* Total Path Attribute Length */ 		stream_putw(s, 0); 	} else { 		/* Convert AFI, SAFI to values for packet. */ 		bgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);  		/* Total Path Attribute Length */ 		stream_putw(s, 6); 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); 		stream_putc(s, BGP_ATTR_MP_UNREACH_NLRI); 		stream_putc(s, 3); 		stream_putw(s, pkt_afi); 		stream_putc(s, pkt_safi); 	}  	bgp_packet_set_size(s); 	return s; }"
"448563_not_vulnerable.c","not_vulnerable","void bgp_generate_updgrp_packets(struct thread *thread) { 	struct peer *peer = THREAD_ARG(thread);  	struct stream *s; 	struct peer_af *paf; 	struct bpacket *next_pkt; 	uint32_t wpq; 	uint32_t generated = 0; 	afi_t afi; 	safi_t safi;  	wpq = atomic_load_explicit(&peer->bgp->wpkt_quanta, 				   memory_order_relaxed);  	/* 	 * The code beyond this part deals with update packets, proceed only 	 * if peer is Established and updates are not on hold (as part of 	 * update-delay processing). 	 */ 	if (!peer_established(peer)) 		return;  	if ((peer->bgp->main_peers_update_hold) 	    || bgp_update_delay_active(peer->bgp)) 		return;  	if (peer->t_routeadv) 		return;  	do { 		enum bgp_af_index index;  		s = NULL; 		for (index = BGP_AF_START; index < BGP_AF_MAX; index++) { 			paf = peer->peer_af_array[index]; 			if (!paf || !PAF_SUBGRP(paf)) 				continue;  			afi = paf->afi; 			safi = paf->safi; 			next_pkt = paf->next_pkt_to_send;  			/* 			 * Try to generate a packet for the peer if we are at 			 * the end of the list. Always try to push out 			 * WITHDRAWs first. 			 */ 			if (!next_pkt || !next_pkt->buffer) { 				next_pkt = subgroup_withdraw_packet( 					PAF_SUBGRP(paf)); 				if (!next_pkt || !next_pkt->buffer) 					subgroup_update_packet(PAF_SUBGRP(paf)); 				next_pkt = paf->next_pkt_to_send; 			}  			/* 			 * If we still don't have a packet to send to the peer, 			 * then try to find out out if we have to send eor or 			 * if not, skip to the next AFI, SAFI. Don't send the 			 * EOR prematurely; if the subgroup's coalesce timer is 			 * running, the adjacency-out structure is not created 			 * yet. 			 */ 			if (!next_pkt || !next_pkt->buffer) { 				if (!paf->t_announce_route) { 					/* Make sure we supress BGP UPDATES 					 * for normal processing later again. 					 */ 					UNSET_FLAG(paf->subgroup->sflags, 						   SUBGRP_STATUS_FORCE_UPDATES);  					/* If route-refresh BoRR message was 					 * already sent and we are done with 					 * re-announcing tables for a decent 					 * afi/safi, we ready to send 					 * EoRR request. 					 */ 					if (CHECK_FLAG( 						    peer->af_sflags[afi][safi], 						    PEER_STATUS_BORR_SEND)) { 						bgp_route_refresh_send( 							peer, afi, safi, 0, 0, 							0, 							BGP_ROUTE_REFRESH_EORR);  						SET_FLAG(peer->af_sflags[afi] 									[safi], 							 PEER_STATUS_EORR_SEND); 						UNSET_FLAG( 							peer->af_sflags[afi] 								       [safi], 							PEER_STATUS_BORR_SEND);  						if (bgp_debug_neighbor_events( 							    peer)) 							zlog_debug( 								""%pBP sending route-refresh (EoRR) for %s/%s"", 								peer, 								afi2str(afi), 								safi2str(safi)); 					} 				}  				if (CHECK_FLAG(peer->cap, 					       PEER_CAP_RESTART_RCV)) { 					if (!(PAF_SUBGRP(paf))->t_coalesce 					    && peer->afc_nego[afi][safi] 					    && peer->synctime 					    && !CHECK_FLAG( 						    peer->af_sflags[afi][safi], 						    PEER_STATUS_EOR_SEND)) { 						/* If EOR is disabled, 						 * the message is  not sent 						 */ 						if (BGP_SEND_EOR(peer->bgp, afi, 								 safi)) { 							SET_FLAG( 								peer->af_sflags 									[afi] 									[safi], 								PEER_STATUS_EOR_SEND);  							/* Update EOR 							 * send time 							 */ 							peer->eor_stime[afi] 								       [safi] = 								monotime(NULL);  							BGP_UPDATE_EOR_PKT( 								peer, afi, safi, 								s); 						} 					} 				} 				continue; 			}  			/* Update packet send time */ 			peer->pkt_stime[afi][safi] = monotime(NULL);  			/* Found a packet template to send, overwrite 			 * packet with appropriate attributes from peer 			 * and advance peer */ 			s = bpacket_reformat_for_peer(next_pkt, paf); 			bgp_packet_add(peer, s); 			bpacket_queue_advance_peer(paf); 		} 	} while (s && (++generated < wpq));  	if (generated) 		bgp_writes_on(peer);  	bgp_write_proceed_actions(peer); }"
"448582_not_vulnerable.c","not_vulnerable","gdk_pixbuf__xbm_image_begin_load (GdkPixbufModuleSizeFunc       size_func,                                   GdkPixbufModulePreparedFunc   prepare_func, 				  GdkPixbufModuleUpdatedFunc    update_func, 				  gpointer                      user_data, 				  GError                      **error) { 	XBMData *context; 	gint fd;  	context = g_new (XBMData, 1); 	context->prepare_func = prepare_func; 	context->update_func = update_func; 	context->user_data = user_data; 	context->all_okay = TRUE; 	fd = g_file_open_tmp (""gdkpixbuf-xbm-tmp.XXXXXX"", 			      &context->tempname, 			      NULL); 	if (fd < 0) { 		g_free (context); 		return NULL; 	}  	context->file = fdopen (fd, ""w+""); 	if (context->file == NULL) { 		g_free (context->tempname); 		g_free (context); 		return NULL; 	}  	return context; }"
"448584_not_vulnerable.c","not_vulnerable","read_bitmap_file_data (FILE    *fstream, 		       guint   *width,  		       guint   *height, 		       guchar **data, 		       int     *x_hot,  		       int     *y_hot) { 	guchar *bits = NULL;		/* working variable */ 	char line[MAX_SIZE];		/* input line from file */ 	int size;			/* number of bytes of data */ 	char name_and_type[MAX_SIZE];	/* an input line */ 	char *type;			/* for parsing */ 	int value;			/* from an input line */ 	int version10p;			/* boolean, old format */ 	int padding;			/* to handle alignment */ 	int bytes_per_line;		/* per scanline of data */ 	guint ww = 0;			/* width */ 	guint hh = 0;			/* height */ 	int hx = -1;			/* x hotspot */ 	int hy = -1;			/* y hotspot */  	/* first time initialization */ 	if (!initialized) { 		init_hex_table (); 	}  	/* error cleanup and return macro */ #define	RETURN(code) { g_free (bits); return code; }  	while (fgets (line, MAX_SIZE, fstream)) { 		if (strlen (line) == MAX_SIZE-1) 			RETURN (FALSE); 		if (sscanf (line,""#define %s %d"",name_and_type,&value) == 2) { 			if (!(type = strrchr (name_and_type, '_'))) 				type = name_and_type; 			else { 				type++; 			}  			if (!strcmp (""width"", type)) {                                 if (value <= 0)                                         RETURN (FALSE); 				ww = (unsigned int) value;                         } 			if (!strcmp (""height"", type)) {                                 if (value <= 0)                                         RETURN (FALSE); 				hh = (unsigned int) value;                         } 			if (!strcmp (""hot"", type)) { 				if (type-- == name_and_type 				    || type-- == name_and_type) 					continue; 				if (!strcmp (""x_hot"", type)) 					hx = value; 				if (!strcmp (""y_hot"", type)) 					hy = value; 			} 			continue; 		}      		if (sscanf (line, ""static short %s = {"", name_and_type) == 1) 			version10p = 1; 		else if (sscanf (line,""static const unsigned char %s = {"",name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line,""static unsigned char %s = {"",name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line, ""static const char %s = {"", name_and_type) == 1) 			version10p = 0; 		else if (sscanf (line, ""static char %s = {"", name_and_type) == 1) 			version10p = 0; 		else 			continue;  		if (!(type = strrchr (name_and_type, '_'))) 			type = name_and_type; 		else 			type++;  		if (strcmp (""bits[]"", type)) 			continue;      		if (!ww || !hh) 			RETURN (FALSE);  		if ((ww % 16) && ((ww % 16) < 9) && version10p) 			padding = 1; 		else 			padding = 0;  		bytes_per_line = (ww+7)/8 + padding;  		size = bytes_per_line * hh;                 if (size / bytes_per_line != hh) /* overflow */                         RETURN (FALSE); 		bits = g_malloc (size);  		if (version10p) { 			unsigned char *ptr; 			int bytes;  			for (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) { 				if ((value = next_int (fstream)) < 0) 					RETURN (FALSE); 				*(ptr++) = value; 				if (!padding || ((bytes+2) % bytes_per_line)) 					*(ptr++) = value >> 8; 			} 		} else { 			unsigned char *ptr; 			int bytes;  			for (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) { 				if ((value = next_int (fstream)) < 0)  					RETURN (FALSE); 				*ptr=value; 			} 		} 		break; 	}  	if (!bits) 		RETURN (FALSE);  	*data = bits; 	*width = ww; 	*height = hh; 	if (x_hot) 		*x_hot = hx; 	if (y_hot) 		*y_hot = hy;  	return TRUE; }"
"448919_not_vulnerable.c","not_vulnerable","int ZEXPORT inflateCopy(dest, source) z_streamp dest; z_streamp source; {     struct inflate_state FAR *state;     struct inflate_state FAR *copy;     unsigned char FAR *window;     unsigned wsize;      /* check input */     if (inflateStateCheck(source) || dest == Z_NULL)         return Z_STREAM_ERROR;     state = (struct inflate_state FAR *)source->state;      /* allocate space */     copy = (struct inflate_state FAR *)            ZALLOC(source, 1, sizeof(struct inflate_state));     if (copy == Z_NULL) return Z_MEM_ERROR;     window = Z_NULL;     if (state->window != Z_NULL) {         window = (unsigned char FAR *)                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));         if (window == Z_NULL) {             ZFREE(source, copy);             return Z_MEM_ERROR;         }     }      /* copy state */     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));     copy->strm = dest;     if (state->lencode >= state->codes &&         state->lencode <= state->codes + ENOUGH - 1) {         copy->lencode = copy->codes + (state->lencode - state->codes);         copy->distcode = copy->codes + (state->distcode - state->codes);     }     copy->next = copy->codes + (state->next - state->codes);     if (window != Z_NULL) {         wsize = 1U << state->wbits;         zmemcpy(window, state->window, wsize);     }     copy->window = window;     dest->state = (struct internal_state FAR *)copy;     return Z_OK; }"
"450323_not_vulnerable.c","not_vulnerable","check_solid_tile32(VncState *vs, int x, int y, int w, int h,                    uint32_t *color, bool samecolor) {     VncDisplay *vd = vs->vd;     uint32_t *fbptr;     uint32_t c;     int dx, dy;      fbptr = vnc_server_fb_ptr(vd, x, y);      c = *fbptr;     if (samecolor && (uint32_t)c != *color) {         return false;     }      for (dy = 0; dy < h; dy++) {         for (dx = 0; dx < w; dx++) {             if (c != fbptr[dx]) {                 return false;             }         }         fbptr = (uint32_t *)             ((uint8_t *)fbptr + vnc_server_fb_stride(vd));     }      *color = (uint32_t)c;     return true; }"
"450821_not_vulnerable.c","not_vulnerable","readdir_result_type (struct readdir_result d) { #if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE # define D_TYPE_TO_RESULT(source) (source)->d_type,   return d.type; #else # define D_TYPE_TO_RESULT(source)   return DT_UNKNOWN; #endif }"
"452250_not_vulnerable.c","not_vulnerable","PHP_FUNCTION(xsl_xsltprocessor_transform_to_uri) { 	zval *id, *docp = NULL; 	xmlDoc *newdocp; 	xsltStylesheetPtr sheetp; 	int ret, uri_len; 	char *uri; 	xsl_object *intern;  	id = getThis(); 	intern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC); 	sheetp = (xsltStylesheetPtr) intern->ptr;  	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""op"", &docp, &uri, &uri_len) == FAILURE) { 		RETURN_FALSE; 	}  	newdocp = php_xsl_apply_stylesheet(id, intern, sheetp, docp TSRMLS_CC);  	ret = -1; 	if (newdocp) { 		ret = xsltSaveResultToFilename(uri, newdocp, sheetp, 0); 		xmlFreeDoc(newdocp); 	}  	RETVAL_LONG(ret); }"
"455174_not_vulnerable.c","not_vulnerable","MOBI_RET mobi_parse_fdst(const MOBIData *m, MOBIRawml *rawml) {     if (m == NULL) {         debug_print(""%s"", ""Mobi structure not initialized\n"");         return MOBI_INIT_FAILED;     }     const size_t fdst_record_number = mobi_get_fdst_record_number(m);     if (fdst_record_number == MOBI_NOTSET) {         return MOBI_DATA_CORRUPT;     }     const MOBIPdbRecord *fdst_record = mobi_get_record_by_seqnumber(m, fdst_record_number);     if (fdst_record == NULL) {         return MOBI_DATA_CORRUPT;     }     MOBIBuffer *buf = mobi_buffer_init_null(fdst_record->data, fdst_record->size);     if (buf == NULL) {         debug_print(""%s\n"", ""Memory allocation failed"");         return MOBI_MALLOC_FAILED;     }     char fdst_magic[5];     mobi_buffer_getstring(fdst_magic, buf, 4);     const size_t data_offset = mobi_buffer_get32(buf);     const size_t section_count = mobi_buffer_get32(buf);     if (strncmp(fdst_magic, FDST_MAGIC, 4) != 0 ||         section_count <= 1 ||         section_count != *m->mh->fdst_section_count ||         data_offset != 12) {         debug_print(""FDST wrong magic: %s, sections count: %zu or data offset: %zu\n"", fdst_magic, section_count, data_offset);         mobi_buffer_free_null(buf);         return MOBI_DATA_CORRUPT;     }     if ((buf->maxlen - buf->offset) < section_count * 8) {         debug_print(""%s"", ""Record FDST too short\n"");         mobi_buffer_free_null(buf);         return MOBI_DATA_CORRUPT;     }     rawml->fdst = malloc(sizeof(MOBIFdst));     if (rawml->fdst == NULL) {         debug_print(""%s\n"", ""Memory allocation failed"");         mobi_buffer_free_null(buf);         return MOBI_MALLOC_FAILED;     }     rawml->fdst->fdst_section_count = section_count;     rawml->fdst->fdst_section_starts = malloc(sizeof(*rawml->fdst->fdst_section_starts) * section_count);     if (rawml->fdst->fdst_section_starts == NULL) {         debug_print(""%s\n"", ""Memory allocation failed"");         mobi_buffer_free_null(buf);         free(rawml->fdst);         rawml->fdst = NULL;         return MOBI_MALLOC_FAILED;     }     rawml->fdst->fdst_section_ends = malloc(sizeof(*rawml->fdst->fdst_section_ends) * section_count);     if (rawml->fdst->fdst_section_ends == NULL) {         debug_print(""%s\n"", ""Memory allocation failed"");         mobi_buffer_free_null(buf);         free(rawml->fdst->fdst_section_starts);         free(rawml->fdst);         rawml->fdst = NULL;         return MOBI_MALLOC_FAILED;     }     size_t i = 0;     while (i < section_count) {         rawml->fdst->fdst_section_starts[i] = mobi_buffer_get32(buf);         rawml->fdst->fdst_section_ends[i] = mobi_buffer_get32(buf);         debug_print(""FDST[%zu]:\t%i\t%i\n"", i, rawml->fdst->fdst_section_starts[i], rawml->fdst->fdst_section_ends[i]);         i++;     }     mobi_buffer_free_null(buf);     return MOBI_SUCCESS; }"
"455282_not_vulnerable.c","not_vulnerable","test_for_canon_directory (name)      const char *name; {   char *fn;   int r;    fn = (*name == '~') ? bash_tilde_expand (name, 0) : savestring (name);   bash_filename_stat_hook (&fn);   r = file_isdir (fn);   free (fn);    return (r); }"
"455314_not_vulnerable.c","not_vulnerable","extglob_skipname (pat, dname, flags)      char *pat, *dname;      int flags; {   char *pp, *pe, *t, *se;   int n, r, negate, wild, nullpat;    negate = *pat == '!';   wild = *pat == '*' || *pat == '?';   pp = pat + 2;   se = pp + strlen (pp) - 1;		/* end of string */   pe = glob_patscan (pp, se, 0);	/* end of extglob pattern (( */   /* we should check for invalid extglob pattern here */   if (pe == 0)     return 0;    /* if pe != se we have more of the pattern at the end of the extglob      pattern. Check the easy case first ( */   if (pe == se && *pe == ')' && (t = strchr (pp, '|')) == 0)     {       *pe = '\0'; #if defined (HANDLE_MULTIBYTE)       r = mbskipname (pp, dname, flags); #else       r = skipname (pp, dname, flags);	/*(*/ #endif       *pe = ')';       if (wild && pe[1])	/* if we can match zero instances, check further */         return (skipname (pe+1, dname, flags));       return r;     }    /* Is the extglob pattern between the parens the null pattern?  The null      pattern can match nothing, so should we check any remaining portion of      the pattern? */   nullpat = pe >= (pat + 2) && pe[-2] == '(' && pe[-1] == ')';    /* check every subpattern */   while (t = glob_patscan (pp, pe, '|'))     {       n = t[-1];	/* ( */       if (extglob_pattern_p (pp) && n == ')') 	t[-1] = n;	/* no-op for now */       else 	t[-1] = '\0'; #if defined (HANDLE_MULTIBYTE)       r = mbskipname (pp, dname, flags); #else       r = skipname (pp, dname, flags); #endif       t[-1] = n;       if (r == 0)	/* if any pattern says not skip, we don't skip */         return r;       pp = t;     }	/*(*/    /* glob_patscan might find end of string */   if (pp == se)     return r;    /* but if it doesn't then we didn't match a leading dot */   if (wild && *pe)	/* if we can match zero instances, check further */     return (skipname (pe, dname, flags));   return 1; }"
"455322_not_vulnerable.c","not_vulnerable","edit_and_execute_command (count, c, editing_mode, edit_command)      int count, c, editing_mode;      char *edit_command; {   char *command, *metaval;   int r, rrs, metaflag;   sh_parser_state_t ps;    rrs = rl_readline_state;   saved_command_line_count = current_command_line_count;    /* Accept the current line. */   rl_newline (1, c);    if (rl_explicit_arg)     {       command = (char *)xmalloc (strlen (edit_command) + 8);       sprintf (command, ""%s %d"", edit_command, count);     }   else     {       /* Take the command we were just editing, add it to the history file, 	 then call fc to operate on it.  We have to add a dummy command to 	 the end of the history because fc ignores the last command (assumes 	 it's supposed to deal with the command before the `fc'). */       /* This breaks down when using command-oriented history and are not 	 finished with the command, so we should not ignore the last command */       using_history ();       current_command_line_count++;	/* for rl_newline above */       bash_add_history (rl_line_buffer);       current_command_line_count = 0;	/* for dummy history entry */       bash_add_history ("""");       history_lines_this_session++;       using_history ();       command = savestring (edit_command);     }    metaval = rl_variable_value (""input-meta"");   metaflag = RL_BOOLEAN_VARIABLE_VALUE (metaval);      if (rl_deprep_term_function)     (*rl_deprep_term_function) ();   save_parser_state (&ps);   r = parse_and_execute (command, (editing_mode == VI_EDITING_MODE) ? ""v"" : ""C-xC-e"", SEVAL_NOHIST);   restore_parser_state (&ps);   if (rl_prep_term_function)     (*rl_prep_term_function) (metaflag);    current_command_line_count = saved_command_line_count;    /* Now erase the contents of the current line and undo the effects of the      rl_accept_line() above.  We don't even want to make the text we just      executed available for undoing. */   rl_line_buffer[0] = '\0';	/* XXX */   rl_point = rl_end = 0;   rl_done = 0;   rl_readline_state = rrs;  #if defined (VI_MODE)   if (editing_mode == VI_EDITING_MODE)     rl_vi_insertion_mode (1, c); #endif    rl_forced_update_display ();    return r; }"
"455344_not_vulnerable.c","not_vulnerable","udequote_pathname (pathname)      char *pathname; {   register int i, j;    for (i = j = 0; pathname && pathname[i]; )     {       if (pathname[i] == '\\') 	i++;        pathname[j++] = pathname[i++];        if (pathname[i - 1] == 0) 	break;     }   if (pathname)     pathname[j] = '\0'; }"
"455386_not_vulnerable.c","not_vulnerable","xfs_inode_set_reclaim_tag( 	struct xfs_inode	*ip) { 	struct xfs_mount	*mp = ip->i_mount; 	struct xfs_perag	*pag;  	pag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino)); 	spin_lock(&pag->pag_ici_lock); 	spin_lock(&ip->i_flags_lock);  	radix_tree_tag_set(&pag->pag_ici_root, XFS_INO_TO_AGINO(mp, ip->i_ino), 			   XFS_ICI_RECLAIM_TAG); 	xfs_perag_set_reclaim_tag(pag); 	__xfs_iflags_set(ip, XFS_IRECLAIMABLE);  	spin_unlock(&ip->i_flags_lock); 	spin_unlock(&pag->pag_ici_lock); 	xfs_perag_put(pag); }"
"455423_not_vulnerable.c","not_vulnerable","xfs_iflag_for_tag( 	int		tag) { 	switch (tag) { 	case XFS_ICI_EOFBLOCKS_TAG: 		return XFS_IEOFBLOCKS; 	case XFS_ICI_COWBLOCKS_TAG: 		return XFS_ICOWBLOCKS; 	default: 		ASSERT(0); 		return 0; 	} }"
"457876_not_vulnerable.c","not_vulnerable","load_cache (GeglProperties *op_magick_load) {   if (!op_magick_load->user_data)     {       gchar    *filename;       GeglNode *graph, *sink, *loader;       GeglBuffer *newbuf = NULL;        /* ImageMagick backed fallback FIXME: make this robust.        * maybe use pipes in a manner similar to the raw loader,        * or at least use a properly unique filename  */       char     *argv[4]  = {""convert"", NULL, NULL, NULL};        filename = g_build_filename (g_get_tmp_dir (), ""gegl-magick.png"", NULL);        argv[1] = g_strdup_printf (""%s[0]"", op_magick_load->path);       argv[2] = filename;       if (!g_spawn_sync (NULL, argv, NULL, G_SPAWN_DEFAULT,                           NULL, NULL, NULL, NULL, NULL, NULL))         g_warning (""Error executing ImageMagick convert program"");        g_free (argv[1]);        graph = gegl_node_new ();       sink = gegl_node_new_child (graph,                                  ""operation"", ""gegl:buffer-sink"",                                  ""buffer"", &newbuf, NULL);       loader = gegl_node_new_child (graph,                                     ""operation"", ""gegl:png-load"",                                     ""path"", filename, NULL);       gegl_node_link_many (loader, sink, NULL);       gegl_node_process (sink);       op_magick_load->user_data = (gpointer) newbuf;       g_object_unref (graph);       g_free (filename);     } }"
"459101_not_vulnerable.c","not_vulnerable","static void tc_chain_tmplt_del(const struct tcf_proto_ops *tmplt_ops, 			       void *tmplt_priv) { 	/* If template ops are set, no work to do for us. */ 	if (!tmplt_ops) 		return;  	tmplt_ops->tmplt_destroy(tmplt_priv); 	module_put(tmplt_ops->owner); }"
"459182_not_vulnerable.c","not_vulnerable","static void tcf_block_release(struct Qdisc *q, struct tcf_block *block, 			      bool rtnl_held) { 	if (!IS_ERR_OR_NULL(block)) 		tcf_block_refcnt_put(block, rtnl_held);  	if (q) { 		if (rtnl_held) 			qdisc_put(q); 		else 			qdisc_put_unlocked(q); 	} }"
"459215_not_vulnerable.c","not_vulnerable","static void tcf_proto_mark_delete(struct tcf_proto *tp) { 	spin_lock(&tp->lock); 	tp->deleting = true; 	spin_unlock(&tp->lock); }"
"462231_not_vulnerable.c","not_vulnerable","static void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval) {     buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);     buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);     buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);     buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0); }"
"462240_not_vulnerable.c","not_vulnerable","static pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos) {     return (pj_uint16_t) ((buf[pos + 0] << 8) | \ 			  (buf[pos + 1] << 0)); }"
"462267_not_vulnerable.c","not_vulnerable","PJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type) {     if (PJ_STUN_IS_REQUEST(msg_type)) 	return ""request"";     else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type)) 	return ""success response"";     else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type)) 	return ""error response"";     else if (PJ_STUN_IS_INDICATION(msg_type)) 	return ""indication"";     else 	return ""???""; }"
"462316_not_vulnerable.c","not_vulnerable","pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs) {     uint count = min(max_data,                      pcs->status.write_pos - pcs->status.read_pos);      if (count)         memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);     pcs->status.read_pos += count;     if (pcs->status.read_pos == pcs->status.write_pos) {         gs_free_object(pcs->memory, pcs->status.buffer, ""status buffer"");         pcs->status.buffer = NULL;         pcs->status.write_pos = pcs->status.read_pos = 0;     }     return count; }"
"462411_not_vulnerable.c","not_vulnerable","createInstance(instanceConf_t **pinst) { 	instanceConf_t *inst; 	DEFiRet; 	CHKmalloc(inst = MALLOC(sizeof(instanceConf_t))); 	inst->next = NULL;  	inst->pszBindPort = NULL; 	inst->pszBindAddr = NULL; 	inst->pszBindPath = NULL; 	inst->fileUID = -1; 	inst->fileGID = -1; 	inst->fCreateMode = 0644; 	inst->bFailOnPerms = 1; 	inst->bUnlink = 0; 	inst->pszBindRuleset = NULL; 	inst->pszInputName = NULL; 	inst->bSuppOctetFram = 1; 	inst->bSPFramingFix = 0; 	inst->bKeepAlive = 0; 	inst->iKeepAliveIntvl = 0; 	inst->iKeepAliveProbes = 0; 	inst->iKeepAliveTime = 0; 	inst->bEmitMsgOnClose = 0; 	inst->dfltTZ = NULL; 	inst->iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER; 	inst->pBindRuleset = NULL; 	inst->ratelimitBurst = 10000; /* arbitrary high limit */ 	inst->ratelimitInterval = 0; /* off */ 	inst->compressionMode = COMPRESS_SINGLE_MSG;  	/* node created, let's add to config */ 	if(loadModConf->tail == NULL) { 		loadModConf->tail = loadModConf->root = inst; 	} else { 		loadModConf->tail->next = inst; 		loadModConf->tail = inst; 	}  	*pinst = inst; finalize_it: 	RETiRet; }"
"462537_not_vulnerable.cpp","not_vulnerable","void controller::start_reload_all_thread(std::vector<int> * indexes) { 	LOG(level::INFO,""starting reload all thread""); 	std::thread t(downloadthread(this, indexes)); 	t.detach(); }"
"462550_not_vulnerable.cpp","not_vulnerable","void controller::edit_urls_file() { 	const char * editor;  	editor = getenv(""VISUAL""); 	if (!editor) 		editor = getenv(""EDITOR""); 	if (!editor) 		editor = ""vi"";  	std::string cmdline = strprintf::fmt(""%s \""%s\"""", editor, utils::replace_all(url_file,""\"""",""\\\""""));  	v->push_empty_formaction(); 	stfl::reset();  	utils::run_interactively(cmdline, ""controller::edit_urls_file"");  	v->pop_current_formaction();  	reload_urls_file(); }"
"463107_not_vulnerable.c","not_vulnerable","EXPORTED int annotatemore_writemask(const char *mboxname, const char *entry,                                     const char *userid, const struct buf *value) {     if (mboxname_userownsmailbox(userid, mboxname))         return annotatemore_write(mboxname, entry, """", value);     else         return annotatemore_write(mboxname, entry, userid, value); }"
"463184_not_vulnerable.c","not_vulnerable","static int find_desc_store(annotate_state_t *state,                            const char *name,                            const annotate_entrydesc_t **descp) {     int scope = state->which;     const ptrarray_t *descs;     const annotate_entrydesc_t *db_entry;     annotate_entrydesc_t *desc;     int i;      if (scope == ANNOTATION_SCOPE_SERVER) {         descs = &server_entries;         db_entry = &server_db_entry;     }     else if (scope == ANNOTATION_SCOPE_MAILBOX) {         descs = &mailbox_entries;         db_entry = &mailbox_db_entry;     }     else if (scope == ANNOTATION_SCOPE_MESSAGE) {         descs = &message_entries;         db_entry = &message_db_entry;     }     else {         syslog(LOG_ERR, ""IOERROR: unknown scope in find_desc_store %d"", scope);         return IMAP_INTERNAL;     }      /* check for DAV annotations */     if (state->mailbox && (state->mailbox->mbtype & MBTYPES_DAV) &&         !strncmp(name, DAV_ANNOT_NS, strlen(DAV_ANNOT_NS))) {         *descp = db_entry;         return 0;     }      /* check known IMAP annotations */     for (i = 0 ; i < descs->count ; i++) {         desc = descs->data[i];         if (strcmp(name, desc->name))             continue;         if (!desc->set) {             /* read-only annotation */             return IMAP_PERMISSION_DENIED;         }         *descp = desc;         return 0;     }      /* unknown annotation */     if (!config_getswitch(IMAPOPT_ANNOTATION_ALLOW_UNDEFINED))         return IMAP_PERMISSION_DENIED;      /* check for /flags and /vendor/cmu */     if (scope == ANNOTATION_SCOPE_MESSAGE &&         !strncmp(name, ""/flags/"", 7))         return IMAP_PERMISSION_DENIED;      if (!strncmp(name, IMAP_ANNOT_NS, strlen(IMAP_ANNOT_NS)))         return IMAP_PERMISSION_DENIED;      *descp = db_entry;     return 0; }"
"464941_not_vulnerable.c","not_vulnerable","static inline int is_in_cp950_pua(int c1, int c) { 	if ((c1 >= 0xfa && c1 <= 0xfe) || (c1 >= 0x8e && c1 <= 0xa0) || 			(c1 >= 0x81 && c1 <= 0x8d) || (c1 >= 0xc7 && c1 <= 0xc8)) { 		return (c >=0x40 && c <= 0x7e) || (c >= 0xa1 && c <= 0xfe); 	} 	if (c1 == 0xc6) { 		return c >= 0xa1 && c <= 0xfe; 	} 	return 0; }"
"468353_not_vulnerable.c","not_vulnerable","on_connection_cancelled (GCancellable *cancellable,                          gpointer      data) {   GCancellable *attempt_cancellable = data;    g_cancellable_cancel (attempt_cancellable); }"
"468360_not_vulnerable.c","not_vulnerable","g_socket_client_set_proxy_resolver (GSocketClient  *client,                                     GProxyResolver *proxy_resolver) {   /* We have to be careful to avoid calling    * g_proxy_resolver_get_default() until we're sure we need it,    * because trying to load the default proxy resolver module will    * break some test programs that aren't expecting it (eg,    * tests/gsettings).    */    if (client->priv->proxy_resolver)     g_object_unref (client->priv->proxy_resolver);    client->priv->proxy_resolver = proxy_resolver;    if (client->priv->proxy_resolver)     g_object_ref (client->priv->proxy_resolver); }"
"468364_not_vulnerable.c","not_vulnerable","g_socket_client_class_init (GSocketClientClass *class) {   GObjectClass *gobject_class = G_OBJECT_CLASS (class);    gobject_class->finalize = g_socket_client_finalize;   gobject_class->set_property = g_socket_client_set_property;   gobject_class->get_property = g_socket_client_get_property;    /**    * GSocketClient::event:    * @client: the #GSocketClient    * @event: the event that is occurring    * @connectable: the #GSocketConnectable that @event is occurring on    * @connection: (nullable): the current representation of the connection    *    * Emitted when @client's activity on @connectable changes state.    * Among other things, this can be used to provide progress    * information about a network connection in the UI. The meanings of    * the different @event values are as follows:    *    * - %G_SOCKET_CLIENT_RESOLVING: @client is about to look up @connectable    *   in DNS. @connection will be %NULL.    *    * - %G_SOCKET_CLIENT_RESOLVED:  @client has successfully resolved    *   @connectable in DNS. @connection will be %NULL.    *    * - %G_SOCKET_CLIENT_CONNECTING: @client is about to make a connection    *   to a remote host; either a proxy server or the destination server    *   itself. @connection is the #GSocketConnection, which is not yet    *   connected.  Since GLib 2.40, you can access the remote    *   address via g_socket_connection_get_remote_address().    *    * - %G_SOCKET_CLIENT_CONNECTED: @client has successfully connected    *   to a remote host. @connection is the connected #GSocketConnection.    *    * - %G_SOCKET_CLIENT_PROXY_NEGOTIATING: @client is about to negotiate    *   with a proxy to get it to connect to @connectable. @connection is    *   the #GSocketConnection to the proxy server.    *    * - %G_SOCKET_CLIENT_PROXY_NEGOTIATED: @client has negotiated a    *   connection to @connectable through a proxy server. @connection is    *   the stream returned from g_proxy_connect(), which may or may not    *   be a #GSocketConnection.    *    * - %G_SOCKET_CLIENT_TLS_HANDSHAKING: @client is about to begin a TLS    *   handshake. @connection is a #GTlsClientConnection.    *    * - %G_SOCKET_CLIENT_TLS_HANDSHAKED: @client has successfully completed    *   the TLS handshake. @connection is a #GTlsClientConnection.    *    * - %G_SOCKET_CLIENT_COMPLETE: @client has either successfully connected    *   to @connectable (in which case @connection is the #GSocketConnection    *   that it will be returning to the caller) or has failed (in which    *   case @connection is %NULL and the client is about to return an error).    *    * Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted    * multiple times (or not at all) for a given connectable (in    * particular, if @client ends up attempting to connect to more than    * one address). However, if @client emits the #GSocketClient::event    * signal at all for a given connectable, that it will always emit    * it with %G_SOCKET_CLIENT_COMPLETE when it is done.    *    * Note that there may be additional #GSocketClientEvent values in    * the future; unrecognized @event values should be ignored.    *    * Since: 2.32    */   signals[EVENT] =     g_signal_new (I_(""event""), 		  G_TYPE_FROM_CLASS (gobject_class), 		  G_SIGNAL_RUN_LAST, 		  G_STRUCT_OFFSET (GSocketClientClass, event), 		  NULL, NULL, 		  NULL, 		  G_TYPE_NONE, 3, 		  G_TYPE_SOCKET_CLIENT_EVENT, 		  G_TYPE_SOCKET_CONNECTABLE, 		  G_TYPE_IO_STREAM);    g_object_class_install_property (gobject_class, PROP_FAMILY, 				   g_param_spec_enum (""family"", 						      P_(""Socket family""), 						      P_(""The sockets address family to use for socket construction""), 						      G_TYPE_SOCKET_FAMILY, 						      G_SOCKET_FAMILY_INVALID, 						      G_PARAM_CONSTRUCT |                                                       G_PARAM_READWRITE |                                                       G_PARAM_STATIC_STRINGS));    g_object_class_install_property (gobject_class, PROP_TYPE, 				   g_param_spec_enum (""type"", 						      P_(""Socket type""), 						      P_(""The sockets type to use for socket construction""), 						      G_TYPE_SOCKET_TYPE, 						      G_SOCKET_TYPE_STREAM, 						      G_PARAM_CONSTRUCT |                                                       G_PARAM_READWRITE |                                                       G_PARAM_STATIC_STRINGS));    g_object_class_install_property (gobject_class, PROP_PROTOCOL, 				   g_param_spec_enum (""protocol"", 						      P_(""Socket protocol""), 						      P_(""The protocol to use for socket construction, or 0 for default""), 						      G_TYPE_SOCKET_PROTOCOL, 						      G_SOCKET_PROTOCOL_DEFAULT, 						      G_PARAM_CONSTRUCT |                                                       G_PARAM_READWRITE |                                                       G_PARAM_STATIC_STRINGS));    g_object_class_install_property (gobject_class, PROP_LOCAL_ADDRESS, 				   g_param_spec_object (""local-address"", 							P_(""Local address""), 							P_(""The local address constructed sockets will be bound to""), 							G_TYPE_SOCKET_ADDRESS, 							G_PARAM_CONSTRUCT |                                                         G_PARAM_READWRITE |                                                         G_PARAM_STATIC_STRINGS));    g_object_class_install_property (gobject_class, PROP_TIMEOUT, 				   g_param_spec_uint (""timeout"", 						      P_(""Socket timeout""), 						      P_(""The I/O timeout for sockets, or 0 for none""), 						      0, G_MAXUINT, 0, 						      G_PARAM_CONSTRUCT |                                                       G_PARAM_READWRITE |                                                       G_PARAM_STATIC_STRINGS));     g_object_class_install_property (gobject_class, PROP_ENABLE_PROXY, 				    g_param_spec_boolean (""enable-proxy"", 							  P_(""Enable proxy""), 							  P_(""Enable proxy support""), 							  TRUE, 							  G_PARAM_CONSTRUCT | 							  G_PARAM_READWRITE | 							  G_PARAM_STATIC_STRINGS));    g_object_class_install_property (gobject_class, PROP_TLS, 				   g_param_spec_boolean (""tls"", 							 P_(""TLS""), 							 P_(""Whether to create TLS connections""), 							 FALSE, 							 G_PARAM_CONSTRUCT | 							 G_PARAM_READWRITE | 							 G_PARAM_STATIC_STRINGS));   g_object_class_install_property (gobject_class, PROP_TLS_VALIDATION_FLAGS, 				   g_param_spec_flags (""tls-validation-flags"", 						       P_(""TLS validation flags""), 						       P_(""TLS validation flags to use""), 						       G_TYPE_TLS_CERTIFICATE_FLAGS, 						       G_TLS_CERTIFICATE_VALIDATE_ALL, 						       G_PARAM_CONSTRUCT | 						       G_PARAM_READWRITE | 						       G_PARAM_STATIC_STRINGS));    /**    * GSocketClient:proxy-resolver:    *    * The proxy resolver to use    *    * Since: 2.36    */   g_object_class_install_property (gobject_class, PROP_PROXY_RESOLVER,                                    g_param_spec_object (""proxy-resolver"",                                                         P_(""Proxy resolver""),                                                         P_(""The proxy resolver to use""),                                                         G_TYPE_PROXY_RESOLVER,                                                         G_PARAM_CONSTRUCT |                                                         G_PARAM_READWRITE |                                                         G_PARAM_STATIC_STRINGS)); }"
"468381_not_vulnerable.c","not_vulnerable","g_socket_client_init (GSocketClient *client) {   client->priv = g_socket_client_get_instance_private (client);   client->priv->type = G_SOCKET_TYPE_STREAM;   client->priv->app_proxies = g_hash_table_new_full (g_str_hash, 						     g_str_equal, 						     g_free, 						     NULL); }"
"473821_not_vulnerable.c","not_vulnerable","onigenc_unicode_get_case_fold_codes_by_str(OnigEncoding enc,     OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end,     OnigCaseFoldCodeItem items[]) {   int n, i, j, k, len;   OnigCodePoint code, codes[3];   CodePointList3 *to, *z3;   CodePointList2 *z2;    if (CaseFoldInited == 0) init_case_fold_table();    n = 0;    code = ONIGENC_MBC_TO_CODE(enc, p, end);   len = enclen(enc, p, end);  #ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI   if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {     if (code == 0x0049) {       items[0].byte_len = len;       items[0].code_len = 1;       items[0].code[0]  = 0x0131;       return 1;     }     else if (code == 0x0130) {       items[0].byte_len = len;       items[0].code_len = 1;       items[0].code[0]  = 0x0069;       return 1;     }     else if (code == 0x0131) {       items[0].byte_len = len;       items[0].code_len = 1;       items[0].code[0]  = 0x0049;       return 1;     }     else if (code == 0x0069) {       items[0].byte_len = len;       items[0].code_len = 1;       items[0].code[0]  = 0x0130;       return 1;     }   } #endif    if (onig_st_lookup(FoldTable, (st_data_t )code, (void* )&to) != 0) {     if (to->n == 1) {       OnigCodePoint orig_code = code;        items[0].byte_len = len;       items[0].code_len = 1;       items[0].code[0]  = to->code[0];       n++;        code = to->code[0];       if (onig_st_lookup(Unfold1Table, (st_data_t )code, (void* )&to) != 0) { 	for (i = 0; i < to->n; i++) { 	  if (to->code[i] != orig_code) { 	    items[n].byte_len = len; 	    items[n].code_len = 1; 	    items[n].code[0]  = to->code[i]; 	    n++; 	  } 	}       }     }     else if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {       OnigCodePoint cs[3][4];       int fn, ncs[3];        for (fn = 0; fn < to->n; fn++) { 	cs[fn][0] = to->code[fn]; 	if (onig_st_lookup(Unfold1Table, (st_data_t )cs[fn][0], 			   (void* )&z3) != 0) { 	  for (i = 0; i < z3->n; i++) { 	    cs[fn][i+1] = z3->code[i]; 	  } 	  ncs[fn] = z3->n + 1; 	} 	else 	  ncs[fn] = 1;       }        if (fn == 2) { 	for (i = 0; i < ncs[0]; i++) { 	  for (j = 0; j < ncs[1]; j++) { 	    items[n].byte_len = len; 	    items[n].code_len = 2; 	    items[n].code[0]  = cs[0][i]; 	    items[n].code[1]  = cs[1][j]; 	    n++; 	  } 	}  	if (onig_st_lookup(Unfold2Table, (st_data_t )to->code, 			   (void* )&z2) != 0) { 	  for (i = 0; i < z2->n; i++) { 	    if (z2->code[i] == code) continue;  	    items[n].byte_len = len; 	    items[n].code_len = 1; 	    items[n].code[0]  = z2->code[i]; 	    n++; 	  } 	}       }       else { 	for (i = 0; i < ncs[0]; i++) { 	  for (j = 0; j < ncs[1]; j++) { 	    for (k = 0; k < ncs[2]; k++) { 	      items[n].byte_len = len; 	      items[n].code_len = 3; 	      items[n].code[0]  = cs[0][i]; 	      items[n].code[1]  = cs[1][j]; 	      items[n].code[2]  = cs[2][k]; 	      n++; 	    } 	  } 	}  	if (onig_st_lookup(Unfold3Table, (st_data_t )to->code, 			   (void* )&z2) != 0) { 	  for (i = 0; i < z2->n; i++) { 	    if (z2->code[i] == code) continue;  	    items[n].byte_len = len; 	    items[n].code_len = 1; 	    items[n].code[0]  = z2->code[i]; 	    n++; 	  } 	}       }        /* multi char folded code is not head of another folded multi char */       flag = 0; /* DISABLE_CASE_FOLD_MULTI_CHAR(flag); */     }   }   else {     if (onig_st_lookup(Unfold1Table, (st_data_t )code, (void* )&to) != 0) {       for (i = 0; i < to->n; i++) { 	items[n].byte_len = len; 	items[n].code_len = 1; 	items[n].code[0]  = to->code[i]; 	n++;       }     }   }     if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {     p += len;     if (p < end) {       int clen;        codes[0] = code;       code = ONIGENC_MBC_TO_CODE(enc, p, end);       if (onig_st_lookup(FoldTable, (st_data_t )code, (void* )&to) != 0 	  && to->n == 1) { 	codes[1] = to->code[0];       }       else 	codes[1] = code;        clen = enclen(enc, p, end);       len += clen;       if (onig_st_lookup(Unfold2Table, (st_data_t )codes, (void* )&z2) != 0) { 	for (i = 0; i < z2->n; i++) { 	  items[n].byte_len = len; 	  items[n].code_len = 1; 	  items[n].code[0]  = z2->code[i]; 	  n++; 	}       }        p += clen;       if (p < end) { 	code = ONIGENC_MBC_TO_CODE(enc, p, end); 	if (onig_st_lookup(FoldTable, (st_data_t )code, (void* )&to) != 0 	    && to->n == 1) { 	  codes[2] = to->code[0]; 	} 	else 	  codes[2] = code;  	clen = enclen(enc, p, end); 	len += clen; 	if (onig_st_lookup(Unfold3Table, (st_data_t )codes, 			   (void* )&z2) != 0) { 	  for (i = 0; i < z2->n; i++) { 	    items[n].byte_len = len; 	    items[n].code_len = 1; 	    items[n].code[0]  = z2->code[i]; 	    n++; 	  } 	}       }     }   }    return n; }"
"473840_not_vulnerable.c","not_vulnerable","is_allowed_reverse_match(const UChar* s, const UChar* end, OnigEncoding enc ARG_UNUSED) {   const UChar c = *s;   return (SJIS_ISMB_TRAIL(c) ? FALSE : TRUE); }"
"473979_not_vulnerable.cpp","not_vulnerable","unpack_entries(register st_table *table) {     st_index_t i;     struct st_table_entry *packed_bins[MAX_PACKED_NUMHASH*2];     st_table tmp_table = *table;      memcpy(packed_bins, table->bins, sizeof(struct st_table_entry *) * table->num_entries*2);     table->bins = packed_bins;     tmp_table.entries_packed = 0;     tmp_table.num_entries = 0;     memset(tmp_table.bins, 0, sizeof(struct st_table_entry *) * tmp_table.num_bins);     for (i = 0; i < table->num_entries; i++) {         st_insert(&tmp_table, (st_data_t)packed_bins[i*2], (st_data_t)packed_bins[i*2+1]);     }     *table = tmp_table; }"
"473982_not_vulnerable.c","not_vulnerable","bm_search(regex_t* reg, const UChar* target, const UChar* target_end, 	  const UChar* text, const UChar* text_end, const UChar* text_range) {   const UChar *s, *t, *p, *end;   const UChar *tail;  #ifdef ONIG_DEBUG_SEARCH   fprintf(stderr, ""bm_search: text: %""PRIuPTR"", text_end: %""PRIuPTR"", text_range: %""PRIuPTR""\n"", 	  text, text_end, text_range); #endif    end = text_range + (target_end - target) - 1;   if (end > text_end)     end = text_end;    tail = target_end - 1;   s = text + (target_end - target) - 1;   if (IS_NULL(reg->int_map)) {     while (s < end) {       p = s;       t = tail; #ifdef ONIG_DEBUG_SEARCH   fprintf(stderr, ""bm_search_loop: pos: %d %s\n"", 	  (int)(s - text), s); #endif       while (*p == *t) { 	if (t == target) return (UChar* )p; 	p--; t--;       }       s += reg->map[*s];     }   }   else { /* see int_map[] */     while (s < end) {       p = s;       t = tail;       while (*p == *t) { 	if (t == target) return (UChar* )p; 	p--; t--;       }       s += reg->int_map[*s];     }   }   return (UChar* )NULL; }"
"474057_not_vulnerable.c","not_vulnerable","uniname2ctype_p (str, len)      register const char *str;      register unsigned int len; {   static const struct uniname2ctype_struct wordlist[] =     { #ifdef USE_UNICODE_PROPERTIES       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str3,                                        33},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str5,                                        23},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str7,                                       35},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str8,                                       24},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str10,                                       20},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str11,                                       36},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str12,                                       26},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str13,                                        17},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str16,                                       21},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str20,                                       18},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str21,                                      93},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str22,                                     93},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str23,                                    150},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str26,                                       59},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str29,                                    127},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str30,                                     142},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str31,                                    142},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str32,                                    113},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str34,                                  18},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str37,                                    147},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str40,                                  147},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str42,                                       51},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str44,                                    86},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str46,                                     74},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str47,                                     3},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str48,                                    74},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str51,                                     108},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str53,                                   79},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str54,                                    110},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str55,                                    115},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str60,                                    108},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str63,                                 115},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str66,                                       27},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str67,                                       49},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str69,                                    105},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str70,                                   184},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str71,                                       46},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str73,                                        50},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str74,                                  178},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str75,                                    151},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str76,                                    100},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str84,                                    157},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str88,                                    113},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str89,                                     81},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str90,                                     92},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str91,                       197},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str92,                                  91},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str93,                                   170},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str94,                                    14},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str95,                       42},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str98,                                    17},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str99,                             170},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str100,                                   81},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str101,                                    152},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str103,                                  182},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str105,                              36},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str106,                              26},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str109,                                     91},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str112,                                    119},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str114,                     38},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str115,                                        45},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str116,                                       69},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str117,                                      197},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str119,                                    195},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str120,                                      66},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str121,                                     190},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str122,                                       22},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str123,                                 152},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str124,                                     180},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str125,                                     99},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str126,                   161},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str128,                                 122},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str137,                                 188},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str143,                                     193},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str147,                               180},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str148,                                    200},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str149,                                     98},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str151,                      100},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str152,                                       53},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str153,                              49},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str156,                               110},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str161,                    162},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str162,                                 151},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str163,                            51},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str166,                            194},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str170,                                    194},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str171,                           177},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str172,                               113},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str174,                          182},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str175,                     174},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str176,                                     82},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str179,                         178},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str180,                                    179},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str181,                   184},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str183,                         195},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str187,                                   119},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str190,                              132},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str192,                               82},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str193,                                   23},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str195,                                       34},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str197,                                    187},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str198,                                    112},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str200,                          27},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str202,                                       43},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str203,                                    171},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str206,                                       38},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str209,                             35},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str212,                                       42},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str215,                                157},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str217,                                       32},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str218,                                  65},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str220,                               66},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str222,                                      65},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str223,                                     1},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str227,                                       30},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str229,                                  127},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str234,                               104},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str235,                                   73},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str236,                                     77},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str237,                                    127},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str243,                                    124},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str244,                                    159},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str245,                                    162},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str246,                                    161},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str250,                                 77},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str251,                                      192},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str252,                                 167},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str255,                              136},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str258,                                     87},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str261,                                    87},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str268,                                    58},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str269,                                    149},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str270,                       186},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str271,                                    140},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str275,          190},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str278,                                     7},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str286,                                    123},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str292,                                    154},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str294,                                     54},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str296,                                    120},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str297,                         40},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str301,                         43},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str303,                                    134},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str306,                                   175},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str307,                               154},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str308,                                       44},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str310,                                     79},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str311,                                    125},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str314,                                 150},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str317,                                 120},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str321,                                  140},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str322,                                    167},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str324,                                    158},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str325,                                    174},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str326,                              129},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str327,                               21},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str328,                                       40},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str335,                                 112},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str340,                                    166},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str341,                                    102},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str343,                               175},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str344,                                   102},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str345,                                     97},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str346,                                 98},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str349,                                       31},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str350,                                   198},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str353,                                50},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str355,                                     94},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str356,                                  111},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str358,                                117},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str359,                                    160},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str361,                                    128},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str367,                                  94},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str371,                                    111},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str372,                                    145},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str373,                                   97},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str374,                                  83},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str375,                                105},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str376,                                 125},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str379,                                     96},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str380,                                 201},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str381,                                 203},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str382,                                 210},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str383,                                 211},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str384,                                 208},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str385,                                        37},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str386,                                       39},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str388,                                    155},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str389,                                 202},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str390,                                 209},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str391,                                 212},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str392,                                 207},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str393,                                     5},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str395,                                    143},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str396,                                     9},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str397,                                 205},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str398,                                 206},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str399,                                     78},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str402,                                   169},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str405,                                 204},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str408,                             169},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str413,                   193},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str420,                                     88},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str422,                                       52},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str427,                                        29},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str430,                                       25},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str432,                      187},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str433,                                134},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str434,                                   189},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str436,                           53},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str438,                                    70},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str442,                                    13},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str443,                               163},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str445,                                     68},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str446,                                    186},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str447,                                    177},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str452,                                   19},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str456,                            59},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str457,                                130},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str459,                               139},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str462,                                     181},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str464,                              143},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str465,                       198},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str466,                                     4},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str474,                                    139},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str480,                            34},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str484,                                    107},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str485,                                       48},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str488,                          183},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str493,                             179},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str496,                                     67},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str497,                               20},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str502,                                 137},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str506,                               55},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str508,                                    118},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str512,                                   11},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str513,                                 67},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str516,                                    104},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str518,                              68},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str521,                                 16},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str523,                                    101},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str529,                                     138},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str530,                                    138},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str533,                                    141},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str534,                              191},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str535,                                  166},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str536,                                    137},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str538,                                    106},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str540,                                    144},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str542,                    60},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str543,                                181},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str550,                                     191},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str554,                                 141},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str562,                                      60},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str563,                             71},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str565,                                    136},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str573,                                    163},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str576,                                     8},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str577,                                    133},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str580,                                     6},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str586,                                   196},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str587,                                      109},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str588,                                    146},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str589,                                     76},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str591,                                  146},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str592,                         41},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str593,                                     86},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str594,                           70},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str596,                                  164},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str597,                                    132},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str598,                                    109},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str599,                                    164},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str601,                                 76},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str602,                                    129},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str605,                                  183},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str617,                                    117},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str620,                                      62},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str623,                                   33},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str625,                                    114},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str626,                                     89},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str627,                          24},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str628,                    62},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str629,                              192},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str632,                                    121},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str634,                                    131},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str636,                                       28},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str640,                                 114},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str643,                              133},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str644,                                     80},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str645,                                  89},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str646,                                     83},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str647,                                56},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str656,                                    122},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str659,                           199},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str660,                                   80},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str663,                                     12},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str667,                         159},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str672,                                121},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str675,                            31},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str677,                                 96},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str678,                                    148},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str681,                                  148},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str686,                             131},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str687,                                     85},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str692,                                    130},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str696,                           46},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str701,                                   0},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str705,                                107},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str706,                                  185},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str707,                                 99},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str708,                                 85},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str710,                               128},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str716,                          39},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str718,                         160},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str725,                                    10},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str732,                                       19},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str734,                                    116},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str735,                                  145},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str736,                     185},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str739,                           25},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str745,                           32},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str749,                    64},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str752,                                     29},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str757,                                22},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str765,                       52},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str767,                                   101},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str768,                                     176},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str772,                          28},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str777,                                176},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str778,                                     64},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str781,                                   71},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str782,                                    103},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str788,                        189},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str792,                                57},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str793,                                   103},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str795,                              30},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str797,                              168},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str806,                                  199},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str816,                                 124},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str818,                          44},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str821,                                    156},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str831,                                   116},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str840,                                    165},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str851,                                   45},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str856,                    61},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str857,                                 123},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str861,                                   118},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str868,                              37},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str872,                                  172},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str888,                               48},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str892,                                     75},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str898,                    63},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str902,                           173},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str903,                                    126},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str916,                               135},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str918,                                       41},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str927,                                     63},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str932,                                   156},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str940,                                     84},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str944,                                  168},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str951,                             158},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str976,                69},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str980,                           47},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str999,                                     90},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1007,                                     95},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1020,                                90},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1026,                                  95},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1032,                                   88},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1033,                                126},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1037,                                    135},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1093,                                       47},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1097,                                106},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1124,                                    153},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1146,                                      15},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1148,                                 144},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1190,                                      61},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1263,                                   173},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1329,                                     2},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1347,                                   72},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1358,                                   165},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1395,                                 200},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1410,                                    75},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, #endif /* USE_UNICODE_PROPERTIES */       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, #ifndef USE_UNICODE_PROPERTIES       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str7,                                     7},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str8,                                     8},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str9,                                     1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str10,                                    13},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str11,                                   11},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str12,                                   0},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str13,                                    10},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str14,                                    14},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str15,                                     3},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str16,                                     9},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str17,                                     12},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str18,                                     6},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str19,                                     5},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str20,                                     4},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str21,                                     2} #else /* USE_UNICODE_PROPERTIES */       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1463,                             72},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1470,                                 84},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1556,                                   78},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1621,                     153},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},       {-1}, {-1},       {(int)(long)&((struct uniname2ctype_pool_t *)0)->uniname2ctype_pool_str1741,                                     73} #endif /* USE_UNICODE_PROPERTIES */     };    if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)     {       register int key = uniname2ctype_hash (str, len);        if (key <= MAX_HASH_VALUE && key >= 0)         {           register int o = wordlist[key].name;           if (o >= 0)             {               register const char *s = o + uniname2ctype_pool;                if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')                 return &wordlist[key];             }         }     }   return 0; }"
"474080_not_vulnerable.c","not_vulnerable","print_optimize_info(FILE* f, regex_t* reg) {   static const char* on[] = { ""NONE"", ""EXACT"", ""EXACT_BM"", ""EXACT_BM_NOT_REV"",                               ""EXACT_IC"", ""MAP"" };    fprintf(f, ""optimize: %s\n"", on[reg->optimize]);   fprintf(f, ""  anchor: ""); print_anchor(f, reg->anchor);   if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)     print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);   fprintf(f, ""\n"");    if (reg->optimize) {     fprintf(f, ""  sub anchor: ""); print_anchor(f, reg->sub_anchor);     fprintf(f, ""\n"");   }   fprintf(f, ""\n"");    if (reg->exact) {     UChar *p;     fprintf(f, ""exact: ["");     for (p = reg->exact; p < reg->exact_end; p++) {       fputc(*p, f);     }     fprintf(f, ""]: length: %ld\n"", (reg->exact_end - reg->exact));   }   else if (reg->optimize & ONIG_OPTIMIZE_MAP) {     int c, i, n = 0;      for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)       if (reg->map[i]) n++;      fprintf(f, ""map: n=%d\n"", n);     if (n > 0) {       c = 0;       fputc('[', f);       for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) { 	if (reg->map[i] != 0) {           if (c > 0)  fputs("", "", f);           c++;           if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&               ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))             fputc(i, f);           else             fprintf(f, ""%d"", i);         }       }       fprintf(f, ""]\n"");     }   } }"
"477385_not_vulnerable.c","not_vulnerable","R_API RBinJavaAttrInfo *r_bin_java_read_next_attr(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 buf_len) { 	RBinJavaAttrInfo *attr = NULL; 	ut32 sz = 0; 	ut8 *buffer = NULL; 	const ut8 *a_buf = offset + buf; 	ut8 attr_idx_len = 6; 	if (offset + 6 > buf_len) { 		eprintf (""[X] r_bin_java: Error unable to parse remainder of classfile in Attribute offset "" 			""(0x%""PFMT64x "") > len  of remaining bytes (0x%""PFMT64x "").\n"", offset, buf_len); 		return NULL; 	} 	// ut16 attr_idx, ut32 length of attr. 	sz = R_BIN_JAVA_UINT (a_buf, 2) + attr_idx_len; // r_bin_java_read_int (bin, buf_offset+2) + attr_idx_len; 	if (sz + offset > buf_len) { 		eprintf (""[X] r_bin_java: Error unable to parse remainder of classfile in Attribute len "" 			""(0x%x) + offset (0x%""PFMT64x "") exceeds length of buffer (0x%""PFMT64x "").\n"", 			sz, offset, buf_len); 		return NULL; 	} 	// when reading the attr bytes, need to also 	// include the initial 6 bytes, which 	// are not included in the attribute length 	// , 	// sz, buf_offset, buf_offset+sz); 	buffer = r_bin_java_get_attr_buf (bin, sz, offset, buf, buf_len); 	// printf (""%d %d %d\n"", sz, buf_len, offset); 	if (offset < buf_len) { 		attr = r_bin_java_read_next_attr_from_buffer (bin, buffer, buf_len - offset, offset); 		free (buffer);  		if (!attr) { 			return NULL; 		} 		attr->size = sz; 	} else { 		free (buffer); 		eprintf (""IS OOB\n""); 	} 	return attr; }"
"482530_not_vulnerable.c","not_vulnerable","hexValue(const FileInfo *file, const widechar *digits, int length) { 	int k; 	unsigned int binaryValue = 0; 	for (k = 0; k < length; k++) { 		unsigned int hexDigit = 0; 		if (digits[k] >= '0' && digits[k] <= '9') 			hexDigit = digits[k] - '0'; 		else if (digits[k] >= 'a' && digits[k] <= 'f') 			hexDigit = digits[k] - 'a' + 10; 		else if (digits[k] >= 'A' && digits[k] <= 'F') 			hexDigit = digits[k] - 'A' + 10; 		else { 			compileError(file, ""invalid %d-digit hexadecimal number"", length); 			return (widechar)0xffffffff; 		} 		binaryValue |= hexDigit << (4 * (length - 1 - k)); 	} 	return (widechar)binaryValue; }"
"482684_not_vulnerable.c","not_vulnerable","gst_flxdec_change_state (GstElement * element, GstStateChange transition) {   GstFlxDec *flxdec;   GstStateChangeReturn ret;    flxdec = GST_FLXDEC (element);    switch (transition) {     case GST_STATE_CHANGE_NULL_TO_READY:       break;     case GST_STATE_CHANGE_READY_TO_PAUSED:       gst_adapter_clear (flxdec->adapter);       flxdec->state = GST_FLXDEC_READ_HEADER;       break;     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:       break;     default:       break;   }    ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);    switch (transition) {     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:       break;     case GST_STATE_CHANGE_PAUSED_TO_READY:       if (flxdec->frame_data) {         g_free (flxdec->frame_data);         flxdec->frame_data = NULL;       }       if (flxdec->delta_data) {         g_free (flxdec->delta_data);         flxdec->delta_data = NULL;       }       if (flxdec->converter) {         flx_colorspace_converter_destroy (flxdec->converter);         flxdec->converter = NULL;       }       break;     case GST_STATE_CHANGE_READY_TO_NULL:       break;     default:       break;   }   return ret; }"
"482688_not_vulnerable.c","not_vulnerable","flx_decode_delta_flc (GstFlxDec * flxdec, guchar * data, guchar * dest) {   gulong count, lines, start_l, opcode;   guchar *start_p;    g_return_val_if_fail (flxdec != NULL, FALSE);   g_return_val_if_fail (flxdec->delta_data != NULL, FALSE);    /* use last frame for delta */   memcpy (dest, flxdec->delta_data, flxdec->size);    lines = (data[0] + (data[1] << 8));   if (lines > flxdec->hdr.height) {     GST_ERROR_OBJECT (flxdec, ""Invalid FLC packet detected. too many lines."");     return FALSE;   }   data += 2;    start_p = dest;   start_l = lines;    while (lines) {     dest = start_p + (flxdec->hdr.width * (start_l - lines));      /* process opcode(s) */     while ((opcode = (data[0] + (data[1] << 8))) & 0xc000) {       data += 2;       if ((opcode & 0xc000) == 0xc000) {         /* line skip count */         gulong skip = (0x10000 - opcode);         if (skip > flxdec->hdr.height) {           GST_ERROR_OBJECT (flxdec, ""Invalid FLC packet detected. ""               ""skip line count too big."");           return FALSE;         }         start_l += skip;         dest += flxdec->hdr.width * skip;       } else {         /* last pixel */         dest += flxdec->hdr.width;         *dest++ = (opcode & 0xff);       }     }     data += 2;      /* last opcode is the packet count */     while (opcode--) {       /* skip count */       guchar skip = *data++;       dest += skip;        /* RLE count */       count = *data++;        if (count > 0x7f) {         /* replicate word run */         count = 0x100 - count;          if (skip + count > flxdec->hdr.width) {           GST_ERROR_OBJECT (flxdec, ""Invalid FLC packet detected. ""               ""line too long."");           return FALSE;         }          while (count--) {           *dest++ = data[0];           *dest++ = data[1];         }         data += 2;       } else {         if (skip + count > flxdec->hdr.width) {           GST_ERROR_OBJECT (flxdec, ""Invalid FLC packet detected. ""               ""line too long."");           return FALSE;         }          /* literal word run */         while (count--) {           *dest++ = *data++;           *dest++ = *data++;         }       }     }     lines--;   }    return TRUE; }"
"484710_not_vulnerable.c","not_vulnerable","void mobi_buffer_add8(MOBIBuffer *buf, const uint8_t data) {     if (buf->offset + 1 > buf->maxlen) {         debug_print(""%s"", ""Buffer full\n"");         buf->error = MOBI_BUFFER_END;         return;     }     buf->data[buf->offset++] = data; }"
"484716_not_vulnerable.c","not_vulnerable","void mobi_buffer_addraw(MOBIBuffer *buf, const unsigned char* data, const size_t len) {     if (buf->offset + len > buf->maxlen) {         debug_print(""%s"", ""Buffer full\n"");         buf->error = MOBI_BUFFER_END;         return;     }     memcpy(buf->data + buf->offset, data, len);     buf->offset += len; }"
"484735_not_vulnerable.c","not_vulnerable","void mobi_buffer_dup8(uint8_t **val, MOBIBuffer *buf) {     *val = NULL;     if (buf->offset + 1 > buf->maxlen) {         return;     }     *val = malloc(sizeof(uint8_t));     if (*val == NULL) {         return;     }     **val = mobi_buffer_get8(buf); }"
"484737_not_vulnerable.c","not_vulnerable","uint32_t mobi_buffer_get_varlen(MOBIBuffer *buf, size_t *len) {     return _buffer_get_varlen(buf, len, 1); }"
"484764_not_vulnerable.c","not_vulnerable","static int xennet_init_queue(struct netfront_queue *queue) { 	unsigned short i; 	int err = 0; 	char *devid;  	spin_lock_init(&queue->tx_lock); 	spin_lock_init(&queue->rx_lock); 	spin_lock_init(&queue->rx_cons_lock);  	timer_setup(&queue->rx_refill_timer, rx_refill_timeout, 0);  	devid = strrchr(queue->info->xbdev->nodename, '/') + 1; 	snprintf(queue->name, sizeof(queue->name), ""vif%s-q%u"", 		 devid, queue->id);  	/* Initialise tx_skb_freelist as a free chain containing every entry. */ 	queue->tx_skb_freelist = 0; 	queue->tx_pend_queue = TX_LINK_NONE; 	for (i = 0; i < NET_TX_RING_SIZE; i++) { 		queue->tx_link[i] = i + 1; 		queue->grant_tx_ref[i] = INVALID_GRANT_REF; 		queue->grant_tx_page[i] = NULL; 	} 	queue->tx_link[NET_TX_RING_SIZE - 1] = TX_LINK_NONE;  	/* Clear out rx_skbs */ 	for (i = 0; i < NET_RX_RING_SIZE; i++) { 		queue->rx_skbs[i] = NULL; 		queue->grant_rx_ref[i] = INVALID_GRANT_REF; 	}  	/* A grant for every tx ring slot */ 	if (gnttab_alloc_grant_references(NET_TX_RING_SIZE, 					  &queue->gref_tx_head) < 0) { 		pr_alert(""can't alloc tx grant refs\n""); 		err = -ENOMEM; 		goto exit; 	}  	/* A grant for every rx ring slot */ 	if (gnttab_alloc_grant_references(NET_RX_RING_SIZE, 					  &queue->gref_rx_head) < 0) { 		pr_alert(""can't alloc rx grant refs\n""); 		err = -ENOMEM; 		goto exit_free_tx; 	}  	return 0;   exit_free_tx: 	gnttab_free_grant_references(queue->gref_tx_head);  exit: 	return err; }"
"484765_not_vulnerable.c","not_vulnerable","static int xennet_rxidx(RING_IDX idx) { 	return idx & (NET_RX_RING_SIZE - 1); }"
"484775_not_vulnerable.c","not_vulnerable","static netdev_features_t xennet_fix_features(struct net_device *dev, 	netdev_features_t features) { 	struct netfront_info *np = netdev_priv(dev);  	if (features & NETIF_F_SG && 	    !xenbus_read_unsigned(np->xbdev->otherend, ""feature-sg"", 0)) 		features &= ~NETIF_F_SG;  	if (features & NETIF_F_IPV6_CSUM && 	    !xenbus_read_unsigned(np->xbdev->otherend, 				  ""feature-ipv6-csum-offload"", 0)) 		features &= ~NETIF_F_IPV6_CSUM;  	if (features & NETIF_F_TSO && 	    !xenbus_read_unsigned(np->xbdev->otherend, ""feature-gso-tcpv4"", 0)) 		features &= ~NETIF_F_TSO;  	if (features & NETIF_F_TSO6 && 	    !xenbus_read_unsigned(np->xbdev->otherend, ""feature-gso-tcpv6"", 0)) 		features &= ~NETIF_F_TSO6;  	return features; }"
"484806_not_vulnerable.c","not_vulnerable","static void xennet_tx_setup_grant(unsigned long gfn, unsigned int offset, 				  unsigned int len, void *data) { 	struct xennet_gnttab_make_txreq *info = data; 	unsigned int id; 	struct xen_netif_tx_request *tx; 	grant_ref_t ref; 	/* convenient aliases */ 	struct page *page = info->page; 	struct netfront_queue *queue = info->queue; 	struct sk_buff *skb = info->skb;  	id = get_id_from_list(&queue->tx_skb_freelist, queue->tx_link); 	tx = RING_GET_REQUEST(&queue->tx, queue->tx.req_prod_pvt++); 	ref = gnttab_claim_grant_reference(&queue->gref_tx_head); 	WARN_ON_ONCE(IS_ERR_VALUE((unsigned long)(int)ref));  	gnttab_grant_foreign_access_ref(ref, queue->info->xbdev->otherend_id, 					gfn, GNTMAP_readonly);  	queue->tx_skbs[id] = skb; 	queue->grant_tx_page[id] = page; 	queue->grant_tx_ref[id] = ref;  	info->tx_local.id = id; 	info->tx_local.gref = ref; 	info->tx_local.offset = offset; 	info->tx_local.size = len; 	info->tx_local.flags = 0;  	*tx = info->tx_local;  	/* 	 * Put the request in the pending queue, it will be set to be pending 	 * when the producer index is about to be raised. 	 */ 	add_id_to_list(&queue->tx_pend_queue, queue->tx_link, id);  	info->tx = tx; 	info->size += info->tx_local.size; }"
"487624_not_vulnerable.c","not_vulnerable","asmlinkage long sys_sethostname(char __user *name, int len) { 	int errno; 	char tmp[__NEW_UTS_LEN];  	if (!capable(CAP_SYS_ADMIN)) 		return -EPERM; 	if (len < 0 || len > __NEW_UTS_LEN) 		return -EINVAL; 	down_write(&uts_sem); 	errno = -EFAULT; 	if (!copy_from_user(tmp, name, len)) { 		memcpy(utsname()->nodename, tmp, len); 		utsname()->nodename[len] = 0; 		errno = 0; 	} 	up_write(&uts_sem); 	return errno; }"
"487665_not_vulnerable.c","not_vulnerable","asmlinkage long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid) { 	int retval;  	if (!(retval = put_user(current->gid, rgid)) && 	    !(retval = put_user(current->egid, egid))) 		retval = put_user(current->sgid, sgid);  	return retval; }"
"488354_not_vulnerable.c","not_vulnerable","static void remove_anon_migration_ptes(struct page *old, struct page *new) { 	struct anon_vma *anon_vma; 	struct vm_area_struct *vma; 	unsigned long mapping;  	mapping = (unsigned long)new->mapping;  	if (!mapping || (mapping & PAGE_MAPPING_ANON) == 0) 		return;  	/* 	 * We hold the mmap_sem lock. So no need to call page_lock_anon_vma. 	 */ 	anon_vma = (struct anon_vma *) (mapping - PAGE_MAPPING_ANON); 	spin_lock(&anon_vma->lock);  	list_for_each_entry(vma, &anon_vma->head, anon_vma_node) 		remove_migration_pte(vma, old, new);  	spin_unlock(&anon_vma->lock); }"
"488386_not_vulnerable.cpp","not_vulnerable","int arch_setup_additional_pages(struct linux_binprm *bprm, 				int executable_stack) { 	struct mm_struct *mm = current->mm; 	struct page **vdso_pagelist; 	unsigned long vdso_pages; 	unsigned long vdso_base; 	int rc;  	if (!vdso_ready) 		return 0;  #ifdef CONFIG_PPC64 	if (test_thread_flag(TIF_32BIT)) { 		vdso_pagelist = vdso32_pagelist; 		vdso_pages = vdso32_pages; 		vdso_base = VDSO32_MBASE; 	} else { 		vdso_pagelist = vdso64_pagelist; 		vdso_pages = vdso64_pages; 		vdso_base = VDSO64_MBASE; 	} #else 	vdso_pagelist = vdso32_pagelist; 	vdso_pages = vdso32_pages; 	vdso_base = VDSO32_MBASE; #endif  	current->mm->context.vdso_base = 0;  	/* vDSO has a problem and was disabled, just don't ""enable"" it for the 	 * process 	 */ 	if (vdso_pages == 0) 		return 0; 	/* Add a page to the vdso size for the data page */ 	vdso_pages ++;  	/* 	 * pick a base address for the vDSO in process space. We try to put it 	 * at vdso_base which is the ""natural"" base for it, but we might fail 	 * and end up putting it elsewhere. 	 */ 	down_write(&mm->mmap_sem); 	vdso_base = get_unmapped_area(NULL, vdso_base, 				      vdso_pages << PAGE_SHIFT, 0, 0); 	if (IS_ERR_VALUE(vdso_base)) { 		rc = vdso_base; 		goto fail_mmapsem; 	}  	/* 	 * our vma flags don't have VM_WRITE so by default, the process isn't 	 * allowed to write those pages. 	 * gdb can break that with ptrace interface, and thus trigger COW on 	 * those pages but it's then your responsibility to never do that on 	 * the ""data"" page of the vDSO or you'll stop getting kernel updates 	 * and your nice userland gettimeofday will be totally dead. 	 * It's fine to use that for setting breakpoints in the vDSO code 	 * pages though 	 * 	 * Make sure the vDSO gets into every core dump. 	 * Dumping its contents makes post-mortem fully interpretable later 	 * without matching up the same kernel and hardware config to see 	 * what PC values meant. 	 */ 	rc = install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT, 				     VM_READ|VM_EXEC| 				     VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC| 				     VM_ALWAYSDUMP, 				     vdso_pagelist); 	if (rc) 		goto fail_mmapsem;  	/* Put vDSO base into mm struct */ 	current->mm->context.vdso_base = vdso_base;  	up_write(&mm->mmap_sem); 	return 0;   fail_mmapsem: 	up_write(&mm->mmap_sem); 	return rc; }"
"488426_not_vulnerable.c","not_vulnerable","static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd, 				     unsigned long addr, unsigned long end, 				     pte_fn_t fn, void *data) { 	pte_t *pte; 	int err; 	pgtable_t token; 	spinlock_t *uninitialized_var(ptl);  	pte = (mm == &init_mm) ? 		pte_alloc_kernel(pmd, addr) : 		pte_alloc_map_lock(mm, pmd, addr, &ptl); 	if (!pte) 		return -ENOMEM;  	BUG_ON(pmd_huge(*pmd));  	token = pmd_pgtable(*pmd);  	do { 		err = fn(pte, token, addr, data); 		if (err) 			break; 	} while (pte++, addr += PAGE_SIZE, addr != end);  	if (mm != &init_mm) 		pte_unmap_unlock(pte-1, ptl); 	return err; }"
"491910_not_vulnerable.c","not_vulnerable","static ssize_t fuse_perform_write(struct file *file, 				  struct address_space *mapping, 				  struct iov_iter *ii, loff_t pos) { 	struct inode *inode = mapping->host; 	struct fuse_conn *fc = get_fuse_conn(inode); 	int err = 0; 	ssize_t res = 0;  	if (is_bad_inode(inode)) 		return -EIO;  	do { 		struct fuse_req *req; 		ssize_t count;  		req = fuse_get_req(fc); 		if (IS_ERR(req)) { 			err = PTR_ERR(req); 			break; 		}  		count = fuse_fill_write_pages(req, mapping, ii, pos); 		if (count <= 0) { 			err = count; 		} else { 			size_t num_written;  			num_written = fuse_send_write_pages(req, file, inode, 							    pos, count); 			err = req->out.h.error; 			if (!err) { 				res += num_written; 				pos += num_written;  				/* break out of the loop on short write */ 				if (num_written != count) 					err = -EIO; 			} 		} 		fuse_put_request(fc, req); 	} while (!err && iov_iter_count(ii));  	if (res > 0) 		fuse_write_update_size(inode, pos);  	fuse_invalidate_attr(inode);  	return res > 0 ? res : err; }"
"491925_not_vulnerable.c","not_vulnerable","static long fuse_file_ioctl(struct file *file, unsigned int cmd, 			    unsigned long arg) { 	return fuse_file_ioctl_common(file, cmd, arg, 0); }"
"492694_not_vulnerable.c","not_vulnerable","vte_sequence_handler_sr (VteTerminal *terminal, GValueArray *params) { 	long start, end; 	VteScreen *screen;  	screen = terminal->pvt->screen;  	if (screen->scrolling_restricted) { 		start = screen->scrolling_region.start + screen->insert_delta; 		end = screen->scrolling_region.end + screen->insert_delta; 	} else { 		start = terminal->pvt->screen->insert_delta; 		end = start + terminal->row_count - 1; 	}  	if (screen->cursor_current.row == start) { 		/* If we're at the top of the scrolling region, add a 		 * line at the top to scroll the bottom off. */ 		_vte_terminal_ring_remove (terminal, end); 		_vte_terminal_ring_insert (terminal, start, TRUE); 		/* Update the display. */ 		_vte_terminal_scroll_region(terminal, start, end - start + 1, 1); 		_vte_invalidate_cells(terminal, 				      0, terminal->column_count, 				      start, 2); 	} else { 		/* Otherwise, just move the cursor up. */ 		screen->cursor_current.row--; 	} 	/* Adjust the scrollbars if necessary. */ 	_vte_terminal_adjust_adjustments(terminal); 	/* We modified the display, so make a note of it. */ 	terminal->pvt->text_modified_flag = TRUE; }"
"498618_not_vulnerable.c","not_vulnerable","bgr2rgb (guchar       *dest,          const guchar *src,          guint         width,          guint         bytes,          guint         alpha) {   guint x;    if (alpha)     {       for (x = 0; x < width; x++)         {           *(dest++) = src[2];           *(dest++) = src[1];           *(dest++) = src[0];           *(dest++) = src[3];            src += bytes;         }     }   else     {       for (x = 0; x < width; x++)         {           *(dest++) = src[2];           *(dest++) = src[1];           *(dest++) = src[0];            src += bytes;         }     } }"
"500635_not_vulnerable.c","not_vulnerable","sftp_dir sftp_opendir(sftp_session sftp, const char *path){   sftp_message msg = NULL;   sftp_file file = NULL;   sftp_dir dir = NULL;   sftp_status_message status;   ssh_string path_s;   ssh_buffer payload;   uint32_t id;    payload = ssh_buffer_new();   if (payload == NULL) {     ssh_set_error_oom(sftp->session);     return NULL;   }    path_s = ssh_string_from_char(path);   if (path_s == NULL) {     ssh_set_error_oom(sftp->session);     ssh_buffer_free(payload);     return NULL;   }    id = sftp_get_new_id(sftp);   if (buffer_add_u32(payload, id) < 0 ||       buffer_add_ssh_string(payload, path_s) < 0) {     ssh_set_error_oom(sftp->session);     ssh_buffer_free(payload);     ssh_string_free(path_s);     return NULL;   }   ssh_string_free(path_s);    if (sftp_packet_write(sftp, SSH_FXP_OPENDIR, payload) < 0) {     ssh_buffer_free(payload);     return NULL;   }   ssh_buffer_free(payload);    while (msg == NULL) {     if (sftp_read_and_dispatch(sftp) < 0) {       /* something nasty has happened */       return NULL;     }     msg = sftp_dequeue(sftp, id);   }    switch (msg->packet_type) {     case SSH_FXP_STATUS:       status = parse_status_msg(msg);       sftp_message_free(msg);       if (status == NULL) {         return NULL;       }       sftp_set_error(sftp, status->status);       ssh_set_error(sftp->session, SSH_REQUEST_DENIED,           ""SFTP server: %s"", status->errormsg);       status_msg_free(status);       return NULL;     case SSH_FXP_HANDLE:       file = parse_handle_msg(msg);       sftp_message_free(msg);       if (file != NULL) {         dir = malloc(sizeof(struct sftp_dir_struct));         if (dir == NULL) {           ssh_set_error_oom(sftp->session);           return NULL;         }         ZERO_STRUCTP(dir);          dir->sftp = sftp;         dir->name = strdup(path);         if (dir->name == NULL) {           SAFE_FREE(dir);           SAFE_FREE(file);           return NULL;         }         dir->handle = file->handle;         SAFE_FREE(file);       }       return dir;     default:       ssh_set_error(sftp->session, SSH_FATAL,           ""Received message %d during opendir!"", msg->packet_type);       sftp_message_free(msg);   }    return NULL; }"
"500643_not_vulnerable.c","not_vulnerable","void sftp_free(sftp_session sftp){   sftp_request_queue ptr;    if (sftp == NULL) {     return;   }    ssh_channel_send_eof(sftp->channel);   ptr = sftp->queue;   while(ptr) {     sftp_request_queue old;     sftp_message_free(ptr->message);     old = ptr->next;     SAFE_FREE(ptr);     ptr = old;   }    ssh_channel_free(sftp->channel);   sftp_ext_free(sftp->ext);   ZERO_STRUCTP(sftp);    SAFE_FREE(sftp); }"
"500666_not_vulnerable.c","not_vulnerable","int sftp_setstat(sftp_session sftp, const char *file, sftp_attributes attr) {   uint32_t id;   ssh_buffer buffer;   ssh_string path;   sftp_message msg = NULL;   sftp_status_message status = NULL;    buffer = ssh_buffer_new();   if (buffer == NULL) {     ssh_set_error_oom(sftp->session);     return -1;   }    path = ssh_string_from_char(file);   if (path == NULL) {     ssh_set_error_oom(sftp->session);     ssh_buffer_free(buffer);     return -1;   }    id = sftp_get_new_id(sftp);   if (buffer_add_u32(buffer, id) < 0 ||       buffer_add_ssh_string(buffer, path) < 0 ||       buffer_add_attributes(buffer, attr) < 0) {     ssh_set_error_oom(sftp->session);     ssh_buffer_free(buffer);     ssh_string_free(path);     return -1;   }   if (sftp_packet_write(sftp, SSH_FXP_SETSTAT, buffer) < 0) {     ssh_buffer_free(buffer);     ssh_string_free(path);     return -1;   }   ssh_buffer_free(buffer);   ssh_string_free(path);    while (msg == NULL) {     if (sftp_read_and_dispatch(sftp) < 0) {       return -1;     }     msg = sftp_dequeue(sftp, id);   }    /* By specification, this command only returns SSH_FXP_STATUS */   if (msg->packet_type == SSH_FXP_STATUS) {     status = parse_status_msg(msg);     sftp_message_free(msg);     if (status == NULL) {       return -1;     }     sftp_set_error(sftp, status->status);     switch (status->status) {       case SSH_FX_OK:         status_msg_free(status);         return 0;       default:         break;     }     /*      * The status should be SSH_FX_OK if the command was successful, if it      * didn't, then there was an error      */     ssh_set_error(sftp->session, SSH_REQUEST_DENIED,         ""SFTP server: %s"", status->errormsg);     status_msg_free(status);     return -1;   } else {     ssh_set_error(sftp->session, SSH_FATAL,         ""Received message %d when attempting to set stats"", msg->packet_type);     sftp_message_free(msg);   }    return -1; }"
"503875_not_vulnerable.cpp","not_vulnerable","SCM_DEFINE (scm_link, ""link"", 2, 0, 0,             (SCM oldpath, SCM newpath), 	    ""Creates a new name @var{newpath} in the file system for the\n"" 	    ""file named by @var{oldpath}.  If @var{oldpath} is a symbolic\n"" 	    ""link, the link may or may not be followed depending on the\n"" 	    ""system."") #define FUNC_NAME s_scm_link {   int val;    STRING2_SYSCALL (oldpath, c_oldpath, 		   newpath, c_newpath, 		   val = link (c_oldpath, c_newpath));   if (val != 0)     SCM_SYSERROR;   return SCM_UNSPECIFIED; }"
"506431_not_vulnerable.c","not_vulnerable","buffer_append_asn1_length(buffer_t *buf, unsigned int length) { 	if (length < 0x80) { 		buffer_append_c(buf, length); 	} else if (length < 0x100) { 		buffer_append_c(buf, 0x81); 		buffer_append_c(buf, length); 	} else { 		buffer_append_c(buf, 0x82); 		buffer_append_c(buf, length >> 8); 		buffer_append_c(buf, length & 0xff); 	} }"
"506699_not_vulnerable.c","not_vulnerable","static int run_cert(X509 *crt, const char *nameincert,                      const struct set_name_fn *fn) {     const char *const *pname = names;     int failed = 0;      for (; *pname != NULL; ++pname) {         int samename = strcasecmp(nameincert, *pname) == 0;         size_t namelen = strlen(*pname);         char *name = OPENSSL_malloc(namelen + 1);         int match, ret;          memcpy(name, *pname, namelen + 1);          match = -1;         if (!TEST_int_ge(ret = X509_check_host(crt, name, namelen, 0, NULL),                          0)) {             failed = 1;         } else if (fn->host) {             if (ret == 1 && !samename)                 match = 1;             if (ret == 0 && samename)                 match = 0;         } else if (ret == 1)             match = 1;         if (!TEST_true(check_message(fn, ""host"", nameincert, match, *pname)))             failed = 1;          match = -1;         if (!TEST_int_ge(ret = X509_check_host(crt, name, namelen,                                                X509_CHECK_FLAG_NO_WILDCARDS,                                                NULL), 0)) {             failed = 1;         } else if (fn->host) {             if (ret == 1 && !samename)                 match = 1;             if (ret == 0 && samename)                 match = 0;         } else if (ret == 1)             match = 1;         if (!TEST_true(check_message(fn, ""host-no-wildcards"",                                      nameincert, match, *pname)))             failed = 1;          match = -1;         ret = X509_check_email(crt, name, namelen, 0);         if (fn->email) {             if (ret && !samename)                 match = 1;             if (!ret && samename && strchr(nameincert, '@') != NULL)                 match = 0;         } else if (ret)             match = 1;         if (!TEST_true(check_message(fn, ""email"", nameincert, match, *pname)))             failed = 1;         OPENSSL_free(name);     }      return failed == 0; }"
"507766_not_vulnerable.c","not_vulnerable","int EC_GROUP_get_basis_type(const EC_GROUP *group) {     int i;      if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=         NID_X9_62_characteristic_two_field)         /* everything else is currently not supported */         return 0;      /* Find the last non-zero element of group->poly[] */     for (i = 0;          i < (int)OSSL_NELEM(group->poly) && group->poly[i] != 0;          i++)         continue;      if (i == 4)         return NID_X9_62_ppBasis;     else if (i == 2)         return NID_X9_62_tpBasis;     else         /* everything else is currently not supported */         return 0; }"
"507775_not_vulnerable.c","not_vulnerable","int i2o_ECPublicKey(const EC_KEY *a, unsigned char **out) {     size_t buf_len = 0;     int new_buffer = 0;      if (a == NULL) {         ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);         return 0;     }      buf_len = EC_POINT_point2oct(a->group, a->pub_key,                                  a->conv_form, NULL, 0, NULL);      if (out == NULL || buf_len == 0)         /* out == NULL => just return the length of the octet string */         return buf_len;      if (*out == NULL) {         if ((*out = OPENSSL_malloc(buf_len)) == NULL) {             ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);             return 0;         }         new_buffer = 1;     }     if (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,                             *out, buf_len, NULL)) {         ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);         if (new_buffer) {             OPENSSL_free(*out);             *out = NULL;         }         return 0;     }     if (!new_buffer)         *out += buf_len;     return buf_len; }"
"508763_not_vulnerable.c","not_vulnerable","int _ma_update_state_lsns(MARIA_SHARE *share, LSN lsn, TrID create_trid,                           my_bool do_sync, my_bool update_create_rename_lsn) {   int res;   DBUG_ENTER(""_ma_update_state_lsns"");   mysql_mutex_lock(&share->intern_lock);   res= _ma_update_state_lsns_sub(share, lsn, create_trid, do_sync,                                  update_create_rename_lsn);   mysql_mutex_unlock(&share->intern_lock);   DBUG_RETURN(res); }"
"508817_not_vulnerable.cpp","not_vulnerable","void st_select_lex_node::fast_exclude() {   if (link_prev)   {     if ((*link_prev= link_next))       link_next->link_prev= link_prev;   }   // Remove slave structure   for (; slave; slave= slave->next)     slave->fast_exclude();    }"
"508839_not_vulnerable.cpp","not_vulnerable","bool st_select_lex::save_prep_leaf_tables(THD *thd) {   if (prep_leaf_list_state == SAVED)     return FALSE;    List_iterator_fast<TABLE_LIST> li(leaf_tables);   TABLE_LIST *table;    /*     Check that the SELECT_LEX was really prepared and so tables are setup.      It can be subquery in SET clause of UPDATE which was not prepared yet, so     its tables are not yet setup and ready for storing.   */   if (prep_leaf_list_state != READY)     return FALSE;    while ((table= li++))   {     if (leaf_tables_prep.push_back(table))       return TRUE;   }   prep_leaf_list_state= SAVED;   for (SELECT_LEX_UNIT *u= first_inner_unit(); u; u= u->next_unit())   {     for (SELECT_LEX *sl= u->first_select(); sl; sl= sl->next_select())     {       if (sl->save_prep_leaf_tables(thd))         return TRUE;     }   }    return FALSE; }"
"509543_not_vulnerable.cpp","not_vulnerable","const char *ha_maria::index_type(uint key_number) {   return ((table->key_info[key_number].flags & HA_FULLTEXT) ?           ""FULLTEXT"" :           (table->key_info[key_number].flags & HA_SPATIAL) ?           ""SPATIAL"" :           (table->key_info[key_number].algorithm == HA_KEY_ALG_RTREE) ?           ""RTREE"" : ""BTREE""); }"
"512264_not_vulnerable.cpp","not_vulnerable","cmp_item* cmp_item_real::make_same() {   return new cmp_item_real(); }"
"512272_not_vulnerable.cpp","not_vulnerable","longlong Item_func_dyncol_check::val_int() {   char buff[STRING_BUFFER_USUAL_SIZE];   String tmp(buff, sizeof(buff), &my_charset_bin);   DYNAMIC_COLUMN col;   String *str;   enum enum_dyncol_func_result rc;    str= args[0]->val_str(&tmp);   if (args[0]->null_value)     goto null;   col.length= str->length();   /* We do not change the string, so could do this trick */   col.str= (char *)str->ptr();   rc= mariadb_dyncol_check(&col);   if (rc < 0 && rc != ER_DYNCOL_FORMAT)   {     dynamic_column_error_message(rc);     goto null;   }   null_value= FALSE;   return rc == ER_DYNCOL_OK;  null:   null_value= TRUE;   return 0; }"
"512323_not_vulnerable.cpp","not_vulnerable","  virtual const MYSQL_TIME *const_ptr_mysql_time() const { return NULL; }"
"512333_not_vulnerable.cpp","not_vulnerable","  Field *create_tmp_field_ex(TABLE *table, Tmp_field_src *src,                              const Tmp_field_param *param)   {      /*       create_tmp_field_ex() for this type of Items is called for:       - CREATE TABLE ... SELECT       - In ORDER BY: SELECT max(a) FROM t1 GROUP BY a ORDER BY 'const';       - In CURSORS:           DECLARE c CURSOR FOR SELECT 'test';           OPEN c;     */     return tmp_table_field_from_field_type_maybe_null(table, src, param,                                             type() == Item::NULL_ITEM);   }"
"512358_not_vulnerable.c","not_vulnerable","  const double *const_ptr_double() const   { return can_return_const_value(REAL_RESULT) ? &value.real : NULL; }"
"512369_not_vulnerable.cpp","not_vulnerable","  virtual Item *grouping_field_transformer_for_where(THD *thd, uchar *arg)   { return this; }"
"512393_not_vulnerable.cpp","not_vulnerable","bool Item_func_decode_oracle::fix_length_and_dec() {   THD *thd= current_thd;   return (aggregate_then_and_else_arguments(thd, when_count() + 1) ||           aggregate_switch_and_when_arguments(thd, true)); }"
"512492_not_vulnerable.c","not_vulnerable","  bool val_native(THD *thd, Native *to)   {     return has_value() ? Time(thd, this).to_native(to, decimals) : true;   }"
"512525_not_vulnerable.cpp","not_vulnerable","  virtual bool with_subquery() const   {     return (*ref)->with_subquery();   }"
"512556_not_vulnerable.c","not_vulnerable","  Item_hex_string(THD *thd, const char *str, size_t str_length):     Item_hex_constant(thd, str, str_length) {}"
"512568_not_vulnerable.c","not_vulnerable","  longlong val_datetime_packed(THD *thd)   {     return has_value() ? value : 0;   }"
"512597_not_vulnerable.cpp","not_vulnerable","  virtual longlong val_int_min() const   {     return LONGLONG_MIN;   }"
"512656_not_vulnerable.cpp","not_vulnerable","void Item_func_in::print(String *str, enum_query_type query_type) {   args[0]->print_parenthesised(str, query_type, precedence());   if (negated)     str->append(STRING_WITH_LEN("" not""));   str->append(STRING_WITH_LEN("" in (""));   print_args(str, 1, query_type);   str->append(STRING_WITH_LEN("")"")); }"
"512820_not_vulnerable.cpp","not_vulnerable","  virtual With_sum_func_cache* get_with_sum_func_cache() { return NULL; }"
"512847_not_vulnerable.c","not_vulnerable","  const Type_handler *real_type_handler() const   {     // Should not be called, Item_blob is used for SHOW purposes only.     DBUG_ASSERT(0);     return &type_handler_varchar;   }"
"512969_not_vulnerable.cpp","not_vulnerable","Item_func_regex::fix_length_and_dec() {   if (Item_bool_func::fix_length_and_dec() ||       agg_arg_charsets_for_comparison(cmp_collation, args, 2))     return TRUE;    re.init(cmp_collation.collation, 0);   re.fix_owner(this, args[0], args[1]);   return FALSE; }"
"513002_not_vulnerable.c","not_vulnerable","  Item *get_copy(THD *thd)   { return get_item_copy<Item_hex_string>(thd, this); }"
"513179_not_vulnerable.c","not_vulnerable","static int check_func_longlong(THD *thd, struct st_mysql_sys_var *var,                                void *save, st_mysql_value *value) {   my_bool fixed1, fixed2;   long long orig, val;   struct my_option options;   value->val_int(value, &orig);   val= orig;   plugin_opt_set_limits(&options, var);    if (var->flags & PLUGIN_VAR_UNSIGNED)   {     if ((fixed1= (!value->is_unsigned(value) && val < 0)))       val=0;     *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,                                                &fixed2);   }   else   {     if ((fixed1= (value->is_unsigned(value) && val < 0)))       val=LONGLONG_MAX;     *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);   }    return throw_bounds_warning(thd, var->name, fixed1 || fixed2,                               value->is_unsigned(value), (longlong) orig); }"
"513263_not_vulnerable.c","not_vulnerable","bool instantiate_tmp_table(TABLE *table, KEY *keyinfo,                             TMP_ENGINE_COLUMNDEF *start_recinfo,                            TMP_ENGINE_COLUMNDEF **recinfo,                            ulonglong options) {   if (table->s->db_type() == TMP_ENGINE_HTON)   {     if (create_internal_tmp_table(table, keyinfo, start_recinfo, recinfo,                                   options))       return TRUE;     // Make empty record so random data is not written to disk     empty_record(table);     table->status= STATUS_NO_RECORD;   }   if (open_tmp_table(table))     return TRUE;    return FALSE; }"
"513268_not_vulnerable.c","not_vulnerable","join_read_system(JOIN_TAB *tab) {   TABLE *table= tab->table;   int error;   if (table->status & STATUS_GARBAGE)		// If first read   {     if ((error= table->file->ha_read_first_row(table->record[0],                                                table->s->primary_key)))     {       if (error != HA_ERR_END_OF_FILE) 	return report_error(table, error);       mark_as_null_row(tab->table);       empty_record(table);			// Make empty record       return -1;     }     store_record(table,record[1]);   }   else if (!table->status)			// Only happens with left join     restore_record(table,record[1]);			// restore old record   table->null_row=0;   return table->status ? -1 : 0; }"
"513284_not_vulnerable.c","not_vulnerable","static bool create_ref_for_key(JOIN *join, JOIN_TAB *j,                                KEYUSE *org_keyuse, bool allow_full_scan,                                 table_map used_tables) {   uint keyparts, length, key;   TABLE *table;   KEY *keyinfo;   KEYUSE *keyuse= org_keyuse;   bool ftkey= (keyuse->keypart == FT_KEYPART);   THD *thd= join->thd;   DBUG_ENTER(""create_ref_for_key"");    /*  Use best key from find_best */   table= j->table;   key= keyuse->key;   if (!is_hash_join_key_no(key))     keyinfo= table->key_info+key;   else   {     if (create_hj_key_for_table(join, j, org_keyuse, used_tables))       DBUG_RETURN(TRUE);     keyinfo= j->hj_key;   }    if (ftkey)   {     Item_func_match *ifm=(Item_func_match *)keyuse->val;      length=0;     keyparts=1;     ifm->join_key=1;   }   else   {     keyparts=length=0;     uint found_part_ref_or_null= 0;     /*       Calculate length for the used key       Stop if there is a missing key part or when we find second key_part       with KEY_OPTIMIZE_REF_OR_NULL     */     do     {       if (!(~used_tables & keyuse->used_tables) && 	  j->keyuse_is_valid_for_access_in_chosen_plan(join, keyuse))       {         if  (are_tables_local(j, keyuse->val->used_tables()))         {           if ((is_hash_join_key_no(key) && keyuse->keypart != NO_KEYPART) ||               (!is_hash_join_key_no(key) && keyparts == keyuse->keypart &&                !(found_part_ref_or_null & keyuse->optimize)))           {              length+= keyinfo->key_part[keyparts].store_length;              keyparts++;              found_part_ref_or_null|= keyuse->optimize & ~KEY_OPTIMIZE_EQ;           }         }       }       keyuse++;     } while (keyuse->table == table && keyuse->key == key);      if (!keyparts && allow_full_scan)     {       /* It's a LooseIndexScan strategy scanning whole index */       j->type= JT_ALL;       j->index= key;       DBUG_RETURN(FALSE);     }      DBUG_ASSERT(length > 0);     DBUG_ASSERT(keyparts != 0);   } /* not ftkey */      /* set up fieldref */   j->ref.key_parts= keyparts;   j->ref.key_length= length;   j->ref.key= (int) key;   if (!(j->ref.key_buff= (uchar*) thd->calloc(ALIGN_SIZE(length)*2)) ||       !(j->ref.key_copy= (store_key**) thd->alloc((sizeof(store_key*) * 						          (keyparts+1)))) ||       !(j->ref.items=(Item**) thd->alloc(sizeof(Item*)*keyparts)) ||       !(j->ref.cond_guards= (bool**) thd->alloc(sizeof(uint*)*keyparts)))   {     DBUG_RETURN(TRUE);   }   j->ref.key_buff2=j->ref.key_buff+ALIGN_SIZE(length);   j->ref.key_err=1;   j->ref.has_record= FALSE;   j->ref.null_rejecting= 0;   j->ref.disable_cache= FALSE;   j->ref.null_ref_part= NO_REF_PART;   j->ref.const_ref_part_map= 0;   keyuse=org_keyuse;    store_key **ref_key= j->ref.key_copy;   uchar *key_buff=j->ref.key_buff, *null_ref_key= 0;   uint null_ref_part= NO_REF_PART;   bool keyuse_uses_no_tables= TRUE;   if (ftkey)   {     j->ref.items[0]=((Item_func*)(keyuse->val))->key_item();     /* Predicates pushed down into subquery can't be used FT access */     j->ref.cond_guards[0]= NULL;     if (keyuse->used_tables)       DBUG_RETURN(TRUE);                        // not supported yet. SerG      j->type=JT_FT;   }   else   {     uint i;     for (i=0 ; i < keyparts ; keyuse++,i++)     {       while (((~used_tables) & keyuse->used_tables) || 	     !j->keyuse_is_valid_for_access_in_chosen_plan(join, keyuse) ||              keyuse->keypart == NO_KEYPART || 	     (keyuse->keypart !=                (is_hash_join_key_no(key) ?                  keyinfo->key_part[i].field->field_index : i)) ||               !are_tables_local(j, keyuse->val->used_tables()))  	 keyuse++;                              	/* Skip other parts */         uint maybe_null= MY_TEST(keyinfo->key_part[i].null_bit);       j->ref.items[i]=keyuse->val;		// Save for cond removal       j->ref.cond_guards[i]= keyuse->cond_guard;       if (keyuse->null_rejecting)          j->ref.null_rejecting|= (key_part_map)1 << i;       keyuse_uses_no_tables= keyuse_uses_no_tables && !keyuse->used_tables;       /*         Todo: we should remove this check for thd->lex->describe on the next         line. With SHOW EXPLAIN code, EXPLAIN printout code no longer depends         on it. However, removing the check caused change in lots of query         plans! Does the optimizer depend on the contents of         table_ref->key_copy ? If yes, do we produce incorrect EXPLAINs?        */       if (!keyuse->val->used_tables() && !thd->lex->describe)       {					// Compare against constant 	store_key_item tmp(thd,                             keyinfo->key_part[i].field,                            key_buff + maybe_null,                            maybe_null ?  key_buff : 0,                            keyinfo->key_part[i].length,                            keyuse->val,                            FALSE); 	if (thd->is_fatal_error) 	  DBUG_RETURN(TRUE); 	tmp.copy();         j->ref.const_ref_part_map |= key_part_map(1) << i ;       }       else 	*ref_key++= get_store_key(thd, 				  keyuse,join->const_table_map, 				  &keyinfo->key_part[i], 				  key_buff, maybe_null);       /* 	Remember if we are going to use REF_OR_NULL 	But only if field _really_ can be null i.e. we force JT_REF 	instead of JT_REF_OR_NULL in case if field can't be null       */       if ((keyuse->optimize & KEY_OPTIMIZE_REF_OR_NULL) && maybe_null)       { 	null_ref_key= key_buff;         null_ref_part= i;       }       key_buff+= keyinfo->key_part[i].store_length;     }   } /* not ftkey */   *ref_key=0;				// end_marker   if (j->type == JT_FT)     DBUG_RETURN(0);   ulong key_flags= j->table->actual_key_flags(keyinfo);   if (j->type == JT_CONST)     j->table->const_table= 1;   else if (!((keyparts == keyinfo->user_defined_key_parts &&                ((key_flags & (HA_NOSAME | HA_NULL_PART_KEY)) == HA_NOSAME)) || 	     (keyparts > keyinfo->user_defined_key_parts &&   // true only for extended keys                MY_TEST(key_flags & HA_EXT_NOSAME) &&               keyparts == keyinfo->ext_key_parts)) || 	    null_ref_key)   {     /* Must read with repeat */     j->type= null_ref_key ? JT_REF_OR_NULL : JT_REF;     j->ref.null_ref_key= null_ref_key;     j->ref.null_ref_part= null_ref_part;   }   else if (keyuse_uses_no_tables)   {     /*       This happen if we are using a constant expression in the ON part       of an LEFT JOIN.       SELECT * FROM a LEFT JOIN b ON b.key=30       Here we should not mark the table as a 'const' as a field may       have a 'normal' value or a NULL value.     */     j->type=JT_CONST;   }   else     j->type=JT_EQ_REF;    j->read_record.unlock_row= (j->type == JT_EQ_REF)?                               join_read_key_unlock_row : rr_unlock_row;    DBUG_RETURN(0); }"
"513302_not_vulnerable.c","not_vulnerable","join_ft_read_first(JOIN_TAB *tab) {   int error;   TABLE *table= tab->table;    if (!table->file->inited &&       (error= table->file->ha_index_init(tab->ref.key, 1)))   {     (void) report_error(table, error);     return 1;   }    table->file->ft_init();    if ((error= table->file->ha_ft_read(table->record[0])))     return report_error(table, error);   return 0; }"
"514316_not_vulnerable.cpp","not_vulnerable","void Multiupdate_prelocking_strategy::reset(THD *thd) {   done= false;   has_prelocking_list= thd->lex->requires_prelocking(); }"
"517428_not_vulnerable.c","not_vulnerable","static void doGet(HttpRequest req, HttpResponse res) {         set_content_type(res, ""text/html"");         if (ACTION(HOME)) {                 LOCK(Run.mutex)                 do_home(res);                 END_LOCK;         } else if (ACTION(RUNTIME)) {                 handle_runtime(req, res);         } else if (ACTION(TEST)) {                 is_monit_running(res);         } else if (ACTION(ABOUT)) {                 do_about(res);         } else if (ACTION(FAVICON)) {                 printFavicon(res);         } else if (ACTION(PING)) {                 do_ping(res);         } else if (ACTION(GETID)) {                 do_getid(res);         } else if (ACTION(STATUS)) {                 print_status(req, res, 1);         } else if (ACTION(STATUS2)) {                 print_status(req, res, 2);         } else if (ACTION(SUMMARY)) {                 print_summary(req, res);         } else if (ACTION(REPORT)) {                 _printReport(req, res);         } else {                 handle_service(req, res);         } }"
"90171_not_vulnerable.cpp","not_vulnerable","  virtual void RefreshCellularDataPlans(const CellularNetwork* network) {} "
"90183_not_vulnerable.cpp","not_vulnerable","  virtual void SaveCellularNetwork(const CellularNetwork* network) {     DCHECK(network);     if (!EnsureCrosLoaded() || !network)       return;      SetAutoConnect(network->service_path().c_str(), network->auto_connect());   } "
"90222_not_vulnerable.cpp","not_vulnerable","  virtual const WifiNetworkVector& remembered_wifi_networks() const {     return remembered_wifi_networks_;   } "
"90764_not_vulnerable.cpp","not_vulnerable","void QuotaManager::DidRunInitialGetTemporaryGlobalUsage(     StorageType type, int64 usage_unused, int64 unlimited_usage_unused) {   DCHECK_EQ(type, kStorageTypeTemporary);   scoped_refptr<InitializeTemporaryOriginsInfoTask> task(       new InitializeTemporaryOriginsInfoTask(           this, temporary_usage_tracker_.get()));   task->Start(); } "
"90847_not_vulnerable.c","not_vulnerable","   void DidGetUsageAndQuota(QuotaStatusCode status, int64 usage, int64 quota) {      quota_status_ = status;      usage_ = usage;     quota_ = quota;   } "
"90904_not_vulnerable.cpp","not_vulnerable","bool SortByHost(const GURL& lhs, const GURL& rhs) {   return net::GetHostOrSpecFromURL(lhs) > net::GetHostOrSpecFromURL(rhs); } "
"90907_not_vulnerable.cpp","not_vulnerable","UsageTracker::UsageTracker(const QuotaClientList& clients, StorageType type,                            SpecialStoragePolicy* special_storage_policy)     : type_(type),       callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {   for (QuotaClientList::const_iterator iter = clients.begin();       iter != clients.end();       ++iter) {     client_tracker_map_.insert(std::make_pair(         (*iter)->id(),         new ClientUsageTracker(this, *iter, type, special_storage_policy)));   } } "
"95900_not_vulnerable.cpp","not_vulnerable","void AddInstallWorkItems(const InstallationState& original_state,                          const InstallerState& installer_state,                          const FilePath& setup_path,                          const FilePath& archive_path,                          const FilePath& src_path,                          const FilePath& temp_path,                          const Version& new_version,                          scoped_ptr<Version>* current_version,                          WorkItemList* install_list) {   DCHECK(install_list);    const FilePath& target_path = installer_state.target_path();    install_list->AddCreateDirWorkItem(temp_path);   install_list->AddCreateDirWorkItem(target_path);    if (current_version != NULL && current_version->get() != NULL) {     FilePath old_installer_dir(         installer_state.GetInstallerDirectory(**current_version));     FilePath old_archive(old_installer_dir.Append(archive_path.BaseName()));     install_list->AddDeleteTreeWorkItem(old_archive, temp_path)         ->set_ignore_failure(true);   }    FilePath new_chrome_exe(target_path.Append(installer::kChromeNewExe));    install_list->AddDeleteTreeWorkItem(new_chrome_exe, temp_path);   install_list->AddCopyTreeWorkItem(       src_path.Append(installer::kChromeExe).value(),       target_path.Append(installer::kChromeExe).value(),       temp_path.value(), WorkItem::NEW_NAME_IF_IN_USE, new_chrome_exe.value());    if (base::win::OSInfo::GetInstance()->wow64_status() !=       base::win::OSInfo::WOW64_DISABLED) {     install_list->AddMoveTreeWorkItem(         src_path.Append(installer::kWowHelperExe).value(),         target_path.Append(installer::kWowHelperExe).value(),         temp_path.value(),         WorkItem::ALWAYS_MOVE);   }    bool check_for_duplicates =       (current_version != NULL && current_version->get() != NULL &&        current_version->get()->Equals(new_version));   install_list->AddMoveTreeWorkItem(       src_path.AppendASCII(new_version.GetString()).value(),       target_path.AppendASCII(new_version.GetString()).value(),       temp_path.value(),       check_for_duplicates ? WorkItem::CHECK_DUPLICATES :                              WorkItem::ALWAYS_MOVE);    install_list->AddCopyTreeWorkItem(       src_path.Append(installer::kDictionaries).value(),       target_path.Append(installer::kDictionaries).value(),       temp_path.value(), WorkItem::IF_NOT_PRESENT);    install_list->AddDeleteTreeWorkItem(       target_path.Append(installer::kChromeOldExe), temp_path);    AddInstallerCopyTasks(installer_state, setup_path, archive_path, temp_path,                         new_version, install_list);    const HKEY root = installer_state.root_key();    const Products& products = installer_state.products();   for (size_t i = 0; i < products.size(); ++i) {     const Product* product = products[i];      AddUninstallShortcutWorkItems(installer_state, setup_path, new_version,                                   install_list, *product);      AddVersionKeyWorkItems(root, product->distribution(), new_version,                            install_list);   }    if (installer_state.is_multi_install()) {     AddVersionKeyWorkItems(root,         installer_state.multi_package_binaries_distribution(), new_version,         install_list);   }    AddProductSpecificWorkItems(original_state, installer_state, setup_path,                               new_version, install_list);    AddGoogleUpdateWorkItems(original_state, installer_state, install_list);    AddQuickEnableWorkItems(installer_state, original_state, &setup_path,                           &new_version, install_list);    AppendPostInstallTasks(installer_state,                          setup_path,                          new_chrome_exe,                          current_version->get(),                          new_version,                          temp_path,                          install_list); } "
