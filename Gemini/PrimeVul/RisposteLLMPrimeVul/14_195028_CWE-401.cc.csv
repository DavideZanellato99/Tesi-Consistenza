"iteration","is_vulnerable","assigned_cwe","assigned_cwe_name","cwe_description","explanation"
"1","True","CWE-400","Uncontrolled Resource Consumption","The product does not properly control the allocation and maintenance of a limited resource, thereby allowing an attacker to exhaust the resource and cause a denial of service.","The code allows for an excessively large memory allocation when decoding PNG images to the DT_FLOAT data type. Specifically, the new uint16[height * width * decode.channels] allocation can request up to approximately 4 gigabytes of memory. Although the total_size (width * height) is checked against (1LL << 29), this limit, combined with the number of channels and the size of uint16, still permits an allocation that can exhaust system resources, leading to a Denial of Service (DoS) if an attacker provides a specially crafted large PNG image."
"2","True","CWE-400","Uncontrolled Resource Consumption","The product does not properly control the allocation and maintenance of a limited resource, thereby allowing an attacker to exhaust the resource and cause a denial of service.","The code allows for an excessively large memory allocation when decoding PNG images to the DT_FLOAT data type. Specifically, the new uint16[height * width * decode.channels] allocation can request up to approximately 4 gigabytes of memory. Although the total_size (width * height) is checked against (1LL << 29), this limit, combined with the number of channels and the size of uint16, still permits an allocation that can exhaust system resources, leading to a Denial of Service (DoS) if an attacker provides a specially crafted large PNG image."
"3","True","CWE-122","Heap-based Buffer Overflow","The product copies an input buffer to an output buffer that is allocated on the heap, but the output buffer is smaller than the input buffer, which can lead to a buffer overflow.","The code passes an incorrect buffer size to the png::CommonFinishDecode function. The buffer_size argument is calculated as the size of a single image row (decode.channels * width * sizeof(T)) instead of the total allocated buffer size for the entire image (height * decode.channels * width * sizeof(T)). If the png::CommonFinishDecode function attempts to write the full image data, it will write beyond the bounds of the provided buffer, leading to a heap buffer overflow. This can result in denial of service, information disclosure, or arbitrary code execution."
"4","True","CWE-122","Heap-based Buffer Overflow","The product copies an input buffer to an output buffer that is allocated on the heap, but the output buffer is smaller than the input buffer, which can lead to a buffer overflow.","The code passes an incorrect buffer size to the png::CommonFinishDecode function. The buffer_size argument is calculated as the size of a single image row (decode.channels * width * sizeof(T)) instead of the total allocated buffer size for the entire image (height * decode.channels * width * sizeof(T)). If the png::CommonFinishDecode function attempts to write the full image data, it will write beyond the bounds of the provided buffer, leading to a heap buffer overflow. This can result in denial of service, information disclosure, or arbitrary code execution."
"5","True","CWE-400","Uncontrolled Resource Consumption","The product does not properly control the allocation and maintenance of a limited resource, thereby allowing an attacker to exhaust the resource and cause a denial of service.","The code allows for an excessively large memory allocation when decoding PNG images to the DT_FLOAT data type. Specifically, the new uint16[height * width * decode.channels] allocation can request up to approximately 4 gigabytes of memory. Although the total_size (width * height) is checked against (1LL << 29), this limit, combined with the number of channels and the size of uint16, still permits an allocation that can exhaust system resources, leading to a Denial of Service (DoS) if an attacker provides a specially crafted large PNG image."
