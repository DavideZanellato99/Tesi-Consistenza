"iteration","is_vulnerable","assigned_cwe","assigned_cwe_name","cwe_description","explanation"
"1","True","CWE-113","Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')","The web server or application does not neutralize or incorrectly neutralizes CR and LF characters in HTTP headers. This can allow an attacker to inject arbitrary HTTP headers, leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks.","The code constructs HTTP response headers using values derived from user-controlled input, specifically request parameters (e.g., response-content-type) and object metadata attributes. If these user-controlled values contain newline characters (CRLF), they can be injected directly into the HTTP response headers via calls to `dump_header`. This allows an authenticated attacker to inject arbitrary HTTP headers, potentially leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks. While some specific `response-*` parameters are checked for anonymous access, authenticated users can still exploit this for other parameters and object metadata."
"2","True","CWE-113","Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')","The web server or application does not neutralize or incorrectly neutralizes CR and LF characters in HTTP headers. This can allow an attacker to inject arbitrary HTTP headers, leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks.","The code constructs HTTP response headers using values derived from user-controlled input, specifically request parameters (e.g., response-content-type) and object metadata attributes. If these user-controlled values contain newline characters (CRLF), they can be injected directly into the HTTP response headers via calls to `dump_header`. This allows an authenticated attacker to inject arbitrary HTTP headers, potentially leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks. While some specific `response-*` parameters are checked for anonymous access, authenticated users can still exploit this for other parameters and object metadata."
"3","True","CWE-113","Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')","The software receives data from an upstream component, but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in an HTTP header. This can enable an attacker to inject arbitrary HTTP headers and potentially split the HTTP response into two separate responses.","The code is vulnerable to HTTP Header Injection (CWE-113). User-controlled input from two sources is directly used to construct HTTP response headers without proper sanitization. Firstly, values retrieved from request arguments via s->info.args.get(p->param, &exists) are assigned to response_attrs and later dumped using dump_header. Secondly, user-defined object metadata values (iter->second) are also dumped as custom headers (X-Object-Meta-*) using dump_header. If an attacker provides input containing carriage return and newline characters (CRLF, i.e., %0d%0a), they can inject arbitrary HTTP headers into the response, potentially leading to session hijacking, cross-site scripting, or other attacks. The check for anonymous users only prevents unauthenticated manipulation of specific response headers, but an authenticated user could still exploit this for custom metadata or other response parameters."
"4","True","CWE-113","Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')","The software receives data from an upstream component, but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in an HTTP header. This can enable an attacker to inject arbitrary HTTP headers and potentially split the HTTP response into two separate responses.","The code is vulnerable to HTTP Header Injection (CWE-113). User-controlled input from two sources is directly used to construct HTTP response headers without proper sanitization. Firstly, values retrieved from request arguments via s->info.args.get(p->param, &exists) are assigned to response_attrs and later dumped using dump_header. Secondly, user-defined object metadata values (iter->second) are also dumped as custom headers (X-Object-Meta-*) using dump_header. If an attacker provides input containing carriage return and newline characters (CRLF, i.e., %0d%0a), they can inject arbitrary HTTP headers into the response, potentially leading to session hijacking, cross-site scripting, or other attacks. The check for anonymous users only prevents unauthenticated manipulation of specific response headers, but an authenticated user could still exploit this for custom metadata or other response parameters."
"5","True","CWE-113","Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')","The web server or application does not neutralize or incorrectly neutralizes CR and LF characters in HTTP headers. This can allow an attacker to inject arbitrary HTTP headers, leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks.","The code constructs HTTP response headers using values derived from user-controlled input, specifically request parameters (e.g., response-content-type) and object metadata attributes. If these user-controlled values contain newline characters (CRLF), they can be injected directly into the HTTP response headers via calls to `dump_header`. This allows an authenticated attacker to inject arbitrary HTTP headers, potentially leading to HTTP Response Splitting, cache poisoning, or cross-site scripting (XSS) attacks. While some specific `response-*` parameters are checked for anonymous access, authenticated users can still exploit this for other parameters and object metadata."
